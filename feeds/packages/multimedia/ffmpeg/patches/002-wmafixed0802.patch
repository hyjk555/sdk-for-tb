--- a/libavcodec/bswap.h
+++ b/libavcodec/bswap.h
@@ -0,0 +1,169 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file bswap.h
+ * byte swap.
+ */
+#include "config.h"
+#ifndef __BSWAP_H__
+#define __BSWAP_H__
+
+#ifdef HAVE_BYTESWAP_H
+#include <byteswap.h>
+#else
+
+
+/* rockbox' optimised inline functions 
+#define bswap_16(x) swap16(x)
+#define bswap_32(x) swap32(x)*/
+
+#define bswap_16(x) (((x) & 0x00ff) << 8 | ((x) & 0xff00) >> 8)
+
+// code from bits/byteswap.h (C) 1997, 1998 Free Software Foundation, Inc.
+#define bswap_32(x) \
+     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) | \
+      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
+
+static inline uint64_t ByteSwap64(uint64_t x)
+{
+    union { 
+        uint64_t ll;
+        uint32_t l[2]; 
+    } w, r;
+    w.ll = x;
+    r.l[0] = bswap_32 (w.l[1]);
+    r.l[1] = bswap_32 (w.l[0]);
+    return r.ll;
+}
+#define bswap_64(x) ByteSwap64(x)
+
+
+/*static inline uint64_t ByteSwap64(uint64_t x)
+{
+    union { 
+        uint64_t ll;
+        struct {
+           uint32_t l,h;
+        } l;
+    } r;
+    r.l.l = bswap_32 (x);
+    r.l.h = bswap_32 (x>>32);
+    return r.ll;
+}
+#define bswap_64(x) ByteSwap64(x)
+#elif defined(ARCH_X86)
+static inline unsigned short ByteSwap16(unsigned short x)
+{
+  __asm__("xchgb %b0,%h0"	:
+        "=q" (x)	:
+        "0" (x));
+    return x;
+}
+#define bswap_16(x) ByteSwap16(x)*/
+
+/*static inline unsigned int ByteSwap32(unsigned int x)
+{
+#if __CPU__ > 386
+ __asm__("bswap	%0":
+      "=r" (x)     :
+#else
+ __asm__("xchgb	%b0,%h0\n"
+      "	rorl	$16,%0\n"
+      "	xchgb	%b0,%h0":
+      "=q" (x)		:
+#endif
+      "0" (x));
+  return x;
+}
+#define bswap_32(x) ByteSwap32(x)*/
+
+/*static inline unsigned long long int ByteSwap64(unsigned long long int x)
+{
+  register union { __extension__ uint64_t __ll;
+          uint32_t __l[2]; } __x;
+  __asm__("xchgl	%0,%1":
+      "=r"(__x.__l[0]),"=r"(__x.__l[1]):
+      "0"(bswap_32((unsigned long)x)),"1"(bswap_32((unsigned long)(x>>32))));
+  return __x.__ll;
+}
+#define bswap_64(x) ByteSwap64(x)*/
+
+/*#elif defined(ARCH_SH4)
+
+static inline uint16_t ByteSwap16(uint16_t x) {
+	__asm__("swap.b %0,%0":"=r"(x):"0"(x));
+	return x;
+}
+
+static inline uint32_t ByteSwap32(uint32_t x) {
+	__asm__(
+	"swap.b %0,%0\n"
+	"swap.w %0,%0\n"
+	"swap.b %0,%0\n"
+	:"=r"(x):"0"(x));
+	return x;
+}
+
+#define bswap_16(x) ByteSwap16(x)
+#define bswap_32(x) ByteSwap32(x)
+
+static inline uint64_t ByteSwap64(uint64_t x)
+{
+    union { 
+        uint64_t ll;
+        struct {
+           uint32_t l,h;
+        } l;
+    } r;
+    r.l.l = bswap_32 (x);
+    r.l.h = bswap_32 (x>>32);
+    return r.ll;
+}
+#define bswap_64(x) ByteSwap64(x)
+
+#else*/
+
+
+
+/*#endif	 !ARCH_X86 */
+
+#endif	/* !HAVE_BYTESWAP_H */
+
+// be2me ... BigEndian to MachineEndian
+// le2me ... LittleEndian to MachineEndian
+
+#if HAVE_BIGENDIAN
+#define be2me_16(x) (x)
+#define be2me_32(x) (x)
+#define be2me_64(x) (x)
+#define le2me_16(x) bswap_16(x)
+#define le2me_32(x) bswap_32(x)
+#define le2me_64(x) bswap_64(x)
+#else
+#define be2me_16(x) bswap_16(x)
+#define be2me_32(x) bswap_32(x)
+#define be2me_64(x) bswap_64(x)
+#define le2me_16(x) (x)
+#define le2me_32(x) (x)
+#define le2me_64(x) (x)
+#endif /*HAVE_BIGENDIAN*/
+
+#endif /* __BSWAP_H__ */

--- a/libavcodec/fixed_bitstream.c
+++ b/libavcodec/fixed_bitstream.c
@@ -0,0 +1,265 @@
+/*
+ * Common bit i/o utils
+ * Copyright (c) 2000, 2001 Fabrice Bellard.
+ * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * alternative bitstream reader & writer by Michael Niedermayer <michaelni@gmx.at>
+ */
+
+/**
+ * @file bitstream.c
+ * bitstream api.
+ */
+
+#include "fixed_bitstream.h"
+
+#include <stdio.h>
+
+#define DEBUGF printf
+
+/**
+ * Same as av_mallocz_static(), but does a realloc.
+ *
+ * @param[in] ptr The block of memory to reallocate.
+ * @param[in] size The requested size.
+ * @return Block of memory of requested size.
+ * @deprecated. Code which uses ff_realloc_static is broken/missdesigned
+ * and should correctly use static arrays
+ 
+attribute_deprecated void *ff_realloc_static(void *ptr, unsigned int size);
+
+const uint8_t ff_sqrt_tab_fixed[128]={
+        0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
+        5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
+        9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11
+};*/
+
+const uint8_t ff_log2_tab_fixed[256]={
+        0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+};
+
+void align_put_bits_fixed(PutBitContext_fixed *s)
+{
+#ifdef ALT_BITSTREAM_WRITER
+    put_bits_fixed(s,(  - s->index) & 7,0);
+#else
+    put_bits_fixed(s,s->bit_left & 7,0);
+#endif
+}
+
+void ff_put_string_fixed(PutBitContext_fixed * pbc, char *s, int put_zero)
+{
+    while(*s){
+        put_bits_fixed(pbc, 8, *s);
+        s++;
+    }
+    if(put_zero)
+        put_bits_fixed(pbc, 8, 0);
+}
+
+/* VLC decoding */
+#define GET_DATA_FIX(v, table, i, wrap, size) \
+{\
+    const uint8_t *ptr = (const uint8_t *)table + i * wrap;\
+    switch(size) {\
+    case 1:\
+        v = *(const uint8_t *)ptr;\
+        break;\
+    case 2:\
+        v = *(const uint16_t *)ptr;\
+        break;\
+    default:\
+        v = *(const uint32_t *)ptr;\
+        break;\
+    }\
+}
+
+static int alloc_table_fixed(VLC_FIX *vlc, int size)
+{
+    int index;
+    index = vlc->table_size;
+    vlc->table_size += size;
+    if (vlc->table_size > vlc->table_allocated) {
+       /* DEBUGF("Tried to allocate past the end of a Huffman table: %d/%d\n", 
+            vlc->table_allocated, vlc->table_allocated+(1 << vlc->bits));*/
+        vlc->table_allocated += (1 << vlc->bits);
+        if (!vlc->table)
+            return -1;
+    }
+    return index;
+}
+
+static int build_table_fixed(VLC_FIX *vlc, int table_nb_bits,
+                       int nb_codes,
+                       const void *bits, int bits_wrap, int bits_size,
+                       const void *codes, int codes_wrap, int codes_size,
+                       uint32_t code_prefix, int n_prefix)
+{
+    int i, j, k, n, table_size, table_index, nb, n1, index, code_prefix2;
+    uint32_t code;
+    int flags = 0;
+    VLC_TYPE (*table)[2];
+
+    table_size = 1 << table_nb_bits;
+    table_index = alloc_table_fixed(vlc, table_size);
+#ifdef DEBUG_VLC
+    printf("new table index=%d size=%d code_prefix=%x n=%d\n",
+           table_index, table_size, code_prefix, n_prefix);
+#endif
+    if (table_index < 0)
+        return -1;
+    table = &vlc->table[table_index];
+
+    for(i=0;i<table_size;i++) {
+        table[i][1] = 0; //bits
+        table[i][0] = -1; //codes
+    }
+
+    /* first pass: map codes and compute auxillary table sizes */
+    for(i=0;i<nb_codes;i++) {
+        GET_DATA_FIX(n, bits, i, bits_wrap, bits_size);
+        GET_DATA_FIX(code, codes, i, codes_wrap, codes_size);
+        /* we accept tables with holes */
+        if (n <= 0)
+            continue;
+#if defined(DEBUG_VLC) && 0
+        printf("i=%d n=%d code=0x%x\n", i, n, code);
+#endif
+        /* if code matches the prefix, it is in the table */
+        n -= n_prefix;
+        if(flags & INIT_VLC_LE)
+            code_prefix2= code & (n_prefix>=32 ? 0xffffffff : (uint32_t)(1 << n_prefix)-1);
+        else
+            code_prefix2= code >> n;
+        if (n > 0 && (int)code_prefix2 == (int)code_prefix) {
+            if (n <= table_nb_bits) {
+                /* no need to add another table */
+                j = (code << (table_nb_bits - n)) & (table_size - 1);
+                nb = 1 << (table_nb_bits - n);
+                for(k=0;k<nb;k++) {
+                    if(flags & INIT_VLC_LE)
+                        j = (code >> n_prefix) + (k<<n);
+#ifdef DEBUG_VLC
+                    av_log(NULL, 0, "%4x: code=%d n=%d\n",
+                           j, i, n);
+#endif
+                    if (table[j][1] /*bits*/ != 0) {
+                        return -1;
+                    }
+                    table[j][1] = n; //bits
+                    table[j][0] = i; //code
+                    j++;
+                }
+            } else {
+                n -= table_nb_bits;
+                j = (code >> ((flags & INIT_VLC_LE) ? n_prefix : n)) & ((1 << table_nb_bits) - 1);
+#ifdef DEBUG_VLC
+                av_log(NULL, 0,"%4x: n=%d (subtable)\n",
+                       j, n);
+#endif
+                /* compute table size */
+                n1 = -table[j][1]; //bits
+                if (n > n1)
+                    n1 = n;
+                table[j][1] = -n1; //bits
+            }
+        }
+    }
+
+    /* second pass : fill auxillary tables recursively */
+    for(i=0;i<table_size;i++) {
+        n = table[i][1]; //bits
+        if (n < 0) {
+            n = -n;
+            if (n > table_nb_bits) {
+                n = table_nb_bits;
+                table[i][1] = -n; //bits
+            }
+            index = build_table_fixed(vlc, n, nb_codes,
+                                bits, bits_wrap, bits_size,
+                                codes, codes_wrap, codes_size,
+                                (flags & INIT_VLC_LE) ? (code_prefix | (i << n_prefix)) : ((code_prefix << table_nb_bits) | i),
+                                n_prefix + table_nb_bits);
+            if (index < 0)
+                return -1;
+            /* note: realloc has been done, so reload tables */
+            table = &vlc->table[table_index];
+            table[i][0] = index; //code
+        }
+    }
+    return table_index;
+}
+
+/* Build VLC decoding tables suitable for use with get_vlc().
+
+   'nb_bits' set thee decoding table size (2^nb_bits) entries. The
+   bigger it is, the faster is the decoding. But it should not be too
+   big to save memory and L1 cache. '9' is a good compromise.
+
+   'nb_codes' : number of vlcs codes
+
+   'bits' : table which gives the size (in bits) of each vlc code.
+
+   'codes' : table which gives the bit pattern of of each vlc code.
+
+   'xxx_wrap' : give the number of bytes between each entry of the
+   'bits' or 'codes' tables.
+
+   'xxx_size' : gives the number of bytes of each entry of the 'bits'
+   or 'codes' tables.
+
+   'wrap' and 'size' allow using any memory configuration and types
+   (byte/word/long) to store the 'bits' and 'codes' tables.
+
+   'use_static' should be set to 1 for tables, which should be freed
+   with av_free_static(), 0 if free_vlc() will be used.
+*/
+int init_vlc_fixed(VLC_FIX *vlc, int nb_bits, int nb_codes,
+             const void *bits, int bits_wrap, int bits_size,
+             const void *codes, int codes_wrap, int codes_size,
+             int flags)
+{
+
+    vlc->bits = nb_bits;
+     vlc->table_size = 0;
+
+#ifdef DEBUG_VLC
+    printf("build table nb_codes=%d\n", nb_codes);
+#endif
+
+    if (build_table_fixed(vlc, nb_bits, nb_codes,
+                    bits, bits_wrap, bits_size,
+                    codes, codes_wrap, codes_size,
+                    0, 0) < 0) {
+        //av_free(vlc->table);
+        return -1;
+    }
+    /* return flags to block gcc warning while allowing us to keep
+     * consistent with ffmpeg's function parameters
+     */
+    return flags;
+}

--- a/libavcodec/fixed_bitstream.h
+++ b/libavcodec/fixed_bitstream.h
@@ -0,0 +1,993 @@
+/*
+ * copyright (c) 2004 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file bitstream.h
+ * bitstream api header.
+ */
+
+#ifndef BITSTREAM_H
+#define BITSTREAM_H
+
+#define av_always_inline inline
+#define attribute_deprecated
+
+#include <inttypes.h>
+#include <stdlib.h>
+#include "get_bits.h"
+#ifdef __arm__
+#define CONFIG_ALIGN 1
+#endif
+
+/*#ifdef ROCKBOX_BIG_ENDIAN
+#define WORDS_BIGENDIAN
+#endif*/
+
+#include "bswap.h"
+
+extern const uint8_t ff_log2_tab_fixed[256];
+
+
+/*misc utility functions added to make it compile */
+static inline int av_log2_fixed(unsigned int v)
+{
+    int n;
+
+    n = 0;
+    if (v & 0xffff0000) {
+        v >>= 16;
+        n += 16;
+    }
+    if (v & 0xff00) {
+        v >>= 8;
+        n += 8;
+    }
+    n += ff_log2_tab_fixed[v];
+
+    return n;
+}
+
+#if defined(ALT_BITSTREAM_READER_LE) && !defined(ALT_BITSTREAM_READER)
+#define ALT_BITSTREAM_READER
+#endif
+
+//#define ALT_BITSTREAM_WRITER
+//#define ALIGNED_BITSTREAM_WRITER
+#if !defined(LIBMPEG2_BITSTREAM_READER) && !defined(A32_BITSTREAM_READER) && !defined(ALT_BITSTREAM_READER)
+#   ifdef ARCH_ARMV4L
+#       define A32_BITSTREAM_READER
+#   else
+#define ALT_BITSTREAM_READER
+//#define LIBMPEG2_BITSTREAM_READER
+//#define A32_BITSTREAM_READER
+#   endif
+#endif
+#define LIBMPEG2_BITSTREAM_READER_HACK //add BERO
+
+//extern const uint8_t ff_reverse[256];
+
+/*#if defined(ARCH_X86)
+// avoid +32 for shift optimization (gcc should do that ...)
+static inline  int32_t NEG_SSR32_fixed( int32_t a, int8_t s){
+    __asm__ ("sarl %1, %0\n\t"
+         : "+r" (a)
+         : "ic" ((uint8_t)(-s))
+    );
+    return a;
+}
+static inline uint32_t NEG_USR32_fixed(uint32_t a, int8_t s){
+    __asm__ ("shrl %1, %0\n\t"
+         : "+r" (a)
+         : "ic" ((uint8_t)(-s))
+    );
+    return a;
+}
+#else*/
+#    define NEG_SSR32_fixed(a,s) ((( int32_t)(a))>>(32-(s)))
+#    define NEG_USR32_fixed(a,s) (((uint32_t)(a))>>(32-(s)))
+//#endif
+
+/* bit output */
+
+/* buf and buf_end must be present and used by every alternative writer. */
+typedef struct PutBitContext_fixed {
+#ifdef ALT_BITSTREAM_WRITER
+    uint8_t *buf, *buf_end;
+    int index;
+#else
+    uint32_t bit_buf;
+    int bit_left;
+    uint8_t *buf, *buf_ptr, *buf_end;
+#endif
+} PutBitContext_fixed;
+
+static inline void init_put_bits_fixed(PutBitContext_fixed *s, uint8_t *buffer, int buffer_size)
+{
+    if(buffer_size < 0) {
+        buffer_size = 0;
+        buffer = NULL;
+    }
+
+    s->buf = buffer;
+    s->buf_end = s->buf + buffer_size;
+#ifdef ALT_BITSTREAM_WRITER
+    s->index=0;
+    ((uint32_t*)(s->buf))[0]=0;
+//    memset(buffer, 0, buffer_size);
+#else
+    s->buf_ptr = s->buf;
+    s->bit_left=32;
+    s->bit_buf=0;
+#endif
+}
+
+/* return the number of bits output */
+static inline int put_bits_count_fixed(PutBitContext_fixed *s)
+{
+#ifdef ALT_BITSTREAM_WRITER
+    return s->index;
+#else
+    return (s->buf_ptr - s->buf) * 8 + 32 - s->bit_left;
+#endif
+}
+
+/* pad the end of the output stream with zeros */
+static inline void flush_put_bits_fixed(PutBitContext_fixed *s)
+{
+#ifdef ALT_BITSTREAM_WRITER
+    align_put_bits_fixed(s);
+#else
+    s->bit_buf<<= s->bit_left;
+    while (s->bit_left < 32) {
+        /* XXX: should test end of buffer */
+        *s->buf_ptr++=s->bit_buf >> 24;
+        s->bit_buf<<=8;
+        s->bit_left+=8;
+    }
+    s->bit_left=32;
+    s->bit_buf=0;
+#endif
+}
+
+void align_put_bits_fixed(PutBitContext_fixed *s);
+void ff_put_string_fixed(PutBitContext_fixed * pbc, char *s, int put_zero);
+
+/* bit input */
+/* buffer, buffer_end and size_in_bits must be present and used by every reader */
+typedef struct GetBitContext_fixed {
+    const uint8_t *buffer, *buffer_end;
+#ifdef ALT_BITSTREAM_READER
+    int index;
+#elif defined LIBMPEG2_BITSTREAM_READER
+    uint8_t *buffer_ptr;
+    uint32_t cache;
+    int bit_count;
+#elif defined A32_BITSTREAM_READER
+    uint32_t *buffer_ptr;
+    uint32_t cache0;
+    uint32_t cache1;
+    int bit_count;
+#endif
+    int size_in_bits;
+} GetBitContext_fixed;
+
+#define VLC_TYPE int16_t
+
+typedef struct VLC_FIX {
+    int bits;
+    VLC_TYPE (*table)[2]; /* code, bits */
+    int table_size, table_allocated;
+} VLC_FIX;
+
+typedef struct RL_VLC_ELEM_FIX {
+    int16_t level;
+    int8_t len;
+    uint8_t run;
+} RL_VLC_ELEM_FIX;
+//jh
+#    define unaligned32_fixed(a) (*(const uint32_t*)(a))
+
+
+#if defined(ARCH_SPARC) || defined(ARCH_ARMV4L) || defined(ARCH_MIPS) || defined(ARCH_BFIN)
+#define UNALIGNED_STORES_ARE_BAD
+#endif
+
+/* used to avoid missaligned exceptions on some archs (alpha, ...) */
+#if defined(ARCH_X86) || defined(CPU_COLDFIRE)
+#    define unaligned16(a) (*(const uint16_t*)(a))
+#    define unaligned64(a) (*(const uint64_t*)(a))
+#else
+#    ifdef __GNUC__
+#    define unaligned(x)                                \
+static inline uint##x##_t unaligned##x(const void *v) { \
+    struct Unaligned {                                  \
+        uint##x##_t i;                                  \
+    } __attribute__((packed));                          \
+                                                        \
+    return ((const struct Unaligned *) v)->i;           \
+}
+#    elif defined(__DECC)
+#    define unaligned(x)                                        \
+static inline uint##x##_t unaligned##x(const void *v) {         \
+    return *(const __unaligned uint##x##_t *) v;                \
+}
+#    else
+#    define unaligned(x)                                        \
+static inline uint##x##_t unaligned##x(const void *v) {         \
+    return *(const uint##x##_t *) v;                            \
+}
+#    endif
+unaligned(16)
+unaligned(32)
+unaligned(64)
+#undef unaligned
+#endif /* defined(ARCH_X86) */
+
+#ifndef ALT_BITSTREAM_WRITER
+static inline void put_bits_fixed(PutBitContext_fixed *s, int n, unsigned int value)
+{
+    unsigned int bit_buf;
+    int bit_left;
+
+    // printf("put_bits_fixed=%d %x\n", n, value);
+    // assert(n == 32 || value < (1U << n));
+    bit_buf = s->bit_buf;
+    bit_left = s->bit_left;
+
+    //    printf("n=%d value=%x cnt=%d buf=%x\n", n, value, bit_cnt, bit_buf);
+    /* XXX: optimize */
+    if (n < bit_left) {
+        bit_buf = (bit_buf<<n) | value;
+        bit_left-=n;
+    } else {
+        bit_buf<<=bit_left;
+        bit_buf |= value >> (n - bit_left);
+#ifdef UNALIGNED_STORES_ARE_BAD
+        if (3 & (intptr_t) s->buf_ptr) {
+            s->buf_ptr[0] = bit_buf >> 24;
+            s->buf_ptr[1] = bit_buf >> 16;
+            s->buf_ptr[2] = bit_buf >>  8;
+            s->buf_ptr[3] = bit_buf      ;
+        } else
+#endif
+        *(uint32_t *)s->buf_ptr = be2me_32(bit_buf);
+        //printf("bitbuf = %08x\n", bit_buf);
+        s->buf_ptr+=4;
+        bit_left+=32 - n;
+        bit_buf = value;
+    }
+
+    s->bit_buf = bit_buf;
+    s->bit_left = bit_left;
+}
+#endif
+
+#ifdef ALT_BITSTREAM_WRITER
+static inline void put_bits_fixed(PutBitContext_fixed *s, int n, unsigned int value)
+{
+#    ifdef ALIGNED_BITSTREAM_WRITER
+/*#        if defined(ARCH_X86)
+    __asm__ volatile(
+        "movl %0, %%ecx                 \n\t"
+        "xorl %%eax, %%eax              \n\t"
+        "shrdl %%cl, %1, %%eax          \n\t"
+        "shrl %%cl, %1                  \n\t"
+        "movl %0, %%ecx                 \n\t"
+        "shrl $3, %%ecx                 \n\t"
+        "andl $0xFFFFFFFC, %%ecx        \n\t"
+        "bswapl %1                      \n\t"
+        "orl %1, (%2, %%ecx)            \n\t"
+        "bswapl %%eax                   \n\t"
+        "addl %3, %0                    \n\t"
+        "movl %%eax, 4(%2, %%ecx)       \n\t"
+        : "=&r" (s->index), "=&r" (value)
+        : "r" (s->buf), "r" (n), "0" (s->index), "1" (value<<(-n))
+        : "%eax", "%ecx"
+    );
+#        else*/
+    int index= s->index;
+    uint32_t *ptr= ((uint32_t *)s->buf)+(index>>5);
+
+    value<<= 32-n;
+
+    ptr[0] |= be2me_32(value>>(index&31));
+    ptr[1]  = be2me_32(value<<(32-(index&31)));
+//if(n>24) printf("%d %d\n", n, value);
+    index+= n;
+    s->index= index;
+//#        endif
+/*#    else //ALIGNED_BITSTREAM_WRITER
+#        if defined(ARCH_X86)
+    __asm__ volatile(
+        "movl $7, %%ecx                 \n\t"
+        "andl %0, %%ecx                 \n\t"
+        "addl %3, %%ecx                 \n\t"
+        "negl %%ecx                     \n\t"
+        "shll %%cl, %1                  \n\t"
+        "bswapl %1                      \n\t"
+        "movl %0, %%ecx                 \n\t"
+        "shrl $3, %%ecx                 \n\t"
+        "orl %1, (%%ecx, %2)            \n\t"
+        "addl %3, %0                    \n\t"
+        "movl $0, 4(%%ecx, %2)          \n\t"
+        : "=&r" (s->index), "=&r" (value)
+        : "r" (s->buf), "r" (n), "0" (s->index), "1" (value)
+        : "%ecx"
+    );
+#        else*/
+    int index= s->index;
+    uint32_t *ptr= (uint32_t*)(((uint8_t *)s->buf)+(index>>3));
+
+    ptr[0] |= be2me_32(value<<(32-n-(index&7) ));
+    ptr[1] = 0;
+//if(n>24) printf("%d %d\n", n, value);
+    index+= n;
+    s->index= index;
+//#        endif
+#    endif //!ALIGNED_BITSTREAM_WRITER
+}
+#endif
+
+static inline uint8_t* pbBufPtr_fixed(PutBitContext_fixed *s)
+{
+#ifdef ALT_BITSTREAM_WRITER
+        return s->buf + (s->index>>3);
+#else
+        return s->buf_ptr;
+#endif
+}
+
+/**
+ *
+ * PutBitContext_fixed must be flushed & aligned to a byte boundary before calling this.
+ */
+static inline void skip_put_bytes_fixed(PutBitContext_fixed *s, int n){
+       // assert((put_bits_fixed_count_fixed(s)&7)==0);
+#ifdef ALT_BITSTREAM_WRITER
+        FIXME may need some cleaning of the buffer
+        s->index += n<<3;
+#else
+       // assert(s->bit_left==32);
+        s->buf_ptr += n;
+#endif
+}
+
+/**
+ * skips the given number of bits.
+ * must only be used if the actual values in the bitstream dont matter
+ */
+static inline void skip_put_bits_fixed(PutBitContext_fixed *s, int n){
+#ifdef ALT_BITSTREAM_WRITER
+    s->index += n;
+#else
+    s->bit_left -= n;
+    s->buf_ptr-= s->bit_left>>5;
+    s->bit_left &= 31;
+#endif
+}
+
+/**
+ * Changes the end of the buffer.
+ */
+static inline void set_put_bits_buffer_size_fixed(PutBitContext_fixed *s, int size){
+    s->buf_end= s->buf + size;
+}
+
+/* Bitstream reader API docs:
+name
+    abritary name which is used as prefix for the internal variables
+
+gb
+    GetBitContext_fixed
+
+OPEN_READER(name, gb)
+    loads gb into local variables
+
+CLOSE_READER(name, gb)
+    stores local vars in gb
+
+UPDATE_CACHE(name, gb)
+    refills the internal cache from the bitstream
+    after this call at least MIN_CACHE_BITS will be available,
+
+GET_CACHE(name, gb)
+    will output the contents of the internal cache, next bit is MSB of 32 or 64 bit (FIXME 64bit)
+
+SHOW_UBITS(name, gb, num)
+    will return the next num bits
+
+SHOW_SBITS_FIX(name, gb, num)
+    will return the next num bits and do sign extension
+
+SKIP_BITS(name, gb, num)
+    will skip over the next num bits
+    note, this is equivalent to SKIP_CACHE; SKIP_COUNTER
+
+SKIP_CACHE(name, gb, num)
+    will remove the next num bits from the cache (note SKIP_COUNTER MUST be called before UPDATE_CACHE / CLOSE_READER)
+
+SKIP_COUNTER(name, gb, num)
+    will increment the internal bit counter (see SKIP_CACHE & SKIP_BITS)
+
+LAST_SKIP_CACHE(name, gb, num)
+    will remove the next num bits from the cache if it is needed for UPDATE_CACHE otherwise it will do nothing
+
+LAST_SKIP_BITS(name, gb, num)
+    is equivalent to SKIP_LAST_CACHE; SKIP_COUNTER
+
+for examples see get_bits, show_bits, skip_bits, get_vlc
+*/
+
+static inline int unaligned32_be_fixed(const void *v)
+{
+//#ifdef CONFIG_ALIGN
+        const uint8_t *p=v;
+        return (((p[0]<<8) | p[1])<<16) | (p[2]<<8) | (p[3]);
+/*#else
+        return be2me_32( unaligned32_fixed(v)); //original
+#endif*/
+}
+
+static inline int unaligned32_le_fixed(const void *v)
+{
+//#ifdef CONFIG_ALIGN
+       const uint8_t *p=v;
+       return (((p[3]<<8) | p[2])<<16) | (p[1]<<8) | (p[0]);
+/*#else
+       return le2me_32( unaligned32_fixed(v)); //original
+#endif*/
+}
+
+#ifdef ALT_BITSTREAM_READER
+#   define MIN_CACHE_BITS 25
+
+#   define OPEN_READER_FIX(name, gb)\
+        int name##_index= (gb)->index;\
+        int name##_cache= 0;\
+
+#   define CLOSE_READER_FIX(name, gb)\
+        (gb)->index= name##_index;\
+
+# ifdef ALT_BITSTREAM_READER_LE
+#   define UPDATE_CACHE_FIX(name, gb)\
+        name##_cache= unaligned32_le_fixed( ((const uint8_t *)(gb)->buffer)+(name##_index>>3) ) >> (name##_index&0x07);\
+
+#   define SKIP_CACHE_FIX(name, gb, num)\
+        name##_cache >>= (num);
+# else
+#   define UPDATE_CACHE_FIX(name, gb)\
+        name##_cache= unaligned32_be_fixed( ((const uint8_t *)(gb)->buffer)+(name##_index>>3) ) << (name##_index&0x07);\
+
+#   define SKIP_CACHE_FIX(name, gb, num)\
+        name##_cache <<= (num);
+# endif
+
+// FIXME name?
+#   define SKIP_COUNTER(name, gb, num)\
+        name##_index += (num);\
+
+#   define SKIP_BITS_FIX(name, gb, num)\
+        {\
+            SKIP_CACHE_FIX(name, gb, num)\
+            SKIP_COUNTER(name, gb, num)\
+        }\
+
+#   define LAST_SKIP_BITS_FIX(name, gb, num) SKIP_COUNTER(name, gb, num)
+#   define LAST_SKIP_CACHE_FIX(name, gb, num) ;
+
+# ifdef ALT_BITSTREAM_READER_LE
+#   define SHOW_UBITS_FIX(name, gb, num)\
+        ((name##_cache) & (NEG_USR32_fixed(0xffffffff,num)))
+
+#   define SHOW_SBITS_FIX(name, gb, num)\
+        NEG_SSR32_fixed((name##_cache)<<(32-(num)), num)
+# else
+#   define SHOW_UBITS_FIX(name, gb, num)\
+        NEG_USR32_fixed(name##_cache, num)
+
+#   define SHOW_SBITS_FIX(name, gb, num)\
+        NEG_SSR32_fixed(name##_cache, num)
+# endif
+
+#   define GET_CACHE_FIX(name, gb)\
+        ((uint32_t)name##_cache)
+
+static inline int get_bits_count_fixed(GetBitContext_fixed *s){
+    return s->index;
+}
+
+static inline void skip_bits_long_fixed(GetBitContext_fixed *s, int n){
+    s->index += n;
+}
+
+#elif defined LIBMPEG2_BITSTREAM_READER
+//libmpeg2 like reader
+
+#   define MIN_CACHE_BITS 17
+
+#   define OPEN_READER_FIX(name, gb)\
+        int name##_bit_count=(gb)->bit_count;\
+        int name##_cache= (gb)->cache;\
+        uint8_t * name##_buffer_ptr=(gb)->buffer_ptr;\
+
+#   define CLOSE_READER_FIX(name, gb)\
+        (gb)->bit_count= name##_bit_count;\
+        (gb)->cache= name##_cache;\
+        (gb)->buffer_ptr= name##_buffer_ptr;\
+
+#ifdef LIBMPEG2_BITSTREAM_READER_HACK
+
+#   define UPDATE_CACHE_FIX(name, gb)\
+    if(name##_bit_count >= 0){\
+        name##_cache+= (int)be2me_16(*(uint16_t*)name##_buffer_ptr) << name##_bit_count;\
+        name##_buffer_ptr += 2;\
+        name##_bit_count-= 16;\
+    }\
+
+#else
+
+#   define UPDATE_CACHE_FIX(name, gb)\
+    if(name##_bit_count >= 0){\
+        name##_cache+= ((name##_buffer_ptr[0]<<8) + name##_buffer_ptr[1]) << name##_bit_count;\
+        name##_buffer_ptr+=2;\
+        name##_bit_count-= 16;\
+    }\
+
+#endif
+
+#   define SKIP_CACHE_FIX(name, gb, num)\
+        name##_cache <<= (num);\
+
+#   define SKIP_COUNTER(name, gb, num)\
+        name##_bit_count += (num);\
+
+#   define SKIP_BITS_FIX(name, gb, num)\
+        {\
+            SKIP_CACHE_FIX(name, gb, num)\
+            SKIP_COUNTER(name, gb, num)\
+        }\
+
+#   define LAST_SKIP_BITS_FIX(name, gb, num) SKIP_BITS_FIX(name, gb, num)
+#   define LAST_SKIP_CACHE_FIX(name, gb, num) SKIP_CACHE_FIX(name, gb, num)
+
+#   define SHOW_UBITS_FIX(name, gb, num)\
+        NEG_USR32_fixed(name##_cache, num)
+
+#   define SHOW_SBITS_FIX(name, gb, num)\
+        NEG_SSR32_fixed(name##_cache, num)
+
+#   define GET_CACHE_FIX(name, gb)\
+        ((uint32_t)name##_cache)
+
+static inline int get_bits_count_fixed(GetBitContext_fixed *s){
+    return (s->buffer_ptr - s->buffer)*8 - 16 + s->bit_count;
+}
+
+static inline void skip_bits_long_fixed(GetBitContext_fixed *s, int n){
+    OPEN_READER_FIX(re, s)
+    re_bit_count += n;
+    re_buffer_ptr += 2*(re_bit_count>>4);
+    re_bit_count &= 15;
+    re_cache = ((re_buffer_ptr[-2]<<8) + re_buffer_ptr[-1]) << (16+re_bit_count);
+    UPDATE_CACHE_FIX(re, s)
+    CLOSE_READER_FIX(re, s)
+}
+
+#elif defined A32_BITSTREAM_READER
+
+#   define MIN_CACHE_BITS 32
+
+#   define OPEN_READER_FIX(name, gb)\
+        int name##_bit_count=(gb)->bit_count;\
+        uint32_t name##_cache0= (gb)->cache0;\
+        uint32_t name##_cache1= (gb)->cache1;\
+        uint32_t * name##_buffer_ptr=(gb)->buffer_ptr;\
+
+#   define CLOSE_READER_FIX(name, gb)\
+        (gb)->bit_count= name##_bit_count;\
+        (gb)->cache0= name##_cache0;\
+        (gb)->cache1= name##_cache1;\
+        (gb)->buffer_ptr= name##_buffer_ptr;\
+
+#   define UPDATE_CACHE_FIX(name, gb)\
+    if(name##_bit_count > 0){\
+        const uint32_t next= be2me_32( *name##_buffer_ptr );\
+        name##_cache0 |= NEG_USR32_fixed(next,name##_bit_count);\
+        name##_cache1 |= next<<name##_bit_count;\
+        name##_buffer_ptr++;\
+        name##_bit_count-= 32;\
+    }\
+
+/*#if defined(ARCH_X86)
+#   define SKIP_CACHE_FIX(name, gb, num)\
+        __asm__(\
+            "shldl %2, %1, %0          \n\t"\
+            "shll %2, %1               \n\t"\
+            : "+r" (name##_cache0), "+r" (name##_cache1)\
+            : "Ic" ((uint8_t)(num))\
+           );
+#else*/
+#   define SKIP_CACHE_FIX(name, gb, num)\
+        name##_cache0 <<= (num);\
+        name##_cache0 |= NEG_USR32_fixed(name##_cache1,num);\
+        name##_cache1 <<= (num);
+//#endif
+
+#   define SKIP_COUNTER(name, gb, num)\
+        name##_bit_count += (num);\
+
+#   define SKIP_BITS_FIX(name, gb, num)\
+        {\
+            SKIP_CACHE_FIX(name, gb, num)\
+            SKIP_COUNTER(name, gb, num)\
+        }\
+
+#   define LAST_SKIP_BITS_FIX(name, gb, num) SKIP_BITS_FIX(name, gb, num)
+#   define LAST_SKIP_CACHE_FIX(name, gb, num) SKIP_CACHE_FIX(name, gb, num)
+
+#   define SHOW_UBITS_FIX(name, gb, num)\
+        NEG_USR32_fixed(name##_cache0, num)
+
+#   define SHOW_SBITS_FIX(name, gb, num)\
+        NEG_SSR32_fixed(name##_cache0, num)
+
+#   define GET_CACHE_FIX(name, gb)\
+        (name##_cache0)
+
+static inline int get_bits_count_fixed(GetBitContext_fixed *s){
+    return ((uint8_t*)s->buffer_ptr - s->buffer)*8 - 32 + s->bit_count;
+}
+
+static inline void skip_bits_long_fixed(GetBitContext_fixed *s, int n){
+    OPEN_READER_FIX(re, s)
+    re_bit_count += n;
+    re_buffer_ptr += re_bit_count>>5;
+    re_bit_count &= 31;
+    re_cache0 = be2me_32( re_buffer_ptr[-1] ) << re_bit_count;
+    re_cache1 = 0;
+    UPDATE_CACHE_FIX(re, s)
+    CLOSE_READER_FIX(re, s)
+}
+
+#endif
+
+/**
+ * read mpeg1 dc style vlc (sign bit + mantisse with no MSB).
+ * if MSB not set it is negative
+ * @param n length in bits
+ * @author BERO
+ */
+static inline int get_xbits_fixed(GetBitContext_fixed *s, int n){
+    register int sign;
+    register int32_t cache;
+    OPEN_READER_FIX(re, s)
+    UPDATE_CACHE_FIX(re, s)
+    cache = GET_CACHE_FIX(re,s);
+    sign=(~cache)>>31;
+    LAST_SKIP_BITS_FIX(re, s, n)
+    CLOSE_READER_FIX(re, s)
+    return (NEG_USR32_fixed(sign ^ cache, n) ^ sign) - sign;
+}
+
+static inline int get_sbits_fixed(GetBitContext_fixed *s, int n){
+    register int tmp;
+    OPEN_READER_FIX(re, s)
+    UPDATE_CACHE_FIX(re, s)
+    tmp= SHOW_SBITS_FIX(re, s, n);
+    LAST_SKIP_BITS_FIX(re, s, n)
+    CLOSE_READER_FIX(re, s)
+    return tmp;
+}
+
+/**
+ * reads 1-17 bits.
+ * Note, the alt bitstream reader can read up to 25 bits, but the libmpeg2 reader can't
+ */
+static inline unsigned int get_bits_fixed(GetBitContext_fixed *s, int n){
+    register int tmp;
+    OPEN_READER_FIX(re, s)
+    UPDATE_CACHE_FIX(re, s)
+    tmp= SHOW_UBITS_FIX(re, s, n);
+    LAST_SKIP_BITS_FIX(re, s, n)
+    CLOSE_READER_FIX(re, s)
+    return tmp;
+}
+
+/**
+ * shows 1-17 bits.
+ * Note, the alt bitstream reader can read up to 25 bits, but the libmpeg2 reader can't
+ */
+static inline unsigned int show_bits_fixed(GetBitContext_fixed *s, int n){
+    register int tmp;
+    OPEN_READER_FIX(re, s)
+    UPDATE_CACHE_FIX(re, s)
+    tmp= SHOW_UBITS_FIX(re, s, n);
+//    CLOSE_READER(re, s)
+    return tmp;
+}
+
+static inline void skip_bits_fixed(GetBitContext_fixed *s, int n){
+/* Note: gcc seems to optimize this to s->index+=n for the ALT_READER :)) */
+    OPEN_READER_FIX(re, s)
+    UPDATE_CACHE_FIX(re, s)
+    LAST_SKIP_BITS_FIX(re, s, n)
+    CLOSE_READER_FIX(re, s)
+}
+
+static inline unsigned int get_bits1_fixed(GetBitContext_fixed *s){
+#ifdef ALT_BITSTREAM_READER
+    int index= s->index;
+    uint8_t result= s->buffer[ index>>3 ];
+#ifdef ALT_BITSTREAM_READER_LE
+    result>>= (index&0x07);
+    result&= 1;
+#else
+    result<<= (index&0x07);
+    result>>= 8 - 1;
+#endif
+    index++;
+    s->index= index;
+
+    return result;
+#else
+    return get_bits_fixed(s, 1);
+#endif
+}
+
+static inline unsigned int show_bits1_fixed(GetBitContext_fixed *s){
+    return show_bits_fixed(s, 1);
+}
+
+static inline void skip_bits1_fixed(GetBitContext_fixed *s){
+    skip_bits_fixed(s, 1);
+}
+
+/**
+ * reads 0-32 bits.
+ */
+static inline unsigned int get_bits_long_fixed(GetBitContext_fixed *s, int n){
+    if(n<=17) return get_bits_fixed(s, n);
+    else{
+#ifdef ALT_BITSTREAM_READER_LE
+        int ret= get_bits_fixed(s, 16);
+        return ret | (get_bits_fixed(s, n-16) << 16);
+#else
+        int ret= get_bits_fixed(s, 16) << (n-16);
+        return ret | get_bits_fixed(s, n-16);
+#endif
+    }
+}
+
+/**
+ * shows 0-32 bits.
+ */
+static inline unsigned int show_bits_long_fixed(GetBitContext_fixed *s, int n){
+    if(n<=17) return show_bits_fixed(s, n);
+    else{
+        GetBitContext_fixed gb= *s;
+        int ret= get_bits_long_fixed(s, n);
+        *s= gb;
+        return ret;
+    }
+}
+
+/*
+static inline int check_marker(GetBitContext_fixed *s, const char *msg)
+{
+    int bit= get_bits1(s);
+    if(!bit)
+        av_log(NULL, AV_LOG_INFO, "Marker bit missing %s\n", msg);
+
+    return bit;
+}
+*/
+
+/**
+ * init GetBitContext_fixed.
+ * @param buffer bitstream buffer, must be FF_INPUT_BUFFER_PADDING_SIZE bytes larger then the actual read bits
+ * because some optimized bitstream readers read 32 or 64 bit at once and could read over the end
+ * @param bit_size the size of the buffer in bits
+ */
+static inline void init_get_bits_fixed(GetBitContext_fixed *s,
+                   const uint8_t *buffer, int bit_size)
+{
+    int buffer_size= (bit_size+7)>>3;
+    if(buffer_size < 0 || bit_size < 0) {
+        buffer_size = bit_size = 0;
+        buffer = NULL;
+    }
+
+    s->buffer= buffer;
+    s->size_in_bits= bit_size;
+    s->buffer_end= buffer + buffer_size;
+#ifdef ALT_BITSTREAM_READER
+    s->index=0;
+#elif defined LIBMPEG2_BITSTREAM_READER
+    s->buffer_ptr = (uint8_t*)((intptr_t)buffer&(~1));
+    s->bit_count = 16 + 8*((intptr_t)buffer&1);
+    skip_bits_long_fixed(s, 0);
+#elif defined A32_BITSTREAM_READER
+    s->buffer_ptr = (uint32_t*)((intptr_t)buffer&(~3));
+    s->bit_count = 32 + 8*((intptr_t)buffer&3);
+    skip_bits_long_fixed(s, 0);
+#endif
+}
+
+static inline void align_get_bits_fixed(GetBitContext_fixed *s)
+{
+    int n= (-get_bits_count_fixed(s)) & 7;
+    if(n) skip_bits_fixed(s, n);
+}
+
+int init_vlc_fixed(VLC_FIX *vlc, int nb_bits, int nb_codes,
+             const void *bits, int bits_wrap, int bits_size,
+             const void *codes, int codes_wrap, int codes_size,
+             int flags);
+#define INIT_VLC_USE_STATIC 1
+#define INIT_VLC_LE         2
+void free_vlc_fixed(VLC_FIX *vlc);
+
+/**
+ *
+ * if the vlc code is invalid and max_depth=1 than no bits will be removed
+ * if the vlc code is invalid and max_depth>1 than the number of bits removed
+ * is undefined
+ */
+#define GET_VLC_FIX(code, name, gb, table, bits, max_depth)\
+{\
+    int n, index, nb_bits;\
+\
+    index= SHOW_UBITS_FIX(name, gb, bits); \
+    code = table[index][0];\
+    n    = table[index][1];\
+\
+    if(max_depth > 1 && n < 0){\
+        LAST_SKIP_BITS_FIX(name, gb, bits) \
+        UPDATE_CACHE_FIX(name, gb) \
+\
+        nb_bits = -n;\
+\
+        index= SHOW_UBITS_FIX(name, gb, nb_bits) + code; \
+        code = table[index][0];\
+        n    = table[index][1];\
+        if(max_depth > 2 && n < 0){\
+            LAST_SKIP_BITS_FIX(name, gb, nb_bits)  \
+            UPDATE_CACHE_FIX(name, gb)\
+\
+            nb_bits = -n;\
+\
+            index= SHOW_UBITS_FIX(name, gb, nb_bits) + code; \
+            code = table[index][0];\
+            n    = table[index][1];\
+        }\
+    }\
+    SKIP_BITS_FIX(name, gb, n) \
+}
+
+#define GET_RL_VLC_FIX(level, run, name, gb, table, bits, max_depth, need_update)\
+{\
+    int n, index, nb_bits;\
+\
+    index= SHOW_UBITS_FIX(name, gb, bits);\
+    level = table[index].level;\
+    n     = table[index].len;\
+\
+    if(max_depth > 1 && n < 0){\
+        SKIP_BITS_FIX(name, gb, bits)\
+        if(need_update){\
+            UPDATE_CACHE_FIX(name, gb)\
+        }\
+\
+        nb_bits = -n;\
+\
+        index= SHOW_UBITS_FIX(name, gb, nb_bits) + level;\
+        level = table[index].level;\
+        n     = table[index].len;\
+    }\
+    run= table[index].run;\
+    SKIP_BITS_FIX(name, gb, n)\
+}
+
+
+/**
+ * parses a vlc code, faster then get_vlc()
+ * @param bits is the number of bits which will be read at once, must be
+ *             identical to nb_bits in init_vlc()
+ * @param max_depth is the number of times bits bits must be read to completely
+ *                  read the longest vlc code
+ *                  = (max_vlc_length + bits - 1) / bits
+ */
+static av_always_inline int get_vlc2_fixed(GetBitContext_fixed *s, VLC_TYPE (*table)[2],
+                                  int bits, int max_depth)
+{
+    int code;                //av_log(NULL,AV_LOG_INFO,"aa\n");
+
+    OPEN_READER_FIX(re, s)     //  av_log(NULL,AV_LOG_INFO,"bb\n");
+    UPDATE_CACHE_FIX(re, s)     // av_log(NULL,AV_LOG_INFO,"cc\n");
+
+    GET_VLC_FIX(code, re, s, table, bits, max_depth) //av_log(NULL,AV_LOG_INFO,"dd\n");
+
+    CLOSE_READER_FIX(re, s)      // av_log(NULL,AV_LOG_INFO,"ee\n");
+    return code;
+}
+
+#ifdef TRACE
+static inline void print_bin_fixed(int bits, int n){
+    int i;
+
+    for(i=n-1; i>=0; i--){
+        av_log(NULL, AV_LOG_DEBUG, "%d", (bits>>i)&1);
+    }
+    for(i=n; i<24; i++)
+        av_log(NULL, AV_LOG_DEBUG, " ");
+}
+
+static inline int get_bits_trace_fixed(GetBitContext_fixed *s, int n, char *file, const char *func, int line){
+    int r= get_bits_fixed(s, n);
+
+    print_bin_fixed(r, n);
+    av_log(NULL, AV_LOG_DEBUG, "%5d %2d %3d bit @%5d in %s %s:%d\n", r, n, r, get_bits_count_fixed(s)-n, file, func, line);
+    return r;
+}
+
+static inline int get_vlc_trace_fixed(GetBitContext_fixed *s, VLC_TYPE (*table)[2], int bits, int max_depth, char *file, const char *func, int line){
+    int show= show_bits_fixed(s, 24);
+    int pos= get_bits_count_fixed(s);
+    int r= get_vlc2_fixed(s, table, bits, max_depth);
+    int len= get_bits_count_fixed(s) - pos;
+    int bits2= show>>(24-len);
+
+    print_bin_fixed(bits2, len);
+
+    av_log(NULL, AV_LOG_DEBUG, "%5d %2d %3d vlc @%5d in %s %s:%d\n", bits2, len, r, pos, file, func, line);
+    return r;
+}
+
+static inline int get_xbits_trace_fixed(GetBitContext_fixed *s, int n, char *file, const char *func, int line){
+    int show= show_bits_fixed(s, n);
+    int r= get_xbits_fixed(s, n);
+
+    print_bin_fixed(show, n);
+    av_log(NULL, AV_LOG_DEBUG, "%5d %2d %3d xbt @%5d in %s %s:%d\n", show, n, r, get_bits_count_fixed(s)-n, file, func, line);
+    return r;
+}
+
+#define get_bits_fixed(s, n)  get_bits_trace_fixed(s, n, __FILE__, __PRETTY_FUNCTION__, __LINE__)
+#define get_bits1_fixed(s)    get_bits_trace_fixed(s, 1, __FILE__, __PRETTY_FUNCTION__, __LINE__)
+#define get_xbits_fixed(s, n) get_xbits_trace_fixed(s, n, __FILE__, __PRETTY_FUNCTION__, __LINE__)
+#define get_vlc_fixed(s, vlc)            get_vlc_trace_fixed(s, (vlc)->table, (vlc)->bits, 3, __FILE__, __PRETTY_FUNCTION__, __LINE__)
+#define get_vlc2_fixed(s, tab, bits, max) get_vlc_trace_fixed(s, tab, bits, max, __FILE__, __PRETTY_FUNCTION__, __LINE__)
+
+#define tprintf(p, ...) av_log(p, AV_LOG_DEBUG, __VA_ARGS__)
+
+#else //TRACE
+#define tprintf(p, ...) {}
+#endif
+
+static inline int decode012_fixed(GetBitContext_fixed *gb){
+    int n;
+    n = get_bits1_fixed(gb);
+    if (n == 0)
+        return 0;
+    else
+        return get_bits1_fixed(gb) + 1;
+}
+
+#endif /* BITSTREAM_H */

--- a/libavcodec/fixed_fft.c
+++ b/libavcodec/fixed_fft.c
@@ -0,0 +1,153 @@
+/*
+ * WMA compatible decoder
+ * Copyright (c) 2002 The FFmpeg Project.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <inttypes.h>
+#include "fixed_fft.h"
+#include "wmafixed.h"
+
+#define IBSS_ATTR
+#define ICONST_ATTR
+#define ICODE_ATTR
+
+FFTComplex_fixed  exptab0[512] IBSS_ATTR;
+
+/* butter fly op */
+#define BF_FIX(pre, pim, qre, qim, pre1, pim1, qre1, qim1) \
+{ \
+  int32_t ax, ay, bx, by; \
+  bx=pre1; \
+  by=pim1; \
+  ax=qre1; \
+  ay=qim1; \
+  pre = (bx + ax); \
+  pim = (by + ay); \
+  qre = (bx - ax); \
+  qim = (by - ay); \
+}
+
+
+int fft_calc_unscaled_fixed(FFTContext_fixed *s, FFTComplex_fixed *z)
+{
+    int ln = s->nbits;
+    int j, np, np2;
+    int nblocks, nloops;
+    register FFTComplex_fixed *p, *q;
+    int l;
+    int32_t tmp_re, tmp_im;
+    int tabshift = 10-ln;
+
+    np = 1 << ln;
+
+    /* pass 0 */
+    p=&z[0];
+    j=(np >> 1);
+    do
+    {
+        BF_FIX(p[0].re, p[0].im, p[1].re, p[1].im,
+           p[0].re, p[0].im, p[1].re, p[1].im);
+        p+=2;
+    }
+    while (--j != 0);
+
+    /* pass 1 */
+    p=&z[0];
+    j=np >> 2;
+    if (s->inverse)
+    {
+        do
+        {
+            BF_FIX(p[0].re, p[0].im, p[2].re, p[2].im,
+               p[0].re, p[0].im, p[2].re, p[2].im);
+            BF_FIX(p[1].re, p[1].im, p[3].re, p[3].im,
+               p[1].re, p[1].im, -p[3].im, p[3].re);
+            p+=4;
+        }
+        while (--j != 0);
+    }
+    else
+    {
+        do
+        {
+            BF_FIX(p[0].re, p[0].im, p[2].re, p[2].im,
+               p[0].re, p[0].im, p[2].re, p[2].im);
+            BF_FIX(p[1].re, p[1].im, p[3].re, p[3].im,
+               p[1].re, p[1].im, p[3].im, -p[3].re);
+            p+=4;
+        }
+        while (--j != 0);
+    }
+
+    /* pass 2 .. ln-1 */
+    nblocks = np >> 3;
+    nloops = 1 << 2;
+    np2 = np >> 1;
+    do
+    {
+        p = z;
+        q = z + nloops;
+        for (j = 0; j < nblocks; ++j)
+        {
+            BF_FIX(p->re, p->im, q->re, q->im,
+               p->re, p->im, q->re, q->im);
+
+            p++;
+            q++;
+            for(l = nblocks; l < np2; l += nblocks)
+            {
+                CMUL_FIX(&tmp_re, &tmp_im, exptab0[(l<<tabshift)].re, exptab0[(l<<tabshift)].im, q->re, q->im);
+                //CMUL(&tmp_re, &tmp_im, exptab[l].re, exptab[l].im, q->re, q->im);
+                BF_FIX(p->re, p->im, q->re, q->im,
+                   p->re, p->im, tmp_re, tmp_im);
+                p++;
+                q++;
+            }
+
+            p += nloops;
+            q += nloops;
+        }
+        nblocks = nblocks >> 1;
+        nloops = nloops << 1;
+    }
+    while (nblocks != 0);
+
+    return 0;
+}
+
+int fft_init_global_fixed(void)
+{
+    int i, n;
+    int32_t c1, s1, s2;
+
+    n=1<<10;
+    s2 = 1 ? 1 : -1;
+
+    for(i=0;i<(n/2);++i)
+    {
+        int32_t ifix = itofix32(i);
+        int32_t nfix = itofix32(n);
+        int32_t res = fixdiv32(ifix,nfix);
+
+        s1 = fsincos(res<<16, &c1);
+
+        exptab0[i].re = c1;
+        exptab0[i].im = s1*s2;
+    }
+
+    return 0;
+}

--- a/libavcodec/fixed_fft.h
+++ b/libavcodec/fixed_fft.h
@@ -0,0 +1,47 @@
+/*
+ * WMA compatible decoder
+ * Copyright (c) 2002 The FFmpeg Project.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef WMA_FFT_H
+#define WMA_FFT_H 1
+
+#include <inttypes.h>
+
+typedef int32_t FFTSample;
+
+typedef struct FFTComplex_fixed
+{
+    int32_t re, im;
+}
+FFTComplex_fixed;
+
+typedef struct FFTContext_fixed
+{
+    int nbits;
+    int inverse;
+    uint16_t *revtab;
+    FFTComplex_fixed *exptab;
+    FFTComplex_fixed *exptab1; /* only used by SSE code */
+    int (*fft_calc)(struct FFTContext_fixed *s, FFTComplex_fixed *z);
+}
+FFTContext_fixed;
+
+int fft_calc_unscaled_fixed(FFTContext_fixed *s, FFTComplex_fixed *z);
+int fft_init_global_fixed(void);
+
+#endif

--- a/libavcodec/fixed_mdct.c
+++ b/libavcodec/fixed_mdct.c
@@ -0,0 +1,164 @@
+/*
+ * WMA compatible decoder
+ * Copyright (c) 2002 The FFmpeg Project.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <string.h>
+#include "wmafixed.h"
+#include "fixed_mdct.h"
+
+/*these are the sin and cos rotations used by the MDCT*/
+
+/*accessed too infrequently to give much speedup in IRAM*/
+
+int32_t *tcosarray[5], *tsinarray[5];
+int32_t tcos0[1024], tcos1[512], tcos2[256], tcos3[128], tcos4[64];
+int32_t tsin0[1024], tsin1[512], tsin2[256], tsin3[128], tsin4[64];
+
+uint16_t revtab0[1024];
+
+/**
+ * init MDCT or IMDCT computation.
+ */
+int ff_mdct_init_fixed1(MDCTContext_fixed *s, int nbits, int inverse)
+{
+    int n, n4, i;
+
+    memset(s, 0, sizeof(*s));
+    n = 1 << nbits;            /* nbits ranges from 12 to 8 inclusive */
+    s->nbits = nbits;
+    s->n = n;
+    n4 = n >> 2;
+    s->tcos = tcosarray[12-nbits];
+    s->tsin = tsinarray[12-nbits];
+    for(i=0;i<n4;i++)
+    {
+        int32_t ip = itofix32(i) + 0x2000;
+        ip = ip >> nbits;
+
+        /*I can't remember why this works, but it seems
+          to agree for ~24 bits, maybe more!*/
+        s->tsin[i] = - fsincos(ip<<16, &(s->tcos[i]));
+        s->tcos[i] *=-1;
+    }
+
+    (&s->fft)->nbits = nbits-2;
+    (&s->fft)->inverse = inverse;
+
+    return 0;
+
+}
+
+/**
+ * Compute inverse MDCT of size N = 2^nbits
+ * @param output N samples
+ * @param input N/2 samples
+ * @param tmp N/2 samples
+ */
+void ff_imdct_calc_fixed(MDCTContext_fixed *s,
+                   int32_t *output,
+                   int32_t *input)
+{
+    int k, n8, n4, n2, n, j,scale;
+    const int32_t *tcos = s->tcos;
+    const int32_t *tsin = s->tsin;
+    const int32_t *in1, *in2;
+    FFTComplex_fixed *z1 = (FFTComplex_fixed *)output;
+    FFTComplex_fixed *z2 = (FFTComplex_fixed *)input;
+    int revtabshift = 12 - s->nbits;
+
+    n = 1 << s->nbits;
+
+    n2 = n >> 1;
+    n4 = n >> 2;
+    n8 = n >> 3;
+
+    /* pre rotation */
+    in1 = input;
+    in2 = input + n2 - 1;
+
+    for(k = 0; k < n4; k++)
+    {
+        j=revtab0[k<<revtabshift];
+        CMUL_FIX(&z1[j].re, &z1[j].im, *in2, *in1, tcos[k], tsin[k]);
+        in1 += 2;
+        in2 -= 2;
+    }
+
+    scale = fft_calc_unscaled_fixed(&s->fft, z1);
+
+    /* post rotation + reordering */
+    for(k = 0; k < n4; k++)
+    {
+        CMUL_FIX(&z2[k].re, &z2[k].im, (z1[k].re), (z1[k].im), tcos[k], tsin[k]);
+    }
+
+    for(k = 0; k < n8; k++)
+    {
+        int32_t r1,r2,r3,r4,r1n,r2n,r3n;
+
+        r1 = z2[n8 + k].im;
+        r1n = r1 * -1;
+        r2 = z2[n8-1-k].re;
+        r2n = r2 * -1;
+        r3 = z2[k+n8].re;
+        r3n = r3 * -1;
+        r4 = z2[n8-k-1].im;
+
+        output[2*k] = r1n;
+        output[n2-1-2*k] = r1;
+
+        output[2*k+1] = r2;
+        output[n2-1-2*k-1] = r2n;
+
+        output[n2 + 2*k]= r3n;
+        output[n-1- 2*k]= r3n;
+
+        output[n2 + 2*k+1]= r4;
+        output[n-2 - 2 * k] = r4;
+    }
+}
+
+/* init MDCT */
+
+int mdct_init_global_fixed(void)
+{
+    int i,j,m;
+
+    /* although seemingly degenerate, these cannot actually be merged together without
+       a substantial increase in error which is unjustified by the tiny memory savings*/
+
+    tcosarray[0] = tcos0; tcosarray[1] = tcos1; tcosarray[2] = tcos2; tcosarray[3] = tcos3;tcosarray[4] = tcos4;
+    tsinarray[0] = tsin0; tsinarray[1] = tsin1; tsinarray[2] = tsin2; tsinarray[3] = tsin3;tsinarray[4] = tsin4;
+
+    /* init the MDCT bit reverse table here rather then in fft_init */
+
+    for(i=0;i<1024;i++)           /*hard coded to a 2048 bit rotation*/
+    {                             /*smaller sizes can reuse the largest*/
+        m=0;
+        for(j=0;j<10;j++)
+        {
+            m |= ((i >> j) & 1) << (10-j-1);
+        }
+
+       revtab0[i]=m;
+    }
+
+    fft_init_global_fixed();
+
+    return 0;
+}

--- a/libavcodec/fixed_mdct.h
+++ b/libavcodec/fixed_mdct.h
@@ -0,0 +1,40 @@
+/*
+ * WMA compatible decoder
+ * Copyright (c) 2002 The FFmpeg Project.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef WMA_MDCT_H
+#define WMA_MDCT_H 1
+
+#include "fixed_fft.h"
+
+typedef struct MDCTContext_fixed
+{
+    int n;     /* size of MDCT (i.e. number of input data * 2) */
+    int nbits; /* n = 2^nbits */
+    /* pre/post rotation tables */
+    int32_t *tcos;
+    int32_t *tsin;
+    FFTContext_fixed fft;
+}
+MDCTContext_fixed;
+
+int ff_mdct_init_fixed1(MDCTContext_fixed *s, int nbits, int inverse);
+void ff_imdct_calc_fixed(MDCTContext_fixed *s, int32_t *output, int32_t *input);
+int mdct_init_global_fixed(void);
+
+#endif

--- a/libavcodec/fixed_wmadec.h
+++ b/libavcodec/fixed_wmadec.h
@@ -0,0 +1,145 @@
+/*
+ * WMA compatible decoder
+ * Copyright (c) 2002 The FFmpeg Project.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _WMADEC_H
+#define _WMADEC_H
+
+#include <inttypes.h>
+#include "avcodec.h"
+//#include "fixed_asf.h"
+#include "fixed_bitstream.h" /* For GetBitContext */
+#include "fixed_mdct.h"
+
+#undef TRACE
+
+/* size of blocks */
+#define BLOCK_MIN_BITS 7
+#define BLOCK_MAX_BITS 11
+#define BLOCK_MAX_SIZE (1 << BLOCK_MAX_BITS)
+
+#define BLOCK_NB_SIZES (BLOCK_MAX_BITS - BLOCK_MIN_BITS + 1)
+
+/* XXX: find exact max size */
+#define HIGH_BAND_MAX_SIZE 16
+
+#define NB_LSP_COEFS 10
+
+/* XXX: is it a suitable value ? */
+#define MAX_CODED_SUPERFRAME_SIZE 16384
+
+#define M_PI    3.14159265358979323846
+
+#define M_PI_F  0x3243f // in fixed 32 format
+#define TWO_M_PI_F  0x6487f   //in fixed 32
+
+#define MAX_CHANNELS 2
+
+#define NOISE_TAB_SIZE 8192
+
+#define LSP_POW_BITS 7
+
+typedef struct WMACodecContext
+{
+    GetBitContext_fixed gb;
+
+    int nb_block_sizes;  /* number of block sizes */
+
+    int sample_rate;
+    int nb_channels;
+    int bit_rate;
+    int version; /* 1 = 0x160 (WMAV1), 2 = 0x161 (WMAV2) */
+    int block_align;
+    int use_bit_reservoir;
+    int use_variable_block_len;
+    int use_exp_vlc;  /* exponent coding: 0 = lsp, 1 = vlc + delta */
+    int use_noise_coding; /* true if perceptual noise is added */
+    int byte_offset_bits;
+    VLC_FIX exp_vlc;
+    int exponent_sizes[BLOCK_NB_SIZES];
+    uint16_t exponent_bands[BLOCK_NB_SIZES][25];
+    int high_band_start[BLOCK_NB_SIZES]; /* index of first coef in high band */
+    int coefs_start;               /* first coded coef */
+    int coefs_end[BLOCK_NB_SIZES]; /* max number of coded coefficients */
+    int exponent_high_sizes[BLOCK_NB_SIZES];
+    int exponent_high_bands[BLOCK_NB_SIZES][HIGH_BAND_MAX_SIZE];
+    VLC_FIX hgain_vlc;
+
+    /* coded values in high bands */
+    int high_band_coded[MAX_CHANNELS][HIGH_BAND_MAX_SIZE];
+    int high_band_values[MAX_CHANNELS][HIGH_BAND_MAX_SIZE];
+
+    /* there are two possible tables for spectral coefficients */
+    VLC_FIX coef_vlc[2];
+    uint16_t *run_table[2];
+    uint16_t *level_table[2];
+    /* frame info */
+    int frame_len;       /* frame length in samples */
+    int frame_len_bits;  /* frame_len = 1 << frame_len_bits */
+
+    /* block info */
+    int reset_block_lengths;
+    int block_len_bits; /* log2 of current block length */
+    int next_block_len_bits; /* log2 of next block length */
+    int prev_block_len_bits; /* log2 of prev block length */
+    int block_len; /* block length in samples */
+    int block_num; /* block number in current frame */
+    int block_pos; /* current position in frame */
+    uint8_t ms_stereo; /* true if mid/side stereo mode */
+    uint8_t channel_coded[MAX_CHANNELS]; /* true if channel is coded */
+    int exponents_bsize[MAX_CHANNELS];      // log2 ratio frame/exp. length
+    int32_t exponents[MAX_CHANNELS][BLOCK_MAX_SIZE];
+    int32_t max_exponent[MAX_CHANNELS];
+    int16_t coefs1[MAX_CHANNELS][BLOCK_MAX_SIZE];
+    int32_t (*coefs)[MAX_CHANNELS][BLOCK_MAX_SIZE];
+    MDCTContext_fixed mdct_ctx[BLOCK_NB_SIZES];
+    int32_t *windows[BLOCK_NB_SIZES];
+    /* output buffer for one frame and the last for IMDCT windowing */
+    int32_t frame_out[MAX_CHANNELS][BLOCK_MAX_SIZE * 2];
+    /* last frame info */
+    uint8_t last_superframe[MAX_CODED_SUPERFRAME_SIZE + 4]; /* padding added */
+    int last_bitoffset;
+    int last_superframe_len;
+    int32_t *noise_table;
+    int noise_index;
+    int32_t noise_mult; /* XXX: suppress that and integrate it in the noise array */
+    /* lsp_to_curve tables */
+    int32_t lsp_cos_table[BLOCK_MAX_SIZE];
+    int64_t lsp_pow_e_table[256];
+    int32_t lsp_pow_m_table1[(1 << LSP_POW_BITS)];
+    int32_t lsp_pow_m_table2[(1 << LSP_POW_BITS)];
+
+    /* State of current superframe decoding */
+    int bit_offset;
+    int nb_frames;
+    int current_frame;
+
+#ifdef TRACE
+
+    int frame_count;
+#endif
+}
+WMACodecContext;
+
+static int wma_decode_init(AVCodecContext * avctx);
+int wma_decode_superframe_init(WMACodecContext* s,
+                               uint8_t *buf, int buf_size);
+/*int wma_decode_superframe_frame(WMACodecContext* s,
+                                int32_t *samples,
+                                uint8_t *buf, int buf_size);*/
+#endif

--- a/libavcodec/fixed_wmadeci.c
+++ b/libavcodec/fixed_wmadeci.c
@@ -0,0 +1,1694 @@
+/*
+ * WMA compatible decoder
+ * Copyright (c) 2002 The FFmpeg Project.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/**
+ * @file wmadec.c
+ * WMA compatible decoder.
+ */
+
+#define IBSS_ATTR
+#define ICONST_ATTR
+#define ICODE_ATTR
+
+#ifdef NDEBUG
+#include <stdio.h>
+#undef WMA_DEBUG /* enable when debugging wma */
+#endif
+
+//#include "fixed_asf.h"
+#include "fixed_wmadec.h"
+#include "wmafixed.h"
+#include "fixed_bitstream.h"
+#include <string.h> /* memcpy() */
+
+#define VLCBITS 7       /*7 is the lowest without glitching*/
+#define VLCMAX ((22+VLCBITS-1)/VLCBITS)
+
+#define EXPVLCBITS 7
+#define EXPMAX ((19+EXPVLCBITS-1)/EXPVLCBITS)
+
+#define HGAINVLCBITS 9
+#define HGAINMAX ((13+HGAINVLCBITS-1)/HGAINVLCBITS)
+
+//jh0728
+#define BLOCK_MAX_SIZE_WMA (1 << 11)
+#define MAX_CHANNELS_WMA 2
+
+#define ENTER() //av_log(NULL,AV_LOG_INFO,"%s:ENTER\n", __FUNCTION__)
+#define LEAVE() //av_log(NULL,AV_LOG_INFO,"%s:LEAVE\n", __FUNCTION__)
+
+int wma_decode_superframe_frame(WMACodecContext* s,
+                                int32_t* samples, /*output*/
+                                uint8_t *buf,  /*input*/
+                                int buf_size);
+typedef struct CoefVLCTable_fixed
+{
+    int n; /* total number of codes */
+    const uint32_t *huffcodes; /* VLC bit values */
+    const uint8_t *huffbits;   /* VLC bit size */
+    const uint16_t *levels; /* table to build run/level tables */
+}
+CoefVLCTable_fixed;
+
+static void wma_lsp_to_curve_init(WMACodecContext *s, int frame_len);
+
+int32_t coefsarray[MAX_CHANNELS_WMA][BLOCK_MAX_SIZE_WMA] IBSS_ATTR;
+
+/* static variables that replace malloced stuff */
+/* these are the MDCT reconstruction windows */
+int32_t stat0[2048], stat1[1024], stat2[512], stat3[256], stat4[128];
+
+/* these are VLC lookup tables */
+uint16_t *runtabarray[2], *levtabarray[2];
+
+/* these could be made smaller since only one can be 1336 */
+uint16_t runtab0[1336], runtab1[1336], levtab0[1336], levtab1[1336];
+
+#define VLCBUF1SIZE 4598
+#define VLCBUF2SIZE 3574
+#define VLCBUF3SIZE 360
+#define VLCBUF4SIZE 540
+
+/*putting these in IRAM actually makes PP slower*/
+
+int32_t vlcbuf1[VLCBUF1SIZE][2];
+int32_t vlcbuf2[VLCBUF2SIZE][2];
+int32_t vlcbuf3[VLCBUF3SIZE][2];
+int32_t vlcbuf4[VLCBUF4SIZE][2];
+
+#include "wmadata.h" // PJJ
+
+/*
+ * Helper functions for wma_window.
+ *
+ *
+ */
+/*
+#ifdef __arm__
+static inline
+void vector_fmul_add_add(int32_t *dst, const int32_t *data,
+                         const int32_t *window, int n)
+{
+   
+    __asm__ volatile (
+        "0:"
+        "ldmia %[d]!, {r0, r1};"
+        "ldmia %[w]!, {r4, r5};"
+       
+        "smull r8, r9, r0, r4;"
+        "ldmia %[dst], {r0, r4};"
+        "add   r0, r0, r9, lsl #1;"  
+        "smull r8, r9, r1, r5;"
+        "add   r1, r4, r9, lsl #1;"
+        "stmia %[dst]!, {r0, r1};"
+        "subs  %[n], %[n], #2;"
+        "bne   0b;"
+        : [d] "+r" (data), [w] "+r" (window), [dst] "+r" (dst), [n] "+r" (n)
+        : : "r0", "r1", "r4", "r5", "r8", "r9", "memory", "cc");
+}
+
+static inline
+void vector_fmul_reverse(int32_t *dst, const int32_t *src0, const int32_t *src1,
+                         int len)
+{
+   
+    __asm__ volatile (
+        "add   %[s1], %[s1], %[n], lsl #2;"
+        "0:"
+        "ldmia %[s0]!, {r0, r1};"
+        "ldmdb %[s1]!, {r4, r5};"
+        "smull r8, r9, r0, r5;"
+        "mov   r0, r9, lsl #1;"
+        "smull r8, r9, r1, r4;"
+        "mov   r1, r9, lsl #1;"
+        "stmia %[dst]!, {r0, r1};"
+        "subs  %[n], %[n], #2;"
+        "bne   0b;"
+        : [s0] "+r" (src0), [s1] "+r" (src1), [dst] "+r" (dst), [n] "+r" (len)
+        : : "r0", "r1", "r4", "r5", "r8", "r9", "memory", "cc");
+}
+
+#elif defined(CPU_COLDFIRE)
+
+static inline
+void vector_fmul_add_add(int32_t *dst, const int32_t *data,
+                         const int32_t *window, int n)
+{
+    
+    __asm__ volatile (
+        "0:"
+        "movem.l (%[d]), %%d0-%%d3;"
+        "movem.l (%[w]), %%d4-%%d5/%%a0-%%a1;"
+        "mac.l %%d0, %%d4, %%acc0;"
+        "mac.l %%d1, %%d5, %%acc1;"
+        "mac.l %%d2, %%a0, %%acc2;"
+        "mac.l %%d3, %%a1, %%acc3;"
+        "lea.l (16, %[d]), %[d];"
+        "lea.l (16, %[w]), %[w];"
+        "movclr.l %%acc0, %%d0;"
+        "movclr.l %%acc1, %%d1;"
+        "movclr.l %%acc2, %%d2;"
+        "movclr.l %%acc3, %%d3;"
+        "add.l %%d0, (%[dst])+;"
+        "add.l %%d1, (%[dst])+;"
+        "add.l %%d2, (%[dst])+;"
+        "add.l %%d3, (%[dst])+;"
+        "subq.l #4, %[n];"
+        "jne 0b;"
+        : [d] "+a" (data), [w] "+a" (window), [dst] "+a" (dst), [n] "+d" (n)
+        : : "d0", "d1", "d2", "d3", "d4", "d5", "a0", "a1", "memory", "cc");
+}
+
+static inline
+void vector_fmul_reverse(int32_t *dst, const int32_t *src0, const int32_t *src1,
+                         int len)
+{
+    
+    __asm__ volatile (
+        "lea.l (-16, %[s1], %[n]*4), %[s1];"
+        "0:"
+        "movem.l (%[s0]), %%d0-%%d3;"
+        "movem.l (%[s1]), %%d4-%%d5/%%a0-%%a1;"
+        "mac.l %%d0, %%a1, %%acc0;"
+        "mac.l %%d1, %%a0, %%acc1;"
+        "mac.l %%d2, %%d5, %%acc2;"
+        "mac.l %%d3, %%d4, %%acc3;"
+        "lea.l (16, %[s0]), %[s0];"
+        "lea.l (-16, %[s1]), %[s1];"
+        "movclr.l %%acc0, %%d0;"
+        "movclr.l %%acc1, %%d1;"
+        "movclr.l %%acc2, %%d2;"
+        "movclr.l %%acc3, %%d3;"
+        "movem.l %%d0-%%d3, (%[dst]);"
+        "lea.l (16, %[dst]), %[dst];"
+        "subq.l #4, %[n];"
+        "jne 0b;"
+        : [s0] "+a" (src0), [s1] "+a" (src1), [dst] "+a" (dst), [n] "+d" (len)
+        : : "d0", "d1", "d2", "d3", "d4", "d5", "a0", "a1", "memory", "cc");
+}
+
+#else*/
+
+static inline void vector_fmul_add_add(int32_t *dst, const int32_t *src0, const int32_t *src1, int len){
+    int i;                                                           ENTER();
+    for(i=0; i<len; i++)
+        dst[i] = fixmul32b(src0[i], src1[i]) + dst[i];               LEAVE();
+}
+
+static inline void vector_fmul_reverse(int32_t *dst, const int32_t *src0, const int32_t *src1, int len){
+    int i;
+    src1 += len-1;                                      ENTER();
+    for(i=0; i<len; i++)
+        dst[i] = fixmul32b(src0[i], src1[-i]);            ENTER();
+}
+
+/*#endif
+
+*
+  * Apply MDCT window and add into output.
+  *
+  * We ensure that when the windows overlap their squared sum
+  * is always 1 (MDCT reconstruction rule).
+  *
+  * The Vorbis I spec has a great diagram explaining this process.
+  * See section 1.3.2.3 of http://xiph.org/vorbis/doc/Vorbis_I_spec.html
+  */
+static void wma_window(WMACodecContext *s, int32_t *in, int32_t *out)
+{
+    int block_len, bsize, n;
+                                                         ENTER();
+     /* left part */
+     /*previous block was larger, so we'll use the size of the current block to set the window size*/
+    if (s->block_len_bits <= s->prev_block_len_bits) {
+         block_len = s->block_len;
+         bsize = s->frame_len_bits - s->block_len_bits;           //av_log(NULL,AV_LOG_INFO,"1\n");
+
+         vector_fmul_add_add(out, in, s->windows[bsize], block_len);
+
+    } else {
+         /*previous block was smaller or the same size, so use it's size to set the window length*/
+         block_len = 1 << s->prev_block_len_bits;             // av_log(NULL,AV_LOG_INFO,"2\n");
+         /*find the middle of the two overlapped blocks, this will be the first overlapped sample*/
+         n = (s->block_len - block_len) >> 1;                   //   av_log(NULL,AV_LOG_INFO,"3\n");
+         bsize = s->frame_len_bits - s->prev_block_len_bits;      // av_log(NULL,AV_LOG_INFO,"4\n");
+
+         vector_fmul_add_add(out+n, in+n, s->windows[bsize],  block_len); //av_log(NULL,AV_LOG_INFO,"5\n");
+
+         memcpy(out+n+block_len, in+n+block_len, n*sizeof(int32_t)); //av_log(NULL,AV_LOG_INFO,"6\n");
+    }
+    /* Advance to the end of the current block and prepare to window it for the next block.
+     * Since the window function needs to be reversed, we do it backwards starting with the
+     * last sample and moving towards the first
+     */
+     out += s->block_len;
+     in += s->block_len;            //av_log(NULL,AV_LOG_INFO,"7\n");
+
+     /* right part */
+     if (s->block_len_bits <= s->next_block_len_bits) {
+         block_len = s->block_len;
+         bsize = s->frame_len_bits - s->block_len_bits;
+
+         vector_fmul_reverse(out, in, s->windows[bsize], block_len); //av_log(NULL,AV_LOG_INFO,"8\n");
+
+     } else {
+         block_len = 1 << s->next_block_len_bits;
+         n = (s->block_len - block_len) >> 1;
+         bsize = s->frame_len_bits - s->next_block_len_bits;   //av_log(NULL,AV_LOG_INFO,"9\n");
+
+         memcpy(out, in, n*sizeof(int32_t));
+
+         vector_fmul_reverse(out+n, in+n, s->windows[bsize], block_len);      //av_log(NULL,AV_LOG_INFO,"10\n");
+
+         memset(out+n+block_len, 0, n*sizeof(int32_t));
+     }                                                       LEAVE();
+}
+
+/* XXX: use same run/length optimization as mpeg decoders */
+static void init_coef_vlc(VLC_FIX *vlc,
+                          uint16_t **prun_table, uint16_t **plevel_table,
+                          const CoefVLCTable_fixed *vlc_table, int tab)
+{
+    int n;
+    const uint8_t *table_bits;
+    const uint32_t *table_codes;
+    const uint16_t *levels_table;
+    uint16_t *run_table, *level_table;
+    const uint16_t *p;
+    int i, l, j, level;
+ 
+     n = vlc_table->n;
+     table_bits = vlc_table->huffbits;   
+     table_codes = vlc_table->huffcodes;      
+     levels_table = vlc_table->levels;                                ENTER();
+    init_vlc_fixed(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);
+
+    run_table = runtabarray[tab];
+    level_table= levtabarray[tab];
+
+    p = levels_table;
+    i = 2;
+    level = 1;
+    while (i < n)
+    {
+        l = *p++;
+        for(j=0;j<l;++j)
+        {
+            run_table[i] = j;
+            level_table[i] = level;
+            ++i;
+        }
+        ++level;
+    }
+    *prun_table = run_table;
+    *plevel_table = level_table;                   LEAVE();
+}
+
+//int wma_decode_init(WMACodecContext* s, asf_waveformatex_t *wfx)
+static int wma_decode_init(AVCodecContext * avctx)
+{
+   
+    WMACodecContext *s;
+    int i, flags1, flags2;
+    int32_t *window;
+    uint8_t *extradata;
+    int64_t bps1;
+    int32_t high_freq;
+    int64_t bps;
+    int sample_rate1;
+    int coef_vlc_table;
+
+    #ifdef CPU_COLDFIRE
+    coldfire_set_macsr(EMAC_FRACTIONAL | EMAC_SATURATE);
+    #endif
+    s = avctx->priv_data;
+    s->sample_rate = avctx->sample_rate;
+    s->nb_channels = avctx->channels;
+    s->bit_rate = avctx->bit_rate;
+    s->block_align = avctx->block_align;                 ENTER();
+ //av_log(NULL,AV_LOG_INFO,"============\nsample_rate:%d\nnb_channels:%d\nbit_rate%d\nblock_align%d\n=============\n",s->sample_rate,s->nb_channels,s->bit_rate,s->block_align);
+
+    s->coefs = &coefsarray;
+
+    if (avctx->codec->id == CODEC_ID_WMAV1) {
+        s->version = 1;
+    } else if (avctx->codec->id == CODEC_ID_WMAV2 ) {
+        s->version = 2;
+    } else {
+        /*one of those other wma flavors that don't have GPLed decoders */
+        return -1;
+    }
+
+    /* extract flag infos */
+    flags1 = 0;
+    flags2 = 0;
+    extradata = avctx->extradata;
+    if (s->version == 1 && avctx->extradata_size >= 4) {
+        flags1 = extradata[0] | (extradata[1] << 8);
+        flags2 = extradata[2] | (extradata[3] << 8);
+    }else if (s->version == 2 && avctx->extradata_size >= 6){
+        flags1 = extradata[0] | (extradata[1] << 8) |
+                 (extradata[2] << 16) | (extradata[3] << 24);
+        flags2 = extradata[4] | (extradata[5] << 8);
+    }
+    s->use_exp_vlc = flags2 & 0x0001;
+    s->use_bit_reservoir = flags2 & 0x0002;
+    s->use_variable_block_len = flags2 & 0x0004;
+
+    /* compute MDCT block size */
+    if (s->sample_rate <= 16000){
+        s->frame_len_bits = 9;
+    }else if (s->sample_rate <= 22050 ||
+             (s->sample_rate <= 32000 && s->version == 1)){
+        s->frame_len_bits = 10;
+    }else{
+        s->frame_len_bits = 11;
+    }
+    s->frame_len = 1 << s->frame_len_bits;
+    if (s-> use_variable_block_len)
+    {
+        int nb_max, nb;
+        nb = ((flags2 >> 3) & 3) + 1;
+        if ((s->bit_rate / s->nb_channels) >= 32000)
+        {
+            nb += 2;
+        }
+        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;  /* max is 11-7 */
+        if (nb > nb_max)
+            nb = nb_max;
+        s->nb_block_sizes = nb + 1;
+    }
+    else
+    {
+        s->nb_block_sizes = 1;
+    }
+
+    /* init rate dependant parameters */
+    s->use_noise_coding = 1;
+    high_freq = itofix64(s->sample_rate) >> 1;
+
+    /* if version 2, then the rates are normalized */
+    sample_rate1 = s->sample_rate;
+    if (s->version == 2)
+    {
+        if (sample_rate1 >= 44100)
+            sample_rate1 = 44100;
+        else if (sample_rate1 >= 22050)
+            sample_rate1 = 22050;
+        else if (sample_rate1 >= 16000)
+            sample_rate1 = 16000;
+        else if (sample_rate1 >= 11025)
+            sample_rate1 = 11025;
+        else if (sample_rate1 >= 8000)
+            sample_rate1 = 8000;
+    }
+
+    int64_t tmp = itofix64(s->bit_rate);
+    int64_t tmp2 = itofix64(s->nb_channels * s->sample_rate);
+    bps = fixdiv64(tmp, tmp2);
+    int64_t tim = bps * s->frame_len;
+    int64_t tmpi = fixdiv64(tim,itofix64(8));
+    s->byte_offset_bits = av_log2_fixed(fixtoi64(tmpi+0x8000)) + 2;
+
+    /*av_log(NULL,AV_LOG_INFO,"tmp=%ld tmp2=%ldtim = %ld tmpi=%ld s->byte_offset_bits=%ld \n", tmp, tmp2,tim,tmpi,s->byte_offset_bits);
+    av_log(NULL,AV_LOG_INFO,"bps=%ld\n",bps);*/
+
+    /* compute high frequency value and choose if noise coding should
+       be activated */
+    bps1 = bps;
+    if (s->nb_channels == 2)
+        bps1 = fixmul32(bps,0x1999a);
+    if (sample_rate1 == 44100)
+    {
+        if (bps1 >= 0x9c29)
+            s->use_noise_coding = 0;
+        else
+            high_freq = fixmul32(high_freq,0x6666);
+    }
+    else if (sample_rate1 == 22050)
+    {
+        if (bps1 >= 0x128f6)
+            s->use_noise_coding = 0;
+        else if (bps1 >= 0xb852)
+            high_freq = fixmul32(high_freq,0xb333);
+        else
+            high_freq = fixmul32(high_freq,0x999a);
+    }
+    else if (sample_rate1 == 16000)
+    {
+        if (bps > 0x8000)
+            high_freq = fixmul32(high_freq,0x8000);
+        else
+            high_freq = fixmul32(high_freq,0x4ccd);
+    }
+    else if (sample_rate1 == 11025)
+    {
+        high_freq = fixmul32(high_freq,0xb333);
+    }
+    else if (sample_rate1 == 8000)
+    {
+        if (bps <= 0xa000)
+        {
+           high_freq = fixmul32(high_freq,0x8000);
+        }
+        else if (bps > 0xc000)
+        {
+            s->use_noise_coding = 0;
+        }
+        else
+        {
+            high_freq = fixmul32(high_freq,0xa666);
+        }
+    }
+    else
+    {
+        if (bps >= 0xcccd)
+        {
+            high_freq = fixmul32(high_freq,0xc000);
+        }
+        else if (bps >= 0x999a)
+        {
+            high_freq = fixmul32(high_freq,0x999a);
+        }
+        else
+        {
+            high_freq = fixmul32(high_freq,0x8000);
+        }
+    }
+
+    /*av_log(NULL,AV_LOG_INFO,"flags1=0x%x flags2=0x%x\n", flags1, flags2);
+    av_log(NULL,AV_LOG_INFO,"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\n",
+           s->version, s->nb_channels, s->sample_rate, s->bit_rate, 
+           s->block_align);
+    av_log(NULL,AV_LOG_INFO,"bps=%ld bps1=%ld high_freq=%ld bitoffset=%ld\n", 
+           bps, bps1, high_freq, s->byte_offset_bits);
+   av_log(NULL,AV_LOG_INFO,"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\n",
+           s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);*/
+
+    /* compute the scale factor band sizes for each MDCT block size */
+    {
+        int a, b, pos, lpos, k, block_len, i, j, n;
+        const uint8_t *table;
+
+        if (s->version == 1)
+        {
+            s->coefs_start = 3;
+        }
+        else
+        {
+            s->coefs_start = 0;
+        }
+        for(k = 0; k < s->nb_block_sizes; ++k)
+        {
+            block_len = s->frame_len >> k;
+
+            if (s->version == 1)
+            {
+                lpos = 0;
+                for(i=0;i<25;++i)
+                {
+                    a = wma_critical_freqs[i];
+                    b = s->sample_rate;
+                    pos = ((block_len * 2 * a)  + (b >> 1)) / b;
+                    if (pos > block_len)
+                        pos = block_len;
+                    s->exponent_bands[0][i] = pos - lpos;
+                    if (pos >= block_len)
+                    {
+                        ++i;
+                        break;
+                    }
+                    lpos = pos;
+                }
+                s->exponent_sizes[0] = i;
+            }
+            else
+            {
+                /* hardcoded tables */
+                table = NULL;
+                a = s->frame_len_bits - BLOCK_MIN_BITS - k;
+                if (a < 3)
+                {
+                    if (s->sample_rate >= 44100)
+                        table = exponent_band_44100[a];
+                    else if (s->sample_rate >= 32000)
+                        table = exponent_band_32000[a];
+                    else if (s->sample_rate >= 22050)
+                        table = exponent_band_22050[a];
+                }
+                if (table)
+                {
+                    n = *table++;
+                    for(i=0;i<n;++i)
+                        s->exponent_bands[k][i] = table[i];
+                    s->exponent_sizes[k] = n;
+                }
+                else
+                {
+                    j = 0;
+                    lpos = 0;
+                    for(i=0;i<25;++i)
+                    {
+                        a = wma_critical_freqs[i];
+                        b = s->sample_rate;
+                        pos = ((block_len * 2 * a)  + (b << 1)) / (4 * b);
+                        pos <<= 2;
+                        if (pos > block_len)
+                            pos = block_len;
+                        if (pos > lpos)
+                            s->exponent_bands[k][j++] = pos - lpos;
+                        if (pos >= block_len)
+                            break;
+                        lpos = pos;
+                    }
+                    s->exponent_sizes[k] = j;
+                }
+            }
+
+            /* max number of coefs */
+            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;
+            /* high freq computation */
+
+            int32_t tmp1 = high_freq*2;            /* high_freq is a int32_t!*/
+            int32_t tmp2=itofix32(s->sample_rate>>1);
+            s->high_band_start[k] = fixtoi32( fixdiv32(tmp1, tmp2) * (block_len>>1) +0x8000);
+
+            /*
+            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /
+                                          s->sample_rate + 0.5);*/
+
+            n = s->exponent_sizes[k];
+            j = 0;
+            pos = 0;
+            for(i=0;i<n;++i)
+            {
+                int start, end;
+                start = pos;
+                pos += s->exponent_bands[k][i];
+                end = pos;
+                if (start < s->high_band_start[k])
+                    start = s->high_band_start[k];
+                if (end > s->coefs_end[k])
+                    end = s->coefs_end[k];
+                if (end > start)
+                    s->exponent_high_bands[k][j++] = end - start;
+            }
+            s->exponent_high_sizes[k] = j;
+        }
+    }
+
+    mdct_init_global_fixed();
+
+    for(i = 0; i < s->nb_block_sizes; ++i)
+    {
+        ff_mdct_init_fixed1(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 1);
+    }
+
+    /*ffmpeg uses malloc to only allocate as many window sizes as needed.
+     * However, we're really only interested in the worst case memory usage.
+     * In the worst case you can have 5 window sizes, 128 doubling up 2048
+     * Smaller windows are handled differently.
+     * Since we don't have malloc, just statically allocate this
+     */
+    int32_t *temp[5];
+    temp[0] = stat0;
+    temp[1] = stat1;
+    temp[2] = stat2;
+    temp[3] = stat3;
+    temp[4] = stat4;
+
+    /* init MDCT windows : simple sinus window */
+    for(i = 0; i < s->nb_block_sizes; i++)
+    {
+        int n, j;
+        int32_t alpha;
+        n = 1 << (s->frame_len_bits - i);
+        window = temp[i];
+
+        alpha = (1<<15)>>(s->frame_len_bits - i+1);   /* this calculates 0.5/(2*n) */
+        for(j=0;j<n;++j)
+        {
+            int32_t j2 = itofix32(j) + 0x8000;
+            window[j] = fsincos(fixmul32(j2,alpha)<<16, 0); /* alpha between 0 and pi/2 */
+
+        }
+        s->windows[i] = window;
+
+    }
+
+    s->reset_block_lengths = 1;
+
+    if (s->use_noise_coding)
+    {
+        /* init the noise generator */
+        if (s->use_exp_vlc)
+        {
+            s->noise_mult = 0x51f;
+            s->noise_table = noisetable_exp;
+        }
+        else
+        {
+            s->noise_mult = 0xa3d;
+            /* LSP values are simply 2x the EXP values */
+            for (i=0;i<NOISE_TAB_SIZE;++i)
+                noisetable_exp[i] = noisetable_exp[i]<< 1;
+            s->noise_table = noisetable_exp;
+        }
+#if 0
+        {
+            unsigned int seed;
+            int32_t norm;
+            seed = 1;
+            norm = 0;   // PJJ: near as makes any diff to 0!
+            for (i=0;i<NOISE_TAB_SIZE;++i)
+            {
+                seed = seed * 314159 + 1;
+                s->noise_table[i] = itofix32((int)seed) * norm;
+            }
+        }
+#endif
+
+         s->hgain_vlc.table = vlcbuf4;
+         s->hgain_vlc.table_allocated = VLCBUF4SIZE;
+         init_vlc_fixed(&s->hgain_vlc, HGAINVLCBITS, sizeof(hgain_huffbits),
+                  hgain_huffbits, 1, 1,
+                  hgain_huffcodes, 2, 2, 0);
+    }
+
+    if (s->use_exp_vlc)
+    {
+
+        s->exp_vlc.table = vlcbuf3;
+        s->exp_vlc.table_allocated = VLCBUF3SIZE;
+
+         init_vlc_fixed(&s->exp_vlc, EXPVLCBITS, sizeof(scale_huffbits),
+                  scale_huffbits, 1, 1,
+                  scale_huffcodes, 4, 4, 0);
+    }
+    else
+    {
+        wma_lsp_to_curve_init(s, s->frame_len);
+    }
+
+    /* choose the VLC tables for the coefficients */
+    coef_vlc_table = 2;
+    if (s->sample_rate >= 32000)
+    {
+        if (bps1 < 0xb852)
+            coef_vlc_table = 0;
+        else if (bps1 < 0x128f6)
+            coef_vlc_table = 1;
+    }
+
+    runtabarray[0] = runtab0; runtabarray[1] = runtab1;
+    levtabarray[0] = levtab0; levtabarray[1] = levtab1;
+
+    s->coef_vlc[0].table = vlcbuf1;
+    s->coef_vlc[0].table_allocated = VLCBUF1SIZE;
+    s->coef_vlc[1].table = vlcbuf2;
+    s->coef_vlc[1].table_allocated = VLCBUF2SIZE;
+
+    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0],
+                  &coef_vlcs[coef_vlc_table * 2], 0);
+    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1],
+                  &coef_vlcs[coef_vlc_table * 2 + 1], 1);
+
+    s->last_superframe_len = 0;
+    s->last_bitoffset = 0;                                    LEAVE();
+    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
+    return 0;
+}
+
+
+/* compute x^-0.25 with an exponent and mantissa table. We use linear
+   interpolation to reduce the mantissa table size at a small speed
+   expense (linear interpolation approximately doubles the number of
+   bits of precision). */
+static inline int32_t pow_m1_4(WMACodecContext *s, int32_t x)
+{
+    union {
+        float f;
+        unsigned int v;
+    } u, t;
+    unsigned int e, m;
+    int32_t a, b;
+                                                            ENTER();
+    u.f = fixtof64(x);
+    e = u.v >> 23;
+    m = (u.v >> (23 - LSP_POW_BITS)) & ((1 << LSP_POW_BITS) - 1);
+    /* build interpolation scale: 1 <= t < 2. */
+    t.v = ((u.v << LSP_POW_BITS) & ((1 << 23) - 1)) | (127 << 23);
+    a = s->lsp_pow_m_table1[m];
+    b = s->lsp_pow_m_table2[m];
+
+    /* lsp_pow_e_table contains 32.32 format */
+    /* TODO:  Since we're unlikely have value that cover the whole
+     * IEEE754 range, we probably don't need to have all possible exponents */
+                                                               LEAVE();
+    return (lsp_pow_e_table[e] * (a + fixmul32(b, ftofix32(t.f))) >>32);
+}
+
+static void wma_lsp_to_curve_init(WMACodecContext *s, int frame_len)
+{
+    int32_t wdel, a, b, temp, temp2;
+    int i, m;
+                                                                  ENTER();
+    wdel = fixdiv32(M_PI_F, itofix32(frame_len));
+    temp = fixdiv32(itofix32(1),     itofix32(frame_len));
+    for (i=0; i<frame_len; ++i)
+    {
+        /* TODO: can probably reuse the trig_init values here */
+        fsincos((temp*i)<<15, &temp2);
+        /* get 3 bits headroom + 1 bit from not doubleing the values */
+        s->lsp_cos_table[i] = temp2>>3;
+
+    }
+    /* NOTE: these two tables are needed to avoid two operations in
+       pow_m1_4 */
+    b = itofix32(1);
+    int ix = 0;
+
+    /*double check this later*/
+    for(i=(1 << LSP_POW_BITS) - 1;i>=0;i--)
+    {
+        m = (1 << LSP_POW_BITS) + i;
+        a = pow_a_table[ix++]<<4;
+        s->lsp_pow_m_table1[i] = 2 * a - b;
+        s->lsp_pow_m_table2[i] = b - a;
+        b = a;
+    }                                                  LEAVE();
+
+}
+
+/* NOTE: We use the same code as Vorbis here */
+/* XXX: optimize it further with SSE/3Dnow */
+static void wma_lsp_to_curve(WMACodecContext *s,
+                             int32_t *out,
+                             int32_t *val_max_ptr,
+                             int n,
+                             int32_t *lsp)
+{
+    int i, j;
+    int32_t p, q, w, v, val_max, temp, temp2;
+
+    val_max = 0;                                    ENTER();
+    for(i=0;i<n;++i)
+    {
+        /* shift by 2 now to reduce rounding error,
+         * we can renormalize right before pow_m1_4
+         */
+
+        p = 0x8000<<5;
+        q = 0x8000<<5;
+        w = s->lsp_cos_table[i];
+
+        for (j=1;j<NB_LSP_COEFS;j+=2)
+        {
+            /* w is 5.27 format, lsp is in 16.16, temp2 becomes 5.27 format */
+            temp2 = ((w - (lsp[j - 1]<<11)));
+            temp = q;
+
+            /* q is 16.16 format, temp2 is 5.27, q becomes 16.16 */
+            q = fixmul32b(q, temp2 )<<4;
+            p = fixmul32b(p, (w - (lsp[j]<<11)))<<4;
+        }
+
+        /* 2 in 5.27 format is 0x10000000 */
+        p = fixmul32(p, fixmul32b(p, (0x10000000 - w)))<<3;
+        q = fixmul32(q, fixmul32b(q, (0x10000000 + w)))<<3;
+
+        v = (p + q) >>9;  /* p/q end up as 16.16 */
+        v = pow_m1_4(s, v);
+        if (v > val_max)
+            val_max = v;
+        out[i] = v;
+    }
+
+    *val_max_ptr = val_max;                            LEAVE();
+}
+
+/* decode exponents coded with LSP coefficients (same idea as Vorbis) */
+static void decode_exp_lsp(WMACodecContext *s, int ch)
+{
+    int32_t lsp_coefs[NB_LSP_COEFS];
+    int val, i;
+                                                        ENTER();
+    for (i = 0; i < NB_LSP_COEFS; ++i)
+    {
+        if (i == 0 || i >= 8)
+            val = get_bits_fixed(&s->gb, 3);
+        else
+            val = get_bits_fixed(&s->gb, 4);
+        lsp_coefs[i] = lsp_codebook[i][val];
+    }
+
+    wma_lsp_to_curve(s,
+                     s->exponents[ch],
+                     &s->max_exponent[ch],
+                     s->block_len,
+                     lsp_coefs);                         LEAVE();
+}
+
+/* decode exponents coded with VLC codes */
+static int decode_exp_vlc(WMACodecContext *s, int ch)
+{
+    int last_exp, n, code;
+    const uint16_t *ptr, *band_ptr;
+    int32_t v, max_scale;
+    int32_t *q,*q_end;
+
+    /*accommodate the 60 negative indices */
+    const int32_t *pow_10_to_yover16_ptr;
+    pow_10_to_yover16_ptr = &pow_10_to_yover16[61];
+                                                             ENTER();
+    band_ptr = s->exponent_bands[s->frame_len_bits - s->block_len_bits];
+    ptr = band_ptr;
+    q = s->exponents[ch];
+    q_end = q + s->block_len;
+    max_scale = 0;
+
+    if (s->version == 1) /* wmav1 only */
+    {
+        last_exp = get_bits_fixed(&s->gb, 5) + 10;
+        /* XXX: use a table */
+        v = pow_10_to_yover16_ptr[last_exp];
+        max_scale = v;
+        n = *ptr++;
+        do
+        {
+            *q++ = v;
+        }
+        while (--n);
+    }
+    else
+        last_exp = 36;
+
+    while (q < q_end)
+    {
+        code = get_vlc2_fixed(&s->gb, s->exp_vlc.table, EXPVLCBITS, EXPMAX);
+        if (code < 0)
+        {
+            return -1;
+        }
+        /* NOTE: this offset is the same as MPEG4 AAC ! */
+        last_exp += code - 60;
+        /* XXX: use a table */
+        v = pow_10_to_yover16_ptr[last_exp];
+        if (v > max_scale)
+        {
+            max_scale = v;
+        }
+        n = *ptr++;
+        do
+        {
+            *q++ = v;
+
+        }
+        while (--n);
+    }
+
+    s->max_exponent[ch] = max_scale;                            LEAVE();
+    return 0;
+}
+
+/* return 0 if OK. return 1 if last block of frame. return -1 if
+   unrecorrable error. */
+static int wma_decode_block(WMACodecContext *s)
+{
+    int n, v, a, ch, code, bsize;
+    int coef_nb_bits, total_gain;
+    int nb_coefs[MAX_CHANNELS];
+    int32_t mdct_norm;
+                                                                 ENTER();
+    /* compute current block length */
+    if (s->use_variable_block_len)
+    {
+        n = av_log2_fixed(s->nb_block_sizes - 1) + 1;
+
+        if (s->reset_block_lengths)
+        {
+            s->reset_block_lengths = 0;
+            v = get_bits_fixed(&s->gb, n);
+            if (v >= s->nb_block_sizes)
+            {
+                return -2;
+            }
+            s->prev_block_len_bits = s->frame_len_bits - v;
+            v = get_bits_fixed(&s->gb, n);
+            if (v >= s->nb_block_sizes)
+            {
+                return -3;
+            }
+            s->block_len_bits = s->frame_len_bits - v;
+        }
+        else
+        {
+            /* update block lengths */
+            s->prev_block_len_bits = s->block_len_bits;
+            s->block_len_bits = s->next_block_len_bits;
+        }
+        v = get_bits_fixed(&s->gb, n);
+
+        if (v >= s->nb_block_sizes)
+            return -4;
+
+        s->next_block_len_bits = s->frame_len_bits - v;
+    }
+    else
+    {
+        /* fixed block len */
+        s->next_block_len_bits = s->frame_len_bits;
+        s->prev_block_len_bits = s->frame_len_bits;
+        s->block_len_bits = s->frame_len_bits;
+    }
+    /* now check if the block length is coherent with the frame length */
+    s->block_len = 1 << s->block_len_bits;
+
+    if ((s->block_pos + s->block_len) > s->frame_len)
+    {
+        return -5; /* oddly 32k sample from tracker fails here */
+    }
+
+    if (s->nb_channels == 2)
+    {
+        s->ms_stereo = get_bits_fixed(&s->gb, 1);
+    }
+    v = 0;
+    for (ch = 0; ch < s->nb_channels; ++ch)
+    {
+        a = get_bits_fixed(&s->gb, 1);
+        s->channel_coded[ch] = a;
+        v |= a;
+    }
+    /* if no channel coded, no need to go further */
+    /* XXX: fix potential framing problems */
+    if (!v)
+    {
+        goto next;
+    }
+
+    bsize = s->frame_len_bits - s->block_len_bits;
+
+    /* read total gain and extract corresponding number of bits for
+       coef escape coding */
+    total_gain = 1;
+    for(;;)
+    {
+        a = get_bits_fixed(&s->gb, 7);
+        total_gain += a;
+        if (a != 127)
+        {
+            break;
+        }
+    }
+
+    if (total_gain < 15)
+        coef_nb_bits = 13;
+    else if (total_gain < 32)
+        coef_nb_bits = 12;
+    else if (total_gain < 40)
+        coef_nb_bits = 11;
+    else if (total_gain < 45)
+        coef_nb_bits = 10;
+    else
+        coef_nb_bits = 9;
+
+    /* compute number of coefficients */
+    n = s->coefs_end[bsize] - s->coefs_start;
+
+    for(ch = 0; ch < s->nb_channels; ++ch)
+    {
+        nb_coefs[ch] = n;
+    }
+    /* complex coding */
+    if (s->use_noise_coding)
+    {
+
+        for(ch = 0; ch < s->nb_channels; ++ch)
+        {
+            if (s->channel_coded[ch])
+            {
+                int i, n, a;
+                n = s->exponent_high_sizes[bsize];
+                for(i=0;i<n;++i)
+                {
+                    a = get_bits_fixed(&s->gb, 1);
+                    s->high_band_coded[ch][i] = a;
+                    /* if noise coding, the coefficients are not transmitted */
+                    if (a)
+                        nb_coefs[ch] -= s->exponent_high_bands[bsize][i];
+                }
+            }
+        }
+        for(ch = 0; ch < s->nb_channels; ++ch)
+        {
+            if (s->channel_coded[ch])
+            {
+                int i, n, val, code;
+
+                n = s->exponent_high_sizes[bsize];
+                val = (int)0x80000000;
+                for(i=0;i<n;++i)
+                {
+                    if (s->high_band_coded[ch][i])
+                    {
+                        if (val == (int)0x80000000)
+                        {
+                            val = get_bits_fixed(&s->gb, 7) - 19;
+                        }
+                        else
+                        {
+                            //code = get_vlc(&s->gb, &s->hgain_vlc);
+                            code = get_vlc2_fixed(&s->gb, s->hgain_vlc.table, HGAINVLCBITS, HGAINMAX);
+                            if (code < 0)
+                            {
+                                return -6;
+                            }
+                            val += code - 18;
+                        }
+                        s->high_band_values[ch][i] = val;
+                    }
+                }
+            }
+        }
+    }
+
+    /* exponents can be reused in short blocks. */
+    if ((s->block_len_bits == s->frame_len_bits) || get_bits_fixed(&s->gb, 1))
+    {
+        for(ch = 0; ch < s->nb_channels; ++ch)
+        {
+            if (s->channel_coded[ch])
+            {
+                if (s->use_exp_vlc)
+                {
+                    if (decode_exp_vlc(s, ch) < 0)
+                    {
+                        return -7;
+                    }
+                }
+                else
+                {
+                    decode_exp_lsp(s, ch);
+                }
+                s->exponents_bsize[ch] = bsize;
+            }
+        }
+    }
+
+    /* parse spectral coefficients : just RLE encoding */
+    for(ch = 0; ch < s->nb_channels; ++ch)
+    {
+        if (s->channel_coded[ch])
+        {
+            VLC_FIX *coef_vlc;
+            int level, run, sign, tindex;
+            int16_t *ptr, *eptr;
+            const uint16_t *level_table, *run_table;                //av_log(NULL,AV_LOG_INFO,"11\n");
+
+            /* special VLC tables are used for ms stereo because
+               there is potentially less energy there */
+            tindex = (ch == 1 && s->ms_stereo);
+            coef_vlc = &s->coef_vlc[tindex];
+            run_table = s->run_table[tindex];
+            level_table = s->level_table[tindex];
+            /* XXX: optimize */
+            ptr = &s->coefs1[ch][0];
+            eptr = ptr + nb_coefs[ch];
+            memset(ptr, 0, s->block_len * sizeof(int16_t));           //av_log(NULL,AV_LOG_INFO,"22\n");
+
+            while(1)
+            {                                                         // av_log(NULL,AV_LOG_INFO,"222\n");
+                code = get_vlc2_fixed(&s->gb, coef_vlc->table, VLCBITS, VLCMAX); //av_log(NULL,AV_LOG_INFO,"333\n");
+                //code = get_vlc(&s->gb, coef_vlc);
+                if (code < 0)
+                {
+                    return -8;
+                }
+                if (code == 1)
+                {
+                    /* EOB */
+                    break;
+                }
+                else if (code == 0)
+                {
+                    /* escape */                                   //av_log(NULL,AV_LOG_INFO,"444\n");
+                    level = get_bits_fixed(&s->gb, coef_nb_bits); //av_log(NULL,AV_LOG_INFO,"555\n");
+                    /* NOTE: this is rather suboptimal. reading
+                       block_len_bits would be better */
+                    run = get_bits_fixed(&s->gb, s->frame_len_bits);
+                }
+                else
+                {
+                    /* normal code */
+                    run = run_table[code];
+                    level = level_table[code];
+                }                                              // av_log(NULL,AV_LOG_INFO,"666\n");
+                sign = get_bits_fixed(&s->gb, 1);                 // av_log(NULL,AV_LOG_INFO,"777\n");
+                if (!sign)
+                    level = -level;
+                ptr += run;
+                if (ptr >= eptr)
+                {
+                    break;
+                }
+                *ptr++ = level;
+
+
+                /* NOTE: EOB can be omitted */
+                if (ptr >= eptr)
+                    break;
+            }
+        }
+        if (s->version == 1 && s->nb_channels >= 2)
+        {
+            align_get_bits_fixed(&s->gb);
+        }
+    }                                 //   av_log(NULL,AV_LOG_INFO,"33\n");
+
+    {
+        int n4 = s->block_len >> 1;
+
+        /* theres no reason to do a divide by two in fixed precision ... */
+        mdct_norm = 0x10000>>(s->block_len_bits-1);
+
+        if (s->version == 1)
+        {
+            mdct_norm *= fixtoi32(fixsqrt32(itofix32(n4))); /* PJJ : exercise this path */
+        }
+    }                                      // av_log(NULL,AV_LOG_INFO,"44\n");
+
+    /* finally compute the MDCT coefficients */
+    for(ch = 0; ch < s->nb_channels; ++ch)
+    {
+        if (s->channel_coded[ch])
+        {
+            int16_t *coefs1;
+            int32_t *exponents, *exp_ptr;
+            int32_t *coefs, atemp;
+            int64_t mult;
+            int64_t mult1;
+            int32_t noise, temp1, temp2, mult2;
+            int i, j, n, n1, last_high_band, esize;
+            int32_t exp_power[HIGH_BAND_MAX_SIZE];
+                                                 // av_log(NULL,AV_LOG_INFO,"55\n");
+            coefs1 = s->coefs1[ch];
+            exponents = s->exponents[ch];
+            esize = s->exponents_bsize[ch];
+            coefs = (*(s->coefs))[ch];
+
+            n=0;
+
+            /*
+             *  Previously the IMDCT was run in 17.15 precision to avoid overflow. However rare files could
+             *  overflow here as well, so switch to 17.15 during coefs calculation.
+             */
+
+
+            if (s->use_noise_coding)
+            {
+                /*TODO:  mult should be converted to 32 bit to speed up noise coding*/
+
+                mult = fixdiv64(pow_table[total_gain+20],Fixed32To64(s->max_exponent[ch]));
+                mult = mult* mdct_norm; //what the hell?  This is actually int64_t*2^16!
+                mult1 = mult;
+
+                /* very low freqs : noise */
+                for(i = 0;i < s->coefs_start; ++i)
+                {
+                    *coefs++ = fixmul32((fixmul32(s->noise_table[s->noise_index],
+                                        (*exponents++))>>4),Fixed32From64(mult1)) >>1;               //  av_log(NULL,AV_LOG_INFO,"66\n");
+                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);
+                }
+
+                n1 = s->exponent_high_sizes[bsize];
+
+                /* compute power of high bands */
+                exp_ptr = exponents +
+                          s->high_band_start[bsize] -
+                          s->coefs_start;
+                last_high_band = 0; /* avoid warning */
+                for (j=0;j<n1;++j)
+                {
+                    n = s->exponent_high_bands[s->frame_len_bits -
+                                               s->block_len_bits][j];                  //    av_log(NULL,AV_LOG_INFO,"77\n");
+                    if (s->high_band_coded[ch][j])
+                    {
+                        int32_t e2, v;
+                        e2 = 0;
+                        for(i = 0;i < n; ++i)
+                        {
+                            /*v is noramlized later on so its fixed format is irrelevant*/
+                            v = exp_ptr[i]>>4;
+                            e2 += fixmul32(v, v)>>3;
+                        }
+                         exp_power[j] = e2/n; /*n is an int...*/
+                        last_high_band = j;
+                    }
+                    exp_ptr += n;
+                }
+
+                /* main freqs and high freqs */
+                for(j=-1;j<n1;++j)
+                {
+                    if (j < 0)
+                    {
+                        n = s->high_band_start[bsize] -
+                            s->coefs_start;
+                    }
+                    else
+                    {
+                        n = s->exponent_high_bands[s->frame_len_bits -
+                                                   s->block_len_bits][j];
+                    }
+                    if (j >= 0 && s->high_band_coded[ch][j])
+                    {
+                        /* use noise with specified power */
+                        int32_t tmp = fixdiv32(exp_power[j],exp_power[last_high_band]);
+                        mult1 = (int64_t)fixsqrt32(tmp);
+                        /* XXX: use a table */
+                        /*mult1 is 48.16, pow_table is 48.16*/
+                        mult1 = mult1 * pow_table[s->high_band_values[ch][j]+20] >> PRECISION;             // av_log(NULL,AV_LOG_INFO,"88\n");
+
+                        /*this step has a fairly high degree of error for some reason*/
+                        mult1 = fixdiv64(mult1,fixmul32(s->max_exponent[ch],s->noise_mult));
+
+                        mult1 = mult1*mdct_norm>>PRECISION;
+                        for(i = 0;i < n; ++i)
+                        {
+                            noise = s->noise_table[s->noise_index];
+                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);
+                            *coefs++ = fixmul32((fixmul32(*exponents,noise)>>4),Fixed32From64(mult1)) >>1;
+                            ++exponents;
+                        }
+                    }
+                    else
+                    {
+                        /* coded values + small noise */
+                        for(i = 0;i < n; ++i)
+                        {
+                            // PJJ: check code path
+                            noise = s->noise_table[s->noise_index];
+                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);
+
+                           /*don't forget to renormalize the noise*/
+                           temp1 = (((int32_t)*coefs1++)<<16) + (noise>>4);
+                           temp2 = fixmul32(*exponents, mult>>17);
+                           *coefs++ = fixmul32(temp1, temp2);
+                           ++exponents;
+                        }
+                    }
+                }
+
+                /* very high freqs : noise */
+                n = s->block_len - s->coefs_end[bsize];
+                mult2 = fixmul32(mult>>16,exponents[-1]) ;  /*the work around for 32.32 vars are getting stupid*/
+                for (i = 0; i < n; ++i)
+                {
+                    /*renormalize the noise product and then reduce to 17.15 precison*/
+                    *coefs++ = fixmul32(s->noise_table[s->noise_index],mult2) >>5;
+
+                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);                   // av_log(NULL,AV_LOG_INFO,"99\n");
+                }
+            }
+            else
+            {
+                /*Noise coding not used, simply convert from exp to fixed representation*/
+                int32_t mult3 = (int32_t)(fixdiv64(pow_table[total_gain+20],Fixed32To64(s->max_exponent[ch])));
+                mult3 = fixmul32(mult3, mdct_norm);
+
+                n = nb_coefs[ch];
+
+                /* XXX: optimize more, unrolling this loop in asm might be a good idea */
+                for(i = 0;i < s->coefs_start; i++)
+                    *coefs++ = 0;
+                for(i = 0;i < n; ++i)
+                {
+                    atemp = (coefs1[i] * mult3)>>1;
+                    *coefs++=fixmul32(atemp,exponents[i<<bsize>>esize]);
+                }
+                n = s->block_len - s->coefs_end[bsize];
+                memset(coefs, 0, n*sizeof(int32_t));
+            }
+        }
+    }
+                                                    // av_log(NULL,AV_LOG_INFO,"00\n");
+    if (s->ms_stereo && s->channel_coded[1])
+    {
+        int32_t a, b;
+        int i;
+        int32_t (*coefs)[MAX_CHANNELS_WMA][BLOCK_MAX_SIZE_WMA]  = (s->coefs);
+
+        /* nominal case for ms stereo: we do it before mdct */
+        /* no need to optimize this case because it should almost
+           never happen */
+        if (!s->channel_coded[0])
+        {
+            memset((*(s->coefs))[0], 0, sizeof(int32_t) * s->block_len);
+            s->channel_coded[0] = 1;
+        }
+
+        for(i = 0; i < s->block_len; ++i)
+        {
+            a = (*coefs)[0][i];
+            b = (*coefs)[1][i];
+            (*coefs)[0][i] = a + b;
+            (*coefs)[1][i] = a - b;
+        }
+    }
+
+    for(ch = 0; ch < s->nb_channels; ++ch)
+    {
+        if (s->channel_coded[ch])
+        {
+            static int32_t  output[BLOCK_MAX_SIZE_WMA * 2] IBSS_ATTR;
+
+            int n4, index, n;
+
+            n = s->block_len;
+            n4 = s->block_len >>1;
+
+            ff_imdct_calc_fixed(&s->mdct_ctx[bsize],
+                          output,
+                          (*(s->coefs))[ch]);
+
+            /* add in the frame */
+            index = (s->frame_len / 2) + s->block_pos - n4;                //av_log(NULL,AV_LOG_INFO,"01\n");
+
+            wma_window(s, output, &s->frame_out[ch][index]);             //  av_log(NULL,AV_LOG_INFO,"02\n");
+
+            /* specific fast case for ms-stereo : add to second
+               channel if it is not coded */
+            if (s->ms_stereo && !s->channel_coded[1])
+            {
+                wma_window(s, output, &s->frame_out[1][index]);              //av_log(NULL,AV_LOG_INFO,"03\n");
+            }
+        }
+    }                                      LEAVE();
+
+next:
+    /* update block number */
+    ++s->block_num;
+    s->block_pos += s->block_len;           LEAVE();
+    if (s->block_pos >= s->frame_len)
+    {
+        return 1;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+/* decode a frame of frame_len samples */
+static int wma_decode_frame(WMACodecContext *s, int32_t *samples)
+{
+    int ret, i, n, ch, incr;
+    int32_t *ptr;
+    int32_t *iptr;
+
+    /* read each block */
+    s->block_num = 0;
+    s->block_pos = 0;                       ENTER();
+
+    for(;;)
+    {
+        ret = wma_decode_block(s);
+        if (ret < 0)
+        {
+#ifdef WMA_DEBUG
+            printf("wma_decode_block failed with code %d\n", ret);
+#endif
+            return -1;
+        }
+        if (ret)
+        {
+            break;
+        }
+    }                                    
+
+    /* return frame with full 30-bit precision */
+    n = s->frame_len;
+    incr = s->nb_channels; //av_log(NULL,AV_LOG_INFO,"SFDFSDFSDF\n");
+    for(ch = 0; ch < s->nb_channels; ++ch)
+    {
+        ptr = samples + ch; //av_log(NULL,AV_LOG_INFO,"FDSFSDFSDF\n");
+        iptr = s->frame_out[ch];
+
+        for (i=0;i<n;++i)
+        {
+            *ptr = (*iptr++);
+                     //  if(0 != *ptr)
+                            //    av_log(NULL,AV_LOG_INFO,"%0x  *ptr=%d\n",ptr,*ptr);
+            ptr += incr;
+        }
+        /* prepare for next block */
+        memmove(&s->frame_out[ch][0], &s->frame_out[ch][s->frame_len],
+                s->frame_len * sizeof(int32_t));
+
+    }                                              LEAVE();
+
+    return 0;
+}
+
+/* Initialise the superframe decoding */
+
+int wma_decode_superframe_init(WMACodecContext* s,
+                                 uint8_t *buf,  /*input*/
+                                 int buf_size)
+{
+    if (buf_size==0)
+    {
+        s->last_superframe_len = 0;
+        return 0;
+    }                                          ENTER();
+
+    s->current_frame = 0;
+
+    init_get_bits_fixed(&s->gb, buf, buf_size*8);
+
+    if (s->use_bit_reservoir)
+    {
+        /* read super frame header */
+        get_bits_fixed(&s->gb, 4); /* super frame index */
+        s->nb_frames = get_bits_fixed(&s->gb, 4);
+
+        if (s->last_superframe_len == 0)
+            s->nb_frames --;
+        else if (s->nb_frames == 0)
+            s->nb_frames++;
+
+        s->bit_offset = get_bits_fixed(&s->gb, s->byte_offset_bits + 3);
+    } else {
+        s->nb_frames = 1;
+    }        //av_log(NULL,AV_LOG_INFO,"s->last_superframe_len = %ld buf_size=%d\n",s->last_superframe_len, buf_size);
+                                                      LEAVE();
+    return 1;
+}
+
+
+/* Decode a single frame in the current superframe - return -1 if
+   there was a decoding error, or the number of samples decoded.*/
+
+int wma_decode_superframe_frame(WMACodecContext* s,
+                                int32_t* samples, /*output*/
+                                uint8_t *buf,  /*input*/
+                                int buf_size)
+{
+    int pos, len,ns;
+    uint8_t *q;
+    int done = 0;                             ENTER();// av_log(NULL,AV_LOG_INFO,"s->last_superframe_len = %ld buf_size=%d\n",s->last_superframe_len, buf_size);
+    if ((s->use_bit_reservoir) && (s->current_frame == 0))
+    {
+        if (s->last_superframe_len > 0)
+        {
+            /* add s->bit_offset bits to last frame */
+            if ((s->last_superframe_len + ((s->bit_offset + 7) >> 3)) >
+                    MAX_CODED_SUPERFRAME_SIZE)
+            {
+#ifdef WMA_DEBUG
+                printf("superframe size too large error\n");
+#endif
+                goto fail;
+            }
+            q = s->last_superframe + s->last_superframe_len;
+            len = s->bit_offset;
+            while (len > 0)
+            {
+                *q++ = (get_bits_fixed)(&s->gb, 8);
+                len -= 8;
+            }
+            if (len > 0)
+            {
+                *q++ = (get_bits_fixed)(&s->gb, len) << (8 - len);
+            }
+
+            /* XXX: s->bit_offset bits into last frame */
+            init_get_bits_fixed(&s->gb, s->last_superframe, MAX_CODED_SUPERFRAME_SIZE*8);
+            /* skip unused bits */
+            if (s->last_bitoffset > 0)
+                skip_bits_fixed(&s->gb, s->last_bitoffset);
+
+            /* this frame is stored in the last superframe and in the
+               current one */
+            if (wma_decode_frame(s, samples) < 0)
+            {
+                goto fail;
+            }
+            done = 1;
+        }
+
+        /* read each frame starting from s->bit_offset */
+        pos = s->bit_offset + 4 + 4 + s->byte_offset_bits + 3;
+        init_get_bits_fixed(&s->gb, buf + (pos >> 3), (MAX_CODED_SUPERFRAME_SIZE - (pos >> 3))*8);
+        len = pos & 7;
+        if (len > 0)
+            skip_bits_fixed(&s->gb, len);
+
+        s->reset_block_lengths = 1;
+    }
+
+    /* If we haven't decoded a frame yet, do it now */
+    if (!done)
+        {
+            if (wma_decode_frame(s, samples) < 0)
+            {
+                goto fail;
+            }
+        }
+
+    s->current_frame++;                  // av_log(NULL,AV_LOG_INFO,"s->current_frame=%d\n", s->current_frame);
+
+    if ((s->use_bit_reservoir) && (s->current_frame == s->nb_frames))
+    {
+        /* we copy the end of the frame in the last frame buffer */
+        pos = get_bits_count_fixed(&s->gb) + ((s->bit_offset + 4 + 4 + s->byte_offset_bits + 3) & ~7);
+        s->last_bitoffset = pos & 7;
+        pos >>= 3;
+        len = buf_size - pos;  //av_log(NULL,AV_LOG_INFO,"len = %d\n", len);
+        if (len > MAX_CODED_SUPERFRAME_SIZE || len < 0)
+        {
+#ifdef WMA_DEBUG
+            printf("superframe size too large error after decodeing\n");
+#endif
+            goto fail;
+        }
+        s->last_superframe_len = len;
+        memcpy(s->last_superframe, buf + pos, len);
+    }
+    /*   for( ns = 0 ; ns < BLOCK_MAX_SIZE * MAX_CHANNELS *2; ns++ )
+     {   
+           if(0 != *(samples+ns))
+             av_log(NULL,AV_LOG_INFO,"*(samples+%d)=%d\n",ns, *(samples+ns));
+      }*/
+    return s->frame_len;                     //av_log(NULL,AV_LOG_INFO,"s->frame_len=%d\n", s->frame_len);
+
+fail:
+    /* when error, we reset the bit reservoir */
+
+    s->last_superframe_len = 0;               LEAVE();
+    return -1;
+}
+/*int wma_decode_superframe_frame(WMACodecContext* s,
+                                int32_t* samples, 
+                                uint8_t *buf, 
+                                int buf_size)*/
+//jh0728
+static int wma_decode_superframe(AVCodecContext *avctx,
+                                 void *data, int *data_size,
+                                 AVPacket *avpkt)
+{
+   // int pos, len;
+   // uint8_t *q;
+    
+    int i = 0,n = 0,ns;
+    uint8_t *buf = avpkt->data;
+    int buf_size = avpkt->size;
+    WMACodecContext *s;
+    int16_t *samples;
+    int32_t result[AVCODEC_MAX_AUDIO_FRAME_SIZE];
+    
+    s = avctx->priv_data;
+    samples = data;                                 ENTER();
+    if(wma_decode_superframe_init(s,buf,buf_size) == 0)
+    {
+        av_log(NULL,AV_LOG_INFO,"error while wma_decode_superframe_init!\n");
+        return -1;
+        //exit(1);
+    }                                          // av_log(NULL,AV_LOG_INFO,"buf_size=%d\n",buf_size);
+     *data_size = 0;
+                                   // av_log(NULL,AV_LOG_INFO,"%d \n",s->nb_frames);
+    for( int i = 0 ; i < s->nb_frames; i++ )
+    { 
+        n = wma_decode_superframe_frame(s,(result+(*data_size)*s->nb_channels),buf,buf_size);
+                  //av_log(NULL,AV_LOG_INFO,"n = %ld buf_size=%d\n",n, buf_size);
+        //samples += n * 4;   
+       if(0 > n)        
+           av_log(NULL,AV_LOG_ERROR,"wma_decode_superframe_frame ERROR!\n",n, buf_size);
+       else
+        *data_size += n;
+    }
+
+      *data_size <<= s->nb_channels; 
+      for(i = 0 ; i < *data_size; i++ )
+      {                                                                      
+
+           *(samples + i) = (*(result + i)>>16);/* (bit32 -> bit16)+(Q30 -> Q28) translation */
+
+      }
+                           LEAVE();
+                           //   av_log(NULL,AV_LOG_INFO,"*data_size=%d\n",*data_size);
+    return (*data_size);
+}
+
+static av_cold void flush(AVCodecContext *avctx)
+{
+    WMACodecContext *s = avctx->priv_data;
+
+    s->last_bitoffset=
+    s->last_superframe_len= 0;
+}
+
+AVCodec ff_wmav1_decoder =
+{
+    "wmav1",
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_WMAV1,
+    sizeof(WMACodecContext),
+    wma_decode_init,
+    NULL,
+    NULL,//
+    wma_decode_superframe,
+    .flush=flush,
+    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 1"),
+};
+
+AVCodec ff_wmav2_decoder =
+{
+    "wmav2",
+    AVMEDIA_TYPE_AUDIO,
+    CODEC_ID_WMAV2,
+    sizeof(WMACodecContext),
+    wma_decode_init,
+    NULL,
+    NULL,//
+    wma_decode_superframe,
+    .flush=flush,
+    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 2"),
+};
+

--- a/libavcodec/libavcodec.pc
+++ b/libavcodec/libavcodec.pc
@@ -0,0 +1,14 @@
+prefix=/home/jh/airmusicffm/
+exec_prefix=${prefix}
+libdir=${prefix}/lib
+includedir=${prefix}/include
+
+Name: libavcodec
+Description: FFmpeg codec library
+Version: 52.123.0
+Requires: 
+Requires.private: libavutil = 50.43.0
+Conflicts:
+Libs: -L${libdir} -lavcodec 
+Libs.private: -lm -pthread -lz
+Cflags: -I${includedir}

--- a/libavcodec/libavcodec-uninstalled.pc
+++ b/libavcodec/libavcodec-uninstalled.pc
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}
+includedir=/home/jh/untitled/ffmpeg-0.7.12NF
+
+Name: libavcodec
+Description: FFmpeg codec library
+Version: 52.123.0
+Requires: libavutil = 50.43.0
+Conflicts:
+Libs: ${libdir}/libavcodec.a -lm -pthread -lz 
+Cflags: -I${includedir}

--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -418,9 +418,9 @@
 OBJS-$(CONFIG_VQA_DECODER)             += vqavideo.o
 OBJS-$(CONFIG_WAVPACK_DECODER)         += wavpack.o
 OBJS-$(CONFIG_WMAPRO_DECODER)          += wmaprodec.o wma.o
-OBJS-$(CONFIG_WMAV1_DECODER)           += wmadec.o wma.o aactab.o
+OBJS-$(CONFIG_WMAV1_DECODER)           += fixed_wmadeci.o fixed_fft.o fixed_mdct.o wmafixed.o fixed_bitstream.o
 OBJS-$(CONFIG_WMAV1_ENCODER)           += wmaenc.o wma.o aactab.o
-OBJS-$(CONFIG_WMAV2_DECODER)           += wmadec.o wma.o aactab.o
+OBJS-$(CONFIG_WMAV2_DECODER)           += fixed_wmadeci.o fixed_fft.o fixed_mdct.o wmafixed.o fixed_bitstream.o
 OBJS-$(CONFIG_WMAV2_ENCODER)           += wmaenc.o wma.o aactab.o
 OBJS-$(CONFIG_WMAVOICE_DECODER)        += wmavoice.o \
                                           celp_math.o celp_filters.o \

--- a/libavcodec/wma.c
+++ b/libavcodec/wma.c
@@ -1,528 +0,0 @@
-/*
- * WMA compatible codec
- * Copyright (c) 2002-2007 The FFmpeg Project
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "avcodec.h"
-#include "sinewin.h"
-#include "wma.h"
-#include "wmadata.h"
-
-#undef NDEBUG
-#include <assert.h>
-
-/* XXX: use same run/length optimization as mpeg decoders */
-//FIXME maybe split decode / encode or pass flag
-static void init_coef_vlc(VLC *vlc, uint16_t **prun_table,
-                          float **plevel_table, uint16_t **pint_table,
-                          const CoefVLCTable *vlc_table)
-{
-    int n = vlc_table->n;
-    const uint8_t  *table_bits   = vlc_table->huffbits;
-    const uint32_t *table_codes  = vlc_table->huffcodes;
-    const uint16_t *levels_table = vlc_table->levels;
-    uint16_t *run_table, *level_table, *int_table;
-    float *flevel_table;
-    int i, l, j, k, level;
-
-    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);
-
-    run_table   = av_malloc(n * sizeof(uint16_t));
-    level_table = av_malloc(n * sizeof(uint16_t));
-    flevel_table= av_malloc(n * sizeof(*flevel_table));
-    int_table   = av_malloc(n * sizeof(uint16_t));
-    i = 2;
-    level = 1;
-    k = 0;
-    while (i < n) {
-        int_table[k] = i;
-        l = levels_table[k++];
-        for (j = 0; j < l; j++) {
-            run_table[i]   = j;
-            level_table[i] = level;
-            flevel_table[i]= level;
-            i++;
-        }
-        level++;
-    }
-    *prun_table   = run_table;
-    *plevel_table = flevel_table;
-    *pint_table   = int_table;
-    av_free(level_table);
-}
-
-/**
- *@brief Get the samples per frame for this stream.
- *@param sample_rate output sample_rate
- *@param version wma version
- *@param decode_flags codec compression features
- *@return log2 of the number of output samples per frame
- */
-int av_cold ff_wma_get_frame_len_bits(int sample_rate, int version,
-                                      unsigned int decode_flags)
-{
-
-    int frame_len_bits;
-
-    if (sample_rate <= 16000) {
-        frame_len_bits = 9;
-    } else if (sample_rate <= 22050 ||
-             (sample_rate <= 32000 && version == 1)) {
-        frame_len_bits = 10;
-    } else if (sample_rate <= 48000 || version < 3) {
-        frame_len_bits = 11;
-    } else if (sample_rate <= 96000) {
-        frame_len_bits = 12;
-    } else {
-        frame_len_bits = 13;
-    }
-
-    if (version == 3) {
-        int tmp = decode_flags & 0x6;
-        if (tmp == 0x2) {
-            ++frame_len_bits;
-        } else if (tmp == 0x4) {
-            --frame_len_bits;
-        } else if (tmp == 0x6) {
-            frame_len_bits -= 2;
-        }
-    }
-
-    return frame_len_bits;
-}
-
-int ff_wma_init(AVCodecContext *avctx, int flags2)
-{
-    WMACodecContext *s = avctx->priv_data;
-    int i;
-    float bps1, high_freq;
-    volatile float bps;
-    int sample_rate1;
-    int coef_vlc_table;
-
-    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000
-        || avctx->channels    <= 0 || avctx->channels    > 8
-        || avctx->bit_rate    <= 0)
-        return -1;
-
-    s->sample_rate = avctx->sample_rate;
-    s->nb_channels = avctx->channels;
-    s->bit_rate    = avctx->bit_rate;
-    s->block_align = avctx->block_align;
-
-    dsputil_init(&s->dsp, avctx);
-    ff_fmt_convert_init(&s->fmt_conv, avctx);
-
-    if (avctx->codec->id == CODEC_ID_WMAV1) {
-        s->version = 1;
-    } else {
-        s->version = 2;
-    }
-
-    /* compute MDCT block size */
-    s->frame_len_bits = ff_wma_get_frame_len_bits(s->sample_rate, s->version, 0);
-    s->next_block_len_bits = s->frame_len_bits;
-    s->prev_block_len_bits = s->frame_len_bits;
-    s->block_len_bits      = s->frame_len_bits;
-
-    s->frame_len = 1 << s->frame_len_bits;
-    if (s->use_variable_block_len) {
-        int nb_max, nb;
-        nb = ((flags2 >> 3) & 3) + 1;
-        if ((s->bit_rate / s->nb_channels) >= 32000)
-            nb += 2;
-        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;
-        if (nb > nb_max)
-            nb = nb_max;
-        s->nb_block_sizes = nb + 1;
-    } else {
-        s->nb_block_sizes = 1;
-    }
-
-    /* init rate dependent parameters */
-    s->use_noise_coding = 1;
-    high_freq = s->sample_rate * 0.5;
-
-    /* if version 2, then the rates are normalized */
-    sample_rate1 = s->sample_rate;
-    if (s->version == 2) {
-        if (sample_rate1 >= 44100) {
-            sample_rate1 = 44100;
-        } else if (sample_rate1 >= 22050) {
-            sample_rate1 = 22050;
-        } else if (sample_rate1 >= 16000) {
-            sample_rate1 = 16000;
-        } else if (sample_rate1 >= 11025) {
-            sample_rate1 = 11025;
-        } else if (sample_rate1 >= 8000) {
-            sample_rate1 = 8000;
-        }
-    }
-
-    bps = (float)s->bit_rate / (float)(s->nb_channels * s->sample_rate);
-    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;
-
-    /* compute high frequency value and choose if noise coding should
-       be activated */
-    bps1 = bps;
-    if (s->nb_channels == 2)
-        bps1 = bps * 1.6;
-    if (sample_rate1 == 44100) {
-        if (bps1 >= 0.61) {
-            s->use_noise_coding = 0;
-        } else {
-            high_freq = high_freq * 0.4;
-        }
-    } else if (sample_rate1 == 22050) {
-        if (bps1 >= 1.16) {
-            s->use_noise_coding = 0;
-        } else if (bps1 >= 0.72) {
-            high_freq = high_freq * 0.7;
-        } else {
-            high_freq = high_freq * 0.6;
-        }
-    } else if (sample_rate1 == 16000) {
-        if (bps > 0.5) {
-            high_freq = high_freq * 0.5;
-        } else {
-            high_freq = high_freq * 0.3;
-        }
-    } else if (sample_rate1 == 11025) {
-        high_freq = high_freq * 0.7;
-    } else if (sample_rate1 == 8000) {
-        if (bps <= 0.625) {
-            high_freq = high_freq * 0.5;
-        } else if (bps > 0.75) {
-            s->use_noise_coding = 0;
-        } else {
-            high_freq = high_freq * 0.65;
-        }
-    } else {
-        if (bps >= 0.8) {
-            high_freq = high_freq * 0.75;
-        } else if (bps >= 0.6) {
-            high_freq = high_freq * 0.6;
-        } else {
-            high_freq = high_freq * 0.5;
-        }
-    }
-    av_dlog(s->avctx, "flags2=0x%x\n", flags2);
-    av_dlog(s->avctx, "version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\n",
-            s->version, s->nb_channels, s->sample_rate, s->bit_rate,
-            s->block_align);
-    av_dlog(s->avctx, "bps=%f bps1=%f high_freq=%f bitoffset=%d\n",
-            bps, bps1, high_freq, s->byte_offset_bits);
-    av_dlog(s->avctx, "use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\n",
-            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);
-
-    /* compute the scale factor band sizes for each MDCT block size */
-    {
-        int a, b, pos, lpos, k, block_len, i, j, n;
-        const uint8_t *table;
-
-        if (s->version == 1) {
-            s->coefs_start = 3;
-        } else {
-            s->coefs_start = 0;
-        }
-        for (k = 0; k < s->nb_block_sizes; k++) {
-            block_len = s->frame_len >> k;
-
-            if (s->version == 1) {
-                lpos = 0;
-                for (i = 0; i < 25; i++) {
-                    a = ff_wma_critical_freqs[i];
-                    b = s->sample_rate;
-                    pos = ((block_len * 2 * a) + (b >> 1)) / b;
-                    if (pos > block_len)
-                        pos = block_len;
-                    s->exponent_bands[0][i] = pos - lpos;
-                    if (pos >= block_len) {
-                        i++;
-                        break;
-                    }
-                    lpos = pos;
-                }
-                s->exponent_sizes[0] = i;
-            } else {
-                /* hardcoded tables */
-                table = NULL;
-                a = s->frame_len_bits - BLOCK_MIN_BITS - k;
-                if (a < 3) {
-                    if (s->sample_rate >= 44100) {
-                        table = exponent_band_44100[a];
-                    } else if (s->sample_rate >= 32000) {
-                        table = exponent_band_32000[a];
-                    } else if (s->sample_rate >= 22050) {
-                        table = exponent_band_22050[a];
-                    }
-                }
-                if (table) {
-                    n = *table++;
-                    for (i = 0; i < n; i++)
-                        s->exponent_bands[k][i] = table[i];
-                    s->exponent_sizes[k] = n;
-                } else {
-                    j = 0;
-                    lpos = 0;
-                    for (i = 0; i < 25; i++) {
-                        a = ff_wma_critical_freqs[i];
-                        b = s->sample_rate;
-                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);
-                        pos <<= 2;
-                        if (pos > block_len)
-                            pos = block_len;
-                        if (pos > lpos)
-                            s->exponent_bands[k][j++] = pos - lpos;
-                        if (pos >= block_len)
-                            break;
-                        lpos = pos;
-                    }
-                    s->exponent_sizes[k] = j;
-                }
-            }
-
-            /* max number of coefs */
-            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;
-            /* high freq computation */
-            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /
-                                          s->sample_rate + 0.5);
-            n = s->exponent_sizes[k];
-            j = 0;
-            pos = 0;
-            for (i = 0; i < n; i++) {
-                int start, end;
-                start = pos;
-                pos += s->exponent_bands[k][i];
-                end = pos;
-                if (start < s->high_band_start[k])
-                    start = s->high_band_start[k];
-                if (end > s->coefs_end[k])
-                    end = s->coefs_end[k];
-                if (end > start)
-                    s->exponent_high_bands[k][j++] = end - start;
-            }
-            s->exponent_high_sizes[k] = j;
-#if 0
-            tprintf(s->avctx, "%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: ",
-                    s->frame_len >> k,
-                    s->coefs_end[k],
-                    s->high_band_start[k],
-                    s->exponent_high_sizes[k]);
-            for (j = 0; j < s->exponent_high_sizes[k]; j++)
-                tprintf(s->avctx, " %d", s->exponent_high_bands[k][j]);
-            tprintf(s->avctx, "\n");
-#endif
-        }
-    }
-
-#ifdef TRACE
-    {
-        int i, j;
-        for (i = 0; i < s->nb_block_sizes; i++) {
-            tprintf(s->avctx, "%5d: n=%2d:",
-                    s->frame_len >> i,
-                    s->exponent_sizes[i]);
-            for (j = 0; j < s->exponent_sizes[i]; j++)
-                tprintf(s->avctx, " %d", s->exponent_bands[i][j]);
-            tprintf(s->avctx, "\n");
-        }
-    }
-#endif
-
-    /* init MDCT windows : simple sinus window */
-    for (i = 0; i < s->nb_block_sizes; i++) {
-        ff_init_ff_sine_windows(s->frame_len_bits - i);
-        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];
-    }
-
-    s->reset_block_lengths = 1;
-
-    if (s->use_noise_coding) {
-
-        /* init the noise generator */
-        if (s->use_exp_vlc) {
-            s->noise_mult = 0.02;
-        } else {
-            s->noise_mult = 0.04;
-        }
-
-#ifdef TRACE
-        for (i = 0; i < NOISE_TAB_SIZE; i++)
-            s->noise_table[i] = 1.0 * s->noise_mult;
-#else
-        {
-            unsigned int seed;
-            float norm;
-            seed = 1;
-            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;
-            for (i = 0; i < NOISE_TAB_SIZE; i++) {
-                seed = seed * 314159 + 1;
-                s->noise_table[i] = (float)((int)seed) * norm;
-            }
-        }
-#endif
-    }
-
-    /* choose the VLC tables for the coefficients */
-    coef_vlc_table = 2;
-    if (s->sample_rate >= 32000) {
-        if (bps1 < 0.72) {
-            coef_vlc_table = 0;
-        } else if (bps1 < 1.16) {
-            coef_vlc_table = 1;
-        }
-    }
-    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];
-    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];
-    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],
-                  s->coef_vlcs[0]);
-    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],
-                  s->coef_vlcs[1]);
-
-    return 0;
-}
-
-int ff_wma_total_gain_to_bits(int total_gain)
-{
-         if (total_gain < 15) return 13;
-    else if (total_gain < 32) return 12;
-    else if (total_gain < 40) return 11;
-    else if (total_gain < 45) return 10;
-    else                      return  9;
-}
-
-int ff_wma_end(AVCodecContext *avctx)
-{
-    WMACodecContext *s = avctx->priv_data;
-    int i;
-
-    for (i = 0; i < s->nb_block_sizes; i++)
-        ff_mdct_end(&s->mdct_ctx[i]);
-
-    if (s->use_exp_vlc) {
-        free_vlc(&s->exp_vlc);
-    }
-    if (s->use_noise_coding) {
-        free_vlc(&s->hgain_vlc);
-    }
-    for (i = 0; i < 2; i++) {
-        free_vlc(&s->coef_vlc[i]);
-        av_free(s->run_table[i]);
-        av_free(s->level_table[i]);
-        av_free(s->int_table[i]);
-    }
-
-    return 0;
-}
-
-/**
- * Decode an uncompressed coefficient.
- * @param gb GetBitContext
- * @return the decoded coefficient
- */
-unsigned int ff_wma_get_large_val(GetBitContext* gb)
-{
-    /** consumes up to 34 bits */
-    int n_bits = 8;
-    /** decode length */
-    if (get_bits1(gb)) {
-        n_bits += 8;
-        if (get_bits1(gb)) {
-            n_bits += 8;
-            if (get_bits1(gb)) {
-                n_bits += 7;
-            }
-        }
-    }
-    return get_bits_long(gb, n_bits);
-}
-
-/**
- * Decode run level compressed coefficients.
- * @param avctx codec context
- * @param gb bitstream reader context
- * @param vlc vlc table for get_vlc2
- * @param level_table level codes
- * @param run_table run codes
- * @param version 0 for wma1,2 1 for wmapro
- * @param ptr output buffer
- * @param offset offset in the output buffer
- * @param num_coefs number of input coefficents
- * @param block_len input buffer length (2^n)
- * @param frame_len_bits number of bits for escaped run codes
- * @param coef_nb_bits number of bits for escaped level codes
- * @return 0 on success, -1 otherwise
- */
-int ff_wma_run_level_decode(AVCodecContext* avctx, GetBitContext* gb,
-                            VLC *vlc,
-                            const float *level_table, const uint16_t *run_table,
-                            int version, WMACoef *ptr, int offset,
-                            int num_coefs, int block_len, int frame_len_bits,
-                            int coef_nb_bits)
-{
-    int code, level, sign;
-    const uint32_t *ilvl = (const uint32_t*)level_table;
-    uint32_t *iptr = (uint32_t*)ptr;
-    const unsigned int coef_mask = block_len - 1;
-    for (; offset < num_coefs; offset++) {
-        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);
-        if (code > 1) {
-            /** normal code */
-            offset += run_table[code];
-            sign = get_bits1(gb) - 1;
-            iptr[offset & coef_mask] = ilvl[code] ^ sign<<31;
-        } else if (code == 1) {
-            /** EOB */
-            break;
-        } else {
-            /** escape */
-            if (!version) {
-                level = get_bits(gb, coef_nb_bits);
-                /** NOTE: this is rather suboptimal. reading
-                    block_len_bits would be better */
-                offset += get_bits(gb, frame_len_bits);
-            } else {
-                level = ff_wma_get_large_val(gb);
-                /** escape decode */
-                if (get_bits1(gb)) {
-                    if (get_bits1(gb)) {
-                        if (get_bits1(gb)) {
-                            av_log(avctx,AV_LOG_ERROR,
-                                "broken escape sequence\n");
-                            return -1;
-                        } else
-                            offset += get_bits(gb, frame_len_bits) + 4;
-                    } else
-                        offset += get_bits(gb, 2) + 1;
-                }
-            }
-            sign = get_bits1(gb) - 1;
-            ptr[offset & coef_mask] = (level^sign) - sign;
-        }
-    }
-    /** NOTE: EOB can be omitted */
-    if (offset > num_coefs) {
-        av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n");
-        return -1;
-    }
-
-    return 0;
-}
-

--- a/libavcodec/wmadata.h
+++ b/libavcodec/wmadata.h
@@ -20,17 +20,15 @@
  */
 
 /**
- * @file
+ * @file wmadata.h
  * Various WMA tables.
  */
 
-#ifndef AVCODEC_WMADATA_H
-#define AVCODEC_WMADATA_H
+#define IBSS_ATTR
+#define ICONST_ATTR
+#define ICODE_ATTR
 
-#include <stdint.h>
-#include "wma.h"
-
-const uint16_t ff_wma_critical_freqs[25] = {
+static const uint16_t wma_critical_freqs[25] = {
     100,   200,  300, 400,   510,  630,  770,    920,
     1080, 1270, 1480, 1720, 2000, 2320, 2700,   3150,
     3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500,
@@ -56,7 +54,7 @@
     { 17,  4,   8,   8,   4,  12,  12,   8,   8,  24,  16,  20,  24,  32,  40,  60,  80, 152, },
 };
 
-const uint16_t ff_wma_hgain_huffcodes[37] = {
+static const uint16_t hgain_huffcodes[37] = {
  0x00003, 0x002e7, 0x00001, 0x005cd, 0x0005d, 0x005c9, 0x0005e, 0x00003,
  0x00016, 0x0000b, 0x00001, 0x00006, 0x00001, 0x00006, 0x00004, 0x00005,
  0x00004, 0x00007, 0x00003, 0x00007, 0x00004, 0x0000a, 0x0000a, 0x00002,
@@ -64,7 +62,7 @@
  0x005c8, 0x000b8, 0x005ca, 0x005cb, 0x005cc,
 };
 
-const uint8_t ff_wma_hgain_huffbits[37] = {
+static const uint8_t hgain_huffbits[37] = {
  10, 12, 10, 13,  9, 13,  9,  8,
   7,  5,  5,  4,  4,  3,  3,  3,
   4,  3,  4,  4,  5,  5,  6,  8,
@@ -72,24 +70,55 @@
  13, 10, 13, 13, 13,
 };
 
-const float ff_wma_lsp_codebook[NB_LSP_COEFS][16] = {
- { 1.98732877, 1.97944528, 1.97179088, 1.96260549, 1.95038374, 1.93336114, 1.90719232, 1.86191415, },
- { 1.97260000, 1.96083160, 1.94982586, 1.93806164, 1.92516608, 1.91010199, 1.89232331, 1.87149812,
-   1.84564818, 1.81358067, 1.77620070, 1.73265264, 1.67907855, 1.60959081, 1.50829650, 1.33120330, },
- { 1.90109110, 1.86482426, 1.83419671, 1.80168452, 1.76650116, 1.72816320, 1.68502700, 1.63738256,
-   1.58501580, 1.51795181, 1.43679906, 1.33950585, 1.24176208, 1.12260729, 0.96749668, 0.74048265, },
- { 1.76943864, 1.67822463, 1.59946365, 1.53560582, 1.47470796, 1.41210167, 1.34509536, 1.27339507,
-   1.19303814, 1.09765169, 0.98818722, 0.87239446, 0.74369172, 0.59768184, 0.43168630, 0.17977021, },
- { 1.43428349, 1.32038354, 1.21074086, 1.10577988, 1.00561746, 0.90335924, 0.80437489, 0.70709671,
-   0.60427395, 0.49814048, 0.38509539, 0.27106800, 0.14407416, 0.00219910, -0.16725141, -0.36936085, },
- { 0.99895687, 0.84188166, 0.70753739, 0.57906595, 0.47055563, 0.36966965, 0.26826648, 0.17163380,
-   0.07208392, -0.03062936, -1.40037388, -0.25128968, -0.37213937, -0.51075646, -0.64887512, -0.80308031, },
- { 0.26515280, 0.06313551, -0.08872080, -0.21103548, -0.31069678, -0.39680323, -0.47223474, -0.54167135,
-   -0.61444740, -0.68943343, -0.76580211, -0.85170082, -0.95289061, -1.06514703, -1.20510707, -1.37617746, },
- { -0.53940301, -0.73770929, -0.88424876, -1.01117930, -1.13389091, -1.26830073, -1.42041987, -1.62033919,
-   -1.10158808, -1.16512566, -1.23337128, -1.30414401, -1.37663312, -1.46853845, -1.57625798, -1.66893638, },
- { -0.38601997, -0.56009350, -0.66978483, -0.76028471, -0.83846064, -0.90868087, -0.97408881, -1.03694962, },
- { -1.56144989, -1.65944032, -1.72689685, -1.77857740, -1.82203011, -1.86220079, -1.90283983, -1.94820479, },
+static const int32_t lsp_codebook[NB_LSP_COEFS][16] = {
+{0x1fcc2,0x1fabd,0x1f8c7,0x1f66d,0x1f34c,0x1eef1,0x1e83e,0x1dca6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0},
+{0x1f8fc,0x1f5f9,0x1f328,0x1f025,0x1ecd8,0x1e8fc,0x1e46f,0x1df1b,0x1d87c,0x1d047,0x1c6b5,0x1bb8f,0x1add8,0x19c0e,0x18220,0x154ca},
+{0x1e6ae,0x1dd65,0x1d58e,0x1cd3b,0x1c439,0x1ba69,0x1af5e,0x1a32c,0x195c4,0x18498,0x16fd2,0x156ea,0x13de4,0x11f63,0xf7ae,0xbd90},
+{0x1c4fa,0x1ada0,0x19976,0x1891d,0x17986,0x1697f,0x15858,0x145fd,0x1316b,0x11900,0xfcfa,0xdf55,0xbe63,0x9902,0x6e83,0x2e05},
+{0x16f2d,0x15205,0x135f3,0x11b14,0x10170,0xe743,0xcdec,0xb504,0x9ab2,0x7f86,0x6296,0x4565,0x24e2,0x90,0xffffd52f,0xffffa172},
+{0xffbc,0xd786,0xb521,0x943e,0x7876,0x5ea3,0x44ad,0x2bf0,0x1274,0xfffff829,0xfffe9981,0xffffbfab,0xffffa0bb,0xffff7d3f,0xffff59e3,0xffff3269},
+{0x43e1,0x102a,0xffffe94a,0xffffc9fa,0xffffb076,0xffff9a6b,0xffff871c,0xffff7555,0xffff62b4,0xffff4f81,0xffff3bf4,0xffff25f7,0xffff0c0f,0xfffeef53,0xfffecb7e,0xfffe9fb3},
+{0xffff75ea,0xffff4325,0xffff1da2,0xfffefd23,0xfffeddb9,0xfffebb51,0xfffe945f,0xfffe6131,0xfffee5fe,0xfffed5ba,0xfffec442,0xfffeb224,0xfffe9f95,0xfffe880e,0xfffe6c7a,0xfffe54c1},
+{0xffff9d2e,0xffff709e,0xffff5489,0xffff3d5e,0xffff295b,0xffff1761,0xffff06a2,0xfffef68a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0},
+{0xfffe7045,0xfffe572f,0xfffe45ea,0xfffe38af,0xfffe2d8f,0xfffe2347,0xfffe18df,0xfffe0d42,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}
+};
+
+static const uint32_t scale_huffcodes[121] = {
+ 0x3ffe8, 0x3ffe6, 0x3ffe7, 0x3ffe5, 0x7fff5, 0x7fff1, 0x7ffed, 0x7fff6,
+ 0x7ffee, 0x7ffef, 0x7fff0, 0x7fffc, 0x7fffd, 0x7ffff, 0x7fffe, 0x7fff7,
+ 0x7fff8, 0x7fffb, 0x7fff9, 0x3ffe4, 0x7fffa, 0x3ffe3, 0x1ffef, 0x1fff0,
+ 0x0fff5, 0x1ffee, 0x0fff2, 0x0fff3, 0x0fff4, 0x0fff1, 0x07ff6, 0x07ff7,
+ 0x03ff9, 0x03ff5, 0x03ff7, 0x03ff3, 0x03ff6, 0x03ff2, 0x01ff7, 0x01ff5,
+ 0x00ff9, 0x00ff7, 0x00ff6, 0x007f9, 0x00ff4, 0x007f8, 0x003f9, 0x003f7,
+ 0x003f5, 0x001f8, 0x001f7, 0x000fa, 0x000f8, 0x000f6, 0x00079, 0x0003a,
+ 0x00038, 0x0001a, 0x0000b, 0x00004, 0x00000, 0x0000a, 0x0000c, 0x0001b,
+ 0x00039, 0x0003b, 0x00078, 0x0007a, 0x000f7, 0x000f9, 0x001f6, 0x001f9,
+ 0x003f4, 0x003f6, 0x003f8, 0x007f5, 0x007f4, 0x007f6, 0x007f7, 0x00ff5,
+ 0x00ff8, 0x01ff4, 0x01ff6, 0x01ff8, 0x03ff8, 0x03ff4, 0x0fff0, 0x07ff4,
+ 0x0fff6, 0x07ff5, 0x3ffe2, 0x7ffd9, 0x7ffda, 0x7ffdb, 0x7ffdc, 0x7ffdd,
+ 0x7ffde, 0x7ffd8, 0x7ffd2, 0x7ffd3, 0x7ffd4, 0x7ffd5, 0x7ffd6, 0x7fff2,
+ 0x7ffdf, 0x7ffe7, 0x7ffe8, 0x7ffe9, 0x7ffea, 0x7ffeb, 0x7ffe6, 0x7ffe0,
+ 0x7ffe1, 0x7ffe2, 0x7ffe3, 0x7ffe4, 0x7ffe5, 0x7ffd7, 0x7ffec, 0x7fff4,
+ 0x7fff3,
+};
+
+static const uint8_t scale_huffbits[121] = {
+ 18, 18, 18, 18, 19, 19, 19, 19,
+ 19, 19, 19, 19, 19, 19, 19, 19,
+ 19, 19, 19, 18, 19, 18, 17, 17,
+ 16, 17, 16, 16, 16, 16, 15, 15,
+ 14, 14, 14, 14, 14, 14, 13, 13,
+ 12, 12, 12, 11, 12, 11, 10, 10,
+ 10,  9,  9,  8,  8,  8,  7,  6,
+  6,  5,  4,  3,  1,  4,  4,  5,
+  6,  6,  7,  7,  8,  8,  9,  9,
+ 10, 10, 10, 11, 11, 11, 11, 12,
+ 12, 13, 13, 13, 14, 14, 16, 15,
+ 16, 15, 18, 19, 19, 19, 19, 19,
+ 19, 19, 19, 19, 19, 19, 19, 19,
+ 19, 19, 19, 19, 19, 19, 19, 19,
+ 19, 19, 19, 19, 19, 19, 19, 19,
+ 19,
 };
 
 static const uint32_t coef0_huffcodes[666] = {
@@ -1379,25 +1408,1203 @@
   1,  1,  1,  1,  1,  1,  1,  1,
 };
 
-static const CoefVLCTable coef_vlcs[6] = {
+static const CoefVLCTable_fixed coef_vlcs[6] = {
     {
-        sizeof(coef0_huffbits), sizeof(levels0)/2, coef0_huffcodes, coef0_huffbits, levels0,
+        sizeof(coef0_huffbits), coef0_huffcodes, coef0_huffbits, levels0,
     },
     {
-        sizeof(coef1_huffbits), sizeof(levels1)/2, coef1_huffcodes, coef1_huffbits, levels1,
+        sizeof(coef1_huffbits), coef1_huffcodes, coef1_huffbits, levels1,
     },
     {
-        sizeof(coef2_huffbits), sizeof(levels2)/2, coef2_huffcodes, coef2_huffbits, levels2,
+        sizeof(coef2_huffbits), coef2_huffcodes, coef2_huffbits, levels2,
     },
     {
-        sizeof(coef3_huffbits), sizeof(levels3)/2, coef3_huffcodes, coef3_huffbits, levels3,
+        sizeof(coef3_huffbits), coef3_huffcodes, coef3_huffbits, levels3,
     },
     {
-        sizeof(coef4_huffbits), sizeof(levels4)/2, coef4_huffcodes, coef4_huffbits, levels4,
+        sizeof(coef4_huffbits), coef4_huffcodes, coef4_huffbits, levels4,
     },
     {
-        sizeof(coef5_huffbits), sizeof(levels5)/2, coef5_huffcodes, coef5_huffbits, levels5,
+        sizeof(coef5_huffbits), coef5_huffcodes, coef5_huffbits, levels5,
     },
 };
 
-#endif /* AVCODEC_WMADATA_H */
+/*table of the values of 10^(index*.05)*/
+const int64_t pow_table[] =
+    {   0x199a, 0x1cb9, 0x203a, 0x2429, 0x2893, 0x2d86, 0x3314, 0x3950, 0x404e,
+        0x4827, 0x50f4, 0x5ad5, 0x65ea, 0x725a, 0x804e, 0x8ff6, 0xa186, 0xb53c,
+        0xcb59, 0xe429, 0x10000LL,0x11f3dLL,0x14249LL,0x1699cLL,0x195bcLL,
+        0x1c73dLL,0x1fec9LL,0x23d1dLL,0x2830bLL,0x2d182LL, 0x3298bLL,0x38c53LL,
+        0x3fb28LL,0x47783LL,0x5030aLL,0x59f98LL,0x64f40LL,0x71457LL,0x7f17bLL,
+        0x8e99aLL,0xa0000LL,0xb385eLL,0xc96d9LL,0xe2019LL,0xfd954LL,0x11c865LL,
+        0x13f3dfLL,0x166320LL,0x191e6eLL,0x1c2f10LL,0x1f9f6eLL,0x237b39LL,
+        0x27cf8bLL,0x2cab1aLL,0x321e65LL,0x383bf0LL,0x3f1882LL,0x46cb6aLL,
+        0x4f6eceLL,0x592006LL,0x640000LL,0x7033acLL,0x7de47eLL,0x8d40f6LL,
+        0x9e7d44LL,0xb1d3f4LL,0xc786b7LL,0xdfdf43LL,0xfb304bLL,0x119d69aLL,
+        0x13c3a4eLL,0x162d03aLL,0x18e1b70LL,0x1beaf00LL,0x1f52feeLL,
+        0x2325760LL,0x276f514LL,0x2c3f220LL,0x31a5408LL,0x37b403cLL,0x3e80000LL,
+        0x46204b8LL,0x4eaece8LL,0x58489a0LL,0x630e4a8LL,0x6f24788LL,0x7cb4328LL,
+        0x8beb8a0LL,0x9cfe2f0LL,0xb026200LL,0xc5a4710LL,0xddc2240LL,0xf8d1260LL,
+        0x1172d600LL,0x1393df60LL,0x15f769c0LL,0x18a592c0LL,0x1ba77540LL,
+        0x1f074840LL,0x22d08280LL,0x27100000LL,0x2bd42f40LL,0x312d4100LL,
+        0x372d6000LL,0x3de8ee80LL,0x4576cb80LL,0x4df09f80LL,0x57733600LL,
+        0x621edd80LL,0x6e17d480LL,0x7b86c700LL,0x8a995700LL,0x9b82b800LL,
+        0xae7c5c00LL,0xc3c6b900LL,0xdbaa2200LL,0xf677bc00LL,0x1148a9400LL,
+        0x13648d200LL,0x15c251800LL,0x186a00000LL,0x1b649d800LL,0x1ebc48a00LL,
+        0x227c5c000LL,0x26b195000LL,0x2b6a3f000LL,0x30b663c00LL,0x36a801c00LL,
+        0x3d534a400LL,0x44cee4800LL,0x4d343c800LL,0x569fd6000LL,0x6131b2800LL,
+        0x6d0db9800LL,0x7a5c33800LL,0x894a55000LL,0x9a0ad6000LL,0xacd69d000LL,
+        0xc1ed84000LL,0xd9972f000LL,0xf42400000LL,0x111ee28000LL,0x1335ad6000LL,
+        0x158db98000LL,0x182efd4000LL,0x1b22676000LL,0x1e71fe6000LL,
+        0x2229014000LL,0x26540e8000LL,0x2b014f0000LL,0x3040a5c000LL,
+        0x3623e60000LL,0x3cbf0fc000LL,0x4428940000LL,0x4c79a08000LL,
+        0x55ce758000LL,0x6046c58000LL,0x6c06220000LL,0x7934728000LL,
+        0x87fe7d0000LL,0x9896800000LL,0xab34d90000LL,0xc018c60000LL,
+        0xd7893f0000LL,0xf1d5e40000LL,0x10f580a0000LL,0x13073f00000LL,
+        0x1559a0c0000LL,0x17f48900000LL,0x1ae0d160000LL,0x1e286780000LL,
+        0x21d66fc0000LL,0x25f769c0000LL,0x2a995c80000LL,0x2fcc0440000LL,
+        0x35a10940000LL,0x3c2c3b80000LL,0x4383d500000LL,0x4bc0c780000LL,
+        0x54ff0e80000LL,0x5f5e1000000LL,0x6b010780000LL,0x780f7c00000LL,
+        0x86b5c800000LL,0x9725ae00000LL,0xa9970600000LL,0xbe487500000LL,
+        0xd5804700000LL,0xef8d5a00000LL,0x10cc82e00000LL,0x12d940c00000LL,
+        0x152605c00000LL,0x17baa2200000LL,0x1a9fd9c00000LL,0x1ddf82a00000LL,
+        0x2184a5c00000LL,0x259ba5400000LL,0x2a3265400000LL,0x2f587cc00000LL,
+        0x351f69000000LL,0x3b9aca000000LL,0x42e0a4800000LL,0x4b09ad800000LL,
+        0x54319d000000LL,0x5e778d000000LL,0x69fe64000000LL,0x76ed49800000LL,
+        0x85702c000000LL,0x95b858000000LL,0xa7fd1c000000LL,0xbc7c87000000LL,
+        0xd37c3a000000LL,0xed4a55000000LL,0x10a3e82000000LL,0x12abb1a000000LL,
+        0x14f2e7a000000LL,0x1781474000000LL,0x1a5f7f4000000LL,0x1d974de000000LL,
+        0x2133a18000000LL
+    };
+
+/*  10^(index/16).  We'll need to accomidate negative indicies too.
+    The algorithm sort of implies that there should be 128 values starting at -60,
+    however this has not been confirmed.  More values may be needed.
+*/
+const int32_t pow_10_to_yover16[] ICONST_ATTR=
+{
+    /*60 negative indicies (-60 to -1)*/
+    0xc, 0xd, 0x10, 0x12, 0x15, 0x18, 0x1c, 0x20, 0x25, 0x2b, 0x31, 0x39, 0x42,
+    0x4c, 0x57, 0x65, 0x75, 0x87, 0x9b, 0xb3, 0xcf, 0xef, 0x114, 0x13f, 0x171, 
+    0x1aa, 0x1eb, 0x238, 0x28f, 0x2f5, 0x36a, 0x3f1, 0x48d, 0x542, 0x612, 0x703,
+    0x818, 0x959, 0xacc, 0xc77, 0xe65, 0x10a0, 0x1333, 0x162b, 0x199a, 0x1d90, 
+    0x2223, 0x276c, 0x2d86, 0x3492, 0x3cb5, 0x461b, 0x50f4, 0x5d7c, 0x6bf4, 
+    0x7caa, 0x8ff6, 0xa63e, 0xbff9, 0xddb0,
+    /*non-negative indicies (0-68)*/
+    0x10000, 0x127a0, 0x15562, 0x18a39, 0x1c73d, 0x20db4, 0x25f12, 0x2bd09, 
+    0x3298b, 0x3a6d9, 0x4378b, 0x4dea3, 0x59f98, 0x67e6b, 0x77fbb, 0x8a8de, 
+    0xa0000, 0xb8c3e, 0xd55d1, 0xf6636, 0x11c865, 0x148906, 0x17b6b7, 0x1b625b,
+    0x1f9f6e, 0x248475, 0x2a2b6e, 0x30b25e, 0x383bf0, 0x40f02b, 0x4afd4b, 
+    0x5698b0, 0x640000, 0x737a6b, 0x855a26, 0x99fe1e, 0xb1d3f4, 0xcd5a3e, 
+    0xed232b, 0x111d78b, 0x13c3a4f, 0x16d2c94, 0x1a5b24e, 0x1e6f7b0, 0x2325761,
+    0x28961b3, 0x2ede4eb, 0x361f6de, 0x3e80000, 0x482c830, 0x535857d, 0x603ed31,
+    0x6f24787, 0x8058668, 0x9435fab, 0xab26b6d, 0xc5a4715, 0xe43bdc4, 
+    0x1078f70c, 0x1305acdd, 0x15f769cb, 0x195dd0fa, 0x1d4af12d, 0x21d3a4ab, 
+    0x27100000, 0x2d1bd1e1, 0x341736de, 0x3c2743e8, 0x4576cb4a
+};
+
+const int32_t pow_a_table[] =
+{
+    0x1004,0x1008,0x100c,0x1010,0x1014,0x1018,0x101c,0x1021,0x1025,0x1029,0x102d,
+    0x1031,0x1036,0x103a,0x103e,0x1043,0x1047,0x104b,0x1050,0x1054,0x1059,0x105d,
+    0x1062,0x1066,0x106b,0x106f,0x1074,0x1078,0x107d,0x1082,0x1086,0x108b,0x1090,
+    0x1095,0x1099,0x109e,0x10a3,0x10a8,0x10ad,0x10b2,0x10b7,0x10bc,0x10c1,0x10c6,
+    0x10cb,0x10d0,0x10d5,0x10da,0x10df,0x10e5,0x10ea,0x10ef,0x10f5,0x10fa,0x10ff,
+    0x1105,0x110a,0x1110,0x1115,0x111b,0x1120,0x1126,0x112c,0x1131,0x1137,0x113d,
+    0x1143,0x1149,0x114f,0x1155,0x115a,0x1161,0x1167,0x116d,0x1173,0x1179,0x117f,
+    0x1186,0x118c,0x1192,0x1199,0x119f,0x11a6,0x11ac,0x11b3,0x11b9,0x11c0,0x11c7,
+    0x11ce,0x11d4,0x11db,0x11e2,0x11e9,0x11f0,0x11f8,0x11ff,0x1206,0x120d,0x1215,
+    0x121c,0x1223,0x122b,0x1233,0x123a,0x1242,0x124a,0x1251,0x1259,0x1261,0x1269,
+    0x1271,0x127a,0x1282,0x128a,0x1293,0x129b,0x12a4,0x12ac,0x12b5,0x12be,0x12c7,
+    0x12d0,0x12d9,0x12e2,0x12eb,0x12f4,0x12fe,0x1307
+};
+
+
+/* 32.32 unsigned fixed format */
+/* This is a table of exponent values for an IEEE SP float.  Theres never anything less then about index 115
+ * making the size of this table fairly ridiculous.
+ */
+const int64_t lsp_pow_e_table[] =
+{
+    0xb504f30000000000LL, 0x9837f00000000000LL, 0x8000000000000000LL, 0x6ba27e8000000000LL, 0x5a82798000000000LL,
+    0x4c1bf80000000000LL, 0x4000000000000000LL, 0x35d13f4000000000LL, 0x2d413cc000000000LL, 0x260dfc0000000000LL,
+    0x2000000000000000LL, 0x1ae89fa000000000LL, 0x16a09e6000000000LL, 0x1306fe0000000000LL, 0x1000000000000000LL,
+    0xd744fd000000000LL, 0xb504f3000000000LL, 0x9837f0000000000LL, 0x800000000000000LL, 0x6ba27e800000000LL,
+    0x5a8279800000000LL, 0x4c1bf8000000000LL, 0x400000000000000LL, 0x35d13f400000000LL, 0x2d413cc00000000LL,
+    0x260dfc000000000LL, 0x200000000000000LL, 0x1ae89fa00000000LL, 0x16a09e600000000LL, 0x1306fe000000000LL,
+    0x100000000000000LL, 0xd744fd00000000LL, 0xb504f300000000LL, 0x9837f000000000LL, 0x80000000000000LL,
+    0x6ba27e80000000LL, 0x5a827980000000LL, 0x4c1bf800000000LL, 0x40000000000000LL, 0x35d13f40000000LL,
+    0x2d413cc0000000LL, 0x260dfc00000000LL, 0x20000000000000LL, 0x1ae89fa0000000LL, 0x16a09e60000000LL,
+    0x1306fe00000000LL, 0x10000000000000LL, 0xd744fd0000000LL, 0xb504f30000000LL, 0x9837f00000000LL,
+    0x8000000000000LL, 0x6ba27e8000000LL, 0x5a82798000000LL, 0x4c1bf80000000LL, 0x4000000000000LL,
+    0x35d13f4000000LL, 0x2d413cc000000LL, 0x260dfc0000000LL, 0x2000000000000LL, 0x1ae89fa000000LL,
+    0x16a09e6000000LL, 0x1306fe0000000LL, 0x1000000000000LL, 0xd744fd000000LL, 0xb504f3000000LL,
+    0x9837f0000000LL, 0x800000000000LL, 0x6ba27e800000LL, 0x5a8279800000LL, 0x4c1bf8000000LL,
+    0x400000000000LL, 0x35d13f400000LL, 0x2d413cc00000LL, 0x260dfc000000LL, 0x200000000000LL,
+    0x1ae89fa00000LL, 0x16a09e600000LL, 0x1306fe000000LL, 0x100000000000LL, 0xd744fd00000LL,
+    0xb504f300000LL, 0x9837f000000LL, 0x80000000000LL, 0x6ba27e80000LL, 0x5a827980000LL,
+    0x4c1bf800000LL, 0x40000000000LL, 0x35d13f40000LL, 0x2d413cc0000LL, 0x260dfc00000LL,
+    0x20000000000LL, 0x1ae89fa0000LL, 0x16a09e60000LL, 0x1306fe00000LL, 0x10000000000LL,
+    0xd744fd0000LL, 0xb504f30000LL, 0x9837f00000LL, 0x8000000000LL, 0x6ba27e8000LL,
+    0x5a82798000LL, 0x4c1bf80000LL, 0x4000000000LL, 0x35d13f4000LL, 0x2d413cc000LL,
+    0x260dfc0000LL, 0x2000000000LL, 0x1ae89fa000LL, 0x16a09e6000LL, 0x1306fe0000LL,
+    0x1000000000LL, 0xd744fd000LL, 0xb504f3000LL, 0x9837f0000LL, 0x800000000LL,
+    0x6ba27e800LL, 0x5a8279800LL, 0x4c1bf8000LL, 0x400000000LL, 0x35d13f400LL,
+    0x2d413cc00LL, 0x260dfc000LL, 0x200000000LL, 0x1ae89fa00LL, 0x16a09e600LL,
+    0x1306fe000LL, 0x100000000LL, 0xd744fd00LL, 0xb504f300LL, 0x9837f000LL,
+    0x80000000LL, 0x6ba27e80LL, 0x5a827980LL, 0x4c1bf800LL, 0x40000000LL,
+    0x35d13f40LL, 0x2d413cc0LL, 0x260dfc00LL, 0x20000000LL, 0x1ae89fa0LL,
+    0x16a09e60LL, 0x1306fe00LL, 0x10000000LL, 0xd744fd0LL, 0xb504f30LL,
+    0x9837f00LL, 0x8000000LL, 0x6ba27e8LL, 0x5a82798LL, 0x4c1bf80LL,
+    0x4000000LL, 0x35d13f4LL, 0x2d413ccLL, 0x260dfc0LL, 0x2000000LL,
+    0x1ae89faLL, 0x16a09e6LL, 0x1306fe0LL, 0x1000000LL, 0xd744fdLL,
+    0xb504f3LL, 0x9837f0LL, 0x800000LL, 0x6ba27eLL, 0x5a8279LL,
+    0x4c1bf8LL, 0x400000LL, 0x35d13fLL, 0x2d413cLL, 0x260dfcLL,
+    0x200000LL, 0x1ae89fLL, 0x16a09eLL, 0x1306feLL, 0x100000LL,
+    0xd744fLL, 0xb504fLL, 0x9837fLL, 0x80000LL, 0x6ba27LL,
+    0x5a827LL, 0x4c1bfLL, 0x40000LL, 0x35d13LL, 0x2d413LL,
+    0x260dfLL, 0x20000LL, 0x1ae89LL, 0x16a09LL, 0x1306fLL,
+    0x10000LL, 0xd744LL, 0xb504LL, 0x9837LL, 0x8000LL,
+    0x6ba2LL, 0x5a82LL, 0x4c1bLL, 0x4000LL, 0x35d1LL,
+    0x2d41LL, 0x260dLL, 0x2000LL, 0x1ae8LL, 0x16a0LL,
+    0x1306LL, 0x1000LL, 0xd74LL, 0xb50LL, 0x983LL,
+    0x800LL, 0x6baLL, 0x5a8LL, 0x4c1LL, 0x400LL,
+    0x35dLL, 0x2d4LL, 0x260LL, 0x200LL, 0x1aeLL,
+    0x16aLL, 0x130LL, 0x100LL, 0xd7LL, 0xb5LL,
+    0x98LL, 0x80LL, 0x6bLL, 0x5aLL, 0x4cLL,
+    0x40LL, 0x35LL, 0x2dLL, 0x26LL, 0x20LL,
+    0x1aLL, 0x16LL, 0x13LL, 0x10LL, 0xdLL,
+    0xbLL, 0x9LL, 0x8LL, 0x6LL, 0x5LL,
+    0x4LL, 0x4LL, 0x3LL, 0x2LL, 0x2LL,
+    0x2LL, 0x1LL, 0x1LL, 0x1LL, 0x1LL,
+    0x0LL
+};
+
+/* table of exp noise values multiplied by 16 in order to reduce rounding error */
+int32_t noisetable_exp[] =
+{
+    0x5, 0xfffffa2e, 0xc2c, 0xb47, 0xffffaebe, 0xfffffa63, 0xfffff7ff, 0x16bd,
+    0xffffe704, 0xffffe34e, 0x71ee, 0x396e, 0xffff8bfd, 0x3b4, 0x562f, 0xffffc362,
+    0x5327, 0xffffae19, 0x6cb4, 0x26b0, 0x87c4, 0x21dc, 0x8017, 0x1db0,
+    0xffffe49e, 0xffffb162, 0xffffc808, 0xffffafea, 0xfffffe80, 0xfffffeb8, 0xffff8b6e, 0xffffc7a1,
+    0x3f46, 0x5e8, 0x374f, 0xffff8fba, 0x87fd, 0x21e7, 0xffff9198, 0x78a0,
+    0x7f7c, 0x864f, 0xffffca94, 0x42a7, 0xfffffcd6, 0xffffb916, 0x247a, 0x5679,
+    0x8d9f, 0xffffb350, 0xffff9592, 0xffffcf73, 0x552d, 0xffffeb8c, 0x8622, 0xffff8091,
+    0x238, 0x3ee8, 0x5c2f, 0x6e25, 0xffffe5cb, 0x86a1, 0xffffa8ca, 0xfe2,
+    0x5dac, 0x2da2, 0x5ad1, 0xffffa94f, 0x729, 0xfffffdc0, 0xffff825c, 0x8bcd,
+    0xffff7d05, 0xffff7d9e, 0xffffb5b6, 0x58a3, 0xffff8a3f, 0xffffd9c0, 0xffff8142, 0x596f,
+    0x78aa, 0x2694, 0x78f5, 0xffff8a84, 0x43b3, 0x498a, 0xffffdfe5, 0xffffbba9,
+    0xffff7228, 0xffff72c9, 0xfffff174, 0xffff9a76, 0x64d5, 0x221c, 0x88dd, 0xffffd319,
+    0xfffffe14, 0xfffff99f, 0xffff8ba4, 0x6e34, 0x6cc, 0x3208, 0xfffffb14, 0x6670,
+    0xffffd5ff, 0xffffa502, 0x641d, 0xffff75b6, 0xec2, 0xffffedf2, 0xffffb925, 0xffffe271,
+    0xffffb727, 0xffff7450, 0xfffff421, 0x89e7, 0xfffff635, 0xffffa841, 0xffffda00, 0xffffc94e,
+    0xef9, 0x28cc, 0xffffd477, 0xffff82b9, 0x2a7, 0xffff7540, 0x24c2, 0x4349,
+    0xffffdf34, 0xdf7, 0x323d, 0xffffbce7, 0x29c5, 0x4700, 0x10b0, 0x1eb6,
+    0x1172, 0x84be, 0xffffcee4, 0xffffe7bd, 0x1166, 0xffff7df0, 0xffffe115, 0x2383,
+    0x23a0, 0x784a, 0x6f8e, 0xffff9043, 0x2b66, 0xffffc79e, 0xffff8966, 0xffffbfac,
+    0x5fb1, 0xffffb183, 0x3602, 0x3d19, 0xffff7df4, 0x3ffe, 0xffffc919, 0x5ac7,
+    0xffffa3e8, 0xfffff2ea, 0x47b9, 0xffffe344, 0x12f0, 0xffffc4e8, 0xfffff3fc, 0xffffcacd,
+    0xffffd23b, 0x893a, 0x5e82, 0xffff8d36, 0x50e0, 0x49a6, 0x29dd, 0x16fa,
+    0x451d, 0x8315, 0xffffe455, 0x749, 0x8624, 0x2fe5, 0x3ab5, 0xffffb4f1,
+    0x72d, 0xffffccdf, 0x2b05, 0xffffa816, 0xffff9570, 0xffffd2e7, 0xffffa6ac, 0x2fc2,
+    0xae4, 0x4c93, 0xfffffce1, 0xffffdb9f, 0x8102, 0x6bb1, 0xffffd5bf, 0xffff80e0,
+    0xffffd70e, 0x568f, 0xc12, 0xffff9823, 0x700c, 0xffffa1aa, 0xffffa86c, 0xffffd303,
+    0xffffbe7a, 0x38c9, 0xffff9f18, 0xffffcd7a, 0xffff8d75, 0x6955, 0xffffe70a, 0xffffbf49,
+    0xffffc423, 0x31f, 0xffffe44a, 0x118a, 0xffffebfa, 0xffffedec, 0xffffee42, 0xffffd865,
+    0xffff9b30, 0xffff8759, 0xffff827c, 0xffffbc26, 0xfffffb02, 0xffff8bee, 0xffffe6c2, 0x72f3,
+    0xffffc2c9, 0xffff74ff, 0x2434, 0x1eb4, 0x11c9, 0x61c1, 0xffffa964, 0x89a3,
+    0x6a43, 0x3d7f, 0xffffd09f, 0x14d8, 0x37bc, 0xfffffc31, 0xffffdb03, 0xfffff4e1,
+    0x5547, 0xffffdc87, 0xffff929a, 0x73cc, 0x246f, 0x194e, 0xffffb4ce, 0x86b5,
+    0x2f57, 0x7f05, 0x252b, 0xffff9b05, 0x5b7a, 0x164, 0x57cf, 0x7f86,
+    0x5421, 0xffffa478, 0xffffbbda, 0x1b3c, 0xfffff4cb, 0xffffda7e, 0x5d8e, 0x1957,
+    0xffffb3a7, 0x1979, 0xffff8ddd, 0xffffd7b9, 0xfffff028, 0xffff8c90, 0x476a, 0x6be6,
+    0x419e, 0xfffffd2d, 0x8294, 0xffffc931, 0xffffe1ab, 0xffffdd4f, 0x46f0, 0x1930,
+    0x4e5e, 0x8429, 0xffffde0a, 0xffff8e69, 0x2972, 0x387f, 0x3dd8, 0xffffbcc6,
+    0x121b, 0x6d3d, 0x1fa4, 0xffffa3ea, 0xffffbbef, 0xffffcbd2, 0xffffbe04, 0xffffb424,
+    0xffff7533, 0x70cd, 0x2370, 0x4822, 0xffff756e, 0xffffbe8c, 0x4131, 0x1ead,
+    0x47de, 0xffffed53, 0xffff917e, 0x5f93, 0xffffe264, 0xffffde05, 0xffff9dc3, 0xffffc1d9,
+    0xffff9b25, 0x3ade, 0xfffff9b7, 0xffffac80, 0x239e, 0xffffb980, 0xffffc9a4, 0x788c,
+    0xffffbb6d, 0x3bb7, 0x6483, 0xffffeac0, 0x25ea, 0xffffbdfc, 0x333d, 0x8c0d,
+    0x6d9a, 0xffffafe8, 0xffff8a74, 0x6067, 0xffff8642, 0x1a64, 0xfffff921, 0x3f3b,
+    0xae4, 0x5112, 0x43a4, 0x1573, 0xffffc977, 0xffffa3b4, 0x21be, 0xffff96df,
+    0xfffff035, 0x473b, 0xffff8d26, 0xb75, 0xffffecdc, 0x4455, 0x47d5, 0xffff7581,
+    0xeca, 0xffffb3fe, 0xffff9f6a, 0xffffea15, 0xffffb9c3, 0x5516, 0xffffb654, 0x7f91,
+    0x80b, 0xffff96b7, 0x2b60, 0x36b7, 0xffffc581, 0x285b, 0xffffa002, 0xffffc7e5,
+    0x4965, 0xffff94d4, 0xffff764b, 0x1cd2, 0x5599, 0xffffd272, 0xffffcbfb, 0xffffae6d,
+    0xffffd496, 0x3183, 0xffffe4f5, 0xffffa59f, 0x43df, 0x4569, 0xffffb185, 0x1d56,
+    0xffff933a, 0xffff7a2c, 0x38d0, 0xffffb815, 0x5203, 0xfffffd89, 0xffff93ea, 0xffffa4dd,
+    0x1f13, 0xffffad7d, 0xffffff4f, 0xffffe13c, 0xffffd60a, 0x8c88, 0x8276, 0xffffeaaf,
+    0xffff8a66, 0xffff7888, 0xffff91e9, 0x8bdf, 0xdcf, 0xfffff282, 0xffffe91b, 0x1eb1,
+    0x6fc, 0xffff81f6, 0x1617, 0xffffad02, 0xffffafaf, 0x60d5, 0x6f2b, 0x4e8b,
+    0x2347, 0x3257, 0x29cf, 0x86c4, 0x75b3, 0x7745, 0xfffffcc7, 0x49cd,
+    0x558f, 0xffff7c7a, 0x52e1, 0xffff7626, 0x7690, 0xffffb357, 0xffff7dbf, 0xffffa1ee,
+    0xffffa874, 0xffff846f, 0xffffab72, 0x5cef, 0xffffb0cf, 0xffff8c24, 0xffff8e10, 0xffffe200,
+    0x2a45, 0xfffff883, 0x5155, 0x37c9, 0xad6, 0x1ed9, 0x79e2, 0x1f4c,
+    0x45f8, 0x48ec, 0xffffa331, 0x34a1, 0xffffc7b0, 0x2eb5, 0x5dc, 0x4cdd,
+    0x4e5c, 0xffffa7c7, 0x3b08, 0x2776, 0x2e1a, 0x788d, 0x162b, 0x1fa7,
+    0x466c, 0x5ca2, 0xfffff3ac, 0xffffa62f, 0xfffffd4c, 0x5f48, 0x779, 0x2a5e,
+    0xffffe14e, 0x196, 0xffffaba1, 0x404c, 0xffffdc5b, 0x238f, 0x274, 0xffffa5c6,
+    0xffff9e2b, 0x6201, 0xfffff195, 0xfffff3b0, 0x2285, 0xffffc7f0, 0xffffdff4, 0xffffc43d,
+    0xffffac57, 0xffffb7a6, 0xffffe88c, 0xffffd3ac, 0xffffbb5c, 0x2cbd, 0x44d6, 0x5e30,
+    0xffffeb53, 0x6d8b, 0xffff7f8b, 0xffff99a3, 0xffff7a4e, 0xffffbc82, 0x6a49, 0xfffff220,
+    0xffffeaca, 0x4146, 0x8d72, 0xffffdcb7, 0xffffe2f3, 0xfffff736, 0x557f, 0x13fd,
+    0x66a, 0x5d9, 0x29ee, 0xffffda1e, 0xd38, 0xffffe70f, 0xffffbbd7, 0xffffe1ee,
+    0x4a0d, 0x502e, 0xffff8c37, 0xffffaccc, 0xffffdd0b, 0xffff7401, 0x3a89, 0x73b4,
+    0x71b7, 0x5b43, 0xffff9baf, 0x4d76, 0x25f, 0x7f97, 0xffffcb71, 0x6b4c,
+    0xffffe999, 0x3fd5, 0xffffd40b, 0x3f0d, 0xffffc17b, 0x3de9, 0x87f7, 0x6446,
+    0x5be, 0xffffd88a, 0x7d05, 0xfffffe16, 0x467e, 0x1454, 0xffffca4e, 0xffffa047,
+    0xffff92ac, 0xffffddc9, 0x72a9, 0xffffc902, 0x3605, 0xe47, 0x280c, 0x7662,
+    0x609d, 0xffffae0a, 0x78e0, 0xffffa02a, 0x1c87, 0xfffff91b, 0xffff7792, 0xffff745e,
+    0xffff8097, 0xffff8583, 0xffffe7e4, 0x61a5, 0x36a8, 0x7fe7, 0xffffaecc, 0xffff90f7,
+    0x5ad9, 0x7e2f, 0xffffffca, 0x75c7, 0x7134, 0xffffd7fe, 0x3c22, 0x314c,
+    0x7c97, 0x2068, 0xffff7926, 0x3e7c, 0x6926, 0x67f9, 0x3e28, 0x7c65,
+    0x76b9, 0x25cf, 0x1039, 0xffffdf97, 0x8779, 0xffffe8fd, 0xffff9f74, 0x770a,
+    0x8a50, 0xffffd241, 0xffffddee, 0x5aab, 0xffffc97f, 0x4572, 0x3276, 0xffffe7ec,
+    0xffff8cc2, 0x6331, 0xfffffedf, 0x3b86, 0x3038, 0xffffd628, 0x2645, 0xffff737c,
+    0x72fe, 0xffff8474, 0x23fb, 0x78f, 0x194c, 0x95a, 0xffff91d0, 0xffff8014,
+    0x56e9, 0x2efe, 0xffffae5b, 0x614, 0xffffca3d, 0xffffd77e, 0x73e1, 0x35f7,
+    0x71f3, 0xffff9279, 0xffffe6f3, 0x404b, 0x548d, 0x32a3, 0xc11, 0x637a,
+    0xffff7605, 0x2ba8, 0xffff8f35, 0x8157, 0x423f, 0xffff9711, 0xffffb980, 0xffffb4b1,
+    0x3494, 0xffffc9dd, 0x6c43, 0x563f, 0x52c, 0xffff9680, 0x8b7a, 0xffffcf49,
+    0xffffa40b, 0x6daf, 0xffff840e, 0x29cd, 0xffffbf5c, 0x68b7, 0xffffedf3, 0xffffe329,
+    0xfffff634, 0x8619, 0x33bc, 0x28b4, 0x5ed8, 0xffffcfbb, 0x883a, 0xfffffdf6,
+    0xffffb980, 0x7bac, 0xfffffd6d, 0x418f, 0x4a25, 0xffffbed3, 0x4272, 0xffffef42,
+    0x800f, 0x78e3, 0x82c8, 0x24e1, 0xffffcfa3, 0xffffb385, 0x86b, 0x645b,
+    0x38aa, 0x6a22, 0xffffc21b, 0x60f0, 0x9b6, 0x912, 0x7621, 0xffff94cc,
+    0xffffd5c9, 0xfffffdb5, 0xffffd93a, 0x2a11, 0xffff8b3d, 0xffffc0d2, 0xffffa00f, 0xffffe965,
+    0xfffffa0f, 0xffffbfa9, 0x5e78, 0xffff925b, 0xffffeac8, 0xffffd5af, 0xffffba37, 0x395a,
+    0xffffdc75, 0xfffffdf2, 0xffff7c7b, 0xffff89a3, 0x3766, 0xffffe8a9, 0x7118, 0x399e,
+    0xffff7ff5, 0xffffac9a, 0xffff7d74, 0xffffa5d2, 0x4c27, 0x787f, 0x586, 0x7ce4,
+    0xffffb38e, 0xffffb93d, 0x240d, 0x5a90, 0xffffb448, 0xffff8e29, 0xffffbc06, 0x3bf3,
+    0xffffda90, 0xffffb78d, 0xffffc747, 0xffffa5c0, 0xffffe2dd, 0x7fbd, 0x8946, 0xffff8d50,
+    0x2451, 0x18f9, 0xffffc1d4, 0xffffb689, 0xffffc37b, 0xffffbe2f, 0xffffbe9e, 0x8117,
+    0x7050, 0xfffff504, 0x2b9, 0x464f, 0x298d, 0x2367, 0xffffe8c3, 0x79f1,
+    0x4e38, 0x5cc8, 0x2928, 0xffffb486, 0x7cd6, 0xffffdbd9, 0xfffff110, 0xffffeff7,
+    0x19b8, 0xffffeb99, 0xffff847c, 0xffff7612, 0xffffd542, 0x2966, 0xffff8ce2, 0x38fe,
+    0xffffdeaa, 0x5238, 0x67c4, 0xffffa5e7, 0x4e6d, 0xffffd82e, 0x5973, 0x351b,
+    0x74e8, 0xffffafcd, 0x66dd, 0x20e4, 0x609d, 0xffffade3, 0x509f, 0xffffa21f,
+    0x2cce, 0x54c2, 0x1953, 0x85ce, 0x6bee, 0x3222, 0x6ff6, 0x3773,
+    0x5a64, 0xffffe40f, 0xffffc6df, 0x3556, 0x80a9, 0xffff76c5, 0x495b, 0x1ae4,
+    0xffffca33, 0x31f2, 0x833e, 0x89c3, 0x5f43, 0xffffbee7, 0x3ab2, 0x87af,
+    0x4c74, 0xffff810b, 0xffffbed0, 0x6795, 0xffff785c, 0xffffbc0b, 0x520e, 0x4348,
+    0xe03, 0x4541, 0x2557, 0xffff9110, 0x4044, 0x1947, 0x4dab, 0xcbe,
+    0x3f72, 0x4507, 0xffffa362, 0xffffc20b, 0x6c1b, 0x27c7, 0xffff9bf2, 0x6506,
+    0xffff89cc, 0x5c3e, 0x4509, 0x409a, 0xffff98db, 0x1674, 0xffff9324, 0x7328,
+    0xffff99cf, 0xcd8, 0x730a, 0x14b9, 0x672d, 0xffffd620, 0x1dd8, 0x3bec,
+    0xffff94b6, 0xffffb689, 0x7dfd, 0x3ffd, 0xffff9cb6, 0x3560, 0xffffbaf8, 0xffff8604,
+    0x8795, 0xffff7aec, 0x66a5, 0x6a0b, 0x564b, 0xffff8d00, 0xffffed20, 0x11b8,
+    0xffffdc27, 0x595d, 0xffffddf0, 0xfffffc70, 0xffffd5bf, 0x6714, 0xffffaf69, 0xdb2,
+    0x3786, 0xffffbf9d, 0x7ca7, 0x5a53, 0xffff7c6a, 0xffff8465, 0xffffe4c6, 0xffffa238,
+    0xffff7f9b, 0x6887, 0x3838, 0x7115, 0x5bce, 0xeae, 0x47c, 0xffffd54a,
+    0xffffb9d5, 0x6183, 0x9c3, 0xbd5, 0xffffe217, 0x8237, 0x51d7, 0x52fe,
+    0x6424, 0xffffb192, 0xffff7ebb, 0xffffd373, 0xffff9cf7, 0x390b, 0xffffa473, 0x8953,
+    0xffff90c9, 0x594a, 0xc6e, 0x32ba, 0xffffae73, 0x86c7, 0xffffd7a0, 0xffffa82e,
+    0x8d66, 0xffffabcf, 0xffff84d0, 0x3a84, 0xffffe8bd, 0x4948, 0x3f2a, 0xfffff4e5,
+    0xffffb0bd, 0x4961, 0xffffd95b, 0xffffd96c, 0xffffce34, 0x57ff, 0xffffdf08, 0x2330,
+    0xffffa8c7, 0x24cb, 0x740a, 0xffffdbcf, 0xffffad36, 0x306f, 0xffffa30b, 0xffffc488,
+    0xffff8022, 0x464a, 0x6f00, 0xffffb419, 0xffff8450, 0x2ddb, 0x2731, 0x63fd,
+    0x2946, 0x5c28, 0xffffb064, 0xffffb277, 0x1e0f, 0x6d71, 0xffff7ff3, 0xfffffb02,
+    0xf2a, 0xffffd69c, 0x638, 0xffffe8ff, 0xffffbd7e, 0xffffb26f, 0xffffe153, 0xffff9879,
+    0xffff849c, 0x1f73, 0xffff9b21, 0x2bb1, 0xffffa95b, 0xffffd582, 0xffffdbfa, 0xd2c,
+    0xffffa86f, 0x2ab3, 0xffff9d78, 0x1074, 0xffffbcb5, 0x3990, 0xffffe869, 0xffffb422,
+    0x2dc8, 0xffffca25, 0xffffcfe8, 0xaf1, 0xffff82c8, 0x36a, 0x2f4e, 0xfffffdcd,
+    0x77fa, 0xffffad4f, 0xffffa54a, 0x50b9, 0x6eab, 0x5178, 0x8982, 0xffffe4dd,
+    0xffff9a82, 0x45a2, 0x784e, 0xffffbd6e, 0x5019, 0xffffcc5c, 0x8009, 0x5d96,
+    0xffffac8d, 0xffff8ec9, 0x4c, 0x4222, 0xfffffa7f, 0x3227, 0x67ea, 0xffffe679,
+    0x3dc8, 0xffffb5b5, 0x1424, 0x3e4a, 0xfffff175, 0xffffaf4b, 0x4657, 0x1374,
+    0xffff7233, 0x7190, 0x332, 0xaf0, 0x68c0, 0xffff85ad, 0xffffd0af, 0x2b1,
+    0xffff8d54, 0x1f99, 0xffffe8d5, 0xffffc30b, 0x2877, 0xffff9d40, 0xffff8852, 0xffffb01a,
+    0x4b32, 0x3279, 0xffff9099, 0x5f4f, 0xffffe08c, 0xffff9fe0, 0xffff9ecc, 0xfffff557,
+    0xfffffc25, 0xffffa719, 0xffff920a, 0x62ac, 0xfffff11d, 0x152d, 0xfffff5d6, 0x5223,
+    0xfffff438, 0xffff73f3, 0x34e1, 0x49a9, 0x6a73, 0x2ad3, 0x1f51, 0x824,
+    0x1bc9, 0x5170, 0x552d, 0x52b5, 0xfffff12a, 0xffffec44, 0x7924, 0x5294,
+    0xb63, 0x822f, 0xffff9afd, 0x7e29, 0x2d91, 0x42ad, 0xfffff589, 0xfffff6e9,
+    0x2792, 0x4269, 0xffff9639, 0xffff726f, 0x4074, 0xffffa179, 0x8a6b, 0xffffb431,
+    0x850f, 0xffff903f, 0x6b22, 0x738, 0x16a0, 0xffff917f, 0x8a5a, 0xb61,
+    0xffffcce6, 0x6369, 0xffffb671, 0x66c0, 0x68e6, 0x41aa, 0x2fc3, 0x2382,
+    0xffffabd5, 0x62c, 0x5041, 0xffff9903, 0x846b, 0x86f6, 0x8111, 0x15c,
+    0x62ed, 0xfffff411, 0x517c, 0xffffbb6d, 0x8256, 0x141e, 0xfffffd31, 0x8777,
+    0xffffabbe, 0x4eb5, 0xffffbae4, 0x75a2, 0x2bfc, 0xffff799f, 0x26bd, 0x2296,
+    0x7b36, 0xffffddc6, 0x7517, 0x155a, 0x16b1, 0x25b4, 0xfffff8ce, 0x54e9,
+    0xffffeb3c, 0x7e5e, 0xffffa981, 0xfffffdbb, 0x87f7, 0xfffff4fe, 0x5657, 0x2add,
+    0x5113, 0x7bff, 0xffffbcec, 0x37fb, 0x59a3, 0xffffd989, 0xffff9ac8, 0xffff8e9e,
+    0x5ea9, 0x1bbf, 0x8ca1, 0xffff7365, 0x4d65, 0x874c, 0x4119, 0x63ee,
+    0xffff91ea, 0x8074, 0x8a3c, 0xffff74b0, 0xffffb940, 0x3c7a, 0x50f, 0xffffe11e,
+    0x6c76, 0x5731, 0xf34, 0xffff8ace, 0xffffdb12, 0x4cb2, 0xffffa624, 0x8999,
+    0xffff94e3, 0x469e, 0x4101, 0xffffe271, 0x850d, 0xffff95cf, 0xffff93fa, 0x3357,
+    0x8fe, 0xffff9b75, 0xffffbd9b, 0x6a34, 0x1db7, 0xb19, 0xffffee5f, 0xffffc9c1,
+    0x763, 0xffff9c09, 0x26a7, 0xffffb6c5, 0xf48, 0xe3e, 0x854f, 0xfffffa24,
+    0xffffb689, 0x34bc, 0xffff7a74, 0xffff7240, 0x5849, 0xfffffa7f, 0xffffbd17, 0x17e4,
+    0x8e6, 0xfffff805, 0xffffd6d6, 0xffffecd0, 0xffff8b9c, 0xffffed0b, 0x198e, 0x5422,
+    0x8549, 0x8dc7, 0xffffb649, 0x1cb6, 0x5ba9, 0xffffc4f6, 0x7b31, 0xffff8611,
+    0x62a9, 0xc49, 0xffff7b22, 0xffffd5f0, 0xffff9fce, 0x3f16, 0xffff72a8, 0xffff9a53,
+    0xffffa401, 0xffff9f41, 0x53b8, 0xffffca3e, 0x86a2, 0xffffa27c, 0xffffb022, 0x7c4,
+    0x3425, 0x344e, 0xffffcb0a, 0x6d47, 0x63b3, 0x677c, 0x4077, 0x72b,
+    0x5a90, 0x4348, 0xffff8b9d, 0xffffbcef, 0xffff8e3f, 0x58fa, 0xffffe0a8, 0xffffaf0c,
+    0x4698, 0x3da0, 0xffffd44c, 0xffffe85d, 0x455f, 0x5746, 0x5168, 0xfffff3ad,
+    0xffffd7bb, 0x56b0, 0xffff7845, 0xffff8d1d, 0x8fa, 0xffffe8c1, 0xffffb00f, 0x6f65,
+    0xffffb97c, 0x83b9, 0x4e67, 0x5e2a, 0x787f, 0x8d66, 0x397e, 0x7e75,
+    0x4789, 0x7be7, 0x8a38, 0x7ce2, 0xffff9005, 0x3391, 0x873d, 0x5ade,
+    0x71e5, 0xffffb84e, 0x4718, 0x438, 0x8700, 0xffffdf0d, 0xfffffed4, 0x88,
+    0xfffff494, 0xffffab9a, 0x6c68, 0xffffece3, 0xffff9e05, 0x5590, 0xffffeda6, 0x491d,
+    0x7376, 0x6e88, 0x75df, 0xffffd5a8, 0x88b7, 0xffffe707, 0x356d, 0xffff9881,
+    0xffffef0f, 0xffffa40f, 0xffff8f5e, 0x3b0f, 0x3da, 0xfffff8d1, 0x6809, 0x83dd,
+    0x876d, 0x3c44, 0xffffe878, 0x3faf, 0x78f, 0xffff7a85, 0xffffc78b, 0xffffd711,
+    0xffff9d6b, 0x79c8, 0xd65, 0xffffe3e3, 0x478, 0x7129, 0xffff7dda, 0xffffab18,
+    0xffffcd44, 0xffff7cfc, 0x723a, 0x5c3, 0x3737, 0x3451, 0x650a, 0xffffa327,
+    0xfd9, 0xffff7bae, 0x1f5b, 0x2978, 0x8c99, 0x4cd4, 0xffffb3d6, 0x4036,
+    0x2a0e, 0x35ea, 0x50b, 0xffff9518, 0xffff85c1, 0xffffcdc6, 0xffffdc56, 0xffff8d75,
+    0xffff90f3, 0x11cb, 0xffffa7dd, 0xffff884c, 0xffffc35a, 0xffffc3cf, 0xffffad4a, 0xffffc75a,
+    0xffffa170, 0x8adb, 0x7441, 0xffffe8d1, 0x42b4, 0xffffe1ad, 0xffffdd4a, 0xffff98bf,
+    0x4cc2, 0xffff8b07, 0x334c, 0x5e4d, 0xffffb14a, 0xffff9c04, 0xffffb744, 0xffffa616,
+    0x187d, 0x495a, 0xffffb1c3, 0x524d, 0xffffc04b, 0x6110, 0x6dff, 0x55b8,
+    0x8de1, 0x3394, 0x886f, 0xc21, 0xffff995f, 0xd71, 0xffff90e8, 0xffff983a,
+    0xffff92d8, 0xffffcce2, 0xffff90e7, 0xffff94ff, 0x4e0b, 0xffff9334, 0xffffeacb, 0xffff8f75,
+    0x48aa, 0x7631, 0xfffffbf9, 0xffffd3e0, 0x6850, 0xffffa651, 0xffff8745, 0xffffe780,
+    0xfffff596, 0xfffffed5, 0x3b41, 0x55cd, 0x5a08, 0xffffa0cf, 0xffff75a0, 0xe58,
+    0xffffff64, 0x6763, 0xffff8c5f, 0x69b7, 0x453b, 0xffffba78, 0x7554, 0x4fba,
+    0x6031, 0x1ed6, 0x30a2, 0x3c52, 0xfffffc1a, 0xffffecfe, 0xffffa280, 0xffff9d76,
+    0xffffa66c, 0xffff8dc0, 0xffffaa2b, 0xffffbc38, 0x1cd9, 0xfffff3fa, 0x7078, 0xfffffecb,
+    0x800e, 0xfffffa73, 0xffff9a9f, 0xffffb5c5, 0xffffda01, 0x68c8, 0x7787, 0xffffe959,
+    0xffffc008, 0x357a, 0x37fb, 0xffff9b65, 0x4df5, 0x8ad5, 0x53aa, 0xffffcc5a,
+    0xffff74a9, 0xffffed23, 0x4c8e, 0xffffbd47, 0xb95, 0x774c, 0x5109, 0xffffd8ef,
+    0x4095, 0xffffad7a, 0x8a82, 0x2d80, 0xffff8d9a, 0xd43, 0x6bf9, 0x223,
+    0x3eed, 0xffffc475, 0x3854, 0xffffa438, 0x1ac0, 0x990, 0x50f8, 0xfffffce9,
+    0xffff72ab, 0x41f2, 0x845e, 0xffffef06, 0x7241, 0xffffcf1a, 0x7888, 0x5bf5,
+    0xffffc6a5, 0xffffdbe1, 0x1573, 0x65ba, 0x1f5a, 0xffff9e88, 0xffffef80, 0x580c,
+    0xffff8254, 0x5da1, 0xffff7a42, 0x220e, 0xffff7947, 0xffff7a6b, 0xffffaa90, 0x7b4,
+    0xfffff0e5, 0xf4, 0xd7c, 0x3754, 0xffffa34c, 0x4314, 0x4e93, 0x5f33,
+    0xffffd600, 0x150b, 0xffff867a, 0x5eee, 0x54fd, 0x630d, 0xfffff8e2, 0xffffdd08,
+    0xffffdd29, 0xffff7350, 0xffffbc1a, 0x1429, 0xffffda45, 0x3e79, 0xffffca86, 0x1523,
+    0x620c, 0xa9e, 0xfffffdb9, 0xffffb00f, 0xffff82bf, 0xfffffb63, 0xffff78de, 0x25ad,
+    0x54ac, 0x3831, 0x66b6, 0x696e, 0x4e31, 0xffff81c0, 0xffff854a, 0xa8e,
+    0x8ce6, 0x52dd, 0xffffa6c6, 0xffffe575, 0xffff9907, 0xffff9743, 0x2156, 0xffff8199,
+    0x76ea, 0x7361, 0x8d23, 0xfffffa98, 0xfffffb0d, 0xffffa7b3, 0x12e3, 0x4239,
+    0x4aeb, 0x7461, 0xe02, 0x987, 0x68b5, 0xfffffc95, 0x7ac, 0x7238,
+    0xfffff148, 0xfffff26d, 0x58f4, 0x50b3, 0xffff869d, 0xffff8582, 0x5d94, 0x30fd,
+    0x1e62, 0x83ab, 0xfffffa33, 0xffffb49d, 0x18e9, 0x4781, 0x6d8, 0x7bab,
+    0x1aef, 0x2ca6, 0x81a9, 0x2f34, 0x248d, 0xffff9a23, 0xffffdd8a, 0xffffd9a2,
+    0xfffffba7, 0x754, 0xffffdbe5, 0x28cc, 0xffff9659, 0x2219, 0x6bea, 0xffffe7ad,
+    0xffff856e, 0xffffd3c1, 0x14ff, 0x350, 0x42f3, 0xffffd69d, 0xffffb4b5, 0xffffccd7,
+    0x6500, 0x2fb6, 0xffff95b5, 0xffffe293, 0x5baa, 0xffffc45a, 0xffffda2f, 0xffff8de6,
+    0xffff87ec, 0x5f0e, 0xffffca76, 0xffffac52, 0xfffff9a4, 0xffff9e0d, 0x771a, 0xd62,
+    0x32f3, 0x8367, 0xffff982d, 0x240a, 0x20d, 0xfffff430, 0xffffba8d, 0xffffb810,
+    0xffffcfd1, 0x8044, 0xffffcba1, 0xffff9772, 0xffffee63, 0xfffffd51, 0xfffff324, 0x101e,
+    0xffffe7c7, 0xfffffb15, 0xffffc5eb, 0x8585, 0x427, 0xffffcdbf, 0xffffcc26, 0x21fb,
+    0xffff7c96, 0xffff7705, 0xffffb428, 0xffffa3f8, 0x3906, 0x5787, 0xffffd8af, 0xffffd7d1,
+    0xffff77d7, 0x5504, 0xffff73a1, 0x116e, 0x32d8, 0x16f2, 0x5c09, 0xfffff98c,
+    0x7350, 0x6462, 0xffffada1, 0x3f1b, 0x6378, 0xffff81e0, 0x2dd3, 0xfffff52a,
+    0x8142, 0x89e0, 0xffff9fc6, 0xffff7bf1, 0xffffd116, 0xffffebf0, 0xd84, 0x1669,
+    0xffff9bca, 0x5050, 0x6f8a, 0x2c50, 0x8590, 0x32fd, 0x6abf, 0x6af0,
+    0xffffa4de, 0x2042, 0xffff9f0b, 0x726, 0xffffcb98, 0x12a1, 0x497b, 0xffffa677,
+    0xfffff6f1, 0x2433, 0xffffebc9, 0xffffd8cd, 0x2939, 0x2438, 0xffff79b3, 0xffff9226,
+    0xffff9ca1, 0x4884, 0x6fe7, 0x2f89, 0x812a, 0xffffa72e, 0xffffb33c, 0xffff815e,
+    0xffff8866, 0x3b83, 0xfffff5b5, 0x3fb2, 0x8221, 0xffffd486, 0x2665, 0xffffa540,
+    0x5ce5, 0x893c, 0x4b34, 0x1b5d, 0xffff8b00, 0x8b56, 0xffffb3ab, 0xfffff0d7,
+    0x353f, 0x63ce, 0xffff9b0b, 0xffff9689, 0xfffffe5a, 0x50c5, 0x3f3d, 0x1917,
+    0x3045, 0xffffdb17, 0x2f69, 0x7ecc, 0xffff7f93, 0xffffa392, 0x9ed, 0xffff94dc,
+    0x11e, 0xffffdcb5, 0xffff934b, 0xfffff44a, 0xffffd194, 0xffffe03b, 0x5841, 0xffffd49a,
+    0x26f3, 0xfffffc5a, 0x8d0e, 0x6441, 0x2fc5, 0xffffed7a, 0xffffe739, 0xffffd2ff,
+    0xffffb541, 0xffff8f9e, 0x807, 0xffff8e7d, 0xffff85b9, 0xffff8fc7, 0x778a, 0x8451,
+    0xffffa75f, 0xffffe5b1, 0x2aeb, 0x7fe6, 0xffffc2b3, 0x8534, 0x268a, 0x6711,
+    0xffff8cf8, 0xffffd800, 0xffff7913, 0x7c1b, 0x4e76, 0xffffde5d, 0x1545, 0xfffff355,
+    0xffffc1bb, 0x398c, 0xffff798a, 0xffffdc27, 0x40ed, 0xfffff8fc, 0xfffff918, 0x7ef5,
+    0x5182, 0x8369, 0x47af, 0xffffd6d5, 0xffff7e09, 0xffffa12e, 0x5363, 0xffffce2c,
+    0xffffdc79, 0xfffff095, 0xffff7760, 0x4905, 0xffffd192, 0xffff9ca8, 0x39dc, 0xffffd67b,
+    0x680, 0xffffb5a4, 0xffffd7d7, 0xffffb5a5, 0x7fcd, 0x7305, 0xffff8e3b, 0x179d,
+    0xffffebf4, 0xffffad3c, 0xffff791f, 0xffffb513, 0x7d2e, 0x361f, 0x1a0f, 0xffffd336,
+    0xffff7531, 0xffff73ec, 0x8acc, 0x85bf, 0xffff8a29, 0xd3c, 0x392, 0x4482,
+    0x7272, 0xffff8403, 0x7d3e, 0xfffff055, 0x6ae2, 0xffffc5b3, 0x74ac, 0x30f6,
+    0xfffff4bd, 0x19ba, 0xffffc488, 0xffffeec2, 0x877, 0xa9d, 0xfc1, 0x57a0,
+    0x4879, 0x175a, 0xffffa0c0, 0x533, 0x8765, 0x2d23, 0x7ae9, 0x1d9e,
+    0x16b2, 0x58c4, 0xffffe64f, 0xffff79ba, 0x68cd, 0x5c30, 0xffffb8e0, 0xffffc5d1,
+    0xfffff04f, 0x5fec, 0x19ca, 0xffff8c02, 0x15ab, 0x8897, 0xffffebeb, 0x70d7,
+    0x1662, 0x8c83, 0x8bc8, 0x21c8, 0xffffa728, 0x6513, 0xffff92f4, 0xffffadb2,
+    0x7a29, 0xffffe450, 0x2136, 0xffffc6db, 0x26e, 0x8221, 0x3097, 0x5883,
+    0xffffa134, 0x8284, 0xffffa6d9, 0x1c76, 0xffff8524, 0x164e, 0xffffa415, 0xffff841e,
+    0x309d, 0xffffd4e1, 0xffff99a3, 0x4e11, 0xffff90a2, 0x51bf, 0xffffec39, 0xffff9073,
+    0xe4e, 0xffff7a6a, 0x26b0, 0x64e4, 0x1a95, 0xffffeed3, 0x8049, 0x67b0,
+    0x23e0, 0xffffb836, 0xf72, 0x2c0f, 0xffffacff, 0xffffa183, 0x87b8, 0xffff7e3a,
+    0xffffef41, 0xffff796e, 0xfffffd33, 0x4c73, 0xffffd590, 0xffffdfac, 0xfffff5fb, 0xffff9594,
+    0xffffba62, 0xffffa2d2, 0x496a, 0x1501, 0xffff9a7a, 0xffffc542, 0xffff8a89, 0xffffdda6,
+    0xffff7f5e, 0xffffbf34, 0xffffe1e1, 0xffffb26c, 0xffffe9c3, 0x67cc, 0xffffb506, 0x6416,
+    0x454, 0x3724, 0xffff9c3d, 0x2f27, 0x45cb, 0x670f, 0xffff7969, 0xffffdc9e,
+    0xffff87e1, 0x1948, 0xfffffe4e, 0x1fdd, 0xffffe119, 0x5c64, 0xffffc383, 0x1062,
+    0x6828, 0x6dd8, 0x2238, 0x12d5, 0xffffd611, 0xffff8739, 0x137a, 0x52c6,
+    0x441c, 0xffffc74c, 0xffffee23, 0x583a, 0xffffd369, 0x3c68, 0xffff99a0, 0xffffb914,
+    0xffffbe62, 0xffffcd86, 0x1438, 0xffffe64d, 0x53da, 0x2358, 0x89f6, 0x6e04,
+    0x459f, 0xffffb2a5, 0xffffdaf4, 0xfffface2, 0x6673, 0xfffff8df, 0x594d, 0xffffeedd,
+    0xffffa520, 0xffff8687, 0x70b0, 0x5dba, 0xffffe645, 0x3bbc, 0xffff8028, 0xffffea28,
+    0xffffc7ba, 0x36ca, 0x7c40, 0x34ce, 0xffff7a62, 0x10bf, 0x5ee1, 0xffff98ab,
+    0x10be, 0x3b49, 0x8c53, 0x8386, 0xffff7a09, 0xffff7a77, 0xffff7acd, 0x2cc4,
+    0xffff93aa, 0x574, 0xffffc3ed, 0x2586, 0xffffeca4, 0x750e, 0xffffb075, 0x6308,
+    0x67ac, 0xffffc8a3, 0x49c1, 0xfffff006, 0x89c9, 0x4f36, 0x3909, 0xffffd5d0,
+    0xffffe4c1, 0xffff7a19, 0xffff8552, 0x7a2b, 0xffff9d63, 0x88e9, 0xfffffde4, 0x190a,
+    0xffff826f, 0xffffecd9, 0x1983, 0xffffe551, 0xffff92e2, 0x2c5c, 0xffffd03c, 0x4adf,
+    0x6865, 0xffff7e20, 0xffffea03, 0x841d, 0x4e37, 0x3d59, 0x3171, 0x673a,
+    0x1afc, 0xffffa098, 0xffffde36, 0xfffffbbd, 0x47a5, 0x65be, 0x3738, 0x2beb,
+    0x3e11, 0x6cff, 0x8da8, 0x22a6, 0xffffdf4a, 0x1151, 0xffffc349, 0x3485,
+    0xffffee00, 0xffff864e, 0x865, 0x5989, 0x4145, 0xffff8999, 0xffff835e, 0xffffc2ad,
+    0x2f00, 0xffffdc98, 0x7dfe, 0xffffc2fe, 0x1234, 0xfffff5da, 0xffffd55c, 0x119e,
+    0xffff7dc3, 0xffffb27e, 0x7aae, 0xffff7b34, 0xffffde8e, 0x797, 0xffffab7e, 0xffffe6ce,
+    0x7685, 0x600f, 0x7285, 0x6045, 0xffffe2f4, 0x69e7, 0xffffdfd8, 0x14a,
+    0xffffda78, 0xffffabc0, 0x89c3, 0xffffbeac, 0xc37, 0x6df4, 0xffffe0d2, 0xffffc632,
+    0xffffa62e, 0xffff8d46, 0xffff78fa, 0x3003, 0xfffff74e, 0x42a9, 0xffffe8d6, 0xffff7863,
+    0x6a8e, 0xffff8696, 0x1844, 0xffffa06f, 0xd36, 0xffffd8d8, 0xffffe27c, 0x387e,
+    0x30fb, 0xfffff762, 0x808a, 0x2d5b, 0x6717, 0xffffff14, 0x845b, 0xffff9586,
+    0x68b, 0xffffe56f, 0xffff96b9, 0x6295, 0xffffb26c, 0x2a02, 0xfffffd8b, 0x6b98,
+    0xffff8ca4, 0x501a, 0x5f44, 0xffffa9ac, 0xffffa063, 0xffff9030, 0xffff80d2, 0xffffcd8c,
+    0x4c8c, 0xffffc0f8, 0x397, 0x819c, 0x767c, 0x7d99, 0xfffff123, 0x1b50,
+    0x2c29, 0xffffd70f, 0xffffcca8, 0xffffa017, 0xfffff2b7, 0xffff74f0, 0xffffa9ed, 0x233b,
+    0x1516, 0xffffbb9f, 0xffff97bc, 0x23c4, 0xfffff299, 0x7db1, 0xa52, 0xffff9161,
+    0xffff8541, 0xffff75a7, 0xe20, 0x7dd3, 0xffffcc27, 0xffff9e5e, 0xffffe9ee, 0xb6e,
+    0xffffe271, 0xffffe9e6, 0x6d72, 0xfffffd38, 0xffffa167, 0x6246, 0x83b, 0xffffa571,
+    0xaeb, 0xffff8759, 0xffffa37f, 0xffffea7c, 0x6061, 0x8b6c, 0xffffb904, 0xffff88ea,
+    0xffffa8f7, 0xffffd266, 0xffffa1bf, 0x343a, 0x6f9c, 0xffffd56b, 0x37ef, 0xffff8566,
+    0x4eb7, 0xffffd9b3, 0xffffd22e, 0x8af7, 0x1d78, 0xfffff575, 0x391e, 0x4836,
+    0xffffeaf1, 0xffff89a2, 0x6ac6, 0x611f, 0x8458, 0x2af6, 0x588f, 0x8e5,
+    0x8bf6, 0xffffac56, 0x35d8, 0x6e0, 0x371b, 0xffff7743, 0xffffc693, 0x146c,
+    0xffff80e3, 0xffffb207, 0xffffe58c, 0xffff8e50, 0xffffb07b, 0xfffff121, 0xffff9b54, 0x5dd4,
+    0x700d, 0xffffe8a8, 0xffffdc38, 0xffffe745, 0x3734, 0x1db6, 0xffff8353, 0xffff7e3b,
+    0x8eb, 0x6019, 0x2c5c, 0xffff8bd0, 0x8a7f, 0x7bc1, 0xfffff710, 0x4002,
+    0x3650, 0xffffce4a, 0xffff7cce, 0xb70, 0x359a, 0x3013, 0x362, 0xffffa441,
+    0x5b8e, 0xfffffe99, 0xffff7813, 0x7fdf, 0xffff8fc1, 0x5912, 0xffff8122, 0xfffff92a,
+    0xffff8c22, 0x46a0, 0x5d05, 0xffffc4c0, 0xffffbc37, 0xffff9f62, 0x3103, 0xfffffb57,
+    0xffffdf3b, 0xffffbde0, 0xffffe2fd, 0xffffcb24, 0x7291, 0xffffc112, 0x305d, 0x60f4,
+    0xffffc8ae, 0xffff7574, 0xffffe0d9, 0xe58, 0xfffffeba, 0x66e, 0xffff8463, 0x8643,
+    0xffffa427, 0x405e, 0xffffa5f5, 0xffffcb8f, 0xffffb04c, 0xffff79aa, 0x1a22, 0xffff896c,
+    0xffff7d81, 0x7bda, 0x6989, 0x3996, 0x870e, 0x3a69, 0x3b4a, 0xffff9e08,
+    0x2c97, 0x7ebd, 0xffffbf71, 0x1973, 0xffffdf6b, 0xffffbad9, 0x196a, 0x81e8,
+    0x1c4, 0x61c5, 0x76e9, 0x25c5, 0x5131, 0xffff9e6e, 0xffff9637, 0xffff7d1a,
+    0x5111, 0xffffff97, 0xffff8424, 0xffffbf3b, 0xffffb4f9, 0x2eaf, 0x7b44, 0x409e,
+    0xffffe706, 0x1099, 0x328c, 0x401c, 0x2e7, 0x5b34, 0xffffd2f2, 0xffff9853,
+    0xffff7804, 0xfffff344, 0xfffff283, 0x8ce9, 0xffff8fc2, 0xfffff155, 0xffffe2fe, 0xffff9d35,
+    0x846f, 0xffffe3cf, 0x53f2, 0x67e4, 0xffffb405, 0xffff9c2a, 0x69a7, 0xfffff279,
+    0xffffcd7b, 0xffffe05c, 0x5f40, 0x7110, 0x5c7d, 0xffffc8b4, 0xffffb97c, 0xfffffd3e,
+    0x6b8f, 0xffffa8f4, 0xffffe8d7, 0xffffee7e, 0xa4e, 0xffff8a06, 0x4499, 0x65,
+    0xffff9c0e, 0xffffdb63, 0xffff9123, 0x1fdb, 0x424a, 0xffffecca, 0xffffbde3, 0xb4,
+    0xffffd7b7, 0xffffbb82, 0xffffa8bb, 0xffffcf0c, 0x1c1, 0xffff87e5, 0xfffff7cc, 0xffffc4dd,
+    0xfffff3f1, 0x86c6, 0x3063, 0xffffbf8c, 0x2ddf, 0x7a9, 0x3d41, 0xfffff150,
+    0xffff9224, 0xffffe905, 0xffffbd32, 0x76c2, 0x4021, 0xffff86cd, 0xffff895a, 0xffffd092,
+    0x3b93, 0xffffbf5b, 0xffffe7f1, 0x44e, 0x7e09, 0x514f, 0xffffdae2, 0xffff8ae4,
+    0xffffd626, 0x8cf6, 0xffffc1e5, 0xffff8d3e, 0xffffc16c, 0x5b5, 0xffff8d48, 0x264a,
+    0x6750, 0x5f3f, 0x442e, 0xfffff88b, 0xffffe7d2, 0x73ce, 0xffffffac, 0x3302,
+    0x5125, 0x590c, 0xffffe068, 0xffffb765, 0x473d, 0xffffd9cc, 0x9ae, 0x3ae0,
+    0xffffdd98, 0x4346, 0xbe1, 0x506e, 0xffffe5dd, 0xffff8b4d, 0x6ac3, 0x89a1,
+    0x229b, 0xffffa8bf, 0xffffb463, 0xffffb8aa, 0xffffb1bb, 0xffff8205, 0x76ba, 0x1117,
+    0xffffae9e, 0xddf, 0xffffaf93, 0x1661, 0x490b, 0xffff798e, 0x4d5f, 0xffffbca8,
+    0x13c4, 0x814a, 0x8340, 0xfffffe42, 0xffffc27f, 0xb42, 0xffffbeae, 0x39a3,
+    0x5caa, 0xffffd38d, 0x2dba, 0xfffffe91, 0x5451, 0x768d, 0x827a, 0xffffbf93,
+    0x5ff2, 0xffffeaa2, 0xffffb0fc, 0x677a, 0xffff758a, 0xffffbcc6, 0xffff9166, 0xffff9b70,
+    0xffffa468, 0x36bf, 0xffffbf31, 0x2f3d, 0xffffd890, 0xfffff4af, 0x3b4b, 0xffffc047,
+    0xffff98b3, 0xffffea02, 0xffff9ed7, 0x45b0, 0x8c73, 0xffffa371, 0xfffff4fa, 0xffffe309,
+    0x3fce, 0x3020, 0x7e45, 0x40bb, 0x506c, 0x63a1, 0x52cd, 0xffff7a93,
+    0x3108, 0xffffbf0a, 0xffffe87a, 0xffff782f, 0xffffcb8e, 0x3e37, 0x619a, 0xfffff75a,
+    0xffffeb8a, 0x621f, 0xffff87fb, 0x594b, 0x70ee, 0x519c, 0xfffffa39, 0x540b,
+    0xffff9ea8, 0x5321, 0xffff9ba2, 0xffff8804, 0x1049, 0x6249, 0xffffc186, 0x6915,
+    0x45ba, 0xffffc569, 0x1275, 0x1141, 0xffff7d0c, 0xfffff6a0, 0xc88, 0xffffd0cf,
+    0x5493, 0xffffca10, 0x8ba5, 0x5479, 0x56a5, 0xffff72c4, 0xffffc49a, 0x1f28,
+    0x26e2, 0x1842, 0x5690, 0xffff8ee0, 0xffff7d53, 0x1896, 0xffffbaf2, 0x724a,
+    0xffffc881, 0x2913, 0xffff8e93, 0x1318, 0x288c, 0xffff985d, 0x70ef, 0xffffaa46,
+    0x114b, 0x5357, 0x36e9, 0xffff8651, 0xffffb4bb, 0xffffd3a5, 0xffffe071, 0xffffbc9d,
+    0x6d70, 0xffff93f4, 0xffff939a, 0xffffbf01, 0xffff9dd5, 0x3632, 0x22dd, 0x290a,
+    0xfffff94e, 0xfffffd3f, 0x240b, 0x1dd7, 0xfffff422, 0xffffedb5, 0xffffae3f, 0x3131,
+    0xffffb91a, 0xff0, 0xffffa875, 0xffffc56b, 0x7819, 0x2174, 0xfffffc53, 0xfffff477,
+    0x6134, 0x4655, 0x94, 0xffffd1ee, 0xffff7e80, 0xffff82ef, 0xffffff54, 0x7000,
+    0x1e7c, 0xffffc0d0, 0x84a4, 0x5a2, 0xffff7ba9, 0xffffd915, 0xffff757e, 0x2b2b,
+    0x2182, 0xffff9958, 0x3d0d, 0xffffe4af, 0x5c62, 0x7512, 0x4e8, 0xffffa6ed,
+    0x2f28, 0xffff8ff9, 0x1a0f, 0xffffd103, 0xffff85f6, 0x69f7, 0xffffb04f, 0x41fe,
+    0xffffbc7e, 0x427b, 0xffffa03e, 0xffffee6f, 0xffff9910, 0xffffa897, 0xffff7e20, 0xffffc977,
+    0x266c, 0xffffd8e3, 0x3c0a, 0x22b0, 0xffff92ff, 0x1b5d, 0x24f4, 0x3bb7,
+    0x425b, 0xffff90a5, 0xffffb687, 0x156d, 0x58ef, 0x1b16, 0xffffd3e1, 0x582,
+    0xffffb1b1, 0x691d, 0xfffff853, 0x4c0a, 0x4887, 0xfffffa27, 0xffffbdae, 0xffff8d31,
+    0xfffffdb2, 0xffffd009, 0x6287, 0xfffff1ff, 0xffffa748, 0xffffccdf, 0xffffa977, 0x16dd,
+    0x281e, 0x8047, 0x66a, 0x2c5a, 0xffff86b5, 0x854a, 0x2a5a, 0x70dd,
+    0xfffffeb6, 0x873f, 0xffffdd1a, 0xffffaa65, 0xffff8ca8, 0xffff83da, 0x67c9, 0x4745,
+    0x1b41, 0xffffebf0, 0xffff740b, 0x30d7, 0x2afa, 0xffff761e, 0x5539, 0x23e9,
+    0xffffabd8, 0xffff931a, 0x408b, 0xfffff2cb, 0x67dc, 0xffff7807, 0xffff964a, 0x5288,
+    0xffffc66d, 0x2366, 0x148e, 0x38cb, 0x157f, 0xffff8346, 0xffffb678, 0xffffc4f2,
+    0x1549, 0xffffcdb8, 0xffffc5b7, 0xffffd59b, 0xffffd217, 0x6f4e, 0xffffb9ba, 0x8263,
+    0xfffff2df, 0xffffd860, 0xffffd9d7, 0xffff9597, 0xffffec05, 0xffff81f3, 0x8be0, 0xffffe4a7,
+    0xffff85a4, 0x2fc4, 0x86e9, 0x701, 0x61d3, 0x69ff, 0xffff7563, 0xffff76ce,
+    0xffffc010, 0x822f, 0xffff7b66, 0x5e31, 0xffffc663, 0xfffff119, 0x15f0, 0x85d0,
+    0x28f1, 0x3fd6, 0xffffa127, 0xffff9166, 0xffffb044, 0x2e04, 0x322c, 0xffffb132,
+    0xfffff73e, 0xffffb6b0, 0x3ea8, 0xffffac4d, 0x4a5b, 0xffffa5e8, 0xffff7697, 0x16e,
+    0x49ca, 0x1272, 0x4a93, 0x44ce, 0x53e2, 0xfffff35b, 0xffff778a, 0xffffd189,
+    0xffffb7e4, 0x90c, 0xffff8795, 0xffff96e2, 0x73ed, 0x3b2c, 0x5db2, 0xffff761f,
+    0xffffdc8b, 0x4a06, 0xffffa033, 0xfc9, 0xffffe5e2, 0x7fed, 0xffffca3a, 0x218d,
+    0xffffcb3d, 0x2af8, 0xffffb770, 0x8b27, 0xffffcd03, 0x8615, 0xffff7dd4, 0xffff7494,
+    0x7f51, 0xffffdf3d, 0xffffbc52, 0xffffa686, 0xffffe0e6, 0xffffd409, 0xffffcd88, 0x5d0f,
+    0x6c9c, 0x77ed, 0x69e2, 0x30b8, 0xffff894c, 0xffffe9c1, 0xffffa2b0, 0xffffff92,
+    0xffffeecb, 0xffff7486, 0xfffff3a4, 0x4b1a, 0x15cf, 0xffffd171, 0xffffce83, 0xffffb1f3,
+    0x2d8f, 0xffffa1a2, 0xffff90d0, 0x10a2, 0x4e89, 0xffff730e, 0xffffb689, 0x8bf3,
+    0xffffc917, 0x3a3c, 0x28c6, 0x7a05, 0xffffc793, 0xffff944b, 0xffff8c4f, 0x13b6,
+    0x6540, 0x3b3c, 0x1b68, 0xa31, 0xfffffce2, 0xffffa0f0, 0x4d63, 0xa6,
+    0x290, 0xffff7f48, 0xffffb06c, 0x5986, 0xffffe2e9, 0xffffe281, 0x6fd1, 0xffff9467,
+    0xffffa53c, 0xffffda9c, 0xfffffb90, 0x8a9b, 0x55f2, 0x646f, 0x517f, 0xa33,
+    0x1a6, 0xffff8fda, 0xffff890b, 0xffff81f3, 0xffffaac7, 0xffffd83a, 0x7f, 0x2782,
+    0x6083, 0xfffff711, 0xffffe8c7, 0x5553, 0x55b7, 0x4d1, 0x56e4, 0xffff8f89,
+    0xffffbab6, 0xfffff28b, 0x232b, 0x5139, 0xbe4, 0x3b5e, 0xffffa73f, 0xffffdf16,
+    0xcce, 0x5e29, 0xca2, 0xffffd78f, 0xffff861d, 0xffff8ef5, 0x63a9, 0x3d30,
+    0xffffb006, 0xffffa007, 0x4596, 0x2801, 0x4936, 0x2816, 0x3f0a, 0xffff92c9,
+    0x145, 0x4f85, 0x2c8, 0xc72, 0x36a8, 0xffff81cf, 0xffffeffc, 0xffffde3f,
+    0xffffd5f2, 0x5692, 0x60d4, 0x4861, 0x339d, 0x6449, 0xffffdd43, 0xffff8c56,
+    0xffffeb4d, 0xffff98b3, 0xfffff4cf, 0x455a, 0xffffb995, 0xffffce66, 0x1dce, 0x1f3e,
+    0xffff92ea, 0xfffff303, 0x5783, 0x4aae, 0x29e6, 0xc20, 0x78b9, 0xffff878d,
+    0x637, 0xffffb102, 0xffff7e5e, 0x6193, 0x5e68, 0xffffd7d8, 0x654c, 0xffffe71d,
+    0xfffff721, 0x339e, 0xffff7e57, 0x5529, 0xfffffcf2, 0xffffe584, 0x26cf, 0xffffce2b,
+    0xffffff6b, 0x6600, 0xffffe4e1, 0xffffb27a, 0xffff7760, 0xffff8f2d, 0xffffb0b8, 0xffffc68b,
+    0x6907, 0x1110, 0xffffef9b, 0x27, 0xb8d, 0x2872, 0xffffc27e, 0x1bfd,
+    0x123a, 0xffffdb77, 0xffffa828, 0x4f0a, 0x6fd6, 0xffff7358, 0xffffafee, 0xffffc050,
+    0xffffc121, 0x2dc7, 0xffffe42c, 0x8dbf, 0x2698, 0x7efd, 0xffff98d6, 0xffff9eea,
+    0xffffec08, 0x16a3, 0xd9f, 0x6ccb, 0xffff7e32, 0xffff7561, 0x6907, 0x651b,
+    0xffff9d8d, 0xffff826f, 0x5a7e, 0x7a70, 0xffff9108, 0x54c, 0x84d0, 0x4a6e,
+    0xffffc829, 0x5726, 0xffff9518, 0xffffeb06, 0xdcf, 0x143d, 0x385a, 0xffff8005,
+    0xfffff2a7, 0xffffcd4e, 0xffff8b6d, 0xffffec7a, 0x536b, 0xffff8148, 0xffff7ff7, 0x3098,
+    0x6fd7, 0x6a8c, 0xffff83fd, 0x52ca, 0x8cc1, 0x251c, 0x3fd6, 0xffffd96c,
+    0x26de, 0x710, 0xffff9146, 0xffff9808, 0xffff790a, 0x46c7, 0xffff9cf3, 0x290d,
+    0xffffe6b9, 0xffff9078, 0xffff75f7, 0x678a, 0xfffff708, 0x26f2, 0xfffff7aa, 0x583f,
+    0x2e8f, 0xffffb64c, 0xffffc0bc, 0xffffa35b, 0x264a, 0xffffc82c, 0xcfc, 0x7d89,
+    0x11e0, 0xffffce25, 0xffff9499, 0xffff7aa5, 0xe3c, 0xac7, 0x81c5, 0x7159,
+    0x8c01, 0xb5c, 0xfffffc6c, 0xffffa6c9, 0x8249, 0x7524, 0xffff735e, 0xffffce06,
+    0x10c7, 0x6334, 0xffff7b8d, 0xffffa314, 0xffffce5d, 0x4f8f, 0x3a7e, 0x277f,
+    0x17b8, 0x8cd8, 0xffff9909, 0xffffc891, 0x5de9, 0xffffc012, 0x54d6, 0xffff8015,
+    0xffff90d5, 0x15d, 0x703e, 0x3236, 0xffffdd2d, 0xffffca7a, 0x43c6, 0xb61,
+    0x6fd2, 0x336c, 0xffff9509, 0xffffa109, 0x17f4, 0x18a4, 0x38d9, 0x6b5e,
+    0xffffe932, 0x1fee, 0xffffd6a5, 0xffffeb7f, 0x5284, 0x1655, 0x15c9, 0x1fc6,
+    0x6cd5, 0xffffa187, 0x60f5, 0x7248, 0xffff814d, 0xd14, 0x884e, 0xffff8616,
+    0xffffab6c, 0x8c75, 0x1005, 0x57fc, 0xffff9c74, 0x84f, 0xffffb6a1, 0xffffd988,
+    0xffff7530, 0x782, 0xffffa7be, 0xffff9cf5, 0x1497, 0xffffd560, 0xffffe680, 0xffffdf92,
+    0x2ead, 0x8694, 0xffff9c30, 0x3b22, 0xa82, 0x1f5d, 0xffffba52, 0x5743,
+    0xffffb4ee, 0xffffd01e, 0x119a, 0xffff7eff, 0x86da, 0x3771, 0xffffbc56, 0xffff89e1,
+    0x483, 0xffffdbd8, 0xffffc090, 0x225, 0xac3, 0x4c86, 0x26f7, 0xfffff1fa,
+    0xffff76a6, 0x2bb6, 0x6553, 0xffffb0ba, 0x1b0e, 0x4f6f, 0xffffc8f3, 0x787f,
+    0x8416, 0x392, 0x18cd, 0xffff8c51, 0xffffb50d, 0xfffff2e8, 0x74bb, 0xffffc84a,
+    0xffffca8d, 0xffff8508, 0xfffff79a, 0x5867, 0xffffbde9, 0xffffc76c, 0x5966, 0xffffa1a3,
+    0x3ef6, 0xffffaf76, 0xffffb2a6, 0x62b4, 0xffffaf21, 0x1f61, 0xffff8de2, 0x6ae4,
+    0x1711, 0x2848, 0xffffc6e4, 0xfffff285, 0xffffce37, 0xfffff33d, 0x10fa, 0x14a2,
+    0x8c4b, 0x56d5, 0x6170, 0x2ce9, 0x10d8, 0x350e, 0x3e1e, 0xffffa4e0,
+    0x5090, 0x8035, 0x43bb, 0xffffc129, 0x1cdb, 0x7cf4, 0x5897, 0xffffe38a,
+    0xfffffda4, 0xffff8f8f, 0x1711, 0x73fe, 0x641b, 0x24f7, 0x53da, 0x3e9d,
+    0xffffdd78, 0xffff857b, 0x34e7, 0x7881, 0xffffecc8, 0x80b8, 0xffffd388, 0xffffe600,
+    0xffffea29, 0xffffecc9, 0xffff8b09, 0xfffffb67, 0xffffa4ea, 0x6e11, 0x631b, 0x332,
+    0xffffcdfd, 0x1236, 0xaf1, 0x720, 0x2ab7, 0xffffa89c, 0xffffeab4, 0x65c1,
+    0xffffff40, 0x203b, 0x2c2, 0x4c30, 0xffff94df, 0xffffe58b, 0x71fa, 0xffff8350,
+    0xffff888f, 0x33d, 0xffffa878, 0x3d07, 0x199c, 0x644b, 0x5d3d, 0x2c5,
+    0x783b, 0x855d, 0xfffffe0f, 0x29cf, 0x4bcf, 0x2631, 0xfffff8a4, 0xffffdd94,
+    0x1d61, 0xfffffafc, 0xffff7e05, 0x24a0, 0xffff8a5a, 0x262a, 0x5c5b, 0x229f,
+    0xffffe6a8, 0xffffcde6, 0xffffa684, 0x178, 0x37cf, 0x534, 0x190a, 0x86d9,
+    0xffffd70b, 0xdf9, 0x8a0d, 0x7218, 0xfffff793, 0x420e, 0xffffa733, 0x811f,
+    0xffffa1b0, 0x8cfc, 0xffffb39f, 0xffffb277, 0x8c8d, 0x188, 0x4b59, 0x660c,
+    0xffffc5c1, 0xffffc2c9, 0xffffe996, 0x2fd7, 0x1650, 0x6209, 0xffffa6a9, 0x4c28,
+    0x7291, 0x587e, 0x4ef5, 0xffffaa02, 0xffffb81c, 0xc34, 0xffff79d4, 0xbe0,
+    0x6bc9, 0x49c7, 0xffffb6eb, 0x120a, 0x455f, 0xffffa242, 0x19e1, 0x5b62,
+    0x5cec, 0xffff8be5, 0xfffff857, 0xffffc764, 0xa02, 0xffff8856, 0x702c, 0xffff7b18,
+    0xffff85d1, 0xdb3, 0x6296, 0x3ef2, 0x55a0, 0xffffe47a, 0x3213, 0xffffdcb1,
+    0x2a00, 0x2c6d, 0xfffff530, 0x77d2, 0xfffff051, 0xffff82cc, 0xffffe0f7, 0x603e,
+    0xffffcdcf, 0x3ee8, 0xffff9788, 0x4ee3, 0xffff8a08, 0x44d7, 0xffffae63, 0xffffa7bc,
+    0x151e, 0x5de1, 0xffffe129, 0x7ec1, 0xffff82e1, 0x7a8a, 0xffff7c0f, 0x866a,
+    0x1c48, 0x63fd, 0xfffffdf7, 0x681d, 0xffffeb26, 0x6d6c, 0xfffff7b5, 0x63e,
+    0xffffcbab, 0xffffedcd, 0xffffe5d6, 0x4967, 0x834b, 0x28eb, 0x6365, 0x7e4b,
+    0xffffd7aa, 0xffff759e, 0x5cad, 0x22f6, 0xffffa019, 0xffff7a60, 0xffffb158, 0xffff9830,
+    0xffff88fa, 0x5381, 0xffff9edf, 0xffffb70e, 0xffffb5e0, 0x28b9, 0xffffd778, 0x4aa9,
+    0x1029, 0x4de8, 0x85a, 0xffffa5af, 0xffff9598, 0x694a, 0x442f, 0xffffc325,
+    0x1646, 0x40b4, 0x51b0, 0x50c4, 0xfffff810, 0x6afc, 0x1611, 0x7c33,
+    0x2c36, 0xffffadd9, 0xffffff75, 0xffffa472, 0x2a6f, 0x1ea3, 0x5389, 0x42ec,
+    0xffff7734, 0x10df, 0x7e19, 0xffffbe25, 0x45dc, 0x52d1, 0xffff7b84, 0xfffff9d9,
+    0x202c, 0x6f8c, 0xffff96b0, 0x4581, 0x13a9, 0x7c2c, 0x2c73, 0x456a,
+    0xffff90d7, 0xffff918e, 0x4daf, 0xffff883f, 0x292d, 0xffffd140, 0x4599, 0x7022,
+    0x6e51, 0x6fd8, 0xffffcc81, 0x55a, 0xffffb012, 0xffff8234, 0xffff8e12, 0xffff866e,
+    0xffff82ab, 0x3a12, 0x77f1, 0xffff8e5c, 0xffffb9db, 0x8114, 0xffffb4d1, 0xffffaa27,
+    0xffffef2b, 0x512b, 0xfffff599, 0x2614, 0xffffec61, 0x2e53, 0xffffe14a, 0x8762,
+    0x15ea, 0xffffa04a, 0xa9c, 0x3db3, 0xffff9da7, 0x1ba7, 0x6f1, 0x7046,
+    0x40d8, 0x2807, 0xfffff498, 0x4003, 0xb8b, 0x80d9, 0xffffc968, 0xffffb091,
+    0x6a11, 0x575d, 0xffffbd30, 0x59b7, 0xffffec68, 0x3bc3, 0xffff9852, 0x8d97,
+    0x3bdd, 0xffff7b05, 0x3a08, 0x796a, 0xffffde73, 0x23d7, 0xffff937c, 0xffff8364,
+    0x2c86, 0xfffff529, 0xffffb941, 0x4f9f, 0x300a, 0xffffb69a, 0xffff8ae2, 0xffff76f4,
+    0x6281, 0xffff7a7f, 0xffff8cae, 0x6a9b, 0xffffc3e3, 0x6b24, 0x1a7f, 0xffffbbaa,
+    0xffff9898, 0xfffff100, 0xffff9a77, 0xfffffeb5, 0x8062, 0x26f6, 0x72a6, 0x82a8,
+    0xffff8d48, 0xffffad0b, 0xffff78ed, 0x39d9, 0xffff8cbd, 0xffffe4fb, 0xffff73d3, 0xffff8749,
+    0xffff7787, 0x186d, 0xffff8a66, 0xffffd430, 0x675d, 0x6208, 0x1e0a, 0xffffd207,
+    0x7627, 0x272d, 0xffffe162, 0xffff7f78, 0xffff97cd, 0xffffe52f, 0xffff9648, 0xffffbde7,
+    0x4a2, 0xffffab13, 0x408e, 0xffffaf5a, 0xfffffccf, 0xffffcaee, 0x3ce9, 0xffff9f86,
+    0xffffbdf6, 0x6f7d, 0x1ac0, 0xffff7d8f, 0xffffb5f4, 0x15d5, 0xffffb317, 0xffff8d69,
+    0xffffd179, 0xffff9256, 0xffffaed4, 0xfffffd69, 0xffffe67c, 0x8a5d, 0xffffb985, 0x7bd5,
+    0x1eaa, 0xffff7ea6, 0x7a6, 0xffffcc73, 0x45fe, 0xffff9312, 0xffff8963, 0xffffcd75,
+    0x3534, 0x29af, 0xffffa890, 0xffff81d1, 0x3c3a, 0xffffcbc4, 0x43ba, 0x320c,
+    0x70c6, 0x2ec5, 0x189d, 0xffff768f, 0xfffffcf4, 0x3ea8, 0x8212, 0xffffabef,
+    0xffffc162, 0x22d4, 0x5755, 0xffffc5a0, 0x87f4, 0xffffb7da, 0xffffa9f3, 0x6eb4,
+    0x1abc, 0x5caf, 0x3043, 0x4be4, 0x557b, 0x18e5, 0x2499, 0x7f,
+    0xffffcd2d, 0xffffd93e, 0x3af4, 0xffff8c49, 0xffffc5a9, 0xffffb1ba, 0xffff9c0c, 0x18ba,
+    0x2cbe, 0xffff8efc, 0xffffa34b, 0x3b05, 0x49d, 0xffffe7b4, 0xffffd9de, 0xfffff909,
+    0x5f8, 0x3651, 0xffff7d02, 0x5eda, 0xffffb6f3, 0xffffaa6d, 0x201e, 0xffffc0d0,
+    0xd3c, 0x11dd, 0x8c01, 0xfffff81f, 0x84fb, 0xffffe312, 0x7cdc, 0x6d33,
+    0xffff8b40, 0x79af, 0xfffff0d5, 0xffffe4ee, 0x73a8, 0x20e6, 0xffff927f, 0x8592,
+    0xffffb092, 0x5012, 0x76b, 0xffffa971, 0x8ba1, 0xffffb512, 0x22f3, 0x8ae3,
+    0x4217, 0x70e6, 0xffff8854, 0xffffa794, 0x69dd, 0xffffea58, 0x30f6, 0xffffa42d,
+    0xffff9908, 0x5e1e, 0x2fd4, 0x329, 0x775a, 0xffff95b2, 0xffffa71e, 0xde7,
+    0x2e22, 0x776e, 0x16d4, 0xffff8616, 0xffffb167, 0xffff85b5, 0x57da, 0x72eb,
+    0xffffbaf7, 0xffffc299, 0x59ef, 0xfae, 0x1907, 0x4adb, 0x7242, 0x5bd3,
+    0x189e, 0x5ad4, 0xffff8e3c, 0xffffedaa, 0xbe0, 0xffffffdc, 0xd45, 0x2ef8,
+    0xffff7cd2, 0xffffaddd, 0x685a, 0x832e, 0xffffcf75, 0xffffd4dd, 0xbd6, 0x149f,
+    0x3cdb, 0x7691, 0xffffc1e2, 0xffffa1c4, 0x7548, 0xffffa014, 0xffffe53b, 0xfffff6f1,
+    0xffffeecb, 0xffffa681, 0xffffafc8, 0x6811, 0x875b, 0x1578, 0xffffdcbe, 0xffff8206,
+    0x483f, 0xffff7c5c, 0xffffbf83, 0x2b71, 0x7789, 0xffff733b, 0xffffe5d4, 0x5b88,
+    0x7751, 0xffffc109, 0x4a86, 0x7284, 0x67d8, 0x28d4, 0xffffa41e, 0xffff7baf,
+    0x761d, 0xffffff5a, 0x3e9e, 0x4e25, 0x2a7a, 0xfffff846, 0xffff873f, 0x43a9,
+    0xffffeeea, 0xffff840b, 0x716f, 0xffffacf0, 0x5da3, 0xffffb902, 0xffffaf05, 0x4b57,
+    0x73da, 0xffff956d, 0x4cf1, 0x7716, 0x33dd, 0x464, 0xffffeb6c, 0x4007,
+    0xfffff3b4, 0x1fe3, 0x721, 0xffffe758, 0xffffabb3, 0x19d8, 0xffffbc97, 0xffff751d,
+    0x7cc7, 0xffffb5e3, 0xffff8625, 0x8590, 0xffff8fb2, 0x168b, 0x8a88, 0x5368,
+    0x7a0a, 0xffffff50, 0xffff7c26, 0x2c26, 0x5a95, 0xffffd991, 0x19e2, 0xffff7a6d,
+    0x3e4b, 0x2e49, 0x4b7a, 0xffffcaf0, 0xffffff91, 0x1fc2, 0x4ed5, 0xfffff2a5,
+    0xffffcc85, 0x52ac, 0xffffcef3, 0x13ae, 0xffff7590, 0x4c03, 0x860a, 0x1715,
+    0xfffff3b6, 0x3e42, 0xec, 0x5e30, 0x7f7b, 0xffff8325, 0xffffcc59, 0x3c5a,
+    0x1730, 0xffff84b9, 0x543c, 0xffffc431, 0x210c, 0xffffff67, 0x3247, 0x78fa,
+    0x6646, 0xffffb35a, 0xffffebe6, 0x74d8, 0xffff7d83, 0x696b, 0x2502, 0xffff898c,
+    0xffffa4a3, 0xffffe1a7, 0xffffd2c6, 0xfffff1db, 0x8425, 0x4794, 0xfffff992, 0x5bec,
+    0xffff999e, 0x4e2, 0xffffa80f, 0xffffee33, 0x6505, 0xfffffe03, 0xffffb529, 0x14ad,
+    0xffff8511, 0xffffd437, 0xffffd6f4, 0xffffa716, 0x6fbe, 0xffffb2c5, 0x28fb, 0x9a7,
+    0xffff72d3, 0xffffe490, 0x7ad4, 0x534e, 0x883e, 0x69a3, 0xffff9ebc, 0x36c1,
+    0x3ac1, 0x8cc2, 0x4363, 0xffff980d, 0x42a1, 0xffff94ce, 0x7fa5, 0x59d0,
+    0x2d35, 0xffffaddc, 0xffffc82e, 0x679d, 0xffffff04, 0xfffff390, 0x75c1, 0xfffff28e,
+    0xffff8261, 0x7609, 0x6cc6, 0xffffeb00, 0xffffcdb1, 0xffff97c2, 0x2ec8, 0x7a4d,
+    0x5a53, 0x4a2b, 0xfffff160, 0xffff7c7e, 0x8af1, 0xffffa8aa, 0x8a2, 0xffffd8c4,
+    0x15e7, 0xffffa490, 0x35bb, 0x3846, 0x8b8f, 0xfffff39f, 0x115f, 0x26ed,
+    0x3580, 0xffffdd48, 0xffff763b, 0xffffa8ec, 0xc2d, 0x7e4, 0x73c, 0xffffec28,
+    0xffffb1ff, 0xffffd69c, 0xecc, 0xffff8a47, 0x1570, 0x5278, 0x7478, 0xffffa96c,
+    0x87f7, 0x6c6d, 0xffff9c2a, 0x3e44, 0x4451, 0xffffe66f, 0x77a7, 0xffffa196,
+    0xfffff4c8, 0x4d8, 0xffffda98, 0xffffb107, 0xffffe5f6, 0xffffd073, 0xfffffb60, 0xffffd970,
+    0x7134, 0x1b66, 0xfffffed6, 0xfffffffb, 0x2f5d, 0xffffc33f, 0xffffb63a, 0x17aa,
+    0xffffb6c7, 0xffffb5dd, 0x9a7, 0xffffb6ee, 0xffffce02, 0x4f50, 0xefc, 0xffffe4de,
+    0xffff9e9b, 0xffffd397, 0xffffabfb, 0x771d, 0x7313, 0xffff8f5d, 0xbc, 0xffffa767,
+    0xffff7a43, 0x1a04, 0x7e99, 0x5029, 0x2c61, 0xffffcf61, 0x6e6f, 0xffff8786,
+    0x832e, 0xfffff079, 0x76f0, 0x6720, 0xb72, 0xffffc9bb, 0xffffb384, 0x8b40,
+    0x4f6f, 0xffff9c0e, 0xffff7248, 0x8721, 0xffffb61c, 0x3264, 0x4af3, 0x26fa,
+    0xffff78cb, 0x3f99, 0x519b, 0x3d38, 0xffff9e3c, 0x6363, 0xfffff082, 0x61,
+    0x80e3, 0x882c, 0x1ad9, 0xfffff42c, 0xffffe5d7, 0xffff78aa, 0x7f81, 0x6333,
+    0xe4b, 0x99, 0xfffff37c, 0xffffd8b0, 0x5f1f, 0xffffa399, 0x2fe4, 0x413f,
+    0x2fb, 0x2d48, 0xffff9550, 0xffffd960, 0x8c72, 0xffff83f3, 0x3d50, 0x85ec,
+    0xffffb965, 0x1cdd, 0xffff8626, 0xffffa6c0, 0xffffa058, 0xffffb314, 0x77c1, 0xffffa6dc,
+    0x73d6, 0xffffbbbb, 0xfffffbf9, 0xffffcf13, 0xffffd10c, 0x8c3e, 0x5f5c, 0x4af5,
+    0xffffd141, 0xffffd407, 0xffffc119, 0xffff86b0, 0xffffb16c, 0xfffff4f1, 0x404a, 0x6bab,
+    0xffff9021, 0xffffd5f5, 0xffff87b0, 0xfffffb85, 0xffffbc33, 0x3ef, 0x16dd, 0xfffffc0a,
+    0x346, 0xf7b, 0xffffb212, 0xffffe5b9, 0x1c45, 0x5a37, 0xffff8f95, 0xffffccda,
+    0x11d2, 0xffff74a0, 0x52c1, 0xfffff70b, 0xffff90dd, 0x5ab1, 0x3ecb, 0x70d0,
+    0x8ac4, 0xedb, 0x1091, 0xffff874d, 0xffffdce4, 0x4603, 0x157f, 0x4db,
+    0xffffb596, 0x5604, 0xffff7a31, 0xffffe7e6, 0x3bc2, 0x1ec0, 0x861, 0xffffbb57,
+    0xfffff94b, 0xffff9fb4, 0xffffea52, 0xfffff479, 0xffff9909, 0xffffa95f, 0xffffa074, 0x8889,
+    0x198b, 0x56f4, 0x3423, 0x8241, 0xffffe3ff, 0xffff881a, 0x4e97, 0xffffcf1b,
+    0xffffa603, 0x3957, 0xfffff6d5, 0xfffff0b2, 0x8464, 0x1f13, 0xffffe04e, 0x3ed2,
+    0x1636, 0x19df, 0xffff9d9c, 0xffffb4af, 0xffff764e, 0x787f, 0x42a6, 0xffffda01,
+    0x5a29, 0x8d78, 0x5fae, 0xffffe92e, 0xfffff130, 0x7c51, 0xffffbf50, 0xffffb867,
+    0x2ddf, 0xffffb349, 0xffffd0e9, 0x6b0b, 0x6d50, 0xffffd468, 0xffffa3b0, 0xffff97d8,
+    0x1960, 0xffffdbbb, 0xffffa4af, 0xffffbd37, 0x2ef3, 0x2437, 0xffffd17e, 0x13e5,
+    0x54e0, 0xffffc59f, 0x22bb, 0xffff780f, 0x6239, 0xffff7d96, 0xffffda9d, 0x6e34,
+    0xfffface6, 0x295a, 0x2719, 0xffffda03, 0xffffabc0, 0x23a3, 0x1cf2, 0xffffaa50,
+    0xfffff1aa, 0x6565, 0x75b1, 0xffffc795, 0xffffb3d6, 0xffffac07, 0xffff8ab8, 0xffffe135,
+    0x6be2, 0xffff9a21, 0x66be, 0x1ede, 0xffff9b45, 0xffffddb2, 0x19d9, 0xffff9a42,
+    0x1470, 0xfffffd5c, 0x1e7e, 0x6407, 0x6ab4, 0x9cd, 0x1ce7, 0x7246,
+    0xffffcc0e, 0x334a, 0x8d32, 0xffffdd26, 0xffff876d, 0x5f42, 0xffffce4d, 0x746f,
+    0x23a2, 0xffffbddd, 0x1b98, 0xffffc9e3, 0xffff921c, 0xffffb30e, 0x3477, 0xffffa587,
+    0x4067, 0x18a0, 0x361e, 0xffd, 0xffff880f, 0xffffef9a, 0xffffce51, 0x3ed,
+    0x139b, 0x4957, 0xffffc1b0, 0x5718, 0x4e72, 0x898c, 0x1e76, 0xfffffc63,
+    0x5a7e, 0x3388, 0xffff8b15, 0x8c3, 0x42ed, 0xffff9b9a, 0x1fff, 0xfffff544,
+    0x66a4, 0xffff7c9f, 0xf3d, 0x8823, 0xffffab00, 0x8d96, 0xffff9a08, 0x16d3,
+    0x55a3, 0xffffc3a3, 0x5f6e, 0xffffa6c2, 0xffff982e, 0xffffe233, 0x3b85, 0x4b3b,
+    0xfffff53f, 0x31d2, 0x58f0, 0x8345, 0xffffb052, 0x8516, 0x1013, 0x3e91,
+    0xffffdf3d, 0xffffb256, 0xffff8937, 0x7307, 0x6544, 0xffff9898, 0x26fc, 0x7aaa,
+    0x5d8c, 0x45c4, 0x8168, 0xffffe0d2, 0xffffa15f, 0xffff8c32, 0x23e2, 0x2f6d,
+    0x4e73, 0x5b19, 0xfffff7a0, 0x1530, 0x8a57, 0x5994, 0x7668, 0x8658,
+    0x7810, 0x5ae5, 0xffffdd59, 0xffffe2e3, 0x6ade, 0xffff84ab, 0x2286, 0x3324,
+    0x34d6, 0x6fa3, 0xffff9c8c, 0x1649, 0xffff9152, 0xffffde80, 0x140c, 0xffffe31f,
+    0xffffab3a, 0x85b6, 0x870d, 0x21cd, 0x33ee, 0xffff8aa8, 0xffffcb20, 0x584,
+    0xffffcdb5, 0x4b6c, 0x4b54, 0x559c, 0xffffc9b9, 0xffffc227, 0xffff93ec, 0xffffaf9c,
+    0x2314, 0x4cd1, 0xffff9b8a, 0xffffa7f7, 0xffffe946, 0x6412, 0x8698, 0xfffff049,
+    0xffffe24f, 0xffffbc02, 0xfffff5dc, 0x248b, 0xffffa1a1, 0xfffff591, 0x17f8, 0x7c7f,
+    0x2a38, 0xffffc4b7, 0x50f4, 0x4567, 0xffffe9b3, 0x1139, 0xffffdc63, 0xffffaf43,
+    0xffff921e, 0x38b5, 0x6f7c, 0x7e35, 0x4cb7, 0xffffdbdb, 0xfffffc86, 0x14e0,
+    0xffffb500, 0xffff8fd7, 0xffffc44e, 0xffffe8ae, 0x615, 0x73de, 0x513c, 0xffff8c2d,
+    0xffffa65e, 0x733b, 0xffffaa1a, 0xffff9823, 0x390f, 0x81e5, 0x6388, 0x2547,
+    0x618c, 0xffffc2b5, 0xfe5, 0x61cf, 0xffff8162, 0xffff8c51, 0x8872, 0x5eae,
+    0x5a61, 0xffffab35, 0xffff790b, 0xffff894f, 0xffff7e7f, 0x2ef3, 0xffffa954, 0xffff94a3,
+    0xffffec89, 0xffffe3e7, 0x886c, 0xffff9f5c, 0x6429, 0x5828, 0xffffb33b, 0x38d4,
+    0x3fb6, 0xffffe5df, 0x5e4, 0xffffa316, 0xffffdea1, 0xffffefe5, 0xbb0, 0xf7c,
+    0xfffff415, 0x7f2, 0xfffff4ab, 0x8d31, 0xffffb9b1, 0xffffbbdd, 0xffffc868, 0xfffff245,
+    0xffff91ae, 0x62db, 0xffffd076, 0xffffc4c5, 0x5575, 0x43af, 0xffffe6f3, 0x7cc1,
+    0x6c8b, 0xffffb56c, 0xffffe101, 0xfffffe07, 0xffff8a88, 0xffff9931, 0xfffff933, 0xffffd4bd,
+    0x355e, 0xffffd3df, 0x1e2d, 0x5b90, 0x6ce5, 0xffffff81, 0x5d0e, 0x514b,
+    0xffffa086, 0x1caf, 0x300d, 0xffffc1e2, 0x357c, 0x2820, 0x4be, 0xffff9c0b,
+    0x2e68, 0xffffb03b, 0x8ab1, 0x2aed, 0x3cc8, 0xffffa250, 0xffffca57, 0xffff8fe0,
+    0xffffbc0e, 0xffffa87c, 0x3681, 0xffffff03, 0x6f96, 0xfffff6e8, 0x3818, 0xffff91eb,
+    0x460a, 0xffffc57c, 0x23bf, 0xffffa010, 0x6ae0, 0x38fa, 0x6c95, 0xffffe509,
+    0x2594, 0xffff892e, 0xffffd6fd, 0x4dbf, 0xffff7bca, 0x595b, 0x5265, 0xffff722c,
+    0xffff9bbe, 0x6f1b, 0xffffa0d6, 0xffffb61d, 0xfffff32c, 0xac6, 0xffff8448, 0x37b3,
+    0xffffb59c, 0x6132, 0xffff820a, 0xffffb87e, 0x7e80, 0xffffddb7, 0xffff84db, 0xffff868b,
+    0x1498, 0x5ece, 0x4761, 0xffffbe71, 0xffff7b6f, 0x2492, 0x6b0e, 0xfffffcba,
+    0xa45, 0xd5d, 0x361d, 0xf45, 0x82fe, 0xffffd7cf, 0xffffc64e, 0xffff8ad6,
+    0xffffb43b, 0xfffff00e, 0xffff7b5b, 0xffff9858, 0x3756, 0xffffe97b, 0x6167, 0x52b9,
+    0xfffffc14, 0x4bf6, 0x2c11, 0x5c7b, 0x75fc, 0xfffff1b7, 0x47f4, 0xffffc8ca,
+    0x5fbc, 0xc3f, 0xffff9e06, 0xffffb109, 0xffff791e, 0x6661, 0x8942, 0xffff92b4,
+    0xd4f, 0x15a8, 0x625d, 0x3878, 0xffff9a70, 0x636b, 0xffffad1a, 0xfffffc36,
+    0x1abe, 0xfffff303, 0x4b0a, 0xffffe7cc, 0xffff904c, 0xffffe288, 0x5acd, 0xfffff71e,
+    0x3252, 0xce1, 0x2db2, 0xffffc97a, 0xfffff8e7, 0xffffbb28, 0x7a7d, 0x6ed5,
+    0xffffae7d, 0x8dbe, 0xffff744e, 0xffff8e03, 0x6cb, 0x86a7, 0xffffdc22, 0xffffd8fb,
+    0xffffd18d, 0x4626, 0x8c87, 0xffffc3ae, 0xffffb882, 0x689a, 0x3791, 0xffffc0a0,
+    0x7223, 0x3c, 0x8fe, 0xffff9ecf, 0xffffd89a, 0xffff7e2d, 0xffffa145, 0x56e7,
+    0xfffffb34, 0x480c, 0xffffb7b6, 0x4d54, 0xffffc5f6, 0xffffde25, 0x4d3e, 0x7302,
+    0xffffdb67, 0x4fb7, 0xfffffb02, 0x8765, 0xffffab7b, 0xda7, 0xffffb04f, 0xffffc9e5,
+    0x15b6, 0x2718, 0xffffc98c, 0xffffe2eb, 0x8011, 0x8b74, 0x7aa7, 0xa1a,
+    0x5d48, 0xffff9ffa, 0x1d7, 0xffffef63, 0xffff9746, 0x7c5b, 0xffff816e, 0x6c68,
+    0x156f, 0x85b8, 0x16bc, 0xffffc689, 0xffff8006, 0xffffe2ec, 0xfffff102, 0xffffeb7d,
+    0x8956, 0xfffff640, 0x4713, 0x7bad, 0x41bb, 0xffff9f79, 0x3691, 0xffff7b9d,
+    0x7ca6, 0x5c98, 0x81e4, 0xffff9084, 0x7825, 0x543a, 0xffff8b4b, 0xffffd2f9,
+    0xffff7f0a, 0xffff7655, 0x665e, 0xffffd3df, 0xffff8b05, 0x2da3, 0x2c10, 0x4dcf,
+    0x23e0, 0x4e27, 0x5fb6, 0x82f3, 0xffffe5cb, 0x6d98, 0xffff9691, 0xa4a,
+    0x3f51, 0x2573, 0x894c, 0xffff8107, 0x5091, 0xffffe034, 0x83db, 0x2029,
+    0xffff8d63, 0x6ee6, 0xffff92d2, 0xfffffe7e, 0x5f72, 0x6704, 0xffffd1f6, 0x4d40,
+    0xffffb1f6, 0x2766, 0x4b84, 0x7e47, 0x728a, 0x51f7, 0xffff9a48, 0x1149,
+    0xffffc964, 0x456f, 0xffffa797, 0x6112, 0xffff7e4c, 0xffffea92, 0x8a8b, 0xffffc9bf,
+    0xffffbc0c, 0x6591, 0xffffd69c, 0xffffe54f, 0xffff7adb, 0x581b, 0xffffad1f, 0xffff9607,
+    0x3e51, 0xffffe644, 0x80a4, 0x272e, 0xffffd8d5, 0x4c15, 0x639a, 0x7345,
+    0xffff7d10, 0x1f97, 0xffffe213, 0xffffcd19, 0xffffb907, 0x7196, 0x348c, 0xffffcd02,
+    0xffffc4b0, 0xfffff3d3, 0x56d5, 0xffff7712, 0x2415, 0x19c9, 0xffffaa34, 0x5be0,
+    0xffffbe3d, 0x3edb, 0xffff7ba6, 0xffff8704, 0xffff9b22, 0xffff7398, 0x1ad2, 0x2b12,
+    0xfffffa9e, 0x82a0, 0x289f, 0x20c1, 0xffffa302, 0xffff8bac, 0x5528, 0x5b36,
+    0xffff9f0e, 0x300, 0x76ab, 0xe31, 0x54dc, 0x14c2, 0xfffff3f7, 0xffff9727,
+    0xffffb8a1, 0xfffffd6c, 0x668c, 0x12ce, 0x5e2b, 0x837f, 0x79d9, 0xffff9f2c,
+    0xffffe8c0, 0x5569, 0xffffa931, 0xffff9828, 0x5447, 0xe70, 0xffffc612, 0xffffbdc8,
+    0xffff8100, 0xffff948f, 0xffffd762, 0x165, 0x7caf, 0xffffe5ba, 0xffffd76a, 0x1b3f,
+    0xffffbace, 0x75b9, 0x266, 0x3be3, 0xffffb139, 0xffffdf94, 0x2528, 0xffff85e5,
+    0x63ec, 0xffffea79, 0x784, 0x12c5, 0xffffcf6d, 0xffff941e, 0xffffd6c0, 0xffffe17c,
+    0xffffde73, 0x317d, 0xffff7430, 0x2eea, 0x2d4d, 0xffff7937, 0xfffffb7c, 0xffff802d,
+    0xffff902a, 0xfffff7d6, 0xffffbdb7, 0xffffdf44, 0xffffd10a, 0xffffc6a9, 0x36fe, 0xffffc98c,
+    0xffff732c, 0xffffe42e, 0xffffd1e4, 0x6c5e, 0xffffa8ab, 0x7624, 0xffffdd12, 0xffffaf68,
+    0x4d98, 0x5f15, 0x865d, 0xffff8d23, 0x5266, 0x276c, 0x295e, 0x1d29,
+    0x5e0b, 0x772f, 0x2942, 0x459e, 0xffffe4eb, 0xffff73dd, 0xffffd004, 0xffff886f,
+    0xffffcaf9, 0x18e0, 0xc66, 0xffffd08d, 0xffff7a9f, 0xffffd290, 0x88d8, 0xffff7c4b,
+    0xffff86dd, 0xe4c, 0x15ef, 0xffff99f5, 0xffffde0e, 0x44db, 0x6855, 0x29de,
+    0x3458, 0xffffc7a8, 0xffffdc32, 0xffffb3ec, 0x6e1b, 0xffff8dfd, 0x86a6, 0x685d,
+    0xffffee8d, 0xffff92e9, 0xffffc182, 0xfffff271, 0x39d5, 0xffff86a2, 0xffff7472, 0xffffecba,
+    0xffffd44d, 0xffff7fef, 0xffffd860, 0xffffeb6d, 0x3822, 0xffff91b2, 0xffffe1ea, 0x657f,
+    0xffff98be, 0x7c56, 0xffffe379, 0x1286, 0xfffff440, 0xffffefd4, 0xffffc00c, 0xffffef9d,
+    0xffffbb0a, 0xffffe423, 0x717a, 0xffff8177, 0xffffc56c, 0xffff87c0, 0x389, 0xffffbd6f,
+    0x6a85, 0x6072, 0xffff8991, 0x6768, 0xffffb310, 0x55a0, 0x3566, 0xffffa763,
+    0x6ad8, 0xffffecf0, 0x6e47, 0x460f, 0xffff74c3, 0xffffa827, 0xffff8ed2, 0x63a8,
+    0x6785, 0xffff9ab6, 0x8721, 0xffffb48d, 0xffff8e1d, 0x1b24, 0x4cad, 0x32a8,
+    0xffffa063, 0x3cc6, 0x3f51, 0x27c7, 0x32e2, 0xffff9cf7, 0xffffeca9, 0x6a39,
+    0x58fa, 0x305d, 0xffffb237, 0xffff8301, 0x2b29, 0x4d40, 0xbfb, 0xffffea6f,
+    0x15a1, 0xffffcc4f, 0xffffc735, 0xffffdaca, 0x26e5, 0xffff9e2f, 0xffffc05a, 0xffff8cf2,
+    0x7a37, 0x4531, 0xfffffa02, 0xffffb210, 0x8633, 0x4f0f, 0x754, 0xffffed54,
+    0xffff8740, 0x59d2, 0xffff767e, 0xffff855a, 0x3d85, 0x71b9, 0x72cd, 0x4d3b,
+    0x78a1, 0xffffa6c1, 0x6c3e, 0xffff9317, 0x2926, 0x119a, 0x44d2, 0xffffb033,
+    0xffff935e, 0xffffc224, 0x4ba1, 0xffffdba2, 0xffffb9b7, 0x17e4, 0xffff8b75, 0x2f37,
+    0xffff73b2, 0xffffcc5c, 0xffff88bc, 0x213a, 0x47b0, 0x13d5, 0x3ca1, 0x51a7,
+    0x2e56, 0xffffc38a, 0x7f7a, 0xffffe80b, 0xffff8832, 0x7270, 0xffff8f10, 0xffff7ca1,
+    0x6c56, 0x8390, 0xffffb0bf, 0xffff9200, 0x6bbb, 0x46c8, 0xfffff4db, 0x2ab3,
+    0xffffa2c1, 0x7288, 0xfffff4a6, 0x5ec3, 0x7c3, 0xffff81af, 0x3cc2, 0x28f7,
+    0x4a58, 0xfffff026, 0x7ff0, 0xfffffc62, 0xffff9148, 0xd8f, 0x185, 0x59f4,
+    0x1caa, 0x39dd, 0x3787, 0x4a31, 0xffffed74, 0x4336, 0xffffa9ea, 0x4646,
+    0xffffd6f7, 0x175a, 0xffffe833, 0xffff95e8, 0xffff79ef, 0x7509, 0x68b8, 0x5445,
+    0xffffe6a9, 0x49e4, 0xee4, 0x5e83, 0xffff9812, 0xffff9b80, 0xffffcd5b, 0xffff905e,
+    0x6959, 0x38cf, 0xffffbce0, 0x758b, 0x3d88, 0xffffc47d, 0xffff86ca, 0x1c6a,
+    0x10f2, 0x2934, 0xffffeb47, 0xffffa621, 0xfffff453, 0x8822, 0xffffd84d, 0x88a8,
+    0xffff7738, 0x2211, 0x278b, 0xffffb4fd, 0x4a25, 0x24a1, 0xffff9982, 0x4316,
+    0x1f4, 0xffffec51, 0xffffaf4d, 0xfffff10f, 0x452d, 0xffffed98, 0xffff89e2, 0xffff9770,
+    0xffff7393, 0x2e9a, 0xffffa805, 0x870c, 0xffffb79d, 0xffffdcb9, 0x190f, 0xffffaf36,
+    0xffffae0b, 0x35a8, 0xffffcb81, 0x49b6, 0x5b81, 0xffffad9f, 0x4b00, 0x59f6,
+    0xbcf, 0x2bf6, 0xffff83b9, 0x56a, 0x478b, 0xfffff9a6, 0xffffefb1, 0xd52,
+    0xffff977e, 0xfffffde7, 0x2281, 0x486b, 0xffff7a45, 0x38, 0xffffa31e, 0x545b,
+    0x5f67, 0x759e, 0x7227, 0x4710, 0xffffda15, 0xffffde83, 0xffffb16f, 0x445a,
+    0xffffb2a9, 0xffffe77a, 0x8ff, 0x136f, 0xffffaa07, 0xffff739c, 0x16f8, 0xffffd05a,
+    0x1bc1, 0xffffbd49, 0x6534, 0xffff8187, 0x30d6, 0xffff7c5a, 0x8038, 0xffffc927,
+    0x81d3, 0x6e7, 0x7d71, 0x5eed, 0x2dbc, 0x7779, 0x49d9, 0xffffa59c,
+    0xffff7c2e, 0xffff7a46, 0x1461, 0xffffcbc6, 0x47cd, 0x6df4, 0xffff9c8b, 0xffffba56,
+    0xffffc1aa, 0xffffe2c4, 0xffffb8b3, 0x354f, 0xffffba6f, 0x7e32, 0x88d2, 0x1dda,
+    0x65c3, 0xffff7a23, 0xffffa941, 0x772d, 0xffffa8e4, 0x6cac, 0x6006, 0xffff8cc0,
+    0x2c22, 0xffff8f93, 0xffffd510, 0x4ac1, 0xffffcac2, 0xffffbfc5, 0xffff772e, 0xffffd90e,
+    0xffffc04b, 0x1858, 0xffffdb53, 0x4730, 0xffff87ca, 0xfffff776, 0xb2b, 0x5f04,
+    0xffff7deb, 0xffffafc4, 0x273c, 0xffffa9ad, 0x2f96, 0x1df3, 0xffff99ab, 0x3ccb,
+    0x8cb2, 0x69c, 0xffffb855, 0xffffa904, 0x8a40, 0x1b30, 0xffffbfe7, 0x8a23,
+    0x70f8, 0x57da, 0xffff75fe, 0x2214, 0x2be1, 0xffff990b, 0xffff9394, 0xffffe908,
+    0xffffb2c4, 0xffffa067, 0xfffff7c6, 0xffff97cd, 0xffff7498, 0x3af8, 0x1241, 0x10e3,
+    0xffffa621, 0xfffff296, 0x698e, 0xffffa28b, 0xffff9084, 0x12cf, 0xffffb1f9, 0x4359,
+    0x336c, 0xffffcf1e, 0xffffa763, 0x80bf, 0x4019, 0x47d5, 0xffffec7a, 0xffff83f6,
+    0xffffd75a, 0xffffb050, 0xffff9104, 0xfffffb14, 0xffffd821, 0xffff8b8d, 0xffffb3fd, 0xffffebb6,
+    0x124e, 0xffffd263, 0xffff7eab, 0xb78, 0xffffb115, 0xffffa4e5, 0xffffe296, 0x1f8,
+    0xffffdd28, 0x3378, 0xffff9498, 0x3617, 0xffffb7c3, 0xffffe507, 0xffffe6ae, 0x47b2,
+    0x18a5, 0xffff77c3, 0xffffa734, 0xffffc105, 0xffff8925, 0x7add, 0xfffffab0, 0xffffe3ec,
+    0x39d4, 0x74ba, 0x56ea, 0xffffebec, 0xffff8e36, 0x3b63, 0x931, 0xfffff745,
+    0x81c5, 0x368d, 0xffffbca4, 0xffff80b1, 0xffffe01f, 0xfffff52c, 0xffffacf4, 0x486f,
+    0xffffc5e0, 0xfffffaae, 0x10d4, 0x5ea8, 0x4832, 0x38b4, 0x6894, 0x6002,
+    0xffffdf3b, 0xffffa4a1, 0xffffe890, 0xffffb7b1, 0x3fee, 0x3c88, 0x1b52, 0xffff8883,
+    0x1f6c, 0xfffff5ac, 0xffffc0cb, 0xac9, 0xcd4, 0x14f7, 0xffffa823, 0x21e2,
+    0xffff8831, 0x5526, 0xffffc6a1, 0x4551, 0xffffa492, 0xffff9837, 0xffffa222, 0xffffde9d,
+    0x1efc, 0xffffec4e, 0xffffd75b, 0x3268, 0xffffc8d6, 0xffff7a3f, 0x4c9b, 0xffff86a0,
+    0x45e3, 0xffffddfb, 0xffff806b, 0x7aef, 0xffffcfa4, 0x30ef, 0x7f2b, 0xffffa3bf,
+    0x46d7, 0xfffff316, 0x3720, 0x6dd9, 0xffffdb02, 0xffffbc61, 0xffffdd72, 0x81b9,
+    0x1bf4, 0xffffb670, 0xffffcd6c, 0x37d8, 0xffffbd23, 0x4df6, 0xfffff2eb, 0xfffff687,
+    0x8b59, 0xffff909b, 0x34cd, 0xffffc786, 0x143b, 0x8570, 0xffffc38e, 0x965,
+    0xffffd3a1, 0xffffac12, 0xffffbb63, 0xffffe93f, 0x12d2, 0xffffe053, 0x3b2b, 0x4bcd,
+    0x52f2, 0xfffff538, 0xffffb301, 0xf71, 0xffffb774, 0xffffd5ba, 0xffffbe11, 0x1121,
+    0xffffa83d, 0x1a5a, 0x1ce, 0x8a49, 0xffffccb0, 0x82d2, 0xffffb440, 0xffff8a82,
+    0xffff91fe, 0xffff8bad, 0x3e1d, 0x5005, 0xffffb167, 0xffff8f02, 0x1a0b, 0xffffc6d1,
+    0x6303, 0xffffb2fe, 0xffffae6b, 0x507c, 0xffff907f, 0xffffeecd, 0xffff801b, 0x7b03,
+    0xffffe69a, 0xffff8454, 0xffff8110, 0x2195, 0x60df, 0xffffe944, 0xffff7ac8, 0x21d,
+    0x798, 0xffffed4d, 0xffff78b9, 0x36fa, 0xffff7616, 0xffffbf0e, 0x32c0, 0xffffcc92,
+    0x294d, 0x819b, 0x2413, 0xffffaa63, 0x7ae7, 0xffff72bb, 0x6505, 0xfffff0e8,
+    0x7b0f, 0xffff7b00, 0xffff8a4b, 0xffff8f23, 0x2336, 0xffffe49d, 0xffff9a9c, 0x478d,
+    0xffffc085, 0x6059, 0xffffd216, 0xffff9e9b, 0x5e49, 0xffff7f3e, 0x6038, 0x6ad9,
+    0xffffc10b, 0xffffd364, 0xffff7ecc, 0x6fef, 0xffff7809, 0xffffc298, 0x835f, 0xffffb70d,
+    0xffffbc76, 0xffffc2fa, 0x1779, 0x247d, 0xffffdbe8, 0xffffb8de, 0xffffb96f, 0xffff81ff,
+    0xffffbea1, 0xffffa830, 0xffff7fcd, 0xfffff310, 0x51fe, 0x65dd, 0xffff9f9f, 0xffffc799,
+    0xffff8390, 0xffffd9da, 0xffffbb03, 0xffffb886, 0x6e67, 0x5799, 0x677b, 0x45ad,
+    0xffff934b, 0x70b5, 0x44d0, 0x2f7e, 0xffff7568, 0x15b2, 0xffffbb0d, 0x7bf6,
+    0x2605, 0x2b90, 0x4916, 0xffff9cd0, 0xffffaef8, 0xffffe9ab, 0x7fbe, 0xffffac1a,
+    0x846, 0xffffc2d1, 0xffffbfba, 0x7699, 0xffffbfb5, 0xffffdef6, 0xffffbfed, 0x2d29,
+    0xffffee6e, 0xffffb0c7, 0x8879, 0x8584, 0x3415, 0xffffc2e9, 0xffffc15a, 0xffffa8c4,
+    0x3d0c, 0x31ab, 0xffffc3e1, 0xffff8bd4, 0x2ce5, 0x409c, 0x4243, 0xfffff9ce,
+    0xffffecff, 0x27c6, 0xffffcddf, 0x6137, 0xffff96f2, 0xffff8d64, 0xffff9537, 0x8566,
+    0xffffdf03, 0x6ef9, 0x7ada, 0x1413, 0x46e4, 0xfd7, 0x2c50, 0x7295,
+    0xffff8827, 0x8938, 0x3392, 0xffffe413, 0x6e09, 0xffff811b, 0xffffba76, 0xffffc622,
+    0x4554, 0xffffba5e, 0x6476, 0xffffb6f3, 0x2589, 0xffffcb99, 0x121a, 0x7e6d,
+    0xffffd01a, 0x5bb5, 0xfffff271, 0x5031, 0x528d, 0x63f7, 0x7e28, 0xffffec61,
+    0x18e, 0x1915, 0xffffaa49, 0xfffffd82, 0x6e94, 0x80c3, 0xfffff9b9, 0xffff9231,
+    0x2b46, 0xffffb3c1, 0x8ef, 0x220e, 0xffffa349, 0x3649, 0x8397, 0xffff981d,
+    0x6ad9, 0xffffaee7, 0x1fa9, 0xffffab33, 0x1e07, 0x7698, 0x7732, 0xffffe853,
+    0xffff7232, 0x4f9f, 0xffffcbbf, 0xffff7feb, 0x68ce, 0xffffbdf9, 0x17d4, 0x2ee8,
+    0x12c4, 0x8112, 0xffffb67d, 0x4914, 0xffffd9a2, 0xffff9e22, 0x74c8, 0xffffd9d8,
+    0x5ed2, 0xc27, 0x3957, 0x39ca, 0xffffae61, 0x4edd, 0x15d8, 0x50b9,
+    0x5077, 0xffff9787, 0x421a, 0xffff7ec0, 0xffffb93c, 0xffff922c, 0x867f, 0x855c,
+    0xffff91fc, 0xffff8bc5, 0xffff8a93, 0x3e3f, 0xffff7c92, 0x772f, 0xffffaedc, 0x474e,
+    0xffffb582, 0x135b, 0xffffb468, 0xfffff11d, 0x6298, 0x43bd, 0xffff9698, 0x43e1,
+    0xffffc5a7, 0xfffffed5, 0xffffd9be, 0x4176, 0x322d, 0x6eef, 0xffffbdda, 0xffffce75,
+    0xffff990d, 0x1857, 0xffffe0bc, 0x639e, 0xffffb5de, 0xfffffa1b, 0x70c8, 0x3404,
+    0xffffd256, 0xffffd016, 0x7b8b, 0x69ad, 0x843c, 0xffffe02d, 0xffff7409, 0x4bc2,
+    0xffffa87d, 0xffff7408, 0xffffd4d3, 0x27a2, 0xffff74a7, 0xffffc225, 0xffffc7a1, 0xffffcaa1,
+    0x3a52, 0x2fe3, 0x36c3, 0x4f3c, 0xffffb5b5, 0x1ec0, 0xffffac64, 0x5f2c,
+    0x1f24, 0xffff9dbf, 0x482e, 0x384b, 0xffffb6ca, 0x1acf, 0x66d6, 0x2652,
+    0xffffd61d, 0xffff88fc, 0xffff7bed, 0x1862, 0xffffcf25, 0xffffb8e2, 0xffff9823, 0x526f,
+    0xffff8e92, 0x6309, 0x4888, 0xffffe6f9, 0x631, 0xffffd94a, 0x1cd3, 0xffffa01b,
+    0x43d8, 0x2793, 0x6557, 0x794b, 0x1383, 0x269, 0x1240, 0xffffe15c,
+    0x69c5, 0xffffe7b1, 0x8d62, 0x2ecc, 0x7ab3, 0xffff7c8a, 0xffff7d9c, 0x7270,
+    0x5c06, 0x7667, 0x1006, 0x7c60, 0x53af, 0xffff8990, 0x4bf4, 0x7183,
+    0x2675, 0x30f1, 0x2478, 0x6124, 0xffff8265, 0x116e, 0xffffab22, 0xffffda7e,
+    0xffff8517, 0x89fc, 0xffff7a6e, 0xffffb9f7, 0xffffd29e, 0xffffa22b, 0x461, 0xffff8708,
+    0x1bcb, 0x7e6d, 0xffffc54a, 0x5d4d, 0x88a1, 0xffffdf3b, 0x1d91, 0x12b6,
+    0xffffeb16, 0xffffe8ea, 0x30f0, 0xffff7427, 0xffff7d09, 0xfffff64e, 0xffff8896, 0xffffa354,
+    0xfffff72e, 0xffff81d9, 0xffff996c, 0xffff74a4, 0xffffc3cf, 0xfffff2d2, 0xffffbf2c, 0xffff741d,
+    0xffffd89c, 0xffffc38a, 0xffffde7d, 0x5f1c, 0xffffb1bb, 0xffffa21f, 0xffffb38e, 0x8236,
+    0xfffff3ed, 0xffffce5d, 0x585e, 0xffffbe23, 0xffff8372, 0xffffaf4d, 0x3fcf, 0x3927,
+    0x5dda, 0xffffa074, 0xf76, 0x6969, 0x4196, 0x875e, 0xffffb681, 0x35bc,
+    0xffffbf70, 0x15af, 0xfffff405, 0x8b2a, 0x6d4c, 0x218d, 0x89bc, 0xffff9efe,
+    0xffffc56b, 0xffff942b, 0xffff8aa0, 0x4739, 0x6f8f, 0xffff8a85, 0x6c68, 0xffff958c,
+    0xffff9507, 0xffff9771, 0x3fb7, 0xffff8354, 0x6186, 0xffff90d7, 0x1520, 0xffffe018,
+    0x3b58, 0x411d, 0xffffdc5f, 0x1ecd, 0xc86, 0xffffa92a, 0xffffeaa6, 0x73a,
+    0x3def, 0x58de, 0x4933, 0x675d, 0x5e3, 0x25e2, 0x3eb, 0x714d,
+    0xa3a, 0xffff8420, 0xffffcb78, 0xffff887a, 0xffff7747, 0xffffff76, 0x280b, 0x2abd,
+    0xffffbdcd, 0x7dc1, 0xffffac20, 0xffffc30a, 0xffff7238, 0x27f3, 0xffffce4b, 0x398d,
+    0x4244, 0x3750, 0xffffc875, 0xffffc657, 0xffff9c8c, 0x3779, 0x55ce, 0x49d2,
+    0xfffff9b4, 0xffffd3a7, 0xffffade9, 0x3b41, 0x681f, 0xffff8812, 0xffff7a5a, 0xffffc989,
+    0x49e6, 0x3783, 0xffffb5f4, 0x70ba, 0xffffbf48, 0x8933, 0x3314, 0x2047,
+    0x111e, 0xffffd1e0, 0xffffea38, 0xffff779e, 0xffffabe9, 0xffffe109, 0xffff9c1c, 0x3fdd,
+    0x157b, 0x2726, 0x480, 0xffff7635, 0xffffb05d, 0xffff82de, 0xcec, 0xfffff7d9,
+    0xffffb171, 0x45f9, 0x8a9f, 0x1d04, 0x1b06, 0x80b, 0x39a9, 0xfffff58c,
+    0x274c, 0x1abd, 0xffff7ae0, 0xffffc2a1, 0xffffce98, 0xffff9427, 0xffffa278, 0xffff8c58,
+    0x31d6, 0x6f95, 0xef0, 0xffffd311, 0xffff95a0, 0x7c0b, 0xffffaf59, 0x934,
+    0x73b3, 0xffff98df, 0xffffa574, 0x6069, 0xffffead8, 0x671f, 0x5c9f, 0x4354,
+    0x23dc, 0x1c3f, 0xffffbc97, 0x22d2, 0xffffdd4e, 0x1239, 0x3af3, 0xffffefad,
+    0x6121, 0xffffd1e6, 0x66da, 0xffffcc0a, 0x63ea, 0xfffffc17, 0xffffc2d6, 0xffffa0f2,
+    0xffffc2d3, 0xffffa772, 0x4b13, 0xffffcfba, 0xffffee11, 0x6561, 0x38cc, 0xffffabbe,
+    0xffffe3f2, 0x4c6b, 0xfffff7ef, 0x6373, 0xffffeed8, 0x34cf, 0x59d9, 0x2699,
+    0xffffd7fa, 0xfffffa92, 0xffffac49, 0x62d7, 0x6daa, 0x4ab3, 0xffffaf00, 0xffffce18,
+    0xffff7e6c, 0x118, 0x72fe, 0xffff874a, 0x645, 0x2d6f, 0xffffa91f, 0x7443,
+    0xffff82ca, 0x553f, 0xffffb391, 0xffff83c6, 0x581a, 0x4124, 0x4d68, 0x5981,
+    0x40c2, 0xffff925c, 0x10e3, 0xffff957f, 0x7b13, 0xffff9008, 0x3563, 0xffffb7d3,
+    0xffff8c80, 0x8508, 0x8a7e, 0xffffd76b, 0x5321, 0x39bb, 0xffffe271, 0xffffa6fa,
+    0x758e, 0x3092, 0xffffd014, 0x2666, 0xffff745f, 0xffffb06f, 0xffff861c, 0xffffe4c9,
+    0x306f, 0xffffc98f, 0xffff950b, 0x2139, 0x7698, 0xffff9796, 0x1df5, 0xfffff0f9,
+    0x112c, 0x467a, 0x211b, 0x4469, 0x168f, 0x38b7, 0x2007, 0x2908,
+    0x24, 0x280e, 0x5051, 0xffffb28f, 0x4c68, 0x836a, 0xffffea37, 0xffff9080,
+    0xffff95e1, 0xffffe897, 0xffffcabd, 0xffff87dc, 0x88c2, 0x4507, 0xffff8a98, 0x405f,
+    0x52c8, 0xffffc450, 0x204a, 0xffff8690, 0xffffec68, 0x28a5, 0xffffdb3c, 0xffffa42c,
+    0x13e2, 0xffffb958, 0x595d, 0x4eae, 0xffff8001, 0xffff7f70, 0x4a8c, 0x748b,
+    0xffffb9ea, 0xffff87ba, 0x4a61, 0xa72, 0xfffffc5b, 0xffff9428, 0xfffff71c, 0xffffa0d7,
+    0xffffd5c7, 0xffffcd3f, 0xffff77eb, 0xfffff986, 0xffff92c6, 0x57a0, 0xffffe759, 0x815c,
+    0xffff8cb3, 0xffffcdc4, 0x6a3f, 0x1a8, 0xffff7840, 0x60bd, 0xffffb606, 0xffff8946,
+    0xffffebc2, 0xffffaae5, 0xffffce9d, 0xffffca7c, 0xffff761c, 0x3ffb, 0xffffc9e6, 0xffff94b5,
+    0xffff7888, 0x63fc, 0xffff8da1, 0xffffd969, 0x21b0, 0x47be, 0x39e9, 0xffffee2b,
+    0xffffbc45, 0x82a2, 0x243d, 0x75bc, 0xffff88cf, 0x8c54, 0xffffb154, 0xffffa214,
+    0xffffb8bb, 0x8a04, 0xffff87de, 0x8cd6, 0xffffd8d3, 0xffffc81e, 0xffffdf1c, 0xffffb674,
+    0x5782, 0xffffa361, 0xffffcd7b, 0xffffe9d7, 0xffff9bbf, 0xffffcae9, 0xffffeab3, 0xffffd75e,
+    0xfffffab2, 0xd68, 0x8288, 0x5177, 0x5f43, 0xffffeebd, 0xffffc78f, 0xffff72d2,
+    0x812, 0x752a, 0xffffc8ce, 0xfffff6d2, 0xdb9, 0x6b64, 0x3527, 0xfffff063,
+    0x79be, 0x6579, 0xffffe19c, 0x226f, 0xffff9529, 0x1eb8, 0x8747, 0x41e2,
+    0xffffde27, 0x46e7, 0x86bf, 0xffffa714, 0xffff93c7, 0xffffe02a, 0xffffc1e6, 0x36de,
+    0xffffc76e, 0x43ed, 0x65a, 0x6cf4, 0x57f3, 0x4916, 0xffffecae, 0x7ca7,
+    0x5c09, 0x48f0, 0xffffb23e, 0xffffaecc, 0xffffa88b, 0xffff7d10, 0x87c4, 0x669f,
+    0x56c2, 0x43d, 0x8c6b, 0xfffff478, 0x87cb, 0xffffd0f4, 0xffffa7a1, 0x25e7,
+    0x5a3d, 0x1df, 0xfffff384, 0x3438, 0x1ce8, 0x800, 0xffff8048, 0xffffad8a,
+    0xffff9d72, 0xffff73f5, 0x818d, 0x420a, 0xffffae9d, 0xffffc332, 0xffffbe39, 0xffffce52,
+    0x5b09, 0xffff8635, 0x1157, 0xffffb3d7, 0x33d1, 0xffff8149, 0xffffbe1d, 0xffffff1d,
+    0xe7c, 0xa66, 0xffff8167, 0x191d, 0x1beb, 0xffff82ec, 0xffffa8a3, 0xffff78af,
+    0x52ca, 0xffff7862, 0x7c41, 0x8b97, 0xffffbe29, 0xffffcaac, 0x7279, 0x893c,
+    0x3b70, 0x7947, 0xffffed3c, 0xffffe6e8, 0x3dcb, 0x1d01, 0x88cf, 0xffffb5ae,
+    0xffffa7ef, 0xffffece8, 0xfffffb0a, 0x1c20, 0x3691, 0x4f, 0x40aa, 0xffffebe0,
+    0x5fa0, 0x38, 0x44dd, 0xffff8ab5, 0x2c13, 0xffffd8b8, 0xffff9f3d, 0x8815,
+    0x8683, 0x6a60, 0x1a12, 0xffffa788, 0x5215, 0xffffcc46, 0xffff75bd, 0xffff8c9d,
+    0x2871, 0xffff889e, 0xffff9608, 0x8d91, 0x8c85, 0xffffc2ee, 0x458b, 0x48e7,
+    0x1d47, 0xffffe974, 0xffffa020, 0xffffe1fd, 0x6f80, 0x8264, 0x885, 0x4317,
+    0xffffd135, 0x89c9, 0xffffb412, 0xffff7b42, 0x5b21, 0x5a98, 0xffffbc39, 0x16c0,
+    0xffff7c6e, 0x286b, 0x1996, 0xffffd5e6, 0x5fb3, 0xffff950f, 0xe62, 0x215d,
+    0x2328, 0xffff7dc1, 0xffffacb9, 0x1483, 0x3da9, 0x74e7, 0x410e, 0x8253,
+    0x4216, 0x1ff1, 0x4d3a, 0x3771, 0x817a, 0xffff73f2, 0x624e, 0xffffff16,
+    0x3dc5, 0x1384, 0x377c, 0xf2, 0x4bf2, 0xffff74f7, 0x3060, 0x728d,
+    0x2aee, 0x7273, 0xffff8fbf, 0x1106, 0xffff89df, 0xffffc920, 0x3582, 0x25fd,
+    0xffffce73, 0xffffe0f1, 0x6219, 0xffffadc3, 0xfe9, 0xffff837f, 0xffff9048, 0x781f,
+    0xffffb93b, 0x189f, 0xfffffb71, 0x16d2, 0xf5e, 0xffffb0bf, 0x62f8, 0x51e2,
+    0x2c58, 0x5d59, 0xffffc837, 0x161a, 0xffffa164, 0x39c, 0x10a3, 0xffff79f8,
+    0xfffffd31, 0xffffb4e3, 0xffffc92d, 0x6f16, 0xffffab27, 0xfffff0ba, 0x1be7, 0xffffb0a9,
+    0xffffe906, 0x3a70, 0xffffaf42, 0x8b55, 0xffffa625, 0xffffca7e, 0xffff7fdb, 0x4078,
+    0x5d41, 0x7798, 0xfffff767, 0xffff964e, 0xffffd7df, 0xffffa537, 0x3b4a, 0x35d0,
+    0x5ba2, 0xffffd3b1, 0xffffb2e2, 0xffffd0e7, 0x3602, 0x72f1, 0xffff8dcc, 0xffff7ade,
+    0xffffb1ee, 0xffffafa9, 0xffffdad2, 0xffffea6a, 0x6667, 0xffff941e, 0xfffff259, 0xfffff365,
+    0x15be, 0x1280, 0xfffffcab, 0x8bb6, 0xffffbf10, 0xffffb64d, 0x408f, 0xfffff18a,
+    0xffff9956, 0xffffa946, 0x71e3, 0xffffe7e8, 0xffff7ddc, 0xfffff570, 0x1c0f, 0xffffc10d,
+    0x6e81, 0x367d, 0x2846, 0x635e, 0xffff74fc, 0x4b36, 0xfffff47b, 0x8b6b,
+    0x7d7, 0xffffeb07, 0xfffff577, 0xffffb507, 0x42a5, 0x733c, 0xffffe9a2, 0xffffe885,
+    0xfffff77a, 0xd37, 0x5f47, 0xffffc515, 0xfffffd88, 0xffffeb05, 0xffffcb7f, 0xffffa183,
+    0x63df, 0x896f, 0x7fd9, 0x5f5, 0xffffc008, 0x29ac, 0x360e, 0x259d,
+    0x7d1, 0xfffff226, 0x3d55, 0xffffabfd, 0x54b4, 0x3085, 0x59a1, 0x8a1e,
+    0xffff85f4, 0xffffef3e, 0x49e5, 0xffffe51a, 0xfffffe96, 0xffffdea7, 0x328a, 0xffffa638,
+    0x4ced, 0xffffb2d8, 0xffffec06, 0x854b, 0x46a, 0xfffff0e7, 0x8922, 0x8266,
+    0x280a, 0x68a6, 0x5210, 0x6a2, 0x4142, 0xffffca2d, 0xffff9e3b, 0x5dd5,
+    0xffffe648, 0xffffaac4, 0x22d9, 0xfffff89e, 0x4059, 0xffffab1f, 0xffffd230, 0xffff8d23,
+    0x6cf, 0x6067, 0xffffed0e, 0xffff74f8, 0x58ee, 0xffff964e, 0xffffe204, 0x5e81,
+    0xffff9d1e, 0xffffa77a, 0xffffef8a, 0xffff8f01, 0xffff7694, 0x6c0b, 0x7293, 0x72b2,
+    0xffffa48b, 0xffffeb04, 0x1953, 0x1d, 0xffff888f, 0xffff7b0a, 0xffffa134, 0x7fe3,
+    0xffffacc2, 0x471, 0x999, 0x4397, 0xfffff6a0, 0x7af2, 0xffffaac9, 0xffffe255,
+    0x1170, 0xffffaaec, 0x2b92, 0xffff96a5, 0xffffd8b4, 0x3e4a, 0x44b0, 0xffffefdf,
+    0xffffc299, 0xffff7360, 0xffff7ec4, 0x4be8, 0x2e91, 0xffffc8dc, 0xffffb89a, 0xffff8894,
+    0xffff9818, 0xffffb4a1, 0x669, 0x892, 0x8c52, 0xffffe05d, 0x6fc3, 0xffff861c,
+    0x19f4, 0x876d, 0x2260, 0xffff873f, 0x363e, 0xfffff093, 0x1434, 0x840b,
+    0x648b, 0xffff8ebb, 0x1a62, 0x604e, 0x5874, 0x4304, 0x6f7e, 0xffff8c56,
+    0x603b, 0xffffbaa1, 0xffffe654, 0xffff7ea9, 0xffff9791, 0xffffc749, 0xffffa7d9, 0x11e6,
+    0xffffa58d, 0x6995, 0x4a1c, 0x362e, 0xffff9be4, 0x8266, 0x304, 0xffffbe5c,
+    0xffffb4e6, 0xffffa022, 0xffff821f, 0x1170, 0xffff8639, 0xffffcbf0, 0x2364, 0x6c9a,
+    0xffff8726, 0xffff9417, 0xffffea48, 0xffffb072, 0x5f33, 0x4896, 0xffff7762, 0x65e9,
+    0xfffffd0a, 0x57f, 0x3b2c, 0xffff751d, 0xffff8c1f, 0xffffef92, 0x7117, 0xffffed28,
+    0x8b9f, 0x764b, 0xfffff95d, 0xffff8346, 0xffffada7, 0xffffcd90, 0xffffa794, 0x22f6,
+    0x5821, 0x2a57, 0xffff7575, 0xffffc0a9, 0xffffc11c, 0xffff954c, 0x921, 0xffffb22e,
+    0x6fa4, 0x5f18, 0xffffcc0d, 0xffffd4eb, 0xffff8fd0, 0xffffd740, 0xffffc4d2, 0x5b17,
+    0x7391, 0xffffdc3a, 0xffff923d, 0x4572, 0xffffaf19, 0xffffc9fb, 0xd70, 0x4c5d,
+    0xffffb57d, 0x7eda, 0x60ce, 0x3db6, 0x6478, 0xffff81ca, 0xffff8e3f, 0xffffae43,
+    0x8aad, 0xffff76a0, 0x2d2d, 0xffffc6ed, 0x89c4, 0xfffff0bd, 0xfffff634, 0xffff86cc,
+    0x8934, 0x5c28, 0xfffff07a, 0xffffc810, 0xffffc4d5, 0xffff931a, 0x6cc1, 0xffff820d,
+    0x4ad9, 0xffffe2ec, 0x5400, 0xffffce27, 0xffffa35b, 0xfffffa9a, 0xffffc984, 0x29db,
+    0x198b, 0xb84, 0xffff7987, 0x43fc, 0x475f, 0x432d, 0xffffe7cc, 0xffff9245,
+    0xffffef67, 0x60c2, 0xffffa260, 0x3a6a, 0x6739, 0x6685, 0x1b66, 0xa0,
+    0xffff76b4, 0x2f5f, 0x8857, 0xffffa00d, 0xffff8549, 0x203e, 0x841f, 0x28a6,
+    0x4193, 0xffffa1d6, 0x798f, 0x5d16, 0x279b, 0x9b1, 0xffffd61c, 0xffff9bce,
+    0x3ecd, 0xffffc062, 0xffffac02, 0xffffac45, 0x150e, 0x7e22, 0xffffc92e, 0xffffe529,
+    0x60da, 0x3950, 0x3d86, 0x1575, 0x182f, 0x7ee7, 0xffff8da9, 0x1a01,
+    0x2e85, 0x7cd5, 0xffff8cc0, 0xffff730f, 0xffff8fe1, 0xffffeb15, 0x3bb7, 0x2d60,
+    0xfffffaa0, 0xffffbd0f, 0x33b2, 0xffffd0be, 0xffffc2df, 0xffff7f81, 0x6400, 0xffffd43b,
+    0xffffc823, 0x418c, 0xd2f, 0xffffa895, 0x8c3c, 0xffffbaeb, 0x7f05, 0xffffa145,
+    0x660d, 0xffffa464, 0xfffff7ba, 0x8a12, 0x5b5a, 0xffffc222, 0xffff999e, 0xffffe91a,
+    0x1bd9, 0xffffb0f5, 0x8202, 0x7319, 0xffff877a, 0xffff97b7, 0xffffc451, 0xffffa669,
+    0x34b1, 0xffffbcda, 0xffffb333, 0x76fa, 0x4fb3, 0x1bfa, 0x8822, 0xffffcd78,
+    0xffff7440, 0xfffffb6c, 0xffffb200, 0x4f19, 0x33ed, 0xffffb977, 0x26b, 0xfffff89d,
+    0xffffa1de, 0x61ec, 0x1d9c, 0xffff76c0, 0xffffb7c1, 0xfffff027, 0x700c, 0xffff841a,
+    0xfffffd62, 0xffff8baf, 0x4562, 0x7eab, 0x2ac8, 0xffffca3d, 0x6a8c, 0xffffc5c5,
+    0xffff76cf, 0x454e, 0x44b2, 0x2e49, 0x551c, 0x4b86, 0x734c, 0xffff9db0,
+    0x1d8, 0xffff9219, 0xffffe716, 0xffff7e4f, 0xffffcad7, 0x208, 0xffffa001, 0xffffe587,
+    0xffffeed7, 0xffffc27b, 0xffffc41d, 0x4531, 0x7ee, 0xffff755f, 0xa10, 0x1d02,
+    0xffff75fe, 0xffff9543, 0x237f, 0xffffabf2, 0xd2, 0xae9, 0x2785, 0xffff85c8,
+    0xffff9b84, 0xffffc2d6, 0xffffe149, 0x28ae, 0xffff75f9, 0xffff9667, 0x5647, 0x76e9,
+    0xfffff7f3, 0xffffa9ae, 0xffffc163, 0xffff8412, 0xfaf, 0x1cde, 0xffff888f, 0xffff7e2f,
+    0xffffd400, 0xffff8602, 0x37de, 0xffffb80c, 0xffffd2e9, 0x11ba, 0xffffb448, 0xffff9253,
+    0x603a, 0x71c9, 0x4d23, 0x48c7, 0xffffc84d, 0xffffe1fb, 0x47db, 0x1877,
+    0x45af, 0xfffff561, 0xffffd599, 0x7c57, 0xffff8cd4, 0xffffbc8b, 0x61db, 0x37a0,
+    0x1544, 0xffffca6a, 0x8d85, 0x768f, 0xffff897a, 0xffff923c, 0xffffecde, 0xfffff499,
+    0x100c, 0x5097, 0x8dd1, 0x1d2c, 0xffffd766, 0x31a3, 0xffff9f7e, 0x31e8,
+    0x2744, 0x8dad, 0xffffd73e, 0x33ab, 0x3fed, 0xfffff38c, 0xffffe07f, 0x7827,
+    0xfffffc55, 0x6531, 0x526b, 0x2399, 0x3c8c, 0x4633, 0xffffaafa, 0x11da,
+    0xfffffca9, 0xffff7c90, 0x4499, 0x3445, 0x12c4, 0x2210, 0xffffe1e1, 0x431b,
+    0x45da, 0xffff72cf, 0xffffdae7, 0x6ee7, 0xffffb843, 0x7930, 0xfffffc7c, 0xffffda3e,
+    0xffff89d1, 0x8d06, 0xe73, 0xffff82c9, 0xffffeeb8, 0xffffc7dc, 0x3e13, 0xffff9f2f,
+    0xffff7e2a, 0xffff7eaf, 0x6cb0, 0x5077, 0xc26, 0xffff9fcb, 0xffff7e45, 0x1bc3,
+    0x6cd7, 0x800e, 0x333f, 0xffffef38, 0x3294, 0x38c5, 0xffff9860, 0x7fe2,
+    0x1846, 0xffffc870, 0x8798, 0xffffa794, 0x3433, 0x70a5, 0xffffe031, 0xffffbd5a,
+    0x626c, 0xfffff816, 0x7b1, 0x83fc, 0xffff9362, 0x306, 0x7587, 0xffffdb69,
+    0xffff89e4, 0x1da2, 0x5532, 0xfffffd49, 0xffffba57, 0xffff8941, 0xc84, 0x6b89,
+    0xffffecd4, 0x2578, 0x8a3e, 0xffffbd94, 0xffff8bc6, 0x7a73, 0x5cfc, 0xffffa543,
+    0x4605, 0xffffbde5, 0x8cfe, 0x150b, 0xffffd23e, 0xffffa042, 0xffff7b69, 0xfffff168,
+    0x1c44, 0xffff72f5, 0xfffff3c2, 0xfffff9ed, 0xffffeca1, 0x2d48, 0xffff9bce, 0x272b,
+    0xffffc260, 0xffff929d, 0x3cb9, 0x5c11, 0x5d4, 0xffff8ad7, 0x6aa9, 0xfffffb80,
+    0x572b, 0x2cbd, 0x5e8a, 0xffffb586, 0xfffff8e7, 0x6f5b, 0x28ce, 0x11a,
+    0x71f5, 0xfffff744, 0x1be2, 0xffff95cd, 0x6cef, 0xffffc7f6, 0x1ac3, 0x8c96,
+    0xffff760f, 0xffffa1ba, 0x370, 0x3277, 0xffff817a, 0xffffcee6, 0x195e, 0xffff7ccb,
+    0xffffca7b, 0xffff9d90, 0x540e, 0x6725, 0xffff75a3, 0x48a5, 0xffffada6, 0xfffffdad,
+    0x32e4, 0x1e1e, 0xffffe0eb, 0xffffed3c, 0xfd, 0xffff9fbf, 0x4878, 0x8dbc,
+    0x3ef3, 0xfffffcd0, 0x80e5, 0x77b5, 0x8b4b, 0x7003, 0xffffb759, 0x8938,
+    0x4a57, 0xca9, 0x6783, 0x27ee, 0x2c7a, 0xffff8bf7, 0xffffe754, 0x2a23,
+    0x60ea, 0xffffc6bc, 0xffffb024, 0x34b2, 0xffffe44f, 0x2f16, 0x3df3, 0x883c,
+    0x3eb1, 0xffff81dd, 0x5e00, 0x7ae1, 0x62bc, 0xffffcb8d, 0xffffd0eb, 0x457f,
+    0x6bb3, 0x72a2, 0xffffb521, 0xffff7d69, 0xffffd032, 0x4d2, 0xffff9dcb, 0xfffffd7d,
+    0x44d, 0x3c01, 0x34ed, 0xfffff07f, 0x74a6, 0x894, 0x524d, 0xdb3,
+    0xcb3, 0xffff9661, 0xffff9d9a, 0xffffdae6, 0xffffd8df, 0xffffe241, 0x14a9, 0xffff79ad,
+    0x1d71, 0x17e9, 0xffffcee6, 0x58cc, 0xffffa52b, 0x7b08, 0xec7, 0x5a66,
+    0xffff7f3c, 0xffffc522, 0x210d, 0x109c, 0x162d, 0x4654, 0xfffffee4, 0x1b68,
+    0x7e7b, 0xffffb804, 0xffff9c77, 0xffffa259, 0xfffffcdc, 0xffffb126, 0x6f3e, 0x597e,
+    0xffff8c8b, 0xffffb09a, 0x4d39, 0x8bc3, 0x1208, 0x63f, 0x7e6a, 0x3bb1,
+    0x8dd9, 0x4cac, 0xffff803c, 0xffff9d29, 0xffffa2d6, 0x1a9a, 0x16fe, 0xffffc6c9,
+    0x6ff1, 0xffffb441, 0xffffbdc5, 0xfcd, 0xffffe445, 0xffffa0f3, 0xffffef93, 0xffffdd4e,
+    0x3fe8, 0x40a2, 0xffffeac0, 0x6f7d, 0xffff83d1, 0x459e, 0x6eee, 0x7da,
+    0xffff9f26, 0xffff9da6, 0xffffb81c, 0x25c8, 0x32a6, 0x2351, 0xffff7450, 0xffff90f0,
+    0x16ee, 0xffffa868, 0xffffa2cb, 0xffff79fc, 0xfffffe99, 0x6a31, 0x1a59, 0xffffbca9,
+    0xffff8d29, 0xffffc840, 0xffffd7e8, 0xffff9128, 0xfffff92c, 0xffffd49d, 0xffffa0a4, 0x7533,
+    0x748, 0x4245, 0x34bc, 0x366c, 0xffffc838, 0x3265, 0x8226, 0x4aca,
+    0xffffe761, 0x19e, 0x46bb, 0xffffdafa, 0xffffdd98, 0xffffc1b8, 0x7aa8, 0xffffc744,
+    0xffff7766, 0xffffeb0c, 0x675b, 0x573, 0x5b52, 0xffffd638, 0x49a1, 0x5235,
+    0xffffcd48, 0xffff8960, 0xffff8468, 0xffffc6b1, 0xfffff7c1, 0x6995, 0x5eb4, 0xffffc196,
+    0xffff7779, 0x6104, 0xffff8f5b, 0x2928, 0x6cf0, 0x1b93, 0xffffbdd9, 0x1ca5,
+    0x81b, 0x64c3, 0xfffff230, 0xffffc185, 0xffffd191, 0xffff858e, 0x6eb8, 0xffffd904,
+    0x89ca, 0xffff8102, 0xffffc709, 0x39e2, 0x5bde, 0x1e9e, 0xffffb9c8, 0x81c2,
+    0xffffb753, 0xffff9bba, 0xfe5, 0xffffaabf, 0xffff82e0, 0xffffcc44, 0x22e0, 0x1053,
+    0x6b07, 0x2522, 0x6316, 0x5ddf, 0xfffff8fe, 0xffff896b, 0x8a7d, 0xffff9398,
+    0xffffa42f, 0x4f57, 0x71a, 0xffffef95, 0xffffb170, 0x12e9, 0xffff8147, 0xffffdc5c,
+    0xffff9d76, 0x2a39, 0x2a4a, 0x2d76, 0xffffa31c, 0xffffafcf, 0xffffb76e, 0x617c,
+    0xa00, 0xffff878f, 0xffff737a, 0x6f54, 0x7516, 0xffffbc9a, 0x39c8, 0x5bbe,
+    0x4d20, 0x32b6, 0xffff8d2f, 0xffffcee7, 0x46ef, 0x3bdb, 0xffffc557, 0xffffe1a6,
+    0xffff7a54, 0x6572, 0xffff9a6d, 0x7b59, 0x3be8, 0xffffd635, 0x1acd, 0xffffe77a,
+    0xffffa8c9, 0x531c, 0xffff8a3a, 0xfffff65d, 0xb96, 0x49b8, 0x735b, 0x791,
+    0x682b, 0xfffff0f6, 0x179e, 0xfffff2ef, 0x3992, 0xffffc2d8, 0xffffb85c, 0xffff9e2d,
+    0xffffdc7a, 0x1202, 0xffff761e, 0xffffae43, 0xffffddc9, 0xffff8377, 0xffffd6dc, 0x124,
+    0x493d, 0x2f55, 0xfffff8c8, 0x5f25, 0xfffff800, 0xffff738a, 0x3465, 0x1089,
+    0x4ea3, 0xffff83ec, 0x4f50, 0xffffaac4, 0x1c54, 0x58c5, 0xffffe6ab, 0xffff8a2e,
+    0x74b2, 0x6032, 0xfffff56b, 0x836c, 0xffff8f09, 0x8316, 0xffffeb3e, 0x257c,
+    0xffffd7c8, 0x671f, 0x4eab, 0x1220, 0xffff7c40, 0x3c05, 0xffffd400, 0x841,
+    0xffff7c1a, 0x5119, 0x371c, 0xffffb126, 0xffffa46d, 0xffff8f00, 0xfffffed8, 0x6db7,
+    0x1608, 0xffff7c99, 0x72a6, 0x7cad, 0xffff7831, 0x810d, 0x79d5, 0x1b55,
+    0xffffd273, 0x5d84, 0x5983, 0xffffff4a, 0x5005, 0x69bf, 0xffffe75f, 0xffffd029,
+    0xffffe1e8, 0xffff9e76, 0xff2, 0xfffff4d4, 0xffffe108, 0xffffb618, 0xffffed8b, 0xd27,
+    0x94d, 0x52ff, 0x8634, 0xffffa360, 0xffffffe3, 0xffffb0d8, 0xffffaaee, 0xfffff959,
+    0xffffbdaf, 0xffffc563, 0x2506, 0x4a98, 0xfffff9bb, 0x4ad2, 0x25f4, 0xffff9987,
+    0x5bf9, 0x8d03, 0x58d7, 0xffff988b, 0xffffe7b6, 0x1aeb, 0xffffdd88, 0xffffd037,
+    0xffff9db8, 0xffff77f7, 0x693, 0x8863, 0xffff9329, 0xffffb19f, 0x5447, 0x2606,
+    0x77dd, 0xffffbd47, 0xfffffb00, 0x4c00, 0xffff9169, 0x7d2a, 0x8548, 0xffffe574,
+    0x44b, 0xffffe68c, 0xffff9738, 0x4689, 0x27f6, 0x5a2c, 0x37a7, 0x529d,
+    0xffff7c73, 0x76f2, 0x242f, 0x8134, 0x30a8, 0x3ab2, 0xfffffe83, 0x3bd5,
+    0xffffc9ed, 0xffff7be3, 0x6356, 0xffffab4b, 0x6d2d, 0xffffb6dc, 0x1d24, 0x6908,
+    0x6aa6, 0x4fe3, 0xffffe221, 0xffff8985, 0x3389, 0x6062, 0x8700, 0x4834,
+    0x8cba, 0x842c, 0x15dd, 0x86ac, 0xffffa5c2, 0x375c, 0xffffc3e1, 0x2517,
+    0x2a44, 0xffffa391, 0xffffec55, 0xffff7bec, 0xffffb1e1, 0x5156, 0x7b17, 0xd57,
+    0x962, 0x4e52, 0x3b2e, 0xffffab67, 0xffffda44, 0x69e8, 0xffff78ec, 0xffffd084,
+    0xffff8488, 0x773a, 0x6c60, 0xffffa9c9, 0x6d4a, 0xfffffe96, 0xffffe0e0, 0x1bef,
+    0xffffde02, 0xaae, 0xffff9a10, 0x557, 0x4da9, 0x867c, 0x1741, 0x42f8,
+    0xffffd09b, 0xffffd2d1, 0xffffe212, 0xfffff266, 0x45ed, 0xffffe717, 0x6837, 0x76c1,
+    0xfffffef7, 0x5baf, 0xffffbee3, 0xffff830d, 0xffffb4fa, 0x372b, 0xffffb440, 0xffff8e7e,
+    0xffffa00d, 0xffffbb90, 0xffff92d7, 0xffffa723, 0xffffe18b, 0xfffffbe0, 0xffffdf88, 0xffff76d1,
+    0xffffd2af, 0x3a01, 0x8c46, 0xfffff48e, 0xffff8ada, 0xffffb3f4, 0x46ba, 0xffffa696,
+    0x4a04, 0x8cf1, 0x362f, 0xffffc320, 0x73d2, 0xffffa00f, 0xfffff6ad, 0x7269,
+    0x695e, 0x4812, 0x3b16, 0x6442, 0xffffa02b, 0xffffc2c0, 0xffffe410, 0xffffb923,
+    0x6012, 0xffffdcd3, 0xffffbdfe, 0xffff97be, 0x6ad6, 0xffffe081, 0xffff97e9, 0xffff8adf,
+    0xd9e, 0xffff7e8f, 0xffffc9c6, 0x6a7e, 0x53b9, 0xffff7fb5, 0x8314, 0xffff81f5,
+    0x1d86, 0x3e5d, 0xfffffd9d, 0x201e, 0xffffde6d, 0x2055, 0x7317, 0x167c,
+    0xffffcfa0, 0xffff9bbc, 0xffffa8e0, 0x2d83, 0x5a8d, 0xffffb0bd, 0x3926, 0x669f,
+    0x4b9e, 0x6345, 0x2c7, 0xffff91c9, 0xffff745a, 0x5091, 0x56a3, 0x6e45,
+    0x31ac, 0xffff9847, 0xffffbb04, 0x617c, 0x1374, 0x8dd7, 0xffffe142, 0xffffeb42,
+    0x9d4, 0xffff8b2d, 0x84fc, 0x3b6, 0x604a, 0xffffd453, 0xffffd691, 0xffff7927,
+    0xc47, 0x169d, 0x70bb, 0x10d4, 0x6b25, 0xffff8965, 0xffffc874, 0xffff7571,
+    0x2165, 0xffffbb50, 0xffff7623, 0xffffab6f, 0xfffff47a, 0xffffb87b, 0x14d1, 0xffffff82,
+    0xffffe1b8, 0xf6b, 0xffff74f4, 0xffffefb6, 0xffff88c0, 0x2eec, 0xffffade2, 0xffffdcd2,
+    0xffffb1cc, 0x334f, 0xffffc569, 0xffff8414, 0x8070, 0x7bfa, 0x8992, 0xffffcc6d,
+    0xffffa65a, 0x251f, 0x8bbf, 0x2463, 0xffff74d2, 0xfffff0cf, 0xffffde9a, 0x4f4a,
+    0xffff8446, 0xffffa4e2, 0x808a, 0xfffffadd, 0x723e, 0xffffd82d, 0x1f14, 0x8c71,
+    0xffffdc75, 0x6c3c, 0x4435, 0x472f, 0xffff7252, 0x22e5, 0x19c0, 0x88aa,
+    0xffffd423, 0xffff8758, 0x2758, 0xffffd33d, 0xffffe1bb, 0x83b3, 0x8535, 0xaa5,
+    0x7864, 0x6b59, 0x2ab7, 0x7e5b, 0x6df6, 0x6f3e, 0xffff908a, 0xffffb6d4,
+    0x4eca, 0xffffa83f, 0xffffff3f, 0xffff7a6a, 0xffff74aa, 0x37e9, 0xffff8a5e, 0xfffff391,
+    0xffffc4c1, 0x36fb, 0x21e2, 0x623d, 0xffff7306, 0xfffff202, 0x39cb, 0xffffcd47,
+    0x13b6, 0x630e, 0xffffa3e6, 0xffffeb86, 0x5eb8, 0xffff73c0, 0xfffffa42, 0x49fb,
+    0xffffed95, 0x718f, 0xffff7e6a, 0x1914, 0xffffa5e9, 0x8cf1, 0x2ae3, 0xfffff9e8,
+    0xffffec23, 0x697d, 0x5ab9, 0x77f0, 0xfffff222, 0x5ff0, 0xffffa34d, 0x82bc,
+    0x5950, 0x13c1, 0x5a9b, 0x570c, 0x4992, 0x405c, 0x3ecd, 0xfffff886,
+    0x1362, 0x1704, 0xffff87b3, 0xffffe31c, 0x7e6c, 0x27e7, 0x355a, 0xffff84c4,
+    0xffffe078, 0xffffc000, 0xffffd37a, 0x2690, 0x130d, 0xffffd22b, 0xffffa6c1, 0x12dd,
+    0x36db, 0x5507, 0xffff8c14, 0xffffb616, 0x71ab, 0xffffd884, 0xffff7ed4, 0x1871,
+    0x212a, 0xffff8acf, 0x353, 0x3bca, 0x7cfc, 0xffff7a5d, 0x5990, 0x4bb,
+    0xffff7606, 0x6328, 0x386, 0xffffd02b, 0xffffe3b6, 0xfffff0bb, 0x4b6f, 0x8dc,
+    0xfffff3ea, 0x169c, 0x3ed8, 0xffffa125, 0x3c69, 0xfffffedb, 0x6c9b, 0x17de,
+    0xffffb5f8, 0xef6, 0xfffffbc6, 0xffff82b9, 0xffff7a4e, 0x6193, 0x6994, 0xffffe6b5,
+    0xffffdb01, 0x5c14, 0x68a8, 0x26a4, 0xffffb021, 0x7bcc, 0xffff9f05, 0x814,
+    0x162c, 0xffffb3e7, 0x2c53, 0xffffc8e1, 0x6920, 0xffff7254, 0x6d49, 0xffffb4c2,
+    0xffffcaca, 0xffffe1cd, 0xffffd576, 0xffffbad8, 0xffffc4db, 0xffff7f6b, 0x758b, 0x1f19,
+    0x4407, 0x3b61, 0xffffa2ea, 0xfffff403, 0x26b, 0x6789, 0x5ca7, 0x3b3,
+    0x458b, 0xffffd823, 0xffff83b7, 0x2dc6, 0xffffbd8d, 0xffff7964, 0x77a3, 0x18bd,
+    0x7ada, 0xffffc92e, 0x32e2, 0xffffe36a, 0xffff79db, 0x6ca2, 0xffffafdb, 0xffffba78,
+    0x23cb, 0xffffc5ad, 0xffffe3f4, 0x89d5, 0x86ee, 0x13ca, 0xfffff25b, 0x3ebb,
+    0x680d, 0x628a, 0xffffce21, 0x44c, 0xffff7532, 0xffff72a6, 0xffff88d5, 0x8599,
+    0xffffe7cf, 0xffffbeed, 0xffffbcf5, 0x675c, 0x481d, 0x6ac3, 0xffffc0ae, 0x4ce4,
+    0x46ef, 0x2b3f, 0x47fd, 0x35f4, 0xc48, 0x3038, 0x7b9b, 0x302d,
+    0xffff85f4, 0x6652, 0xffff7f44, 0xffffec9b, 0xffffedd2, 0x2863, 0x2faa, 0x8cf1,
+    0xffffc4e8, 0xcb3, 0xffff925c, 0xffffc9c0, 0xffffad2f, 0x5eb1, 0x5697, 0x66bd,
+    0xffff8080, 0xffff98b1, 0x2955, 0xffffcdbd, 0xffffd6d8, 0xffff84a6, 0xffffe29c, 0xffff9edd,
+    0x391f, 0x625c, 0xffff8094, 0xffffbad3, 0xffff8b97, 0x7d06, 0xffffadce, 0x1036,
+    0xffffcbd0, 0x3027, 0xfffff405, 0x3104, 0xffffd411, 0x614d, 0x426b, 0x410,
+    0x3524, 0xffffddf3, 0x3c3b, 0x7663, 0x4d40, 0x7c3e, 0xffffa330, 0xffffbd4a,
+    0xffffce53, 0x989, 0xffffddc9, 0xffff92ed, 0x4449, 0xffffa2d2, 0xfffff261, 0x5c84,
+    0xfffff447, 0xfffff6c6, 0x4520, 0xffffa40d, 0xffffd253, 0xffffbf75, 0xffffaeea, 0x8c96,
+    0xffff7c66, 0xffffc745, 0x572b, 0x5167, 0xffffdc8a, 0x46cc, 0x5b66, 0xffffd61c,
+    0x3fc6, 0x7a63, 0xffffc4d8, 0xffffe8b4, 0xffffdc6a, 0x6f63, 0xffffd716, 0xffffbb46,
+    0x7426, 0xffff7dde, 0x26f1, 0xffffcd18, 0x1776, 0x4d89, 0x20c5, 0x6457,
+    0x371c, 0xffff8c94, 0xffff72e4, 0x7cc, 0x835b, 0xffffb776, 0xffff93e1, 0xffff83cd,
+    0x7241, 0xffffcfc4, 0xffffbda6, 0x63f0, 0xffffaa19, 0x7cf5, 0xffff8f8d, 0x1942,
+    0xffff87ae, 0x4e6d, 0xffff78d5, 0x6e8c, 0x3539, 0xffffc063, 0x73c, 0x76dc,
+    0xfffff8ff, 0xffffb5a1, 0x19bf, 0xffff7694, 0xf15, 0xfffff136, 0xffff82b9, 0xffffcc83,
+    0xffff88a4, 0xffffc7e0, 0xffff7256, 0xffffe068, 0x25b4, 0xffffed48, 0xffff8d7d, 0x5f8c,
+    0x1892, 0xffffd1e5, 0xffff7417, 0x7ecc, 0xfffffb74, 0x8c0c, 0x4758, 0xffffc7d7,
+    0xffffe764, 0xfffffe29, 0xffff88fa, 0xffffe66d, 0xffffdeb4, 0x2f2d, 0x646b, 0xffffce8c,
+    0x3769, 0x3912, 0xffffe6fb, 0xffffc166, 0xffffce02, 0x4dc7, 0x80b5, 0xffffc70d,
+    0xffffc36a, 0x30ea, 0x7441, 0x5fe4, 0xffff7812, 0xffffe92e, 0xffffcc86, 0xffffe27b,
+    0x49e2, 0x71c0, 0xffffab47, 0xffff9c51, 0x7377, 0xfffffc50, 0x7be0, 0x13e0,
+    0xffffe5f2, 0x2db1, 0x2610, 0xffff8258, 0xffff978f, 0x282b, 0x395, 0x1031,
+    0xffffb66c, 0xffff749b, 0xffffbf6f, 0xffffa7e1, 0x12f1, 0xffffcfa7, 0xfffff7fd, 0x6a21,
+    0x8a4d, 0x4ff5, 0x71be, 0x8096, 0x5502, 0x4f40, 0x81c5, 0x5a75,
+    0xffff8d39, 0x1bc0, 0xffff7827, 0xa59, 0xffff9929, 0x8db3, 0x5df1, 0xfffff7b2,
+    0x420a, 0x6544, 0x6509, 0x7451, 0x1e7f, 0x4f76, 0x315a, 0x3620,
+    0x5091, 0x4403, 0xffffd3e4, 0x5c0c, 0x80c2, 0x36c4, 0x5107, 0xffff943d,
+    0x6452, 0xffffad40, 0xffff9b98, 0x58ab, 0x27b3, 0xffff8be9, 0xffffa656, 0xffffa5f8,
+    0xffffbd22, 0xffff73fd, 0x2758, 0xffffa764, 0x62ed, 0xffff90c5, 0x1e51, 0xffff897b,
+    0xffff82b3, 0x2d25, 0x76ad, 0xffff7f02, 0xfffffa89, 0x2d4f, 0x2ab, 0x5685,
+    0x8ce1, 0xfffff7de, 0x5522, 0xffffbc64, 0xffff9e79, 0xffffef8b, 0xffff84f0, 0xffff933c,
+    0x102e, 0x8bc, 0x5a44, 0xfffffe4f, 0xffffaed9, 0x7aee, 0xffffa2ae, 0x12e0,
+    0x7c7b, 0x3a66, 0xffffb1f5, 0xffffa575, 0x3bf3, 0xffffe14f, 0xffffedca, 0xfffffb3d,
+    0xffff8279, 0x296b, 0x8bc7, 0xc1b, 0xffffea63, 0x65cd, 0xffffa851, 0x878f,
+    0xe37, 0x501a, 0x581c, 0x16c3, 0x6279, 0xffff9e12, 0xfffffc2c, 0x7d4c,
+    0x4c95, 0xffffced3, 0xffff8b07, 0xffff87b0, 0xffffa928, 0x6ce2, 0xffff8bc1, 0xffff7fab,
+    0x5249, 0xffffbf8f, 0x8074, 0x1ab9, 0xffffe2ed, 0xffffebbb, 0xfffffd25, 0x474f,
+    0xffffe439, 0xffffe258, 0xffffb947, 0xfffffa1b, 0xffff90ea, 0x8134, 0x6eed, 0xffffc392,
+    0xffff934a, 0xffffb921, 0xd9a, 0x6581, 0x37f2, 0xffffe672, 0xffffafd9, 0x30eb,
+    0xffffa08e, 0xffffa39d, 0xffff9657, 0x26d0, 0xffffb97f, 0x5df, 0xffff9257, 0x3a34,
+    0xfffffd43, 0xffffc367, 0x8bf0, 0x186, 0x1692, 0x5420, 0x7d2c, 0x83dd,
+    0x4ad1, 0xfffffc05, 0x67a4, 0x7b06, 0xffffacd2, 0x7c2, 0x4f9a, 0x586a,
+    0xffffdacd, 0xfffff2e4, 0xffffa666, 0xffffa2f2, 0xffffdd98, 0x50ec, 0xffffec94, 0xffffe01d,
+    0xffffe6a5, 0x2b32, 0xffff9128, 0xffffba30, 0xffff82ba, 0xffffe9fc, 0xffffe738, 0x20fa,
+    0x3c1b, 0xffffce2f, 0x533, 0x8bdf, 0x79be, 0xffff86e9, 0x82cf, 0xffffab3e,
+    0x591d, 0xfffffeb2, 0xffff7424, 0x8932, 0xffffe0f9, 0xffff9d92, 0xffff7b20, 0x2495,
+    0x879d, 0x85a3, 0x6f1f, 0x1cf2, 0x1220, 0x65c2, 0xffffc751, 0xffffa10f,
+    0xffffa5df, 0xffffd1fd, 0xffffac41, 0xffff73d2, 0xffffc38e, 0xffffa17a, 0xffff9f58, 0x6600,
+    0xffff95d8, 0x8400, 0x38dc, 0xffff9844, 0xffff9378, 0x5fdc, 0x3ed8, 0xb4b,
+    0xffffb1fd, 0xffff72a1, 0x6313, 0x3acb, 0xffffd03c, 0xffffe6bb, 0x59f7, 0x5a17,
+    0x20c2, 0xffffddc9, 0x60e0, 0xffffb1ff, 0x7867, 0xffffad34, 0x8cb0, 0xffff89ed,
+    0xffff9cf1, 0x57ed, 0x186b, 0x85bb, 0x1ed9, 0xffffd073, 0x755, 0x39d,
+    0xffffe507, 0x5144, 0x3bdd, 0xffff748f, 0x5a22, 0x2f8c, 0xffffe210, 0xffff8285,
+    0x2ffa, 0x17c1, 0x11b5, 0xffffa5ff, 0x3950, 0x6b7f, 0xffffc962, 0xfffff345,
+    0x80c6, 0xffffbb45, 0xffffac73, 0xffff941e, 0xffff9774, 0xffffe733, 0x35cb, 0xffffb0e4,
+    0x8a90, 0x296d, 0xffffea99, 0xffffb292, 0x3778, 0xffffff27, 0x3422, 0x2bd4,
+    0xffffb0ac, 0xffffda12, 0x3f00, 0x36ed, 0x38ec, 0xffff9a13, 0xffff9d40, 0x5ec5,
+    0x5a1b, 0x5a7d, 0xffffccab, 0xfffffcd1, 0xffffa33b, 0xffff9848, 0x31d8, 0x2224,
+    0x2eb0, 0xffffa658, 0xffff9e76, 0xffffd97a, 0x65a8, 0xffff8029, 0xf42, 0x2c21
+};

--- a/libavcodec/wmadec.c
+++ b/libavcodec/wmadec.c
@@ -1,964 +0,0 @@
-/*
- * WMA compatible decoder
- * Copyright (c) 2002 The FFmpeg Project
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * WMA compatible decoder.
- * This decoder handles Microsoft Windows Media Audio data, versions 1 & 2.
- * WMA v1 is identified by audio format 0x160 in Microsoft media files
- * (ASF/AVI/WAV). WMA v2 is identified by audio format 0x161.
- *
- * To use this decoder, a calling application must supply the extra data
- * bytes provided with the WMA data. These are the extra, codec-specific
- * bytes at the end of a WAVEFORMATEX data structure. Transmit these bytes
- * to the decoder using the extradata[_size] fields in AVCodecContext. There
- * should be 4 extra bytes for v1 data and 6 extra bytes for v2 data.
- */
-
-#include "avcodec.h"
-#include "wma.h"
-
-#undef NDEBUG
-#include <assert.h>
-
-#define EXPVLCBITS 8
-#define EXPMAX ((19+EXPVLCBITS-1)/EXPVLCBITS)
-
-#define HGAINVLCBITS 9
-#define HGAINMAX ((13+HGAINVLCBITS-1)/HGAINVLCBITS)
-
-static void wma_lsp_to_curve_init(WMACodecContext *s, int frame_len);
-
-#ifdef TRACE
-static void dump_shorts(WMACodecContext *s, const char *name, const short *tab, int n)
-{
-    int i;
-
-    tprintf(s->avctx, "%s[%d]:\n", name, n);
-    for(i=0;i<n;i++) {
-        if ((i & 7) == 0)
-            tprintf(s->avctx, "%4d: ", i);
-        tprintf(s->avctx, " %5d.0", tab[i]);
-        if ((i & 7) == 7)
-            tprintf(s->avctx, "\n");
-    }
-}
-
-static void dump_floats(WMACodecContext *s, const char *name, int prec, const float *tab, int n)
-{
-    int i;
-
-    tprintf(s->avctx, "%s[%d]:\n", name, n);
-    for(i=0;i<n;i++) {
-        if ((i & 7) == 0)
-            tprintf(s->avctx, "%4d: ", i);
-        tprintf(s->avctx, " %8.*f", prec, tab[i]);
-        if ((i & 7) == 7)
-            tprintf(s->avctx, "\n");
-    }
-    if ((i & 7) != 0)
-        tprintf(s->avctx, "\n");
-}
-#endif
-
-static int wma_decode_init(AVCodecContext * avctx)
-{
-    WMACodecContext *s = avctx->priv_data;
-    int i, flags2;
-    uint8_t *extradata;
-
-    s->avctx = avctx;
-
-    /* extract flag infos */
-    flags2 = 0;
-    extradata = avctx->extradata;
-    if (avctx->codec->id == CODEC_ID_WMAV1 && avctx->extradata_size >= 4) {
-        flags2 = AV_RL16(extradata+2);
-    } else if (avctx->codec->id == CODEC_ID_WMAV2 && avctx->extradata_size >= 6) {
-        flags2 = AV_RL16(extradata+4);
-    }
-// for(i=0; i<avctx->extradata_size; i++)
-//     av_log(NULL, AV_LOG_ERROR, "%02X ", extradata[i]);
-
-    s->use_exp_vlc = flags2 & 0x0001;
-    s->use_bit_reservoir = flags2 & 0x0002;
-    s->use_variable_block_len = flags2 & 0x0004;
-
-    if(avctx->codec->id == CODEC_ID_WMAV2 && avctx->extradata_size >= 8){
-        if(AV_RL16(extradata+4)==0xd && s->use_variable_block_len){
-            av_log(avctx, AV_LOG_WARNING, "Disabling use_variable_block_len, if this fails contact the ffmpeg developers and send us the file\n");
-            s->use_variable_block_len= 0; // this fixes issue1503
-        }
-    }
-
-    if(avctx->channels > MAX_CHANNELS){
-        av_log(avctx, AV_LOG_ERROR, "Invalid number of channels (%d)\n", avctx->channels);
-        return -1;
-    }
-
-    if(ff_wma_init(avctx, flags2)<0)
-        return -1;
-
-    /* init MDCT */
-    for(i = 0; i < s->nb_block_sizes; i++)
-        ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 1, 1.0);
-
-    if (s->use_noise_coding) {
-        init_vlc(&s->hgain_vlc, HGAINVLCBITS, sizeof(ff_wma_hgain_huffbits),
-                 ff_wma_hgain_huffbits, 1, 1,
-                 ff_wma_hgain_huffcodes, 2, 2, 0);
-    }
-
-    if (s->use_exp_vlc) {
-        init_vlc(&s->exp_vlc, EXPVLCBITS, sizeof(ff_aac_scalefactor_bits), //FIXME move out of context
-                 ff_aac_scalefactor_bits, 1, 1,
-                 ff_aac_scalefactor_code, 4, 4, 0);
-    } else {
-        wma_lsp_to_curve_init(s, s->frame_len);
-    }
-
-    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
-    return 0;
-}
-
-/**
- * compute x^-0.25 with an exponent and mantissa table. We use linear
- * interpolation to reduce the mantissa table size at a small speed
- * expense (linear interpolation approximately doubles the number of
- * bits of precision).
- */
-static inline float pow_m1_4(WMACodecContext *s, float x)
-{
-    union {
-        float f;
-        unsigned int v;
-    } u, t;
-    unsigned int e, m;
-    float a, b;
-
-    u.f = x;
-    e = u.v >> 23;
-    m = (u.v >> (23 - LSP_POW_BITS)) & ((1 << LSP_POW_BITS) - 1);
-    /* build interpolation scale: 1 <= t < 2. */
-    t.v = ((u.v << LSP_POW_BITS) & ((1 << 23) - 1)) | (127 << 23);
-    a = s->lsp_pow_m_table1[m];
-    b = s->lsp_pow_m_table2[m];
-    return s->lsp_pow_e_table[e] * (a + b * t.f);
-}
-
-static void wma_lsp_to_curve_init(WMACodecContext *s, int frame_len)
-{
-    float wdel, a, b;
-    int i, e, m;
-
-    wdel = M_PI / frame_len;
-    for(i=0;i<frame_len;i++)
-        s->lsp_cos_table[i] = 2.0f * cos(wdel * i);
-
-    /* tables for x^-0.25 computation */
-    for(i=0;i<256;i++) {
-        e = i - 126;
-        s->lsp_pow_e_table[i] = pow(2.0, e * -0.25);
-    }
-
-    /* NOTE: these two tables are needed to avoid two operations in
-       pow_m1_4 */
-    b = 1.0;
-    for(i=(1 << LSP_POW_BITS) - 1;i>=0;i--) {
-        m = (1 << LSP_POW_BITS) + i;
-        a = (float)m * (0.5 / (1 << LSP_POW_BITS));
-        a = pow(a, -0.25);
-        s->lsp_pow_m_table1[i] = 2 * a - b;
-        s->lsp_pow_m_table2[i] = b - a;
-        b = a;
-    }
-}
-
-/**
- * NOTE: We use the same code as Vorbis here
- * @todo optimize it further with SSE/3Dnow
- */
-static void wma_lsp_to_curve(WMACodecContext *s,
-                             float *out, float *val_max_ptr,
-                             int n, float *lsp)
-{
-    int i, j;
-    float p, q, w, v, val_max;
-
-    val_max = 0;
-    for(i=0;i<n;i++) {
-        p = 0.5f;
-        q = 0.5f;
-        w = s->lsp_cos_table[i];
-        for(j=1;j<NB_LSP_COEFS;j+=2){
-            q *= w - lsp[j - 1];
-            p *= w - lsp[j];
-        }
-        p *= p * (2.0f - w);
-        q *= q * (2.0f + w);
-        v = p + q;
-        v = pow_m1_4(s, v);
-        if (v > val_max)
-            val_max = v;
-        out[i] = v;
-    }
-    *val_max_ptr = val_max;
-}
-
-/**
- * decode exponents coded with LSP coefficients (same idea as Vorbis)
- */
-static void decode_exp_lsp(WMACodecContext *s, int ch)
-{
-    float lsp_coefs[NB_LSP_COEFS];
-    int val, i;
-
-    for(i = 0; i < NB_LSP_COEFS; i++) {
-        if (i == 0 || i >= 8)
-            val = get_bits(&s->gb, 3);
-        else
-            val = get_bits(&s->gb, 4);
-        lsp_coefs[i] = ff_wma_lsp_codebook[i][val];
-    }
-
-    wma_lsp_to_curve(s, s->exponents[ch], &s->max_exponent[ch],
-                     s->block_len, lsp_coefs);
-}
-
-/** pow(10, i / 16.0) for i in -60..95 */
-static const float pow_tab[] = {
-    1.7782794100389e-04, 2.0535250264571e-04,
-    2.3713737056617e-04, 2.7384196342644e-04,
-    3.1622776601684e-04, 3.6517412725484e-04,
-    4.2169650342858e-04, 4.8696752516586e-04,
-    5.6234132519035e-04, 6.4938163157621e-04,
-    7.4989420933246e-04, 8.6596432336006e-04,
-    1.0000000000000e-03, 1.1547819846895e-03,
-    1.3335214321633e-03, 1.5399265260595e-03,
-    1.7782794100389e-03, 2.0535250264571e-03,
-    2.3713737056617e-03, 2.7384196342644e-03,
-    3.1622776601684e-03, 3.6517412725484e-03,
-    4.2169650342858e-03, 4.8696752516586e-03,
-    5.6234132519035e-03, 6.4938163157621e-03,
-    7.4989420933246e-03, 8.6596432336006e-03,
-    1.0000000000000e-02, 1.1547819846895e-02,
-    1.3335214321633e-02, 1.5399265260595e-02,
-    1.7782794100389e-02, 2.0535250264571e-02,
-    2.3713737056617e-02, 2.7384196342644e-02,
-    3.1622776601684e-02, 3.6517412725484e-02,
-    4.2169650342858e-02, 4.8696752516586e-02,
-    5.6234132519035e-02, 6.4938163157621e-02,
-    7.4989420933246e-02, 8.6596432336007e-02,
-    1.0000000000000e-01, 1.1547819846895e-01,
-    1.3335214321633e-01, 1.5399265260595e-01,
-    1.7782794100389e-01, 2.0535250264571e-01,
-    2.3713737056617e-01, 2.7384196342644e-01,
-    3.1622776601684e-01, 3.6517412725484e-01,
-    4.2169650342858e-01, 4.8696752516586e-01,
-    5.6234132519035e-01, 6.4938163157621e-01,
-    7.4989420933246e-01, 8.6596432336007e-01,
-    1.0000000000000e+00, 1.1547819846895e+00,
-    1.3335214321633e+00, 1.5399265260595e+00,
-    1.7782794100389e+00, 2.0535250264571e+00,
-    2.3713737056617e+00, 2.7384196342644e+00,
-    3.1622776601684e+00, 3.6517412725484e+00,
-    4.2169650342858e+00, 4.8696752516586e+00,
-    5.6234132519035e+00, 6.4938163157621e+00,
-    7.4989420933246e+00, 8.6596432336007e+00,
-    1.0000000000000e+01, 1.1547819846895e+01,
-    1.3335214321633e+01, 1.5399265260595e+01,
-    1.7782794100389e+01, 2.0535250264571e+01,
-    2.3713737056617e+01, 2.7384196342644e+01,
-    3.1622776601684e+01, 3.6517412725484e+01,
-    4.2169650342858e+01, 4.8696752516586e+01,
-    5.6234132519035e+01, 6.4938163157621e+01,
-    7.4989420933246e+01, 8.6596432336007e+01,
-    1.0000000000000e+02, 1.1547819846895e+02,
-    1.3335214321633e+02, 1.5399265260595e+02,
-    1.7782794100389e+02, 2.0535250264571e+02,
-    2.3713737056617e+02, 2.7384196342644e+02,
-    3.1622776601684e+02, 3.6517412725484e+02,
-    4.2169650342858e+02, 4.8696752516586e+02,
-    5.6234132519035e+02, 6.4938163157621e+02,
-    7.4989420933246e+02, 8.6596432336007e+02,
-    1.0000000000000e+03, 1.1547819846895e+03,
-    1.3335214321633e+03, 1.5399265260595e+03,
-    1.7782794100389e+03, 2.0535250264571e+03,
-    2.3713737056617e+03, 2.7384196342644e+03,
-    3.1622776601684e+03, 3.6517412725484e+03,
-    4.2169650342858e+03, 4.8696752516586e+03,
-    5.6234132519035e+03, 6.4938163157621e+03,
-    7.4989420933246e+03, 8.6596432336007e+03,
-    1.0000000000000e+04, 1.1547819846895e+04,
-    1.3335214321633e+04, 1.5399265260595e+04,
-    1.7782794100389e+04, 2.0535250264571e+04,
-    2.3713737056617e+04, 2.7384196342644e+04,
-    3.1622776601684e+04, 3.6517412725484e+04,
-    4.2169650342858e+04, 4.8696752516586e+04,
-    5.6234132519035e+04, 6.4938163157621e+04,
-    7.4989420933246e+04, 8.6596432336007e+04,
-    1.0000000000000e+05, 1.1547819846895e+05,
-    1.3335214321633e+05, 1.5399265260595e+05,
-    1.7782794100389e+05, 2.0535250264571e+05,
-    2.3713737056617e+05, 2.7384196342644e+05,
-    3.1622776601684e+05, 3.6517412725484e+05,
-    4.2169650342858e+05, 4.8696752516586e+05,
-    5.6234132519035e+05, 6.4938163157621e+05,
-    7.4989420933246e+05, 8.6596432336007e+05,
-};
-
-/**
- * decode exponents coded with VLC codes
- */
-static int decode_exp_vlc(WMACodecContext *s, int ch)
-{
-    int last_exp, n, code;
-    const uint16_t *ptr;
-    float v, max_scale;
-    uint32_t *q, *q_end, iv;
-    const float *ptab = pow_tab + 60;
-    const uint32_t *iptab = (const uint32_t*)ptab;
-
-    ptr = s->exponent_bands[s->frame_len_bits - s->block_len_bits];
-    q = (uint32_t *)s->exponents[ch];
-    q_end = q + s->block_len;
-    max_scale = 0;
-    if (s->version == 1) {
-        last_exp = get_bits(&s->gb, 5) + 10;
-        v = ptab[last_exp];
-        iv = iptab[last_exp];
-        max_scale = v;
-        n = *ptr++;
-        switch (n & 3) do {
-        case 0: *q++ = iv;
-        case 3: *q++ = iv;
-        case 2: *q++ = iv;
-        case 1: *q++ = iv;
-        } while ((n -= 4) > 0);
-    }else
-        last_exp = 36;
-
-    while (q < q_end) {
-        code = get_vlc2(&s->gb, s->exp_vlc.table, EXPVLCBITS, EXPMAX);
-        if (code < 0){
-            av_log(s->avctx, AV_LOG_ERROR, "Exponent vlc invalid\n");
-            return -1;
-        }
-        /* NOTE: this offset is the same as MPEG4 AAC ! */
-        last_exp += code - 60;
-        if ((unsigned)last_exp + 60 >= FF_ARRAY_ELEMS(pow_tab)) {
-            av_log(s->avctx, AV_LOG_ERROR, "Exponent out of range: %d\n",
-                   last_exp);
-            return -1;
-        }
-        v = ptab[last_exp];
-        iv = iptab[last_exp];
-        if (v > max_scale)
-            max_scale = v;
-        n = *ptr++;
-        switch (n & 3) do {
-        case 0: *q++ = iv;
-        case 3: *q++ = iv;
-        case 2: *q++ = iv;
-        case 1: *q++ = iv;
-        } while ((n -= 4) > 0);
-    }
-    s->max_exponent[ch] = max_scale;
-    return 0;
-}
-
-
-/**
- * Apply MDCT window and add into output.
- *
- * We ensure that when the windows overlap their squared sum
- * is always 1 (MDCT reconstruction rule).
- */
-static void wma_window(WMACodecContext *s, float *out)
-{
-    float *in = s->output;
-    int block_len, bsize, n;
-
-    /* left part */
-    if (s->block_len_bits <= s->prev_block_len_bits) {
-        block_len = s->block_len;
-        bsize = s->frame_len_bits - s->block_len_bits;
-
-        s->dsp.vector_fmul_add(out, in, s->windows[bsize],
-                               out, block_len);
-
-    } else {
-        block_len = 1 << s->prev_block_len_bits;
-        n = (s->block_len - block_len) / 2;
-        bsize = s->frame_len_bits - s->prev_block_len_bits;
-
-        s->dsp.vector_fmul_add(out+n, in+n, s->windows[bsize],
-                               out+n, block_len);
-
-        memcpy(out+n+block_len, in+n+block_len, n*sizeof(float));
-    }
-
-    out += s->block_len;
-    in += s->block_len;
-
-    /* right part */
-    if (s->block_len_bits <= s->next_block_len_bits) {
-        block_len = s->block_len;
-        bsize = s->frame_len_bits - s->block_len_bits;
-
-        s->dsp.vector_fmul_reverse(out, in, s->windows[bsize], block_len);
-
-    } else {
-        block_len = 1 << s->next_block_len_bits;
-        n = (s->block_len - block_len) / 2;
-        bsize = s->frame_len_bits - s->next_block_len_bits;
-
-        memcpy(out, in, n*sizeof(float));
-
-        s->dsp.vector_fmul_reverse(out+n, in+n, s->windows[bsize], block_len);
-
-        memset(out+n+block_len, 0, n*sizeof(float));
-    }
-}
-
-
-/**
- * @return 0 if OK. 1 if last block of frame. return -1 if
- * unrecorrable error.
- */
-static int wma_decode_block(WMACodecContext *s)
-{
-    int n, v, a, ch, bsize;
-    int coef_nb_bits, total_gain;
-    int nb_coefs[MAX_CHANNELS];
-    float mdct_norm;
-    FFTContext *mdct;
-
-#ifdef TRACE
-    tprintf(s->avctx, "***decode_block: %d:%d\n", s->frame_count - 1, s->block_num);
-#endif
-
-    /* compute current block length */
-    if (s->use_variable_block_len) {
-        n = av_log2(s->nb_block_sizes - 1) + 1;
-
-        if (s->reset_block_lengths) {
-            s->reset_block_lengths = 0;
-            v = get_bits(&s->gb, n);
-            if (v >= s->nb_block_sizes){
-                av_log(s->avctx, AV_LOG_ERROR, "prev_block_len_bits %d out of range\n", s->frame_len_bits - v);
-                return -1;
-            }
-            s->prev_block_len_bits = s->frame_len_bits - v;
-            v = get_bits(&s->gb, n);
-            if (v >= s->nb_block_sizes){
-                av_log(s->avctx, AV_LOG_ERROR, "block_len_bits %d out of range\n", s->frame_len_bits - v);
-                return -1;
-            }
-            s->block_len_bits = s->frame_len_bits - v;
-        } else {
-            /* update block lengths */
-            s->prev_block_len_bits = s->block_len_bits;
-            s->block_len_bits = s->next_block_len_bits;
-        }
-        v = get_bits(&s->gb, n);
-        if (v >= s->nb_block_sizes){
-            av_log(s->avctx, AV_LOG_ERROR, "next_block_len_bits %d out of range\n", s->frame_len_bits - v);
-            return -1;
-        }
-        s->next_block_len_bits = s->frame_len_bits - v;
-    } else {
-        /* fixed block len */
-        s->next_block_len_bits = s->frame_len_bits;
-        s->prev_block_len_bits = s->frame_len_bits;
-        s->block_len_bits = s->frame_len_bits;
-    }
-
-    if (s->frame_len_bits - s->block_len_bits >= s->nb_block_sizes){
-        av_log(s->avctx, AV_LOG_ERROR, "block_len_bits not initialized to a valid value\n");
-        return -1;
-    }
-
-    /* now check if the block length is coherent with the frame length */
-    s->block_len = 1 << s->block_len_bits;
-    if ((s->block_pos + s->block_len) > s->frame_len){
-        av_log(s->avctx, AV_LOG_ERROR, "frame_len overflow\n");
-        return -1;
-    }
-
-    if (s->nb_channels == 2) {
-        s->ms_stereo = get_bits1(&s->gb);
-    }
-    v = 0;
-    for(ch = 0; ch < s->nb_channels; ch++) {
-        a = get_bits1(&s->gb);
-        s->channel_coded[ch] = a;
-        v |= a;
-    }
-
-    bsize = s->frame_len_bits - s->block_len_bits;
-
-    /* if no channel coded, no need to go further */
-    /* XXX: fix potential framing problems */
-    if (!v)
-        goto next;
-
-    /* read total gain and extract corresponding number of bits for
-       coef escape coding */
-    total_gain = 1;
-    for(;;) {
-        a = get_bits(&s->gb, 7);
-        total_gain += a;
-        if (a != 127)
-            break;
-    }
-
-    coef_nb_bits= ff_wma_total_gain_to_bits(total_gain);
-
-    /* compute number of coefficients */
-    n = s->coefs_end[bsize] - s->coefs_start;
-    for(ch = 0; ch < s->nb_channels; ch++)
-        nb_coefs[ch] = n;
-
-    /* complex coding */
-    if (s->use_noise_coding) {
-
-        for(ch = 0; ch < s->nb_channels; ch++) {
-            if (s->channel_coded[ch]) {
-                int i, n, a;
-                n = s->exponent_high_sizes[bsize];
-                for(i=0;i<n;i++) {
-                    a = get_bits1(&s->gb);
-                    s->high_band_coded[ch][i] = a;
-                    /* if noise coding, the coefficients are not transmitted */
-                    if (a)
-                        nb_coefs[ch] -= s->exponent_high_bands[bsize][i];
-                }
-            }
-        }
-        for(ch = 0; ch < s->nb_channels; ch++) {
-            if (s->channel_coded[ch]) {
-                int i, n, val, code;
-
-                n = s->exponent_high_sizes[bsize];
-                val = (int)0x80000000;
-                for(i=0;i<n;i++) {
-                    if (s->high_band_coded[ch][i]) {
-                        if (val == (int)0x80000000) {
-                            val = get_bits(&s->gb, 7) - 19;
-                        } else {
-                            code = get_vlc2(&s->gb, s->hgain_vlc.table, HGAINVLCBITS, HGAINMAX);
-                            if (code < 0){
-                                av_log(s->avctx, AV_LOG_ERROR, "hgain vlc invalid\n");
-                                return -1;
-                            }
-                            val += code - 18;
-                        }
-                        s->high_band_values[ch][i] = val;
-                    }
-                }
-            }
-        }
-    }
-
-    /* exponents can be reused in short blocks. */
-    if ((s->block_len_bits == s->frame_len_bits) ||
-        get_bits1(&s->gb)) {
-        for(ch = 0; ch < s->nb_channels; ch++) {
-            if (s->channel_coded[ch]) {
-                if (s->use_exp_vlc) {
-                    if (decode_exp_vlc(s, ch) < 0)
-                        return -1;
-                } else {
-                    decode_exp_lsp(s, ch);
-                }
-                s->exponents_bsize[ch] = bsize;
-            }
-        }
-    }
-
-    /* parse spectral coefficients : just RLE encoding */
-    for(ch = 0; ch < s->nb_channels; ch++) {
-        if (s->channel_coded[ch]) {
-            int tindex;
-            WMACoef* ptr = &s->coefs1[ch][0];
-
-            /* special VLC tables are used for ms stereo because
-               there is potentially less energy there */
-            tindex = (ch == 1 && s->ms_stereo);
-            memset(ptr, 0, s->block_len * sizeof(WMACoef));
-            ff_wma_run_level_decode(s->avctx, &s->gb, &s->coef_vlc[tindex],
-                  s->level_table[tindex], s->run_table[tindex],
-                  0, ptr, 0, nb_coefs[ch],
-                  s->block_len, s->frame_len_bits, coef_nb_bits);
-        }
-        if (s->version == 1 && s->nb_channels >= 2) {
-            align_get_bits(&s->gb);
-        }
-    }
-
-    /* normalize */
-    {
-        int n4 = s->block_len / 2;
-        mdct_norm = 1.0 / (float)n4;
-        if (s->version == 1) {
-            mdct_norm *= sqrt(n4);
-        }
-    }
-
-    /* finally compute the MDCT coefficients */
-    for(ch = 0; ch < s->nb_channels; ch++) {
-        if (s->channel_coded[ch]) {
-            WMACoef *coefs1;
-            float *coefs, *exponents, mult, mult1, noise;
-            int i, j, n, n1, last_high_band, esize;
-            float exp_power[HIGH_BAND_MAX_SIZE];
-
-            coefs1 = s->coefs1[ch];
-            exponents = s->exponents[ch];
-            esize = s->exponents_bsize[ch];
-            mult = pow(10, total_gain * 0.05) / s->max_exponent[ch];
-            mult *= mdct_norm;
-            coefs = s->coefs[ch];
-            if (s->use_noise_coding) {
-                mult1 = mult;
-                /* very low freqs : noise */
-                for(i = 0;i < s->coefs_start; i++) {
-                    *coefs++ = s->noise_table[s->noise_index] *
-                      exponents[i<<bsize>>esize] * mult1;
-                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);
-                }
-
-                n1 = s->exponent_high_sizes[bsize];
-
-                /* compute power of high bands */
-                exponents = s->exponents[ch] +
-                    (s->high_band_start[bsize]<<bsize>>esize);
-                last_high_band = 0; /* avoid warning */
-                for(j=0;j<n1;j++) {
-                    n = s->exponent_high_bands[s->frame_len_bits -
-                                              s->block_len_bits][j];
-                    if (s->high_band_coded[ch][j]) {
-                        float e2, v;
-                        e2 = 0;
-                        for(i = 0;i < n; i++) {
-                            v = exponents[i<<bsize>>esize];
-                            e2 += v * v;
-                        }
-                        exp_power[j] = e2 / n;
-                        last_high_band = j;
-                        tprintf(s->avctx, "%d: power=%f (%d)\n", j, exp_power[j], n);
-                    }
-                    exponents += n<<bsize>>esize;
-                }
-
-                /* main freqs and high freqs */
-                exponents = s->exponents[ch] + (s->coefs_start<<bsize>>esize);
-                for(j=-1;j<n1;j++) {
-                    if (j < 0) {
-                        n = s->high_band_start[bsize] -
-                            s->coefs_start;
-                    } else {
-                        n = s->exponent_high_bands[s->frame_len_bits -
-                                                  s->block_len_bits][j];
-                    }
-                    if (j >= 0 && s->high_band_coded[ch][j]) {
-                        /* use noise with specified power */
-                        mult1 = sqrt(exp_power[j] / exp_power[last_high_band]);
-                        /* XXX: use a table */
-                        mult1 = mult1 * pow(10, s->high_band_values[ch][j] * 0.05);
-                        mult1 = mult1 / (s->max_exponent[ch] * s->noise_mult);
-                        mult1 *= mdct_norm;
-                        for(i = 0;i < n; i++) {
-                            noise = s->noise_table[s->noise_index];
-                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);
-                            *coefs++ =  noise *
-                                exponents[i<<bsize>>esize] * mult1;
-                        }
-                        exponents += n<<bsize>>esize;
-                    } else {
-                        /* coded values + small noise */
-                        for(i = 0;i < n; i++) {
-                            noise = s->noise_table[s->noise_index];
-                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);
-                            *coefs++ = ((*coefs1++) + noise) *
-                                exponents[i<<bsize>>esize] * mult;
-                        }
-                        exponents += n<<bsize>>esize;
-                    }
-                }
-
-                /* very high freqs : noise */
-                n = s->block_len - s->coefs_end[bsize];
-                mult1 = mult * exponents[((-1<<bsize))>>esize];
-                for(i = 0; i < n; i++) {
-                    *coefs++ = s->noise_table[s->noise_index] * mult1;
-                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);
-                }
-            } else {
-                /* XXX: optimize more */
-                for(i = 0;i < s->coefs_start; i++)
-                    *coefs++ = 0.0;
-                n = nb_coefs[ch];
-                for(i = 0;i < n; i++) {
-                    *coefs++ = coefs1[i] * exponents[i<<bsize>>esize] * mult;
-                }
-                n = s->block_len - s->coefs_end[bsize];
-                for(i = 0;i < n; i++)
-                    *coefs++ = 0.0;
-            }
-        }
-    }
-
-#ifdef TRACE
-    for(ch = 0; ch < s->nb_channels; ch++) {
-        if (s->channel_coded[ch]) {
-            dump_floats(s, "exponents", 3, s->exponents[ch], s->block_len);
-            dump_floats(s, "coefs", 1, s->coefs[ch], s->block_len);
-        }
-    }
-#endif
-
-    if (s->ms_stereo && s->channel_coded[1]) {
-        /* nominal case for ms stereo: we do it before mdct */
-        /* no need to optimize this case because it should almost
-           never happen */
-        if (!s->channel_coded[0]) {
-            tprintf(s->avctx, "rare ms-stereo case happened\n");
-            memset(s->coefs[0], 0, sizeof(float) * s->block_len);
-            s->channel_coded[0] = 1;
-        }
-
-        s->dsp.butterflies_float(s->coefs[0], s->coefs[1], s->block_len);
-    }
-
-next:
-    mdct = &s->mdct_ctx[bsize];
-
-    for(ch = 0; ch < s->nb_channels; ch++) {
-        int n4, index;
-
-        n4 = s->block_len / 2;
-        if(s->channel_coded[ch]){
-            mdct->imdct_calc(mdct, s->output, s->coefs[ch]);
-        }else if(!(s->ms_stereo && ch==1))
-            memset(s->output, 0, sizeof(s->output));
-
-        /* multiply by the window and add in the frame */
-        index = (s->frame_len / 2) + s->block_pos - n4;
-        wma_window(s, &s->frame_out[ch][index]);
-    }
-
-    /* update block number */
-    s->block_num++;
-    s->block_pos += s->block_len;
-    if (s->block_pos >= s->frame_len)
-        return 1;
-    else
-        return 0;
-}
-
-/* decode a frame of frame_len samples */
-static int wma_decode_frame(WMACodecContext *s, int16_t *samples)
-{
-    int ret, n, ch, incr;
-    const float *output[MAX_CHANNELS];
-
-#ifdef TRACE
-    tprintf(s->avctx, "***decode_frame: %d size=%d\n", s->frame_count++, s->frame_len);
-#endif
-
-    /* read each block */
-    s->block_num = 0;
-    s->block_pos = 0;
-    for(;;) {
-        ret = wma_decode_block(s);
-        if (ret < 0)
-            return -1;
-        if (ret)
-            break;
-    }
-
-    /* convert frame to integer */
-    n = s->frame_len;
-    incr = s->nb_channels;
-    for (ch = 0; ch < MAX_CHANNELS; ch++)
-        output[ch] = s->frame_out[ch];
-    s->fmt_conv.float_to_int16_interleave(samples, output, n, incr);
-    for (ch = 0; ch < incr; ch++) {
-        /* prepare for next block */
-        memmove(&s->frame_out[ch][0], &s->frame_out[ch][n], n * sizeof(float));
-    }
-
-#ifdef TRACE
-    dump_shorts(s, "samples", samples, n * s->nb_channels);
-#endif
-    return 0;
-}
-
-static int wma_decode_superframe(AVCodecContext *avctx,
-                                 void *data, int *data_size,
-                                 AVPacket *avpkt)
-{
-    const uint8_t *buf = avpkt->data;
-    int buf_size = avpkt->size;
-    WMACodecContext *s = avctx->priv_data;
-    int nb_frames, bit_offset, i, pos, len;
-    uint8_t *q;
-    int16_t *samples;
-
-    tprintf(avctx, "***decode_superframe:\n");
-
-    if(buf_size==0){
-        s->last_superframe_len = 0;
-        return 0;
-    }
-    if (buf_size < s->block_align)
-        return AVERROR(EINVAL);
-    if(s->block_align)
-        buf_size = s->block_align;
-
-    samples = data;
-
-    init_get_bits(&s->gb, buf, buf_size*8);
-
-    if (s->use_bit_reservoir) {
-        /* read super frame header */
-        skip_bits(&s->gb, 4); /* super frame index */
-        nb_frames = get_bits(&s->gb, 4) - 1;
-
-        if((nb_frames+1) * s->nb_channels * s->frame_len * sizeof(int16_t) > *data_size){
-            av_log(s->avctx, AV_LOG_ERROR, "Insufficient output space\n");
-            goto fail;
-        }
-
-        bit_offset = get_bits(&s->gb, s->byte_offset_bits + 3);
-
-        if (s->last_superframe_len > 0) {
-            //        printf("skip=%d\n", s->last_bitoffset);
-            /* add bit_offset bits to last frame */
-            if ((s->last_superframe_len + ((bit_offset + 7) >> 3)) >
-                MAX_CODED_SUPERFRAME_SIZE)
-                goto fail;
-            q = s->last_superframe + s->last_superframe_len;
-            len = bit_offset;
-            while (len > 7) {
-                *q++ = (get_bits)(&s->gb, 8);
-                len -= 8;
-            }
-            if (len > 0) {
-                *q++ = (get_bits)(&s->gb, len) << (8 - len);
-            }
-
-            /* XXX: bit_offset bits into last frame */
-            init_get_bits(&s->gb, s->last_superframe, MAX_CODED_SUPERFRAME_SIZE*8);
-            /* skip unused bits */
-            if (s->last_bitoffset > 0)
-                skip_bits(&s->gb, s->last_bitoffset);
-            /* this frame is stored in the last superframe and in the
-               current one */
-            if (wma_decode_frame(s, samples) < 0)
-                goto fail;
-            samples += s->nb_channels * s->frame_len;
-        }
-
-        /* read each frame starting from bit_offset */
-        pos = bit_offset + 4 + 4 + s->byte_offset_bits + 3;
-        if (pos >= MAX_CODED_SUPERFRAME_SIZE * 8)
-            return AVERROR_INVALIDDATA;
-        init_get_bits(&s->gb, buf + (pos >> 3), (MAX_CODED_SUPERFRAME_SIZE - (pos >> 3))*8);
-        len = pos & 7;
-        if (len > 0)
-            skip_bits(&s->gb, len);
-
-        s->reset_block_lengths = 1;
-        for(i=0;i<nb_frames;i++) {
-            if (wma_decode_frame(s, samples) < 0)
-                goto fail;
-            samples += s->nb_channels * s->frame_len;
-        }
-
-        /* we copy the end of the frame in the last frame buffer */
-        pos = get_bits_count(&s->gb) + ((bit_offset + 4 + 4 + s->byte_offset_bits + 3) & ~7);
-        s->last_bitoffset = pos & 7;
-        pos >>= 3;
-        len = buf_size - pos;
-        if (len > MAX_CODED_SUPERFRAME_SIZE || len < 0) {
-            av_log(s->avctx, AV_LOG_ERROR, "len %d invalid\n", len);
-            goto fail;
-        }
-        s->last_superframe_len = len;
-        memcpy(s->last_superframe, buf + pos, len);
-    } else {
-        if(s->nb_channels * s->frame_len * sizeof(int16_t) > *data_size){
-            av_log(s->avctx, AV_LOG_ERROR, "Insufficient output space\n");
-            goto fail;
-        }
-        /* single frame decode */
-        if (wma_decode_frame(s, samples) < 0)
-            goto fail;
-        samples += s->nb_channels * s->frame_len;
-    }
-
-//av_log(NULL, AV_LOG_ERROR, "%d %d %d %d outbytes:%d eaten:%d\n", s->frame_len_bits, s->block_len_bits, s->frame_len, s->block_len,        (int8_t *)samples - (int8_t *)data, s->block_align);
-    *data_size = (int8_t *)samples - (int8_t *)data;
-    return buf_size;
- fail:
-    /* when error, we reset the bit reservoir */
-    s->last_superframe_len = 0;
-    return -1;
-}
-
-static av_cold void flush(AVCodecContext *avctx)
-{
-    WMACodecContext *s = avctx->priv_data;
-
-    s->last_bitoffset=
-    s->last_superframe_len= 0;
-}
-
-AVCodec ff_wmav1_decoder =
-{
-    "wmav1",
-    AVMEDIA_TYPE_AUDIO,
-    CODEC_ID_WMAV1,
-    sizeof(WMACodecContext),
-    wma_decode_init,
-    NULL,
-    ff_wma_end,
-    wma_decode_superframe,
-    .flush=flush,
-    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 1"),
-};
-
-AVCodec ff_wmav2_decoder =
-{
-    "wmav2",
-    AVMEDIA_TYPE_AUDIO,
-    CODEC_ID_WMAV2,
-    sizeof(WMACodecContext),
-    wma_decode_init,
-    NULL,
-    ff_wma_end,
-    wma_decode_superframe,
-    .flush=flush,
-    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 2"),
-};

--- a/libavcodec/wmafixed.c
+++ b/libavcodec/wmafixed.c
@@ -0,0 +1,230 @@
+/****************************************************************************
+ *             __________               __   ___.
+ *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
+ *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
+ *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
+ *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
+ *                     \/            \/     \/    \/            \/
+ *
+ * Copyright (C) 2007 Michael Giacomelli
+ *
+ * All files in this archive are subject to the GNU General Public License.
+ * See the file COPYING in the source tree root for full license agreement.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ ****************************************************************************/
+
+#include "fixed_wmadec.h"
+#include "wmafixed.h"
+#include "config.h"
+
+int64_t IntTo64(int x){
+    int64_t res = 0;
+    unsigned char *p = (unsigned char *)&res;
+
+#if HAVE_BIGENDIAN
+    p[5] = x & 0xff;
+    p[4] = (x & 0xff00)>>8;
+    p[3] = (x & 0xff0000)>>16;
+    p[2] = (x & 0xff000000)>>24;
+#else
+    p[2] = x & 0xff;
+    p[3] = (x & 0xff00)>>8;
+    p[4] = (x & 0xff0000)>>16;
+    p[5] = (x & 0xff000000)>>24;
+#endif
+    return res;
+}
+
+int IntFrom64(int64_t x)
+{
+    int res = 0;
+    unsigned char *p = (unsigned char *)&x;
+
+#if HAVE_BIGENDIAN
+    res = p[5] | (p[4]<<8) | (p[3]<<16) | (p[2]<<24);
+#else
+    res = p[2] | (p[3]<<8) | (p[4]<<16) | (p[5]<<24);
+#endif
+    return res;
+}
+
+int32_t Fixed32From64(int64_t x)
+{
+  return x & 0xFFFFFFFF;
+}
+
+int64_t Fixed32To64(int32_t x)
+{
+  return (int64_t)x;
+}
+
+/*
+ * Not performance senstitive code here
+ */
+
+int64_t fixmul64byfixed(int64_t x, int32_t y)
+{
+    return (x * y);
+/*  return (int64_t) fixmul32(Fixed32From64(x),y); */
+}
+
+int32_t fixdiv32(int32_t x, int32_t y)
+{
+    int64_t temp;
+
+    if(x == 0)
+        return 0;
+    if(y == 0)
+        return 0x7fffffff;
+    temp = x;
+    temp <<= PRECISION;
+    return (int32_t)(temp / y);
+}
+
+int64_t fixdiv64(int64_t x, int64_t y)
+{
+    int64_t temp;
+
+    if(x == 0)
+        return 0;
+    if(y == 0)
+        return 0x07ffffffffffffffLL;
+    temp = x;
+    temp <<= PRECISION64;
+    return (int64_t)(temp / y);
+}
+
+int32_t fixsqrt32(int32_t x)
+{
+    unsigned long r = 0, s, v = (unsigned long)x;
+
+#define STEP(k) s = r + (1 << k * 2); r >>= 1; \
+    if (s <= v) { v -= s; r |= (1 << k * 2); }
+
+    STEP(15);
+    STEP(14);
+    STEP(13);
+    STEP(12);
+    STEP(11);
+    STEP(10);
+    STEP(9);
+    STEP(8);
+    STEP(7);
+    STEP(6);
+    STEP(5);
+    STEP(4);
+    STEP(3);
+    STEP(2);
+    STEP(1);
+    STEP(0);
+
+#undef STEP
+
+    return (int32_t)(r << (PRECISION >> 1));
+}
+
+/* Inverse gain of circular cordic rotation in s0.31 format. */
+static const long cordic_circular_gain = 0xb2458939; /* 0.607252929 */
+
+/* Table of values of atan(2^-i) in 0.32 format fractions of pi where pi = 0xffffffff / 2 */
+static const unsigned long atan_table[] = {
+    0x1fffffff, /* +0.785398163 (or pi/4) */
+    0x12e4051d, /* +0.463647609 */
+    0x09fb385b, /* +0.244978663 */
+    0x051111d4, /* +0.124354995 */
+    0x028b0d43, /* +0.062418810 */
+    0x0145d7e1, /* +0.031239833 */
+    0x00a2f61e, /* +0.015623729 */
+    0x00517c55, /* +0.007812341 */
+    0x0028be53, /* +0.003906230 */
+    0x00145f2e, /* +0.001953123 */
+    0x000a2f98, /* +0.000976562 */
+    0x000517cc, /* +0.000488281 */
+    0x00028be6, /* +0.000244141 */
+    0x000145f3, /* +0.000122070 */
+    0x0000a2f9, /* +0.000061035 */
+    0x0000517c, /* +0.000030518 */
+    0x000028be, /* +0.000015259 */
+    0x0000145f, /* +0.000007629 */
+    0x00000a2f, /* +0.000003815 */
+    0x00000517, /* +0.000001907 */
+    0x0000028b, /* +0.000000954 */
+    0x00000145, /* +0.000000477 */
+    0x000000a2, /* +0.000000238 */
+    0x00000051, /* +0.000000119 */
+    0x00000028, /* +0.000000060 */
+    0x00000014, /* +0.000000030 */
+    0x0000000a, /* +0.000000015 */
+    0x00000005, /* +0.000000007 */
+    0x00000002, /* +0.000000004 */
+    0x00000001, /* +0.000000002 */
+    0x00000000, /* +0.000000001 */
+    0x00000000, /* +0.000000000 */
+};
+
+/*
+ *   Below here functions do not use standard fixed precision!
+ */
+
+/**
+ * Implements sin and cos using CORDIC rotation.
+ *
+ * @param phase has range from 0 to 0xffffffff, representing 0 and
+ *        2*pi respectively.
+ * @param cos return address for cos
+ * @return sin of phase, value is a signed value from LONG_MIN to LONG_MAX,
+ *         representing -1 and 1 respectively.
+ *
+ *        Gives at least 24 bits precision (last 2-8 bits or so are probably off)
+ */
+long fsincos(unsigned long phase, int32_t *cos)
+{
+    int32_t x, x1, y, y1;
+    unsigned long z, z1;
+    int i;
+
+    /* Setup initial vector */
+    x = cordic_circular_gain;
+    y = 0;
+    z = phase;
+
+    /* The phase has to be somewhere between 0..pi for this to work right */
+    if (z < 0xffffffff >> 2) {
+        /* z in first quadrant, z += pi/2 to correct */
+        x = -x;
+        z += 0xffffffff >> 2;
+    } else if (z < 3 * (0xffffffff >> 2)) {
+        /* z in third quadrant, z -= pi/2 to correct */
+        z -= 0xffffffff >> 2;
+    } else {
+        /* z in fourth quadrant, z -= 3pi/2 to correct */
+        x = -x;
+        z -= 3 * (0xffffffff >> 2);
+    }
+
+    /* Each iteration adds roughly 1-bit of extra precision */
+    for (i = 0; i < 31; i++) {
+        x1 = x >> i;
+        y1 = y >> i;
+        z1 = atan_table[i];
+
+        /* Decided which direction to rotate vector. Pivot point is pi/2 */
+        if (z >= 0xffffffff >> 2) {
+            x -= y1;
+            y += x1;
+            z -= z1;
+        } else {
+            x += y1;
+            y -= x1;
+            z += z1;
+        }
+    }
+
+    if (cos)
+        *cos = x;
+
+    return y;
+}

--- a/libavcodec/wmafixed.h
+++ b/libavcodec/wmafixed.h
@@ -0,0 +1,203 @@
+/****************************************************************************
+ *             __________               __   ___.
+ *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
+ *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
+ *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
+ *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
+ *                     \/            \/     \/    \/            \/
+ *
+ * Copyright (C) 2007 Michael Giacomelli
+ *
+ * All files in this archive are subject to the GNU General Public License.
+ * See the file COPYING in the source tree root for full license agreement.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ ****************************************************************************/
+
+/*  fixed precision code.  We use a combination of Sign 15.16 and Sign.31
+    precision here.
+
+    The WMA decoder does not always follow this convention, and occasionally
+    renormalizes values to other formats in order to maximize precision.
+    However, only the two precisions above are provided in this file.
+
+*/
+
+#include <inttypes.h>
+
+#define PRECISION       16
+#define PRECISION64     16
+
+#define fixtof64(x)       (float)((float)(x) / (float)(1 << PRECISION64))        //does not work on int64_t!
+#define ftofix32(x)       ((int32_t)((x) * (float)(1 << PRECISION) + ((x) < 0 ? -0.5 : 0.5)))
+#define itofix64(x)       (IntTo64(x))
+#define itofix32(x)       ((x) << PRECISION)
+#define fixtoi32(x)       ((x) >> PRECISION)
+#define fixtoi64(x)       (IntFrom64(x))
+
+/*fixed functions*/
+
+int64_t IntTo64(int x);
+int IntFrom64(int64_t x);
+int32_t Fixed32From64(int64_t x);
+int64_t Fixed32To64(int32_t x);
+int64_t fixmul64byfixed(int64_t x, int32_t y);
+int32_t fixdiv32(int32_t x, int32_t y);
+int64_t fixdiv64(int64_t x, int64_t y);
+int32_t fixsqrt32(int32_t x);
+long fsincos(unsigned long phase, int32_t *cos);
+
+/*#ifdef __arm__
+
+
+
+#define fixmul32(x, y)  \
+    ({ int32_t __hi;  \
+       uint32_t __lo;  \
+       int32_t __result;  \
+       __asm__ ("smull   %0, %1, %3, %4\n\t"  \
+            "movs    %0, %0, lsr %5\n\t"  \
+            "adc    %2, %0, %1, lsl %6"  \
+            : "=&r" (__lo), "=&r" (__hi), "=r" (__result)  \
+            : "%r" (x), "r" (y),  \
+              "M" (PRECISION), "M" (32 - PRECISION)  \
+            : "cc");  \
+       __result;  \
+    })
+
+#define fixmul32b(x, y)  \
+    ({ int32_t __hi;  \
+       uint32_t __lo;  \
+       int32_t __result;  \
+       __asm__ ("smull   %0, %1, %3, %4\n\t"  \
+            "movs    %2, %1, lsl #1"  \
+            : "=&r" (__lo), "=&r" (__hi), "=r" (__result)  \
+            : "%r" (x), "r" (y)  \
+            : "cc");  \
+       __result;  \
+    })
+
+#elif defined(CPU_COLDFIRE)
+
+static inline int32_t fixmul32(int32_t x, int32_t y)
+{
+#if PRECISION != 16
+#warning Coldfire fixmul32() only works for PRECISION == 16
+#endif
+    int32_t t1;
+    __asm__ (
+        "mac.l   %[x], %[y], %%acc0  \n" 
+        "mulu.l  %[y], %[x]      \n"     
+        "movclr.l %%acc0, %[t1]  \n"     
+        "lsr.l   #1, %[t1]       \n"
+        "move.w  %[t1], %[x]     \n"
+        "swap    %[x]            \n"
+        : [t1] "=&d" (t1), [x] "+d" (x)
+        : [y] "d"  (y)
+    );
+    return x;
+}
+
+static inline int32_t fixmul32b(int32_t x, int32_t y)
+{
+    __asm__ (
+        "mac.l   %[x], %[y], %%acc0  \n" 
+        "movclr.l %%acc0, %[x]  \n"     
+        : [x] "+d" (x)
+        : [y] "d"  (y)
+    );
+    return x;
+}
+
+#else*/
+
+static inline int32_t fixmul32(int32_t x, int32_t y)
+{
+    int64_t temp;
+    temp = x;
+    temp *= y;
+
+    temp >>= PRECISION;
+
+    return (int32_t)temp;
+}
+
+static inline int32_t fixmul32b(int32_t x, int32_t y)
+{
+    int64_t temp;
+
+    temp = x;
+    temp *= y;
+
+    temp >>= 31;        //16+31-16 = 31 bits
+
+    return (int32_t)temp;
+}
+
+/*#endif
+
+#ifdef __arm__
+static inline
+void CMUL_FIX(int32_t *x, int32_t *y,
+          int32_t  a, int32_t  b,
+          int32_t  t, int32_t  v)
+{
+    
+    int x1, y1, l;
+    __asm__(
+        "smull    %[l], %[y1], %[b], %[t] \n"
+        "smlal    %[l], %[y1], %[a], %[v] \n"
+        "rsb      %[b], %[b], #0          \n"
+        "smull    %[l], %[x1], %[a], %[t] \n"
+        "smlal    %[l], %[x1], %[b], %[v] \n"
+        : [l] "=&r" (l), [x1]"=&r" (x1), [y1]"=&r" (y1), [b] "+r" (b)
+        : [a] "r" (a),   [t] "r" (t),    [v] "r" (v)
+        : "cc"
+    );
+    *x = x1 << 1;
+    *y = y1 << 1;
+}
+#elif defined CPU_COLDFIRE
+static inline
+void CMUL_FIX(int32_t *x, int32_t *y,
+          int32_t  a, int32_t  b,
+          int32_t  t, int32_t  v)
+{
+  __asm__ volatile ("mac.l %[a], %[t], %%acc0;"
+                "msac.l %[b], %[v], %%acc0;"
+                "mac.l %[b], %[t], %%acc1;"
+                "mac.l %[a], %[v], %%acc1;"
+                "movclr.l %%acc0, %[a];"
+                "move.l %[a], (%[x]);"
+                "movclr.l %%acc1, %[a];"
+                "move.l %[a], (%[y]);"
+                : [a] "+&r" (a)
+                : [x] "a" (x), [y] "a" (y),
+                  [b] "r" (b), [t] "r" (t), [v] "r" (v)
+                : "cc", "memory");
+}
+#else*/
+static inline
+void CMUL_FIX(int32_t *pre,
+          int32_t *pim,
+          int32_t are,
+          int32_t aim,
+          int32_t bre,
+          int32_t bim)
+{
+    //int64_t x,y;
+    int32_t _aref = are;
+    int32_t _aimf = aim;
+    int32_t _bref = bre;
+    int32_t _bimf = bim;
+    int32_t _r1 = fixmul32b(_bref, _aref);
+    int32_t _r2 = fixmul32b(_bimf, _aimf);
+    int32_t _r3 = fixmul32b(_bref, _aimf);
+    int32_t _r4 = fixmul32b(_bimf, _aref);
+    *pre = _r1 - _r2;
+    *pim = _r3 + _r4;
+
+}
+//#endif

--- a/libavcodec/wma.h
+++ b/libavcodec/wma.h
@@ -1,165 +0,0 @@
-/*
- * WMA compatible codec
- * Copyright (c) 2002-2007 The FFmpeg Project
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_WMA_H
-#define AVCODEC_WMA_H
-
-#include "get_bits.h"
-#include "put_bits.h"
-#include "dsputil.h"
-#include "fft.h"
-#include "fmtconvert.h"
-
-/* size of blocks */
-#define BLOCK_MIN_BITS 7
-#define BLOCK_MAX_BITS 11
-#define BLOCK_MAX_SIZE (1 << BLOCK_MAX_BITS)
-
-#define BLOCK_NB_SIZES (BLOCK_MAX_BITS - BLOCK_MIN_BITS + 1)
-
-/* XXX: find exact max size */
-#define HIGH_BAND_MAX_SIZE 16
-
-#define NB_LSP_COEFS 10
-
-/* XXX: is it a suitable value ? */
-#define MAX_CODED_SUPERFRAME_SIZE 16384
-
-#define MAX_CHANNELS 2
-
-#define NOISE_TAB_SIZE 8192
-
-#define LSP_POW_BITS 7
-
-//FIXME should be in wmadec
-#define VLCBITS 9
-#define VLCMAX ((22+VLCBITS-1)/VLCBITS)
-
-typedef float WMACoef;          ///< type for decoded coefficients, int16_t would be enough for wma 1/2
-
-typedef struct CoefVLCTable {
-    int n;                      ///< total number of codes
-    int max_level;
-    const uint32_t *huffcodes;  ///< VLC bit values
-    const uint8_t *huffbits;    ///< VLC bit size
-    const uint16_t *levels;     ///< table to build run/level tables
-} CoefVLCTable;
-
-typedef struct WMACodecContext {
-    AVCodecContext* avctx;
-    GetBitContext gb;
-    PutBitContext pb;
-    int sample_rate;
-    int nb_channels;
-    int bit_rate;
-    int version;                            ///< 1 = 0x160 (WMAV1), 2 = 0x161 (WMAV2)
-    int block_align;
-    int use_bit_reservoir;
-    int use_variable_block_len;
-    int use_exp_vlc;                        ///< exponent coding: 0 = lsp, 1 = vlc + delta
-    int use_noise_coding;                   ///< true if perceptual noise is added
-    int byte_offset_bits;
-    VLC exp_vlc;
-    int exponent_sizes[BLOCK_NB_SIZES];
-    uint16_t exponent_bands[BLOCK_NB_SIZES][25];
-    int high_band_start[BLOCK_NB_SIZES];    ///< index of first coef in high band
-    int coefs_start;                        ///< first coded coef
-    int coefs_end[BLOCK_NB_SIZES];          ///< max number of coded coefficients
-    int exponent_high_sizes[BLOCK_NB_SIZES];
-    int exponent_high_bands[BLOCK_NB_SIZES][HIGH_BAND_MAX_SIZE];
-    VLC hgain_vlc;
-
-    /* coded values in high bands */
-    int high_band_coded[MAX_CHANNELS][HIGH_BAND_MAX_SIZE];
-    int high_band_values[MAX_CHANNELS][HIGH_BAND_MAX_SIZE];
-
-    /* there are two possible tables for spectral coefficients */
-//FIXME the following 3 tables should be shared between decoders
-    VLC coef_vlc[2];
-    uint16_t *run_table[2];
-    float *level_table[2];
-    uint16_t *int_table[2];
-    const CoefVLCTable *coef_vlcs[2];
-    /* frame info */
-    int frame_len;                          ///< frame length in samples
-    int frame_len_bits;                     ///< frame_len = 1 << frame_len_bits
-    int nb_block_sizes;                     ///< number of block sizes
-    /* block info */
-    int reset_block_lengths;
-    int block_len_bits;                     ///< log2 of current block length
-    int next_block_len_bits;                ///< log2 of next block length
-    int prev_block_len_bits;                ///< log2 of prev block length
-    int block_len;                          ///< block length in samples
-    int block_num;                          ///< block number in current frame
-    int block_pos;                          ///< current position in frame
-    uint8_t ms_stereo;                      ///< true if mid/side stereo mode
-    uint8_t channel_coded[MAX_CHANNELS];    ///< true if channel is coded
-    int exponents_bsize[MAX_CHANNELS];      ///< log2 ratio frame/exp. length
-    DECLARE_ALIGNED(32, float, exponents)[MAX_CHANNELS][BLOCK_MAX_SIZE];
-    float max_exponent[MAX_CHANNELS];
-    WMACoef coefs1[MAX_CHANNELS][BLOCK_MAX_SIZE];
-    DECLARE_ALIGNED(32, float, coefs)[MAX_CHANNELS][BLOCK_MAX_SIZE];
-    DECLARE_ALIGNED(32, FFTSample, output)[BLOCK_MAX_SIZE * 2];
-    FFTContext mdct_ctx[BLOCK_NB_SIZES];
-    float *windows[BLOCK_NB_SIZES];
-    /* output buffer for one frame and the last for IMDCT windowing */
-    DECLARE_ALIGNED(32, float, frame_out)[MAX_CHANNELS][BLOCK_MAX_SIZE * 2];
-    /* last frame info */
-    uint8_t last_superframe[MAX_CODED_SUPERFRAME_SIZE + 4]; /* padding added */
-    int last_bitoffset;
-    int last_superframe_len;
-    float noise_table[NOISE_TAB_SIZE];
-    int noise_index;
-    float noise_mult; /* XXX: suppress that and integrate it in the noise array */
-    /* lsp_to_curve tables */
-    float lsp_cos_table[BLOCK_MAX_SIZE];
-    float lsp_pow_e_table[256];
-    float lsp_pow_m_table1[(1 << LSP_POW_BITS)];
-    float lsp_pow_m_table2[(1 << LSP_POW_BITS)];
-    DSPContext dsp;
-    FmtConvertContext fmt_conv;
-
-#ifdef TRACE
-    int frame_count;
-#endif
-} WMACodecContext;
-
-extern const uint16_t ff_wma_critical_freqs[25];
-extern const uint16_t ff_wma_hgain_huffcodes[37];
-extern const uint8_t ff_wma_hgain_huffbits[37];
-extern const float ff_wma_lsp_codebook[NB_LSP_COEFS][16];
-extern const uint32_t ff_aac_scalefactor_code[121];
-extern const uint8_t  ff_aac_scalefactor_bits[121];
-
-int av_cold ff_wma_get_frame_len_bits(int sample_rate, int version,
-                                      unsigned int decode_flags);
-int ff_wma_init(AVCodecContext * avctx, int flags2);
-int ff_wma_total_gain_to_bits(int total_gain);
-int ff_wma_end(AVCodecContext *avctx);
-unsigned int ff_wma_get_large_val(GetBitContext* gb);
-int ff_wma_run_level_decode(AVCodecContext* avctx, GetBitContext* gb,
-                            VLC *vlc,
-                            const float *level_table, const uint16_t *run_table,
-                            int version, WMACoef *ptr, int offset,
-                            int num_coefs, int block_len, int frame_len_bits,
-                            int coef_nb_bits);
-
-#endif /* AVCODEC_WMA_H */
