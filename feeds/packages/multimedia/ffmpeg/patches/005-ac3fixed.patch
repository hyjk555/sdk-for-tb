--- ffmpeg-0.7.12/libavcodec/ac3dec.c	2012-04-10 01:04:54.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/ac3dec.c	2013-08-16 18:21:40.000000000 +0800
@@ -29,6 +29,10 @@
 #include <math.h>
 #include <string.h>
 
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_AC3_FIXED 1
+#define CONFIG_FFT_FIXED_32 1
+
 #include "libavutil/crc.h"
 #include "internal.h"
 #include "aac_ac3_parser.h"
@@ -41,6 +45,29 @@
  * table for ungrouping 3 values in 7 bits.
  * used for exponents and bap=2 mantissas
  */
+
+#include "ac3dec.h"
+#include "fixed_bitstream.h"
+
+/**
+ * Table for center mix levels
+ * reference: Section 5.4.2.4 cmixlev
+ */
+static const uint8_t center_levels[4] = { 4, 5, 6, 5 };
+
+/**
+ * Table for surround mix levels
+ * reference: Section 5.4.2.5 surmixlev
+ */
+static const uint8_t surround_levels[4] = { 4, 6, 7, 6 };
+
+int end_freq_inv_tab[8] =
+{
+    50529027, 44278013, 39403370, 32292987, 27356480, 23729101, 20951060, 18755316
+};
+
+
+
 static uint8_t ungroup_3_in_7_bits_tab[128][3];
 
 
@@ -64,7 +91,7 @@
 static float dynamic_range_tab[256];
 
 /** Adjustments in dB gain */
-static const float gain_levels[9] = {
+static const INTFLOAT AC3_RENAME(gain_levels)[9] = {
     LEVEL_PLUS_3DB,
     LEVEL_PLUS_1POINT5DB,
     LEVEL_ONE,
@@ -79,14 +106,14 @@
 /**
  * Table for center mix levels
  * reference: Section 5.4.2.4 cmixlev
- */
-static const uint8_t center_levels[4] = { 4, 5, 6, 5 };
+ 
+static const uint8_t center_levels[4] = { 4, 5, 6, 5 };*/
 
 /**
  * Table for surround mix levels
  * reference: Section 5.4.2.5 surmixlev
- */
-static const uint8_t surround_levels[4] = { 4, 6, 7, 6 };
+ 
+static const uint8_t surround_levels[4] = { 4, 6, 7, 6 };*/
 
 /**
  * Table for default stereo downmixing coefficients
@@ -108,6 +135,79 @@
  * reference: Section 7.3.3 Expansion of Mantissas for Symmetrical Quantization
  *            Tables 7.19 to 7.23
  */
+
+static void scale_coefs (
+    int32_t *dst,
+    const int32_t *src,
+    int dynrng,
+    int len)
+{
+    int i, shift, round;
+    int16_t mul;
+    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
+
+    mul = (dynrng & 0x1f) + 0x20;
+    shift = 4 - ((dynrng << 24) >> 29);
+    round = 1 << (shift-1);
+    for (i=0; i<len; i+=8) {
+
+        temp = src[i] * mul;
+        temp1 = src[i+1] * mul;
+        temp = temp + round;
+        temp2 = src[i+2] * mul;
+
+        temp1 = temp1 + round;
+        dst[i] = temp >> shift;
+        temp3 = src[i+3] * mul;
+        temp2 = temp2 + round;
+
+        dst[i+1] = temp1 >> shift;
+        temp4 = src[i + 4] * mul;
+        temp3 = temp3 + round;
+        dst[i+2] = temp2 >> shift;
+
+        temp5 = src[i+5] * mul;
+        temp4 = temp4 + round;
+        dst[i+3] = temp3 >> shift;
+        temp6 = src[i+6] * mul;
+
+        dst[i+4] = temp4 >> shift;
+        temp5 = temp5 + round;
+        temp7 = src[i+7] * mul;
+        temp6 = temp6 + round;
+
+        dst[i+5] = temp5 >> shift;
+        temp7 = temp7 + round;
+        dst[i+6] = temp6 >> shift;
+        dst[i+7] = temp7 >> shift;
+
+    }
+}
+
+static int ac3_fixed_sqrt(int x)
+{
+    int retval;
+    int bit_mask;
+    int guess;
+    int square;
+    int   i;
+    long long accu;
+
+        retval = 0;
+        bit_mask = 0x400000;
+
+        for (i=0; i<23; i++){
+            guess = retval + bit_mask;
+            accu = (long long)guess * guess;
+            square = (int)(accu >> 23);
+            if (x >= square)
+                retval += bit_mask;
+            bit_mask >>= 1;
+        }
+    return retval;
+}
+
+
 static inline int
 symmetric_dequant(int code, int levels)
 {
@@ -172,6 +272,7 @@
  */
 static av_cold int ac3_decode_init(AVCodecContext *avctx)
 {
+    int i;
     AC3DecodeContext *s = avctx->priv_data;
     s->avctx = avctx;
 
@@ -179,20 +280,17 @@
     ac3_tables_init();
     ff_mdct_init(&s->imdct_256, 8, 1, 1.0);
     ff_mdct_init(&s->imdct_512, 9, 1, 1.0);
-    ff_kbd_window_init(s->window, 5.0, 256);
+    AC3_RENAME(ff_kbd_window_init)(s->window, 5.0, 256);
     dsputil_init(&s->dsp, avctx);
+
+    avpriv_fixed_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);
+
     ff_ac3dsp_init(&s->ac3dsp, avctx->flags & CODEC_FLAG_BITEXACT);
     ff_fmt_convert_init(&s->fmt_conv, avctx);
     av_lfg_init(&s->dith_state, 0);
 
-    /* set scale value for float to int16 conversion */
-    if (avctx->request_sample_fmt == AV_SAMPLE_FMT_FLT) {
-        s->mul_bias = 1.0f;
-        avctx->sample_fmt = AV_SAMPLE_FMT_FLT;
-    } else {
-        s->mul_bias = 32767.0f;
-        avctx->sample_fmt = AV_SAMPLE_FMT_S16;
-    }
+    s->mul_bias = MUL_BIAS2;//jh
+    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
 
     /* allow downmixing to stereo or mono */
     if (avctx->channels > 0 && avctx->request_channels > 0 &&
@@ -201,6 +299,12 @@
         avctx->channels = avctx->request_channels;
     }
     s->downmixed = 1;
+   /* for (i = 0; i < AC3_MAX_CHANNELS; i++) {
+        s->xcfptr[i] = s->transform_coeffs[i];
+        s->dlyptr[i] = s->delay[i];
+    }*/
+
+
 
     return 0;
 }
@@ -218,29 +322,29 @@
     /* read the rest of the bsi. read twice for dual mono mode. */
     i = !(s->channel_mode);
     do {
-        skip_bits(gbc, 5); // skip dialog normalization
-        if (get_bits1(gbc))
-            skip_bits(gbc, 8); //skip compression
-        if (get_bits1(gbc))
-            skip_bits(gbc, 8); //skip language code
-        if (get_bits1(gbc))
-            skip_bits(gbc, 7); //skip audio production information
+        skip_bits_fixed(gbc, 5); // skip dialog normalization
+        if (get_bits1_fixed(gbc))
+            skip_bits_fixed(gbc, 8); //skip compression
+        if (get_bits1_fixed(gbc))
+            skip_bits_fixed(gbc, 8); //skip language code
+        if (get_bits1_fixed(gbc))
+            skip_bits_fixed(gbc, 7); //skip audio production information
     } while (i--);
 
-    skip_bits(gbc, 2); //skip copyright bit and original bitstream bit
+    skip_bits_fixed(gbc, 2); //skip copyright bit and original bitstream bit
 
     /* skip the timecodes (or extra bitstream information for Alternate Syntax)
        TODO: read & use the xbsi1 downmix levels */
-    if (get_bits1(gbc))
-        skip_bits(gbc, 14); //skip timecode1 / xbsi1
-    if (get_bits1(gbc))
-        skip_bits(gbc, 14); //skip timecode2 / xbsi2
+    if (get_bits1_fixed(gbc))
+        skip_bits_fixed(gbc, 14); //skip timecode1 / xbsi1
+    if (get_bits1_fixed(gbc))
+        skip_bits_fixed(gbc, 14); //skip timecode2 / xbsi2
 
     /* skip additional bitstream info */
-    if (get_bits1(gbc)) {
-        i = get_bits(gbc, 6);
+    if (get_bits1_fixed(gbc)) {
+        i = get_bits_fixed(gbc, 6);
         do {
-            skip_bits(gbc, 8);
+            skip_bits_fixed(gbc, 8);
         } while(i--);
     }
 
@@ -313,20 +417,20 @@
 static void set_downmix_coeffs(AC3DecodeContext *s)
 {
     int i;
-    float cmix = gain_levels[center_levels[s->center_mix_level]];
-    float smix = gain_levels[surround_levels[s->surround_mix_level]];
-    float norm0, norm1;
+    SHORTFLOAT cmix = AC3_RENAME(gain_levels)[s->  center_mix_level];
+    SHORTFLOAT smix = AC3_RENAME(gain_levels)[s->surround_mix_level];
+    INTFLOAT norm0, norm1;
 
     for(i=0; i<s->fbw_channels; i++) {
-        s->downmix_coeffs[i][0] = gain_levels[ac3_default_coeffs[s->channel_mode][i][0]];
-        s->downmix_coeffs[i][1] = gain_levels[ac3_default_coeffs[s->channel_mode][i][1]];
+        s->downmix_coeffs[i][0] = AC3_RENAME(gain_levels)[ac3_default_coeffs[s->channel_mode][i][0]];
+        s->downmix_coeffs[i][1] = AC3_RENAME(gain_levels)[ac3_default_coeffs[s->channel_mode][i][1]];
     }
     if(s->channel_mode > 1 && s->channel_mode & 1) {
         s->downmix_coeffs[1][0] = s->downmix_coeffs[1][1] = cmix;
     }
     if(s->channel_mode == AC3_CHMODE_2F1R || s->channel_mode == AC3_CHMODE_3F1R) {
         int nf = s->channel_mode - 2;
-        s->downmix_coeffs[nf][0] = s->downmix_coeffs[nf][1] = smix * LEVEL_MINUS_3DB;
+        s->downmix_coeffs[nf][0] = s->downmix_coeffs[nf][1] = AC3_LEVEL(smix);
     }
     if(s->channel_mode == AC3_CHMODE_2F2R || s->channel_mode == AC3_CHMODE_3F2R) {
         int nf = s->channel_mode - 4;
@@ -334,21 +438,22 @@
     }
 
     /* renormalize */
-    norm0 = norm1 = 0.0;
+    norm0 = norm1 = FIXR(0.0);
     for(i=0; i<s->fbw_channels; i++) {
         norm0 += s->downmix_coeffs[i][0];
         norm1 += s->downmix_coeffs[i][1];
     }
-    norm0 = 1.0f / norm0;
-    norm1 = 1.0f / norm1;
+    norm0 = AC3_NORM(norm0);
+    norm1 = AC3_NORM(norm1);
     for(i=0; i<s->fbw_channels; i++) {
-        s->downmix_coeffs[i][0] *= norm0;
-        s->downmix_coeffs[i][1] *= norm1;
+       s->downmix_coeffs[i][0] = (SHORTFLOAT)AC3_MUL(s->downmix_coeffs[i][0],norm0);
+       s->downmix_coeffs[i][1] = (SHORTFLOAT)AC3_MUL(s->downmix_coeffs[i][1],norm1);
     }
 
     if(s->output_mode == AC3_CHMODE_MONO) {
         for(i=0; i<s->fbw_channels; i++)
-            s->downmix_coeffs[i][0] = (s->downmix_coeffs[i][0] + s->downmix_coeffs[i][1]) * LEVEL_MINUS_3DB;
+            s->downmix_coeffs[i][0] = AC3_LEVEL(s->downmix_coeffs[i][0] + s->downmix_coeffs[i][1]);
+            
     }
 }
 
@@ -366,7 +471,7 @@
     /* unpack groups */
     group_size = exp_strategy + (exp_strategy == EXP_D45);
     for(grp=0,i=0; grp<ngrps; grp++) {
-        expacc = get_bits(gbc, 7);
+        expacc = get_bits_fixed(gbc, 7);
         dexp[i++] = ungroup_3_in_7_bits_tab[expacc][0];
         dexp[i++] = ungroup_3_in_7_bits_tab[expacc][1];
         dexp[i++] = ungroup_3_in_7_bits_tab[expacc][2];
@@ -460,7 +565,7 @@
                     mantissa = m->b1_mant[m->b1];
                 }
                 else{
-                    int bits      = get_bits(gbc, 5);
+                    int bits      = get_bits_fixed(gbc, 5);
                     mantissa      = b1_mantissas[bits][0];
                     m->b1_mant[1] = b1_mantissas[bits][1];
                     m->b1_mant[0] = b1_mantissas[bits][2];
@@ -473,7 +578,7 @@
                     mantissa = m->b2_mant[m->b2];
                 }
                 else{
-                    int bits      = get_bits(gbc, 7);
+                    int bits      = get_bits_fixed(gbc, 7);
                     mantissa      = b2_mantissas[bits][0];
                     m->b2_mant[1] = b2_mantissas[bits][1];
                     m->b2_mant[0] = b2_mantissas[bits][2];
@@ -481,7 +586,7 @@
                 }
                 break;
             case 3:
-                mantissa = b3_mantissas[get_bits(gbc, 3)];
+                mantissa = b3_mantissas[get_bits_fixed(gbc, 3)];
                 break;
             case 4:
                 if(m->b4){
@@ -489,17 +594,17 @@
                     mantissa = m->b4_mant;
                 }
                 else{
-                    int bits   = get_bits(gbc, 7);
+                    int bits   = get_bits_fixed(gbc, 7);
                     mantissa   = b4_mantissas[bits][0];
                     m->b4_mant = b4_mantissas[bits][1];
                     m->b4      = 1;
                 }
                 break;
             case 5:
-                mantissa = b5_mantissas[get_bits(gbc, 4)];
+                mantissa = b5_mantissas[get_bits_fixed(gbc, 4)];
                 break;
             default: /* 6 to 15 */
-                mantissa = get_bits(gbc, quantization_tab[bap]);
+                mantissa = get_bits_fixed(gbc, quantization_tab[bap]);
                 /* Shift mantissa and sign-extend it. */
                 mantissa = (mantissa << (32-quantization_tab[bap]))>>8;
                 break;
@@ -613,18 +718,22 @@
     for (ch=1; ch<=channels; ch++) {
         if (s->block_switch[ch]) {
             int i;
-            float *x = s->tmp_output+128;
+            FFTSample *x = s->tmp_output + 128;
             for(i=0; i<128; i++)
                 x[i] = s->transform_coeffs[ch][2*i];
             s->imdct_256.imdct_half(&s->imdct_256, s->tmp_output, x);
-            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, 128);
+            s->fdsp.AC3_RENAME(vector_fmul_window)(s->output[ch - 1], s->delay[ch - 1],s->tmp_output, s->window, 128);
+
             for(i=0; i<128; i++)
                 x[i] = s->transform_coeffs[ch][2*i+1];
             s->imdct_256.imdct_half(&s->imdct_256, s->delay[ch-1], x);
         } else {
             s->imdct_512.imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch]);
-            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, 128);
-            memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));
+
+            s->fdsp.AC3_RENAME(vector_fmul_window)(s->output[ch - 1], s->delay[ch - 1],
+                                       s->tmp_output, s->window, 128);
+
+            memcpy(s->delay[ch - 1], s->tmp_output + 128, 128 * sizeof(FFTSample));
         }
     }
 }
@@ -656,6 +765,33 @@
     }
 }
 
+
+static void ac3_downmix_c_fixed16(int16_t **samples, int16_t (*matrix)[2],
+                      int out_ch, int in_ch, int len)
+{
+    int i, j;
+    int v0, v1;
+    if (out_ch == 2) {
+        for (i = 0; i < len; i++) {
+            v0 = v1 = 0;
+            for (j = 0; j < in_ch; j++) {
+                v0 += samples[j][i] * matrix[j][0];
+                v1 += samples[j][i] * matrix[j][1];
+            }
+            samples[0][i] = (v0+2048)>>12;
+            samples[1][i] = (v1+2048)>>12;
+        }
+    } else if (out_ch == 1) {
+        for (i = 0; i < len; i++) {
+            v0 = 0;
+            for (j = 0; j < in_ch; j++)
+                v0 += samples[j][i] * matrix[j][0];
+            samples[0][i] = (v0+2048)>>12;
+        }
+    }
+}
+
+
 /**
  * Upmix delay samples from stereo to original channel layout.
  */
@@ -713,9 +849,9 @@
     n_subbands = end_subband - start_subband;
 
     /* decode band structure from bitstream or use default */
-    if (!eac3 || get_bits1(gbc)) {
+    if (!eac3 || get_bits1_fixed(gbc)) {
         for (subbnd = 0; subbnd < n_subbands - 1; subbnd++) {
-            coded_band_struct[subbnd] = get_bits1(gbc);
+            coded_band_struct[subbnd] = get_bits1_fixed(gbc);
         }
         band_struct = coded_band_struct;
     } else if (!blk) {
@@ -769,7 +905,7 @@
     different_transforms = 0;
     if (s->block_switch_syntax) {
         for (ch = 1; ch <= fbw_channels; ch++) {
-            s->block_switch[ch] = get_bits1(gbc);
+            s->block_switch[ch] = get_bits1_fixed(gbc);
             if(ch > 1 && s->block_switch[ch] != s->block_switch[1])
                 different_transforms = 1;
         }
@@ -778,24 +914,23 @@
     /* dithering flags */
     if (s->dither_flag_syntax) {
         for (ch = 1; ch <= fbw_channels; ch++) {
-            s->dither_flag[ch] = get_bits1(gbc);
+            s->dither_flag[ch] = get_bits1_fixed(gbc);
         }
     }
 
     /* dynamic range */
     i = !(s->channel_mode);
     do {
-        if(get_bits1(gbc)) {
-            s->dynamic_range[i] = ((dynamic_range_tab[get_bits(gbc, 8)]-1.0) *
-                                  s->avctx->drc_scale)+1.0;
+        if(get_bits1_fixed(gbc)) {
+            s->dynamic_range[i] = AC3_DYNAMIC_RANGE(get_bits_fixed(gbc, 8));
         } else if(blk == 0) {
-            s->dynamic_range[i] = 1.0f;
+            s->dynamic_range[i] = AC3_DYNAMIC_RANGE1;
         }
     } while(i--);
 
     /* spectral extension strategy */
-    if (s->eac3 && (!blk || get_bits1(gbc))) {
-        s->spx_in_use = get_bits1(gbc);
+    if (s->eac3 && (!blk || get_bits1_fixed(gbc))) {
+        s->spx_in_use = get_bits1_fixed(gbc);
         if (s->spx_in_use) {
             int dst_start_freq, dst_end_freq, src_start_freq,
                 start_subband, end_subband;
@@ -805,16 +940,20 @@
                 s->channel_uses_spx[1] = 1;
             } else {
                 for (ch = 1; ch <= fbw_channels; ch++)
-                    s->channel_uses_spx[ch] = get_bits1(gbc);
+                    s->channel_uses_spx[ch] = get_bits1_fixed(gbc);
             }
 
             /* get the frequency bins of the spx copy region and the spx start
                and end subbands */
-            dst_start_freq = get_bits(gbc, 2);
-            start_subband  = get_bits(gbc, 3) + 2;
+            dst_start_freq = get_bits_fixed(gbc, 2);
+            start_subband  = get_bits_fixed(gbc, 3) + 2;
             if (start_subband > 7)
                 start_subband += start_subband - 7;
-            end_subband    = get_bits(gbc, 3) + 5;
+            end_subband    = get_bits_fixed(gbc, 3) + 5;
+
+            s->spx_dst_end_freq = end_freq_inv_tab[end_subband];
+            end_subband += 5;
+
             if (end_subband   > 7)
                 end_subband   += end_subband   - 7;
             dst_start_freq = dst_start_freq * 12 + 25;
@@ -835,8 +974,10 @@
 
             s->spx_dst_start_freq = dst_start_freq;
             s->spx_src_start_freq = src_start_freq;
-            s->spx_dst_end_freq   = dst_end_freq;
 
+#if !CONFIG_AC3_FIXED
+             s->spx_dst_end_freq   = dst_end_freq;
+#endif
             decode_band_structure(gbc, blk, s->eac3, 0,
                                   start_subband, end_subband,
                                   ff_eac3_default_spx_band_struct,
@@ -854,39 +995,53 @@
     if (s->spx_in_use) {
         for (ch = 1; ch <= fbw_channels; ch++) {
             if (s->channel_uses_spx[ch]) {
-                if (s->first_spx_coords[ch] || get_bits1(gbc)) {
-                    float spx_blend;
+                if (s->first_spx_coords[ch] || get_bits1_fixed(gbc)) {
+                    INTFLOAT spx_blend;
                     int bin, master_spx_coord;
 
                     s->first_spx_coords[ch] = 0;
-                    spx_blend = get_bits(gbc, 5) * (1.0f/32);
-                    master_spx_coord = get_bits(gbc, 2) * 3;
+                    spx_blend = AC3_SPX_BLEND(get_bits_fixed(gbc, 5));
+                    master_spx_coord = get_bits_fixed(gbc, 2) * 3;
 
                     bin = s->spx_src_start_freq;
                     for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
                         int bandsize;
                         int spx_coord_exp, spx_coord_mant;
-                        float nratio, sblend, nblend, spx_coord;
+                        INTFLOAT nratio, sblend, nblend;
 
+                        int64_t accu;
                         /* calculate blending factors */
                         bandsize = s->spx_band_sizes[bnd];
-                        nratio = ((float)((bin + (bandsize >> 1))) / s->spx_dst_end_freq) - spx_blend;
-                        nratio = av_clipf(nratio, 0.0f, 1.0f);
-                        nblend = sqrtf(3.0f * nratio); // noise is scaled by sqrt(3) to give unity variance
-                        sblend = sqrtf(1.0f - nratio);
+                        accu = (int64_t)((bin << 23) + (bandsize << 22)) * s->spx_dst_end_freq;
+                        nratio = (int)(accu >> 32);
+                        nratio -= spx_blend << 18;
+
+                        if (nratio < 0) {
+                            nblend = 0;
+                            sblend = 0x800000;
+                        } else if (nratio > 0x7fffff) {
+                            nblend = 0x800000;
+                            sblend = 0;
+                        } else {
+                            nblend = ac3_fixed_sqrt(nratio);
+                            accu = (int64_t)nblend * 1859775393;
+                            nblend = (int)((accu + (1<<29)) >> 30);
+                            sblend = ac3_fixed_sqrt(0x800000 - nratio); //jh
+                        }
                         bin += bandsize;
 
                         /* decode spx coordinates */
-                        spx_coord_exp  = get_bits(gbc, 4);
-                        spx_coord_mant = get_bits(gbc, 2);
+                        spx_coord_exp  = get_bits_fixed(gbc, 4);
+                        spx_coord_mant = get_bits_fixed(gbc, 2);
                         if (spx_coord_exp == 15) spx_coord_mant <<= 1;
                         else                     spx_coord_mant += 4;
                         spx_coord_mant <<= (25 - spx_coord_exp - master_spx_coord);
-                        spx_coord = spx_coord_mant * (1.0f/(1<<23));
 
-                        /* multiply noise and signal blending factors by spx coordinate */
-                        s->spx_noise_blend [ch][bnd] = nblend * spx_coord;
-                        s->spx_signal_blend[ch][bnd] = sblend * spx_coord;
+                        accu = (int64_t)nblend * spx_coord_mant;
+                        s->spx_noise_blend[ch][bnd]  = (int)((accu + (1<<22)) >> 23);
+                        accu = (int64_t)sblend * spx_coord_mant;
+                        s->spx_signal_blend[ch][bnd] = (int)((accu + (1<<22)) >> 23);
+
                     }
                 }
             } else {
@@ -896,10 +1051,10 @@
     }
 
     /* coupling strategy */
-    if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {
+    if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1_fixed(gbc)) {
         memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);
         if (!s->eac3)
-            s->cpl_in_use[blk] = get_bits1(gbc);
+            s->cpl_in_use[blk] = get_bits1_fixed(gbc);
         if (s->cpl_in_use[blk]) {
             /* coupling in use */
             int cpl_start_subband, cpl_end_subband;
@@ -910,7 +1065,7 @@
             }
 
             /* check for enhanced coupling */
-            if (s->eac3 && get_bits1(gbc)) {
+            if (s->eac3 && get_bits1_fixed(gbc)) {
                 /* TODO: parse enhanced coupling strategy info */
                 av_log_missing_feature(s->avctx, "Enhanced coupling", 1);
                 return -1;
@@ -922,17 +1077,17 @@
                 s->channel_in_cpl[2] = 1;
             } else {
                 for (ch = 1; ch <= fbw_channels; ch++)
-                    s->channel_in_cpl[ch] = get_bits1(gbc);
+                    s->channel_in_cpl[ch] = get_bits1_fixed(gbc);
             }
 
             /* phase flags in use */
             if (channel_mode == AC3_CHMODE_STEREO)
-                s->phase_flags_in_use = get_bits1(gbc);
+                s->phase_flags_in_use = get_bits1_fixed(gbc);
 
             /* coupling frequency range */
-            cpl_start_subband = get_bits(gbc, 4);
+            cpl_start_subband = get_bits_fixed(gbc, 4);
             cpl_end_subband = s->spx_in_use ? (s->spx_src_start_freq - 37) / 12 :
-                                              get_bits(gbc, 4) + 3;
+                                              get_bits_fixed(gbc, 4) + 3;
             if (cpl_start_subband >= cpl_end_subband) {
                 av_log(s->avctx, AV_LOG_ERROR, "invalid coupling range (%d >= %d)\n",
                        cpl_start_subband, cpl_end_subband);
@@ -970,14 +1125,14 @@
 
         for (ch = 1; ch <= fbw_channels; ch++) {
             if (s->channel_in_cpl[ch]) {
-                if ((s->eac3 && s->first_cpl_coords[ch]) || get_bits1(gbc)) {
+                if ((s->eac3 && s->first_cpl_coords[ch]) || get_bits1_fixed(gbc)) {
                     int master_cpl_coord, cpl_coord_exp, cpl_coord_mant;
                     s->first_cpl_coords[ch] = 0;
                     cpl_coords_exist = 1;
-                    master_cpl_coord = 3 * get_bits(gbc, 2);
+                    master_cpl_coord = 3 * get_bits_fixed(gbc, 2);
                     for (bnd = 0; bnd < s->num_cpl_bands; bnd++) {
-                        cpl_coord_exp = get_bits(gbc, 4);
-                        cpl_coord_mant = get_bits(gbc, 4);
+                        cpl_coord_exp = get_bits_fixed(gbc, 4);
+                        cpl_coord_mant = get_bits_fixed(gbc, 4);
                         if (cpl_coord_exp == 15)
                             s->cpl_coords[ch][bnd] = cpl_coord_mant << 22;
                         else
@@ -996,14 +1151,14 @@
         /* phase flags */
         if (channel_mode == AC3_CHMODE_STEREO && cpl_coords_exist) {
             for (bnd = 0; bnd < s->num_cpl_bands; bnd++) {
-                s->phase_flags[bnd] = s->phase_flags_in_use? get_bits1(gbc) : 0;
+                s->phase_flags[bnd] = s->phase_flags_in_use? get_bits1_fixed(gbc) : 0;
             }
         }
     }
 
     /* stereo rematrixing strategy and band structure */
     if (channel_mode == AC3_CHMODE_STEREO) {
-        if ((s->eac3 && !blk) || get_bits1(gbc)) {
+        if ((s->eac3 && !blk) || get_bits1_fixed(gbc)) {
             s->num_rematrixing_bands = 4;
             if (cpl_in_use && s->start_freq[CPL_CH] <= 61) {
                 s->num_rematrixing_bands -= 1 + (s->start_freq[CPL_CH] == 37);
@@ -1011,7 +1166,7 @@
                 s->num_rematrixing_bands--;
             }
             for(bnd=0; bnd<s->num_rematrixing_bands; bnd++)
-                s->rematrixing_flags[bnd] = get_bits1(gbc);
+                s->rematrixing_flags[bnd] = get_bits1_fixed(gbc);
         } else if (!blk) {
             av_log(s->avctx, AV_LOG_WARNING, "Warning: new rematrixing strategy not present in block 0\n");
             s->num_rematrixing_bands = 0;
@@ -1021,7 +1176,7 @@
     /* exponent strategies for each channel */
     for (ch = !cpl_in_use; ch <= s->channels; ch++) {
         if (!s->eac3)
-            s->exp_strategy[blk][ch] = get_bits(gbc, 2 - (ch == s->lfe_ch));
+            s->exp_strategy[blk][ch] = get_bits_fixed(gbc, 2 - (ch == s->lfe_ch));
         if(s->exp_strategy[blk][ch] != EXP_REUSE)
             bit_alloc_stages[ch] = 3;
     }
@@ -1037,7 +1192,7 @@
             else if (s->channel_uses_spx[ch])
                 s->end_freq[ch] = s->spx_src_start_freq;
             else {
-                int bandwidth_code = get_bits(gbc, 6);
+                int bandwidth_code = get_bits_fixed(gbc, 6);
                 if (bandwidth_code > 60) {
                     av_log(s->avctx, AV_LOG_ERROR, "bandwidth code = %d > 60\n", bandwidth_code);
                     return -1;
@@ -1058,7 +1213,7 @@
     /* decode exponents for each channel */
     for (ch = !cpl_in_use; ch <= s->channels; ch++) {
         if (s->exp_strategy[blk][ch] != EXP_REUSE) {
-            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;
+            s->dexps[ch][0] = get_bits_fixed(gbc, 4) << !ch;
             if (decode_exponents(gbc, s->exp_strategy[blk][ch],
                                  s->num_exp_groups[ch], s->dexps[ch][0],
                                  &s->dexps[ch][s->start_freq[ch]+!!ch])) {
@@ -1066,18 +1221,18 @@
                 return -1;
             }
             if(ch != CPL_CH && ch != s->lfe_ch)
-                skip_bits(gbc, 2); /* skip gainrng */
+                skip_bits_fixed(gbc, 2); /* skip gainrng */
         }
     }
 
     /* bit allocation information */
     if (s->bit_allocation_syntax) {
-        if (get_bits1(gbc)) {
-            s->bit_alloc_params.slow_decay = ff_ac3_slow_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;
-            s->bit_alloc_params.fast_decay = ff_ac3_fast_decay_tab[get_bits(gbc, 2)] >> s->bit_alloc_params.sr_shift;
-            s->bit_alloc_params.slow_gain  = ff_ac3_slow_gain_tab[get_bits(gbc, 2)];
-            s->bit_alloc_params.db_per_bit = ff_ac3_db_per_bit_tab[get_bits(gbc, 2)];
-            s->bit_alloc_params.floor  = ff_ac3_floor_tab[get_bits(gbc, 3)];
+        if (get_bits1_fixed(gbc)) {
+            s->bit_alloc_params.slow_decay = ff_ac3_slow_decay_tab[get_bits_fixed(gbc, 2)] >> s->bit_alloc_params.sr_shift;
+            s->bit_alloc_params.fast_decay = ff_ac3_fast_decay_tab[get_bits_fixed(gbc, 2)] >> s->bit_alloc_params.sr_shift;
+            s->bit_alloc_params.slow_gain  = ff_ac3_slow_gain_tab[get_bits_fixed(gbc, 2)];
+            s->bit_alloc_params.db_per_bit = ff_ac3_db_per_bit_tab[get_bits_fixed(gbc, 2)];
+            s->bit_alloc_params.floor  = ff_ac3_floor_tab[get_bits_fixed(gbc, 3)];
             for(ch=!cpl_in_use; ch<=s->channels; ch++)
                 bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);
         } else if (!blk) {
@@ -1088,14 +1243,14 @@
 
     /* signal-to-noise ratio offsets and fast gains (signal-to-mask ratios) */
     if(!s->eac3 || !blk){
-        if(s->snr_offset_strategy && get_bits1(gbc)) {
+        if(s->snr_offset_strategy && get_bits1_fixed(gbc)) {
             int snr = 0;
             int csnr;
-            csnr = (get_bits(gbc, 6) - 15) << 4;
+            csnr = (get_bits_fixed(gbc, 6) - 15) << 4;
             for (i = ch = !cpl_in_use; ch <= s->channels; ch++) {
                 /* snr offset */
                 if (ch == i || s->snr_offset_strategy == 2)
-                    snr = (csnr + get_bits(gbc, 4)) << 2;
+                    snr = (csnr + get_bits_fixed(gbc, 4)) << 2;
                 /* run at least last bit allocation stage if snr offset changes */
                 if(blk && s->snr_offset[ch] != snr) {
                     bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 1);
@@ -1105,7 +1260,7 @@
                 /* fast gain (normal AC-3 only) */
                 if (!s->eac3) {
                     int prev = s->fast_gain[ch];
-                    s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];
+                    s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits_fixed(gbc, 3)];
                     /* run last 2 bit allocation stages if fast gain changes */
                     if(blk && prev != s->fast_gain[ch])
                         bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);
@@ -1118,10 +1273,10 @@
     }
 
     /* fast gain (E-AC-3 only) */
-    if (s->fast_gain_syntax && get_bits1(gbc)) {
+    if (s->fast_gain_syntax && get_bits1_fixed(gbc)) {
         for (ch = !cpl_in_use; ch <= s->channels; ch++) {
             int prev = s->fast_gain[ch];
-            s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits(gbc, 3)];
+            s->fast_gain[ch] = ff_ac3_fast_gain_tab[get_bits_fixed(gbc, 3)];
             /* run last 2 bit allocation stages if fast gain changes */
             if(blk && prev != s->fast_gain[ch])
                 bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);
@@ -1132,15 +1287,15 @@
     }
 
     /* E-AC-3 to AC-3 converter SNR offset */
-    if (s->frame_type == EAC3_FRAME_TYPE_INDEPENDENT && get_bits1(gbc)) {
-        skip_bits(gbc, 10); // skip converter snr offset
+    if (s->frame_type == EAC3_FRAME_TYPE_INDEPENDENT && get_bits1_fixed(gbc)) {
+        skip_bits_fixed(gbc, 10); // skip converter snr offset
     }
 
     /* coupling leak information */
     if (cpl_in_use) {
-        if (s->first_cpl_leak || get_bits1(gbc)) {
-            int fl = get_bits(gbc, 3);
-            int sl = get_bits(gbc, 3);
+        if (s->first_cpl_leak || get_bits1_fixed(gbc)) {
+            int fl = get_bits_fixed(gbc, 3);
+            int sl = get_bits_fixed(gbc, 3);
             /* run last 2 bit allocation stages for coupling channel if
                coupling leak changes */
             if(blk && (fl != s->bit_alloc_params.cpl_fast_leak ||
@@ -1157,10 +1312,10 @@
     }
 
     /* delta bit allocation information */
-    if (s->dba_syntax && get_bits1(gbc)) {
+    if (s->dba_syntax && get_bits1_fixed(gbc)) {
         /* delta bit allocation exists (strategy) */
         for (ch = !cpl_in_use; ch <= fbw_channels; ch++) {
-            s->dba_mode[ch] = get_bits(gbc, 2);
+            s->dba_mode[ch] = get_bits_fixed(gbc, 2);
             if (s->dba_mode[ch] == DBA_RESERVED) {
                 av_log(s->avctx, AV_LOG_ERROR, "delta bit allocation strategy reserved\n");
                 return -1;
@@ -1170,11 +1325,11 @@
         /* channel delta offset, len and bit allocation */
         for (ch = !cpl_in_use; ch <= fbw_channels; ch++) {
             if (s->dba_mode[ch] == DBA_NEW) {
-                s->dba_nsegs[ch] = get_bits(gbc, 3) + 1;
+                s->dba_nsegs[ch] = get_bits_fixed(gbc, 3) + 1;
                 for (seg = 0; seg < s->dba_nsegs[ch]; seg++) {
-                    s->dba_offsets[ch][seg] = get_bits(gbc, 5);
-                    s->dba_lengths[ch][seg] = get_bits(gbc, 4);
-                    s->dba_values[ch][seg] = get_bits(gbc, 3);
+                    s->dba_offsets[ch][seg] = get_bits_fixed(gbc, 5);
+                    s->dba_lengths[ch][seg] = get_bits_fixed(gbc, 4);
+                    s->dba_values[ch][seg] = get_bits_fixed(gbc, 3);
                 }
                 /* run last 2 bit allocation stages if new dba values */
                 bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);
@@ -1220,10 +1375,10 @@
     }
 
     /* unused dummy data */
-    if (s->skip_syntax && get_bits1(gbc)) {
-        int skipl = get_bits(gbc, 9);
+    if (s->skip_syntax && get_bits1_fixed(gbc)) {
+        int skipl = get_bits_fixed(gbc, 9);
         while(skipl--)
-            skip_bits(gbc, 8);
+            skip_bits_fixed(gbc, 8);
     }
 
     /* unpack the transform coefficients
@@ -1236,15 +1391,14 @@
     if(s->channel_mode == AC3_CHMODE_STEREO)
         do_rematrixing(s);
 
-    /* apply scaling to coefficients (headroom, dynrng) */
-    for(ch=1; ch<=s->channels; ch++) {
-        float gain = s->mul_bias / 4194304.0f;
-        if(s->channel_mode == AC3_CHMODE_DUALMONO) {
-            gain *= s->dynamic_range[2-ch];
+    for (ch = 1; ch <= s->channels; ch++) {
+              int gain;
+       if(s->channel_mode == AC3_CHMODE_DUALMONO) {
+            gain = s->dynamic_range[2-ch];
         } else {
-            gain *= s->dynamic_range[0];
+           gain = s->dynamic_range[0];
         }
-        s->fmt_conv.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);
+        scale_coefs(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);
     }
 
     /* apply spectral extension to high frequency bins */
@@ -1269,16 +1423,17 @@
         do_imdct(s, s->channels);
 
         if(downmix_output) {
-            s->dsp.ac3_downmix(s->output, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);
+           ac3_downmix_c_fixed16(s->output, s->downmix_coeffs,
+                              s->out_channels, s->fbw_channels, 256);
         }
     } else {
         if(downmix_output) {
-            s->dsp.ac3_downmix(s->transform_coeffs+1, s->downmix_coeffs, s->out_channels, s->fbw_channels, 256);
+            s->ac3dsp.AC3_RENAME(downmix)(s->transform_coeffs + 1, s->downmix_coeffs,s->out_channels, s->fbw_channels, 256);
         }
 
         if(downmix_output && !s->downmixed) {
             s->downmixed = 1;
-            s->dsp.ac3_downmix(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128);
+            s->ac3dsp.AC3_RENAME(downmix)(s->delay, s->downmix_coeffs, s->out_channels, s->fbw_channels, 128);
         }
 
         do_imdct(s, s->out_channels);
@@ -1301,7 +1456,14 @@
     int blk, ch, err;
     int data_size_orig, data_size_tmp;
     const uint8_t *channel_map;
-    const float *output[AC3_MAX_CHANNELS];
+    const SHORTFLOAT *output[AC3_MAX_CHANNELS]; 
+    //int i;                                          
+                                                   /*for(i = 0; i < buf_size ; i++)
+                                                     av_log(NULL, AV_LOG_INFO, "%0x,",buf[i]);*/
+   //for (ch = 0; ch < s->out_channels; ch++)
+//for(i = 0; i < s->frame_size; i++)
+        //     av_log(NULL, AV_LOG_INFO, "%0x,",s->output[0][i]);
+   
 
     /* copy input buffer to decoder context to avoid reading past the end
        of the buffer, which can be caused by a damaged input stream. */
@@ -1313,7 +1475,7 @@
         memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));
     buf = s->input_buffer;
     /* initialize the GetBitContext with the start of valid AC-3 Frame */
-    init_get_bits(&s->gbc, buf, buf_size * 8);
+    init_get_bits_fixed(&s->gbc, buf, buf_size * 8);
 
     /* parse the syncinfo */
     data_size_orig = *data_size;
@@ -1381,6 +1543,10 @@
         avctx->channels = s->out_channels;
         avctx->channel_layout = s->channel_layout;
 
+       /* s->loro_center_mix_level   = AC3_RENAME(gain_levels)[s->  center_mix_level];
+        s->loro_surround_mix_level = AC3_RENAME(gain_levels)[s->surround_mix_level]; 
+        s->ltrt_center_mix_level   = LEVEL_MINUS_3DB;
+        s->ltrt_surround_mix_level = LEVEL_MINUS_3DB;*/
         /* set downmixing coefficients if needed */
         if(s->channels != s->out_channels && !((s->output_mode & AC3_OUTPUT_LFEON) &&
                 s->fbw_channels == s->out_channels)) {
@@ -1398,8 +1564,24 @@
 
     /* decode the audio blocks */
     channel_map = ff_ac3_dec_channel_map[s->output_mode & ~AC3_OUTPUT_LFEON][s->lfe_on];
+
+   /* for (ch = 0; ch < AC3_MAX_CHANNELS; ch++) {
+        output[ch] = s->output[ch];
+        s->outptr[ch] = s->output[ch];
+    }*/
+
     for (ch = 0; ch < s->out_channels; ch++)
-        output[ch] = s->output[channel_map[ch]];
+    {   output[ch] = s->output[channel_map[ch]];
+//for(i = 0; i < s->frame_size; i++)
+            // av_log(NULL, AV_LOG_INFO, "%0x,",output[ch][i]);
+         }
+
+/*jh
+    for (ch = 0; ch < s->channels; ch++) {
+        if (ch < s->out_channels)
+            s->outptr[channel_map[ch]] = (SHORTFLOAT *)data[ch];
+    }*/
+
     data_size_tmp = s->num_blocks * 256 * avctx->channels;
     data_size_tmp *= avctx->sample_fmt == AV_SAMPLE_FMT_FLT ? sizeof(*out_samples_flt) : sizeof(*out_samples_s16);
     if (data_size_orig < data_size_tmp)
@@ -1411,18 +1593,19 @@
             err = 1;
         }
 
-        if (avctx->sample_fmt == AV_SAMPLE_FMT_FLT) {
-            s->fmt_conv.float_interleave(out_samples_flt, output, 256,
+      if (avctx->sample_fmt == AV_SAMPLE_FMT_FLT) {
+            s->fmt_conv.fixed_interleave(out_samples_flt, output, 256,
                                          s->out_channels);
             out_samples_flt += 256 * s->out_channels;
         } else {
-            s->fmt_conv.float_to_int16_interleave(out_samples_s16, output, 256,
+            s->fmt_conv.fixed_to_int16_interleave(out_samples_s16, output, 256,
                                                   s->out_channels);
             out_samples_s16 += 256 * s->out_channels;
         }
+
     }
     *data_size = s->num_blocks * 256 * avctx->channels *
-                 av_get_bytes_per_sample(avctx->sample_fmt);
+                 av_get_bytes_per_sample(avctx->sample_fmt);   //av_log(avctx, AV_LOG_ERROR, "%d %d\n",buf_size,s->out_channels);
     return FFMIN(buf_size, s->frame_size);
 }
 
--- ffmpeg-0.7.12/libavcodec/ac3dec.h	2012-04-10 01:04:54.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/ac3dec.h	2013-08-16 18:00:00.000000000 +0800
@@ -50,7 +50,9 @@
 #ifndef AVCODEC_AC3DEC_H
 #define AVCODEC_AC3DEC_H
 
+#include "fixed_bitstream.h"
 #include "libavutil/lfg.h"
+#include "fixed_dsp.h"
 #include "ac3.h"
 #include "ac3dsp.h"
 #include "get_bits.h"
@@ -96,6 +98,11 @@
     int dba_syntax;                         ///< delta bit allocation syntax enabled    (dbaflde)
     int skip_syntax;                        ///< skip field syntax enabled              (skipflde)
  ///@}
+    int preferred_stereo_downmix;
+    SHORTFLOAT ltrt_center_mix_level;
+    SHORTFLOAT ltrt_surround_mix_level;
+    SHORTFLOAT loro_center_mix_level;
+    SHORTFLOAT loro_surround_mix_level;
 
 ///@name Standard coupling
     int cpl_in_use[AC3_MAX_BLOCKS];         ///< coupling in use                        (cplinu)
@@ -122,8 +129,8 @@
     int num_spx_bands;                          ///< number of spx bands                    (nspxbnds)
     uint8_t spx_band_sizes[SPX_MAX_BANDS];      ///< number of bins in each spx band
     uint8_t first_spx_coords[AC3_MAX_CHANNELS]; ///< first spx coordinates states           (firstspxcos)
-    float spx_noise_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS]; ///< spx noise blending factor  (nblendfact)
-    float spx_signal_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS];///< spx signal blending factor (sblendfact)
+    INTFLOAT spx_noise_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS]; ///< spx noise blending factor  (nblendfact)
+    INTFLOAT spx_signal_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS];///< spx signal blending factor (sblendfact)
 ///@}
 
 ///@name Adaptive hybrid transform
@@ -135,14 +142,15 @@
     int fbw_channels;                           ///< number of full-bandwidth channels
     int channels;                               ///< number of total channels
     int lfe_ch;                                 ///< index of LFE channel
-    float downmix_coeffs[AC3_MAX_CHANNELS][2];  ///< stereo downmix coefficients
+    SHORTFLOAT downmix_coeffs[AC3_MAX_CHANNELS][2];  ///< stereo downmix coefficients
     int downmixed;                              ///< indicates if coeffs are currently downmixed
     int output_mode;                            ///< output channel configuration
     int out_channels;                           ///< number of output channels
 ///@}
 
 ///@name Dynamic range
-    float dynamic_range[2];                 ///< dynamic range
+    INTFLOAT dynamic_range[2];                 ///< dynamic range
+    INTFLOAT drc_scale;                        ///< percentage of dynamic range compression to be applied
 ///@}
 
 ///@name Bandwidth
@@ -189,19 +197,28 @@
 ///@}
 
 ///@name Optimization
+
+    AVFixedDSPContext fdsp;
+
     DSPContext dsp;                         ///< for optimization
+
     AC3DSPContext ac3dsp;
     FmtConvertContext fmt_conv;             ///< optimized conversion functions
     float mul_bias;                         ///< scaling for float_to_int16 conversion
 ///@}
 
+  /*  SHORTFLOAT *outptr[AC3_MAX_CHANNELS];
+    INTFLOAT *xcfptr[AC3_MAX_CHANNELS];
+    INTFLOAT *dlyptr[AC3_MAX_CHANNELS];*/
+
+
 ///@name Aligned arrays
     DECLARE_ALIGNED(16, int,   fixed_coeffs)[AC3_MAX_CHANNELS][AC3_MAX_COEFS];       ///< fixed-point transform coefficients
-    DECLARE_ALIGNED(32, float, transform_coeffs)[AC3_MAX_CHANNELS][AC3_MAX_COEFS];   ///< transform coefficients
-    DECLARE_ALIGNED(32, float, delay)[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE];             ///< delay - added to the next block
-    DECLARE_ALIGNED(32, float, window)[AC3_BLOCK_SIZE];                              ///< window coefficients
-    DECLARE_ALIGNED(32, float, tmp_output)[AC3_BLOCK_SIZE];                          ///< temporary storage for output before windowing
-    DECLARE_ALIGNED(32, float, output)[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE];            ///< output after imdct transform and windowing
+    DECLARE_ALIGNED(32, INTFLOAT, transform_coeffs)[AC3_MAX_CHANNELS][AC3_MAX_COEFS];   ///< transform coefficients
+    DECLARE_ALIGNED(32, INTFLOAT, delay)[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE];             ///< delay - added to the next block
+    DECLARE_ALIGNED(32, INTFLOAT, window)[AC3_BLOCK_SIZE];                              ///< window coefficients
+    DECLARE_ALIGNED(32, INTFLOAT, tmp_output)[AC3_BLOCK_SIZE];                          ///< temporary storage for output before windowing
+    DECLARE_ALIGNED(32, INTFLOAT, output)[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE];            ///< output after imdct transform and windowing
     DECLARE_ALIGNED(32, uint8_t, input_buffer)[AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE]; ///< temp buffer to prevent overread
 ///@}
 } AC3DecodeContext;
--- ffmpeg-0.7.12/libavcodec/ac3dsp.c	2012-04-10 01:05:34.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/ac3dsp.c	2013-08-07 17:35:12.000000000 +0800
@@ -184,6 +184,31 @@
     }
 }
 
+static void ac3_downmix_c_fixed(int32_t **samples, int16_t (*matrix)[2],
+                      int out_ch, int in_ch, int len)
+{
+    int i, j;
+    int64_t v0, v1;
+    if (out_ch == 2) {
+        for (i = 0; i < len; i++) {
+            v0 = v1 = 0;
+            for (j = 0; j < in_ch; j++) {
+                v0 += (int64_t)samples[j][i] * matrix[j][0];
+                v1 += (int64_t)samples[j][i] * matrix[j][1];
+            }
+            samples[0][i] = (v0+2048)>>12;
+            samples[1][i] = (v1+2048)>>12;
+        }
+    } else if (out_ch == 1) {
+        for (i = 0; i < len; i++) {
+            v0 = 0;
+            for (j = 0; j < in_ch; j++)
+                v0 += (int64_t)samples[j][i] * matrix[j][0];
+            samples[0][i] = (v0+2048)>>12;
+        }
+    }
+}
+
 av_cold void ff_ac3dsp_init(AC3DSPContext *c, int bit_exact)
 {
     c->ac3_exponent_min = ac3_exponent_min_c;
@@ -195,6 +220,7 @@
     c->update_bap_counts = ac3_update_bap_counts_c;
     c->compute_mantissa_size = ac3_compute_mantissa_size_c;
     c->extract_exponents = ac3_extract_exponents_c;
+    c->downmix_fixed = ac3_downmix_c_fixed;
 
     if (ARCH_ARM)
         ff_ac3dsp_init_arm(c, bit_exact);
diff -uNr ffmpeg-0.7.12/libavcodec/ac3dsp.h ffmpeg-0.7.12NF/libavcodec/ac3dsp.h
--- ffmpeg-0.7.12/libavcodec/ac3dsp.h	2012-04-10 01:04:54.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/ac3dsp.h	2013-08-07 17:32:24.000000000 +0800
@@ -115,7 +115,8 @@
      * @param[in]  len        number of elements to process
      */
     void (*update_bap_counts)(uint16_t mant_cnt[16], uint8_t *bap, int len);
-
+    void (*downmix_fixed)(int32_t **samples, int16_t (*matrix)[2], int out_ch,
+                    int in_ch, int len);
     /**
      * Calculate the number of bits needed to encode a set of mantissas.
      *
diff -uNr ffmpeg-0.7.12/libavcodec/ac3.h ffmpeg-0.7.12NF/libavcodec/ac3.h
--- ffmpeg-0.7.12/libavcodec/ac3.h	2012-04-10 01:04:54.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/ac3.h	2013-08-16 14:51:50.000000000 +0800
@@ -51,16 +51,65 @@
 #define EXP_D25   2
 #define EXP_D45   3
 
+#ifndef CONFIG_AC3_FIXED
+#define CONFIG_AC3_FIXED 1
+#endif
+
+#if CONFIG_AC3_FIXED
+
+#define CONFIG_FFT_FLOAT 0
+
+#define FIXR(a)                 ((int)((a) * 0 + 0.5))
+#define FIXR12(a)               ((int)((a) * 4096 + 0.5))
+#define FIXR15(a)               ((int)((a) * 32768 + 0.5))
+#define ROUND15(x)              ((x) + 16384) >> 15
+
+#define MUL_BIAS1 65536
+#define MUL_BIAS2 2147418112
+
+#define AC3_RENAME(x)           x ## _fixed
+#define AC3_NORM(norm)          (1<<24)/(norm)
+#define AC3_MUL(a,b)            ((((int64_t) (a)) * (b))>>12)
+#define AC3_DYNAMIC_RANGE(x)    (x)
+#define AC3_SPX_BLEND(x)        (x)
+#define AC3_DYNAMIC_RANGE1      0
+
+#define INTFLOAT                int
+#define SHORTFLOAT              int16_t
+
+
+
+#else /* CONFIG_AC3_FIXED */
+
+#define FIXR(x)                 ((float)(x))
+#define FIXR12(x)               ((float)(x))
+#define FIXR15(x)               ((float)(x))
+#define ROUND15(x)              (x)
+
+#define AC3_RENAME(x)           x
+#define AC3_NORM(norm)          (1.0f/(norm))
+#define AC3_MUL(a,b)            ((a) * (b))
+#define AC3_DYNAMIC_RANGE(x)    ((dynamic_range_tab[x] - 1.0) * s->drc_scale) + 1.0
+#define AC3_SPX_BLEND(x)        (x)* (1.0f/32)
+#define AC3_DYNAMIC_RANGE1      1.0f
+
+#define INTFLOAT                float
+#define SHORTFLOAT              float
+
+#endif /* CONFIG_AC3_FIXED */
+
+#define AC3_LEVEL(x)            ROUND15((x) * FIXR15(0.7071067811865476))
+
 /* pre-defined gain values */
-#define LEVEL_PLUS_3DB          1.4142135623730950
-#define LEVEL_PLUS_1POINT5DB    1.1892071150027209
-#define LEVEL_MINUS_1POINT5DB   0.8408964152537145
-#define LEVEL_MINUS_3DB         0.7071067811865476
-#define LEVEL_MINUS_4POINT5DB   0.5946035575013605
-#define LEVEL_MINUS_6DB         0.5000000000000000
-#define LEVEL_MINUS_9DB         0.3535533905932738
-#define LEVEL_ZERO              0.0000000000000000
-#define LEVEL_ONE               1.0000000000000000
+#define LEVEL_PLUS_3DB          FIXR12(1.4142135623730950)
+#define LEVEL_PLUS_1POINT5DB    FIXR12(1.1892071150027209)
+#define LEVEL_MINUS_1POINT5DB   FIXR12(0.8408964152537145)
+#define LEVEL_MINUS_3DB         FIXR12(0.7071067811865476)
+#define LEVEL_MINUS_4POINT5DB   FIXR12(0.5946035575013605)
+#define LEVEL_MINUS_6DB         FIXR12(0.5000000000000000)
+#define LEVEL_MINUS_9DB         FIXR12(0.3535533905932738)
+#define LEVEL_ZERO              FIXR12(0.0000000000000000)
+#define LEVEL_ONE               FIXR12(1.0000000000000000)
 
 /** Delta bit allocation strategy */
 typedef enum {

--- ffmpeg-0.7.12/libavcodec/dsputil.c	2012-04-10 01:04:54.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/dsputil.c	2013-08-16 17:09:18.000000000 +0800
@@ -2512,6 +2512,25 @@
     }
 }
 
+static void vector_fmul_window_fixed_c(int *dst, const int16_t *src0,
+                                       const int16_t *src1, const int16_t *win, int len)
+{
+    int i,j;
+    dst += len;
+    win += len;
+    src0+= len;
+
+    for (i=-len, j=len-1; i<0; i++, j--) {
+        int s0 = src0[i];
+        int s1 = src1[j];
+        int wi = win[i];
+        int wj = win[j];
+        dst[i] = (s0*wj - s1*wi + 0x4000) >> 15;
+        dst[j] = (s0*wi + s1*wj + 0x4000) >> 15;
+    }
+}
+
+
 static void vector_fmul_scalar_c(float *dst, const float *src, float mul,
                                  int len)
 {
@@ -3102,6 +3121,7 @@
     c->vector_fmul_reverse = vector_fmul_reverse_c;
     c->vector_fmul_add = vector_fmul_add_c;
     c->vector_fmul_window = vector_fmul_window_c;
+    c->vector_fmul_window_fixed = vector_fmul_window_fixed_c;
     c->vector_clipf = vector_clipf_c;
     c->scalarproduct_int16 = scalarproduct_int16_c;
     c->scalarproduct_and_madd_int16 = scalarproduct_and_madd_int16_c;
diff -uNr ffmpeg-0.7.12/libavcodec/dsputil.h ffmpeg-0.7.12NF/libavcodec/dsputil.h
--- ffmpeg-0.7.12/libavcodec/dsputil.h	2012-04-10 01:05:30.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/dsputil.h	2013-08-16 13:40:12.000000000 +0800
@@ -414,6 +414,8 @@
     void (*vector_fmul_add)(float *dst, const float *src0, const float *src1, const float *src2, int len);
     /* assume len is a multiple of 4, and arrays are 16-byte aligned */
     void (*vector_fmul_window)(float *dst, const float *src0, const float *src1, const float *win, int len);
+
+    void (*vector_fmul_window_fixed)(int *dst, const int16_t *src0, const int16_t *src1, const int16_t *win, int len);//jh
     /* assume len is a multiple of 8, and arrays are 16-byte aligned */
     void (*vector_clipf)(float *dst /* align 16 */, const float *src /* align 16 */, float min, float max, int len /* align 16 */);
     /**
                                                                                            
--- ffmpeg-0.7.12/libavcodec/Makefile	2012-04-10 01:05:30.000000000 +0800
+++ ffmpeg-0.7.12NF/libavcodec/Makefile	2013-08-07 19:29:10.000000000 +0800
@@ -35,6 +35,7 @@
 OBJS-$(CONFIG_DXVA2)                   += dxva2.o
 FFT-OBJS-$(CONFIG_HARDCODED_TABLES)    += cos_tables.o cos_fixed_tables.o
 OBJS-$(CONFIG_FFT)                     += avfft.o fft_fixed.o fft_float.o \
+                                          fft_fixed_32.o fft_init_table.o \
                                           $(FFT-OBJS-yes)
 OBJS-$(CONFIG_GOLOMB)                  += golomb.o
 OBJS-$(CONFIG_H264DSP)                 += h264dsp.o h264idct.o
@@ -42,7 +43,7 @@
 OBJS-$(CONFIG_HUFFMAN)                 += huffman.o
 OBJS-$(CONFIG_LPC)                     += lpc.o
 OBJS-$(CONFIG_LSP)                     += lsp.o
-OBJS-$(CONFIG_MDCT)                    += mdct_fixed.o mdct_float.o
+OBJS-$(CONFIG_MDCT)                    += mdct_fixed.o mdct_float.o mdct_fixed_32.o
 OBJS-$(CONFIG_MPEGAUDIODSP)            += mpegaudiodsp.o                \
                                           mpegaudiodsp_fixed.o          \
                                           mpegaudiodsp_float.o
@@ -62,7 +63,7 @@
                                           psymodel.o iirfilter.o \
                                           mpeg4audio.o kbdwin.o
 OBJS-$(CONFIG_AASC_DECODER)            += aasc.o msrledec.o
-OBJS-$(CONFIG_AC3_DECODER)             += ac3dec.o ac3dec_data.o ac3.o kbdwin.o
+OBJS-$(CONFIG_AC3_DECODER)             += ac3dec.o ac3dec_data.o ac3.o kbdwin.o fixed_dsp.o
 OBJS-$(CONFIG_AC3_ENCODER)             += ac3enc_combined.o ac3enc_fixed.o ac3enc_float.o ac3tab.o ac3.o kbdwin.o ac3enc.o
 OBJS-$(CONFIG_AC3_FLOAT_ENCODER)       += ac3enc_float.o ac3tab.o ac3tab.o ac3.o kbdwin.o
 OBJS-$(CONFIG_AC3_FIXED_ENCODER)       += ac3enc_fixed.o ac3tab.o ac3tab.o ac3.o ac3enc.o
@@ -684,7 +685,7 @@
 SKIPHEADERS-$(CONFIG_VDPAU)            += vdpau.h
 SKIPHEADERS-$(CONFIG_XVMC)             += xvmc.h
 
-TESTPROGS = cabac dct fft fft-fixed h264 iirfilter rangecoder snow
+TESTPROGS = cabac dct fft fft-fixed fft-fixed32 h264 iirfilter rangecoder snow
 TESTPROGS-$(HAVE_MMX) += motion
 TESTOBJS = dctref.o
 
--- ffmpeg-0.7.12/libavutil/common.h	2012-04-10 01:04:54.000000000 +0800
+++ ffmpeg-0.7.12NF/libavutil/common.h	2013-08-16 15:36:44.000000000 +0800
@@ -149,11 +149,17 @@
     else             return a;
 }
 
+static av_always_inline av_const int16_t av_clip_int16_c_fixed(int a)
+{
+    return (a >0xefff ? 0xefff : a);
+}
+
 /**
  * Clip a signed integer value into the -32768,32767 range.
  * @param a value to clip
  * @return clipped value
  */
+
 static av_always_inline av_const int16_t av_clip_int16_c(int a)
 {
     if ((a+0x8000) & ~0xFFFF) return (a>>31) ^ 0x7FFF;