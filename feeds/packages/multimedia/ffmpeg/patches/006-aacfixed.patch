diff -uNr ffmpeg-0.7.12/libavcodec/aacdec.c ffmpeg-0.7.12-140902/libavcodec/aacdec.c
--- ffmpeg-0.7.12/libavcodec/aacdec.c	2012-04-10 01:05:33.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacdec.c	2014-09-05 15:21:29.127525135 +0800
@@ -79,2464 +79,3077 @@
            Parametric Stereo.
  */
 
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 1
+#define CONFIG_AAC_FIXED 1
+#define CONFIG_FIXED 1
 
-#include "avcodec.h"
-#include "internal.h"
-#include "get_bits.h"
-#include "dsputil.h"
-#include "fft.h"
-#include "fmtconvert.h"
-#include "lpc.h"
-#include "kbdwin.h"
-#include "sinewin.h"
-
-#include "aac.h"
-#include "aactab.h"
-#include "aacdectab.h"
-#include "cbrt_tablegen.h"
-#include "sbr.h"
-#include "aacsbr.h"
-#include "mpeg4audio.h"
-#include "aacadtsdec.h"
-
-#include <assert.h>
-#include <errno.h>
-#include <math.h>
-#include <string.h>
-
-#if ARCH_ARM
-#   include "arm/aac.h"
-#endif
-
-union float754 {
-    float f;
-    uint32_t i;
-};
-
-static VLC vlc_scalefactors;
-static VLC vlc_spectral[11];
-
-static const char overread_err[] = "Input buffer exhausted before END element found\n";
-
-static ChannelElement *get_che(AACContext *ac, int type, int elem_id)
-{
-    // For PCE based channel configurations map the channels solely based on tags.
-    if (!ac->m4ac.chan_config) {
-        return ac->tag_che_map[type][elem_id];
-    }
-    // For indexed channel configurations map the channels solely based on position.
-    switch (ac->m4ac.chan_config) {
-    case 7:
-        if (ac->tags_mapped == 3 && type == TYPE_CPE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][2];
-        }
-    case 6:
-        /* Some streams incorrectly code 5.1 audio as SCE[0] CPE[0] CPE[1] SCE[1]
-           instead of SCE[0] CPE[0] CPE[1] LFE[0]. If we seem to have
-           encountered such a stream, transfer the LFE[0] element to the SCE[1]'s mapping */
-        if (ac->tags_mapped == tags_per_config[ac->m4ac.chan_config] - 1 && (type == TYPE_LFE || type == TYPE_SCE)) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[type][elem_id] = ac->che[TYPE_LFE][0];
-        }
-    case 5:
-        if (ac->tags_mapped == 2 && type == TYPE_CPE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][1];
-        }
-    case 4:
-        if (ac->tags_mapped == 2 && ac->m4ac.chan_config == 4 && type == TYPE_SCE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][1];
-        }
-    case 3:
-    case 2:
-        if (ac->tags_mapped == (ac->m4ac.chan_config != 2) && type == TYPE_CPE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][0];
-        } else if (ac->m4ac.chan_config == 2) {
-            return NULL;
-        }
-    case 1:
-        if (!ac->tags_mapped && type == TYPE_SCE) {
-            ac->tags_mapped++;
-            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][0];
-        }
-    default:
-        return NULL;
-    }
-}
-
-/**
- * Check for the channel element in the current channel position configuration.
- * If it exists, make sure the appropriate element is allocated and map the
- * channel order to match the internal FFmpeg channel layout.
- *
- * @param   che_pos current channel position configuration
- * @param   type channel element type
- * @param   id channel element id
- * @param   channels count of the number of channels in the configuration
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int che_configure(AACContext *ac,
-                                 enum ChannelPosition che_pos[4][MAX_ELEM_ID],
-                                 int type, int id, int *channels)
-{
-    if (che_pos[type][id]) {
-        if (!ac->che[type][id] && !(ac->che[type][id] = av_mallocz(sizeof(ChannelElement))))
-            return AVERROR(ENOMEM);
-        ff_aac_sbr_ctx_init(ac, &ac->che[type][id]->sbr);
-        if (type != TYPE_CCE) {
-            ac->output_data[(*channels)++] = ac->che[type][id]->ch[0].ret;
-            if (type == TYPE_CPE ||
-                (type == TYPE_SCE && ac->m4ac.ps == 1)) {
-                ac->output_data[(*channels)++] = ac->che[type][id]->ch[1].ret;
-            }
-        }
-    } else {
-        if (ac->che[type][id])
-            ff_aac_sbr_ctx_close(&ac->che[type][id]->sbr);
-        av_freep(&ac->che[type][id]);
-    }
-    return 0;
-}
-
-/**
- * Configure output channel order based on the current program configuration element.
- *
- * @param   che_pos current channel position configuration
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int output_configure(AACContext *ac,
-                                    enum ChannelPosition che_pos[4][MAX_ELEM_ID],
-                                    enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                                    int channel_config, enum OCStatus oc_type)
-{
-    AVCodecContext *avctx = ac->avctx;
-    int i, type, channels = 0, ret;
-
-    if (new_che_pos != che_pos)
-    memcpy(che_pos, new_che_pos, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-
-    if (channel_config) {
-        for (i = 0; i < tags_per_config[channel_config]; i++) {
-            if ((ret = che_configure(ac, che_pos,
-                                     aac_channel_layout_map[channel_config - 1][i][0],
-                                     aac_channel_layout_map[channel_config - 1][i][1],
-                                     &channels)))
-                return ret;
-        }
-
-        memset(ac->tag_che_map, 0, 4 * MAX_ELEM_ID * sizeof(ac->che[0][0]));
-
-        avctx->channel_layout = aac_channel_layout[channel_config - 1];
-    } else {
-        /* Allocate or free elements depending on if they are in the
-         * current program configuration.
-         *
-         * Set up default 1:1 output mapping.
-         *
-         * For a 5.1 stream the output order will be:
-         *    [ Center ] [ Front Left ] [ Front Right ] [ LFE ] [ Surround Left ] [ Surround Right ]
-         */
-
-        for (i = 0; i < MAX_ELEM_ID; i++) {
-            for (type = 0; type < 4; type++) {
-                if ((ret = che_configure(ac, che_pos, type, i, &channels)))
-                    return ret;
-            }
-        }
-
-        memcpy(ac->tag_che_map, ac->che, 4 * MAX_ELEM_ID * sizeof(ac->che[0][0]));
-    }
-
-    avctx->channels = channels;
-
-    ac->output_configured = oc_type;
-
-    return 0;
-}
-
-/**
- * Decode an array of 4 bit element IDs, optionally interleaved with a stereo/mono switching bit.
- *
- * @param cpe_map Stereo (Channel Pair Element) map, NULL if stereo bit is not present.
- * @param sce_map mono (Single Channel Element) map
- * @param type speaker type/position for these channels
- */
-static void decode_channel_map(enum ChannelPosition *cpe_map,
-                               enum ChannelPosition *sce_map,
-                               enum ChannelPosition type,
-                               GetBitContext *gb, int n)
-{
-    while (n--) {
-        enum ChannelPosition *map = cpe_map && get_bits1(gb) ? cpe_map : sce_map; // stereo or mono map
-        map[get_bits(gb, 4)] = type;
-    }
-}
-
-/**
- * Decode program configuration element; reference: table 4.2.
- *
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,
-                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                      GetBitContext *gb)
-{
-    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;
-    int comment_len;
-
-    skip_bits(gb, 2);  // object_type
-
-    sampling_index = get_bits(gb, 4);
-    if (m4ac->sampling_index != sampling_index)
-        av_log(avctx, AV_LOG_WARNING, "Sample rate index in program config element does not match the sample rate index configured by the container.\n");
-
-    num_front       = get_bits(gb, 4);
-    num_side        = get_bits(gb, 4);
-    num_back        = get_bits(gb, 4);
-    num_lfe         = get_bits(gb, 2);
-    num_assoc_data  = get_bits(gb, 3);
-    num_cc          = get_bits(gb, 4);
-
-    if (get_bits1(gb))
-        skip_bits(gb, 4); // mono_mixdown_tag
-    if (get_bits1(gb))
-        skip_bits(gb, 4); // stereo_mixdown_tag
-
-    if (get_bits1(gb))
-        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround
-
-    if (get_bits_left(gb) < 4 * (num_front + num_side + num_back + num_lfe + num_assoc_data + num_cc)) {
-        av_log(avctx, AV_LOG_ERROR, overread_err);
-        return -1;
-    }
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );
-    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );
-    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );
-
-    skip_bits_long(gb, 4 * num_assoc_data);
-
-    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );
-
-    align_get_bits(gb);
-
-    /* comment field, first byte is length */
-    comment_len = get_bits(gb, 8) * 8;
-    if (get_bits_left(gb) < comment_len) {
-        av_log(avctx, AV_LOG_ERROR, overread_err);
-        return -1;
-    }
-    skip_bits_long(gb, comment_len);
-    return 0;
-}
-
-/**
- * Set up channel positions based on a default channel configuration
- * as specified in table 1.17.
- *
- * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static av_cold int set_default_channel_config(AVCodecContext *avctx,
-                                              enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
-                                              int channel_config)
-{
-    if (channel_config < 1 || channel_config > 7) {
-        av_log(avctx, AV_LOG_ERROR, "invalid default channel configuration (%d)\n",
-               channel_config);
-        return -1;
-    }
-
-    /* default channel configurations:
-     *
-     * 1ch : front center (mono)
-     * 2ch : L + R (stereo)
-     * 3ch : front center + L + R
-     * 4ch : front center + L + R + back center
-     * 5ch : front center + L + R + back stereo
-     * 6ch : front center + L + R + back stereo + LFE
-     * 7ch : front center + L + R + outer front left + outer front right + back stereo + LFE
-     */
-
-    if (channel_config != 2)
-        new_che_pos[TYPE_SCE][0] = AAC_CHANNEL_FRONT; // front center (or mono)
-    if (channel_config > 1)
-        new_che_pos[TYPE_CPE][0] = AAC_CHANNEL_FRONT; // L + R (or stereo)
-    if (channel_config == 4)
-        new_che_pos[TYPE_SCE][1] = AAC_CHANNEL_BACK;  // back center
-    if (channel_config > 4)
-        new_che_pos[TYPE_CPE][(channel_config == 7) + 1]
-        = AAC_CHANNEL_BACK;  // back stereo
-    if (channel_config > 5)
-        new_che_pos[TYPE_LFE][0] = AAC_CHANNEL_LFE;   // LFE
-    if (channel_config == 7)
-        new_che_pos[TYPE_CPE][1] = AAC_CHANNEL_FRONT; // outer front left + outer front right
-
-    return 0;
-}
-
-/**
- * Decode GA "General Audio" specific configuration; reference: table 4.1.
- *
- * @param   ac          pointer to AACContext, may be null
- * @param   avctx       pointer to AVCCodecContext, used for logging
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_ga_specific_config(AACContext *ac, AVCodecContext *avctx,
-                                     GetBitContext *gb,
-                                     MPEG4AudioConfig *m4ac,
-                                     int channel_config)
-{
-    enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-    int extension_flag, ret;
-
-    if (get_bits1(gb)) { // frameLengthFlag
-        av_log_missing_feature(avctx, "960/120 MDCT window is", 1);
-        return -1;
-    }
-
-    if (get_bits1(gb))       // dependsOnCoreCoder
-        skip_bits(gb, 14);   // coreCoderDelay
-    extension_flag = get_bits1(gb);
-
-    if (m4ac->object_type == AOT_AAC_SCALABLE ||
-        m4ac->object_type == AOT_ER_AAC_SCALABLE)
-        skip_bits(gb, 3);     // layerNr
-
-    memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-    if (channel_config == 0) {
-        skip_bits(gb, 4);  // element_instance_tag
-        if ((ret = decode_pce(avctx, m4ac, new_che_pos, gb)))
-            return ret;
-    } else {
-        if ((ret = set_default_channel_config(avctx, new_che_pos, channel_config)))
-            return ret;
-    }
-    if (ac && (ret = output_configure(ac, ac->che_pos, new_che_pos, channel_config, OC_GLOBAL_HDR)))
-        return ret;
-
-    if (extension_flag) {
-        switch (m4ac->object_type) {
-        case AOT_ER_BSAC:
-            skip_bits(gb, 5);    // numOfSubFrame
-            skip_bits(gb, 11);   // layer_length
-            break;
-        case AOT_ER_AAC_LC:
-        case AOT_ER_AAC_LTP:
-        case AOT_ER_AAC_SCALABLE:
-        case AOT_ER_AAC_LD:
-            skip_bits(gb, 3);  /* aacSectionDataResilienceFlag
-                                    * aacScalefactorDataResilienceFlag
-                                    * aacSpectralDataResilienceFlag
-                                    */
-            break;
-        }
-        skip_bits1(gb);    // extensionFlag3 (TBD in version 3)
-    }
-    return 0;
-}
-
-/**
- * Decode audio specific configuration; reference: table 1.13.
- *
- * @param   ac          pointer to AACContext, may be null
- * @param   avctx       pointer to AVCCodecContext, used for logging
- * @param   m4ac        pointer to MPEG4AudioConfig, used for parsing
- * @param   data        pointer to AVCodecContext extradata
- * @param   data_size   size of AVCCodecContext extradata
- *
- * @return  Returns error status or number of consumed bits. <0 - error
- */
-static int decode_audio_specific_config(AACContext *ac,
-                                        AVCodecContext *avctx,
-                                        MPEG4AudioConfig *m4ac,
-                                        const uint8_t *data, int data_size)
-{
-    GetBitContext gb;
-    int i;
-
-    av_dlog(avctx, "extradata size %d\n", avctx->extradata_size);
-    for (i = 0; i < avctx->extradata_size; i++)
-         av_dlog(avctx, "%02x ", avctx->extradata[i]);
-    av_dlog(avctx, "\n");
-
-    init_get_bits(&gb, data, data_size * 8);
-
-    if ((i = ff_mpeg4audio_get_config(m4ac, data, data_size)) < 0)
-        return -1;
-    if (m4ac->sampling_index > 12) {
-        av_log(avctx, AV_LOG_ERROR, "invalid sampling rate index %d\n", m4ac->sampling_index);
-        return -1;
-    }
-    if (m4ac->sbr == 1 && m4ac->ps == -1)
-        m4ac->ps = 1;
-
-    skip_bits_long(&gb, i);
-
-    switch (m4ac->object_type) {
-    case AOT_AAC_MAIN:
-    case AOT_AAC_LC:
-    case AOT_AAC_LTP:
-        if (decode_ga_specific_config(ac, avctx, &gb, m4ac, m4ac->chan_config))
-            return -1;
-        break;
-    default:
-        av_log(avctx, AV_LOG_ERROR, "Audio object type %s%d is not supported.\n",
-               m4ac->sbr == 1? "SBR+" : "", m4ac->object_type);
-        return -1;
-    }
-
-    av_dlog(avctx, "AOT %d chan config %d sampling index %d (%d) SBR %d PS %d\n",
-            m4ac->object_type, m4ac->chan_config, m4ac->sampling_index,
-            m4ac->sample_rate, m4ac->sbr, m4ac->ps);
-
-    return get_bits_count(&gb);
-}
-
-/**
- * linear congruential pseudorandom number generator
- *
- * @param   previous_val    pointer to the current state of the generator
- *
- * @return  Returns a 32-bit pseudorandom integer
- */
-static av_always_inline int lcg_random(int previous_val)
-{
-    return previous_val * 1664525 + 1013904223;
-}
-
-static av_always_inline void reset_predict_state(PredictorState *ps)
-{
-    ps->r0   = 0.0f;
-    ps->r1   = 0.0f;
-    ps->cor0 = 0.0f;
-    ps->cor1 = 0.0f;
-    ps->var0 = 1.0f;
-    ps->var1 = 1.0f;
-}
-
-static void reset_all_predictors(PredictorState *ps)
-{
-    int i;
-    for (i = 0; i < MAX_PREDICTORS; i++)
-        reset_predict_state(&ps[i]);
-}
-
-static void reset_predictor_group(PredictorState *ps, int group_num)
-{
-    int i;
-    for (i = group_num - 1; i < MAX_PREDICTORS; i += 30)
-        reset_predict_state(&ps[i]);
-}
-
-#define AAC_INIT_VLC_STATIC(num, size) \
-    INIT_VLC_STATIC(&vlc_spectral[num], 8, ff_aac_spectral_sizes[num], \
-         ff_aac_spectral_bits[num], sizeof( ff_aac_spectral_bits[num][0]), sizeof( ff_aac_spectral_bits[num][0]), \
-        ff_aac_spectral_codes[num], sizeof(ff_aac_spectral_codes[num][0]), sizeof(ff_aac_spectral_codes[num][0]), \
-        size);
-
-static av_cold int aac_decode_init(AVCodecContext *avctx)
-{
-    AACContext *ac = avctx->priv_data;
-    float output_scale_factor;
-
-    ac->avctx = avctx;
-    ac->m4ac.sample_rate = avctx->sample_rate;
-
-    if (avctx->extradata_size > 0) {
-        if (decode_audio_specific_config(ac, ac->avctx, &ac->m4ac,
-                                         avctx->extradata,
-                                         avctx->extradata_size) < 0)
-            return -1;
-    }
-
-    if (avctx->request_sample_fmt == AV_SAMPLE_FMT_FLT) {
-        avctx->sample_fmt = AV_SAMPLE_FMT_FLT;
-        output_scale_factor = 1.0 / 32768.0;
-    } else {
-        avctx->sample_fmt = AV_SAMPLE_FMT_S16;
-        output_scale_factor = 1.0;
-    }
-
-    AAC_INIT_VLC_STATIC( 0, 304);
-    AAC_INIT_VLC_STATIC( 1, 270);
-    AAC_INIT_VLC_STATIC( 2, 550);
-    AAC_INIT_VLC_STATIC( 3, 300);
-    AAC_INIT_VLC_STATIC( 4, 328);
-    AAC_INIT_VLC_STATIC( 5, 294);
-    AAC_INIT_VLC_STATIC( 6, 306);
-    AAC_INIT_VLC_STATIC( 7, 268);
-    AAC_INIT_VLC_STATIC( 8, 510);
-    AAC_INIT_VLC_STATIC( 9, 366);
-    AAC_INIT_VLC_STATIC(10, 462);
-
-    ff_aac_sbr_init();
-
-    dsputil_init(&ac->dsp, avctx);
-    ff_fmt_convert_init(&ac->fmt_conv, avctx);
-
-    ac->random_state = 0x1f2e3d4c;
-
-    ff_aac_tableinit();
-
-    INIT_VLC_STATIC(&vlc_scalefactors,7,FF_ARRAY_ELEMS(ff_aac_scalefactor_code),
-                    ff_aac_scalefactor_bits, sizeof(ff_aac_scalefactor_bits[0]), sizeof(ff_aac_scalefactor_bits[0]),
-                    ff_aac_scalefactor_code, sizeof(ff_aac_scalefactor_code[0]), sizeof(ff_aac_scalefactor_code[0]),
-                    352);
-
-    ff_mdct_init(&ac->mdct,       11, 1, output_scale_factor/1024.0);
-    ff_mdct_init(&ac->mdct_small,  8, 1, output_scale_factor/128.0);
-    ff_mdct_init(&ac->mdct_ltp,   11, 0, -2.0/output_scale_factor);
-    // window initialization
-    ff_kbd_window_init(ff_aac_kbd_long_1024, 4.0, 1024);
-    ff_kbd_window_init(ff_aac_kbd_short_128, 6.0, 128);
-    ff_init_ff_sine_windows(10);
-    ff_init_ff_sine_windows( 7);
-
-    cbrt_tableinit();
-
-    return 0;
-}
-
-/**
- * Skip data_stream_element; reference: table 4.10.
- */
-static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)
-{
-    int byte_align = get_bits1(gb);
-    int count = get_bits(gb, 8);
-    if (count == 255)
-        count += get_bits(gb, 8);
-    if (byte_align)
-        align_get_bits(gb);
-
-    if (get_bits_left(gb) < 8 * count) {
-        av_log(ac->avctx, AV_LOG_ERROR, overread_err);
-        return -1;
-    }
-    skip_bits_long(gb, 8 * count);
-    return 0;
-}
-
-static int decode_prediction(AACContext *ac, IndividualChannelStream *ics,
-                             GetBitContext *gb)
-{
-    int sfb;
-    if (get_bits1(gb)) {
-        ics->predictor_reset_group = get_bits(gb, 5);
-        if (ics->predictor_reset_group == 0 || ics->predictor_reset_group > 30) {
-            av_log(ac->avctx, AV_LOG_ERROR, "Invalid Predictor Reset Group.\n");
-            return -1;
-        }
-    }
-    for (sfb = 0; sfb < FFMIN(ics->max_sfb, ff_aac_pred_sfb_max[ac->m4ac.sampling_index]); sfb++) {
-        ics->prediction_used[sfb] = get_bits1(gb);
-    }
-    return 0;
-}
-
-/**
- * Decode Long Term Prediction data; reference: table 4.xx.
- */
-static void decode_ltp(AACContext *ac, LongTermPrediction *ltp,
-                       GetBitContext *gb, uint8_t max_sfb)
-{
-    int sfb;
-
-    ltp->lag  = get_bits(gb, 11);
-    ltp->coef = ltp_coef[get_bits(gb, 3)];
-    for (sfb = 0; sfb < FFMIN(max_sfb, MAX_LTP_LONG_SFB); sfb++)
-        ltp->used[sfb] = get_bits1(gb);
-}
-
-/**
- * Decode Individual Channel Stream info; reference: table 4.6.
- *
- * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
- */
-static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,
-                           GetBitContext *gb, int common_window)
-{
-    if (get_bits1(gb)) {
-        av_log(ac->avctx, AV_LOG_ERROR, "Reserved bit set.\n");
-        memset(ics, 0, sizeof(IndividualChannelStream));
-        return -1;
-    }
-    ics->window_sequence[1] = ics->window_sequence[0];
-    ics->window_sequence[0] = get_bits(gb, 2);
-    ics->use_kb_window[1]   = ics->use_kb_window[0];
-    ics->use_kb_window[0]   = get_bits1(gb);
-    ics->num_window_groups  = 1;
-    ics->group_len[0]       = 1;
-    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        int i;
-        ics->max_sfb = get_bits(gb, 4);
-        for (i = 0; i < 7; i++) {
-            if (get_bits1(gb)) {
-                ics->group_len[ics->num_window_groups - 1]++;
-            } else {
-                ics->num_window_groups++;
-                ics->group_len[ics->num_window_groups - 1] = 1;
-            }
-        }
-        ics->num_windows       = 8;
-        ics->swb_offset        =    ff_swb_offset_128[ac->m4ac.sampling_index];
-        ics->num_swb           =   ff_aac_num_swb_128[ac->m4ac.sampling_index];
-        ics->tns_max_bands     = ff_tns_max_bands_128[ac->m4ac.sampling_index];
-        ics->predictor_present = 0;
-    } else {
-        ics->max_sfb               = get_bits(gb, 6);
-        ics->num_windows           = 1;
-        ics->swb_offset            =    ff_swb_offset_1024[ac->m4ac.sampling_index];
-        ics->num_swb               =   ff_aac_num_swb_1024[ac->m4ac.sampling_index];
-        ics->tns_max_bands         = ff_tns_max_bands_1024[ac->m4ac.sampling_index];
-        ics->predictor_present     = get_bits1(gb);
-        ics->predictor_reset_group = 0;
-        if (ics->predictor_present) {
-            if (ac->m4ac.object_type == AOT_AAC_MAIN) {
-                if (decode_prediction(ac, ics, gb)) {
-                    memset(ics, 0, sizeof(IndividualChannelStream));
-                    return -1;
-                }
-            } else if (ac->m4ac.object_type == AOT_AAC_LC) {
-                av_log(ac->avctx, AV_LOG_ERROR, "Prediction is not allowed in AAC-LC.\n");
-                memset(ics, 0, sizeof(IndividualChannelStream));
-                return -1;
-            } else {
-                if ((ics->ltp.present = get_bits(gb, 1)))
-                    decode_ltp(ac, &ics->ltp, gb, ics->max_sfb);
-            }
-        }
-    }
-
-    if (ics->max_sfb > ics->num_swb) {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Number of scalefactor bands in group (%d) exceeds limit (%d).\n",
-               ics->max_sfb, ics->num_swb);
-        memset(ics, 0, sizeof(IndividualChannelStream));
-        return -1;
-    }
-
-    return 0;
-}
-
-/**
- * Decode band types (section_data payload); reference: table 4.46.
- *
- * @param   band_type           array of the used band type
- * @param   band_type_run_end   array of the last scalefactor band of a band type run
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_band_types(AACContext *ac, enum BandType band_type[120],
-                             int band_type_run_end[120], GetBitContext *gb,
-                             IndividualChannelStream *ics)
-{
-    int g, idx = 0;
-    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
-    for (g = 0; g < ics->num_window_groups; g++) {
-        int k = 0;
-        while (k < ics->max_sfb) {
-            uint8_t sect_end = k;
-            int sect_len_incr;
-            int sect_band_type = get_bits(gb, 4);
-            if (sect_band_type == 12) {
-                av_log(ac->avctx, AV_LOG_ERROR, "invalid band type\n");
-                return -1;
-            }
-            do {
-                sect_len_incr = get_bits(gb, bits);
-                sect_end += sect_len_incr;
-                if (get_bits_left(gb) < 0) {
-                    av_log(ac->avctx, AV_LOG_ERROR, overread_err);
-                    return -1;
-                }
-                if (sect_end > ics->max_sfb) {
-                    av_log(ac->avctx, AV_LOG_ERROR,
-                           "Number of bands (%d) exceeds limit (%d).\n",
-                           sect_end, ics->max_sfb);
-                    return -1;
-                }
-            } while (sect_len_incr == (1 << bits) - 1);
-            for (; k < sect_end; k++) {
-                band_type        [idx]   = sect_band_type;
-                band_type_run_end[idx++] = sect_end;
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode scalefactors; reference: table 4.47.
- *
- * @param   global_gain         first scalefactor value as scalefactors are differentially coded
- * @param   band_type           array of the used band type
- * @param   band_type_run_end   array of the last scalefactor band of a band type run
- * @param   sf                  array of scalefactors or intensity stereo positions
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_scalefactors(AACContext *ac, float sf[120], GetBitContext *gb,
-                               unsigned int global_gain,
-                               IndividualChannelStream *ics,
-                               enum BandType band_type[120],
-                               int band_type_run_end[120])
-{
-    int g, i, idx = 0;
-    int offset[3] = { global_gain, global_gain - 90, 0 };
-    int clipped_offset;
-    int noise_flag = 1;
-    static const char *sf_str[3] = { "Global gain", "Noise gain", "Intensity stereo position" };
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb;) {
-            int run_end = band_type_run_end[idx];
-            if (band_type[idx] == ZERO_BT) {
-                for (; i < run_end; i++, idx++)
-                    sf[idx] = 0.;
-            } else if ((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) {
-                for (; i < run_end; i++, idx++) {
-                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    clipped_offset = av_clip(offset[2], -155, 100);
-                    if (offset[2] != clipped_offset) {
-                        av_log_ask_for_sample(ac->avctx, "Intensity stereo "
-                                "position clipped (%d -> %d).\nIf you heard an "
-                                "audible artifact, there may be a bug in the "
-                                "decoder. ", offset[2], clipped_offset);
-                    }
-                    sf[idx] = ff_aac_pow2sf_tab[-clipped_offset + POW_SF2_ZERO];
-                }
-            } else if (band_type[idx] == NOISE_BT) {
-                for (; i < run_end; i++, idx++) {
-                    if (noise_flag-- > 0)
-                        offset[1] += get_bits(gb, 9) - 256;
-                    else
-                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    clipped_offset = av_clip(offset[1], -100, 155);
-                    if (offset[1] != clipped_offset) {
-                        av_log_ask_for_sample(ac->avctx, "Noise gain clipped "
-                                "(%d -> %d).\nIf you heard an audible "
-                                "artifact, there may be a bug in the decoder. ",
-                                offset[1], clipped_offset);
-                    }
-                    sf[idx] = -ff_aac_pow2sf_tab[clipped_offset + POW_SF2_ZERO];
-                }
-            } else {
-                for (; i < run_end; i++, idx++) {
-                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                    if (offset[0] > 255U) {
-                        av_log(ac->avctx, AV_LOG_ERROR,
-                               "%s (%d) out of range.\n", sf_str[0], offset[0]);
-                        return -1;
-                    }
-                    sf[idx] = -ff_aac_pow2sf_tab[offset[0] - 100 + POW_SF2_ZERO];
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode pulse data; reference: table 4.7.
- */
-static int decode_pulses(Pulse *pulse, GetBitContext *gb,
-                         const uint16_t *swb_offset, int num_swb)
-{
-    int i, pulse_swb;
-    pulse->num_pulse = get_bits(gb, 2) + 1;
-    pulse_swb        = get_bits(gb, 6);
-    if (pulse_swb >= num_swb)
-        return -1;
-    pulse->pos[0]    = swb_offset[pulse_swb];
-    pulse->pos[0]   += get_bits(gb, 5);
-    if (pulse->pos[0] > 1023)
-        return -1;
-    pulse->amp[0]    = get_bits(gb, 4);
-    for (i = 1; i < pulse->num_pulse; i++) {
-        pulse->pos[i] = get_bits(gb, 5) + pulse->pos[i - 1];
-        if (pulse->pos[i] > 1023)
-            return -1;
-        pulse->amp[i] = get_bits(gb, 4);
-    }
-    return 0;
-}
-
-/**
- * Decode Temporal Noise Shaping data; reference: table 4.48.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_tns(AACContext *ac, TemporalNoiseShaping *tns,
-                      GetBitContext *gb, const IndividualChannelStream *ics)
-{
-    int w, filt, i, coef_len, coef_res, coef_compress;
-    const int is8 = ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE;
-    const int tns_max_order = is8 ? 7 : ac->m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;
-    for (w = 0; w < ics->num_windows; w++) {
-        if ((tns->n_filt[w] = get_bits(gb, 2 - is8))) {
-            coef_res = get_bits1(gb);
-
-            for (filt = 0; filt < tns->n_filt[w]; filt++) {
-                int tmp2_idx;
-                tns->length[w][filt] = get_bits(gb, 6 - 2 * is8);
-
-                if ((tns->order[w][filt] = get_bits(gb, 5 - 2 * is8)) > tns_max_order) {
-                    av_log(ac->avctx, AV_LOG_ERROR, "TNS filter order %d is greater than maximum %d.\n",
-                           tns->order[w][filt], tns_max_order);
-                    tns->order[w][filt] = 0;
-                    return -1;
-                }
-                if (tns->order[w][filt]) {
-                    tns->direction[w][filt] = get_bits1(gb);
-                    coef_compress = get_bits1(gb);
-                    coef_len = coef_res + 3 - coef_compress;
-                    tmp2_idx = 2 * coef_compress + coef_res;
-
-                    for (i = 0; i < tns->order[w][filt]; i++)
-                        tns->coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Decode Mid/Side data; reference: table 4.54.
- *
- * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
- *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
- *                      [3] reserved for scalable AAC
- */
-static void decode_mid_side_stereo(ChannelElement *cpe, GetBitContext *gb,
-                                   int ms_present)
-{
-    int idx;
-    if (ms_present == 1) {
-        for (idx = 0; idx < cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb; idx++)
-            cpe->ms_mask[idx] = get_bits1(gb);
-    } else if (ms_present == 2) {
-        memset(cpe->ms_mask, 1, cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb * sizeof(cpe->ms_mask[0]));
-    }
-}
-
-#ifndef VMUL2
-static inline float *VMUL2(float *dst, const float *v, unsigned idx,
-                           const float *scale)
-{
-    float s = *scale;
-    *dst++ = v[idx    & 15] * s;
-    *dst++ = v[idx>>4 & 15] * s;
-    return dst;
-}
-#endif
-
-#ifndef VMUL4
-static inline float *VMUL4(float *dst, const float *v, unsigned idx,
-                           const float *scale)
-{
-    float s = *scale;
-    *dst++ = v[idx    & 3] * s;
-    *dst++ = v[idx>>2 & 3] * s;
-    *dst++ = v[idx>>4 & 3] * s;
-    *dst++ = v[idx>>6 & 3] * s;
-    return dst;
-}
-#endif
-
-#ifndef VMUL2S
-static inline float *VMUL2S(float *dst, const float *v, unsigned idx,
-                            unsigned sign, const float *scale)
-{
-    union float754 s0, s1;
-
-    s0.f = s1.f = *scale;
-    s0.i ^= sign >> 1 << 31;
-    s1.i ^= sign      << 31;
-
-    *dst++ = v[idx    & 15] * s0.f;
-    *dst++ = v[idx>>4 & 15] * s1.f;
-
-    return dst;
-}
-#endif
-
-#ifndef VMUL4S
-static inline float *VMUL4S(float *dst, const float *v, unsigned idx,
-                            unsigned sign, const float *scale)
-{
-    unsigned nz = idx >> 12;
-    union float754 s = { .f = *scale };
-    union float754 t;
-
-    t.i = s.i ^ (sign & 1U<<31);
-    *dst++ = v[idx    & 3] * t.f;
-
-    sign <<= nz & 1; nz >>= 1;
-    t.i = s.i ^ (sign & 1U<<31);
-    *dst++ = v[idx>>2 & 3] * t.f;
-
-    sign <<= nz & 1; nz >>= 1;
-    t.i = s.i ^ (sign & 1U<<31);
-    *dst++ = v[idx>>4 & 3] * t.f;
-
-    sign <<= nz & 1; nz >>= 1;
-    t.i = s.i ^ (sign & 1U<<31);
-    *dst++ = v[idx>>6 & 3] * t.f;
-
-    return dst;
-}
-#endif
-
-/**
- * Decode spectral data; reference: table 4.50.
- * Dequantize and scale spectral data; reference: 4.6.3.3.
- *
- * @param   coef            array of dequantized, scaled spectral data
- * @param   sf              array of scalefactors or intensity stereo positions
- * @param   pulse_present   set if pulses are present
- * @param   pulse           pointer to pulse data struct
- * @param   band_type       array of the used band type
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_spectrum_and_dequant(AACContext *ac, float coef[1024],
-                                       GetBitContext *gb, const float sf[120],
-                                       int pulse_present, const Pulse *pulse,
-                                       const IndividualChannelStream *ics,
-                                       enum BandType band_type[120])
-{
-    int i, k, g, idx = 0;
-    const int c = 1024 / ics->num_windows;
-    const uint16_t *offsets = ics->swb_offset;
-    float *coef_base = coef;
-
-    for (g = 0; g < ics->num_windows; g++)
-        memset(coef + g * 128 + offsets[ics->max_sfb], 0, sizeof(float) * (c - offsets[ics->max_sfb]));
-
-    for (g = 0; g < ics->num_window_groups; g++) {
-        unsigned g_len = ics->group_len[g];
-
-        for (i = 0; i < ics->max_sfb; i++, idx++) {
-            const unsigned cbt_m1 = band_type[idx] - 1;
-            float *cfo = coef + offsets[i];
-            int off_len = offsets[i + 1] - offsets[i];
-            int group;
-
-            if (cbt_m1 >= INTENSITY_BT2 - 1) {
-                for (group = 0; group < g_len; group++, cfo+=128) {
-                    memset(cfo, 0, off_len * sizeof(float));
-                }
-            } else if (cbt_m1 == NOISE_BT - 1) {
-                for (group = 0; group < g_len; group++, cfo+=128) {
-                    float scale;
-                    float band_energy;
-
-                    for (k = 0; k < off_len; k++) {
-                        ac->random_state  = lcg_random(ac->random_state);
-                        cfo[k] = ac->random_state;
-                    }
-
-                    band_energy = ac->dsp.scalarproduct_float(cfo, cfo, off_len);
-                    scale = sf[idx] / sqrtf(band_energy);
-                    ac->dsp.vector_fmul_scalar(cfo, cfo, scale, off_len);
-                }
-            } else {
-                const float *vq = ff_aac_codebook_vector_vals[cbt_m1];
-                const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];
-                VLC_TYPE (*vlc_tab)[2] = vlc_spectral[cbt_m1].table;
-                OPEN_READER(re, gb);
-
-                switch (cbt_m1 >> 1) {
-                case 0:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned cb_idx;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-                            cb_idx = cb_vector_idx[code];
-                            cf = VMUL4(cf, vq, cb_idx, sf + idx);
-                        } while (len -= 4);
-                    }
-                    break;
-
-                case 1:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nnz;
-                            unsigned cb_idx;
-                            uint32_t bits;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx >> 8 & 15;
-                            bits = nnz ? GET_CACHE(re, gb) : 0;
-                            LAST_SKIP_BITS(re, gb, nnz);
-                            cf = VMUL4S(cf, vq, cb_idx, bits, sf + idx);
-                        } while (len -= 4);
-                    }
-                    break;
-
-                case 2:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned cb_idx;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-                            cb_idx = cb_vector_idx[code];
-                            cf = VMUL2(cf, vq, cb_idx, sf + idx);
-                        } while (len -= 2);
-                    }
-                    break;
-
-                case 3:
-                case 4:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nnz;
-                            unsigned cb_idx;
-                            unsigned sign;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx >> 8 & 15;
-                            sign = nnz ? SHOW_UBITS(re, gb, nnz) << (cb_idx >> 12) : 0;
-                            LAST_SKIP_BITS(re, gb, nnz);
-                            cf = VMUL2S(cf, vq, cb_idx, sign, sf + idx);
-                        } while (len -= 2);
-                    }
-                    break;
-
-                default:
-                    for (group = 0; group < g_len; group++, cfo+=128) {
-                        float *cf = cfo;
-                        uint32_t *icf = (uint32_t *) cf;
-                        int len = off_len;
-
-                        do {
-                            int code;
-                            unsigned nzt, nnz;
-                            unsigned cb_idx;
-                            uint32_t bits;
-                            int j;
-
-                            UPDATE_CACHE(re, gb);
-                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
-
-                            if (!code) {
-                                *icf++ = 0;
-                                *icf++ = 0;
-                                continue;
-                            }
-
-                            cb_idx = cb_vector_idx[code];
-                            nnz = cb_idx >> 12;
-                            nzt = cb_idx >> 8;
-                            bits = SHOW_UBITS(re, gb, nnz) << (32-nnz);
-                            LAST_SKIP_BITS(re, gb, nnz);
-
-                            for (j = 0; j < 2; j++) {
-                                if (nzt & 1<<j) {
-                                    uint32_t b;
-                                    int n;
-                                    /* The total length of escape_sequence must be < 22 bits according
-                                       to the specification (i.e. max is 111111110xxxxxxxxxxxx). */
-                                    UPDATE_CACHE(re, gb);
-                                    b = GET_CACHE(re, gb);
-                                    b = 31 - av_log2(~b);
-
-                                    if (b > 8) {
-                                        av_log(ac->avctx, AV_LOG_ERROR, "error in spectral data, ESC overflow\n");
-                                        return -1;
-                                    }
-
-                                    SKIP_BITS(re, gb, b + 1);
-                                    b += 4;
-                                    n = (1 << b) + SHOW_UBITS(re, gb, b);
-                                    LAST_SKIP_BITS(re, gb, b);
-                                    *icf++ = cbrt_tab[n] | (bits & 1U<<31);
-                                    bits <<= 1;
-                                } else {
-                                    unsigned v = ((const uint32_t*)vq)[cb_idx & 15];
-                                    *icf++ = (bits & 1U<<31) | v;
-                                    bits <<= !!v;
-                                }
-                                cb_idx >>= 4;
-                            }
-                        } while (len -= 2);
-
-                        ac->dsp.vector_fmul_scalar(cfo, cfo, sf[idx], off_len);
-                    }
-                }
-
-                CLOSE_READER(re, gb);
-            }
-        }
-        coef += g_len << 7;
-    }
-
-    if (pulse_present) {
-        idx = 0;
-        for (i = 0; i < pulse->num_pulse; i++) {
-            float co = coef_base[ pulse->pos[i] ];
-            while (offsets[idx + 1] <= pulse->pos[i])
-                idx++;
-            if (band_type[idx] != NOISE_BT && sf[idx]) {
-                float ico = -pulse->amp[i];
-                if (co) {
-                    co /= sf[idx];
-                    ico = co / sqrtf(sqrtf(fabsf(co))) + (co > 0 ? -ico : ico);
-                }
-                coef_base[ pulse->pos[i] ] = cbrtf(fabsf(ico)) * ico * sf[idx];
-            }
-        }
-    }
-    return 0;
-}
-
-static av_always_inline float flt16_round(float pf)
-{
-    union float754 tmp;
-    tmp.f = pf;
-    tmp.i = (tmp.i + 0x00008000U) & 0xFFFF0000U;
-    return tmp.f;
-}
-
-static av_always_inline float flt16_even(float pf)
-{
-    union float754 tmp;
-    tmp.f = pf;
-    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;
-    return tmp.f;
-}
-
-static av_always_inline float flt16_trunc(float pf)
-{
-    union float754 pun;
-    pun.f = pf;
-    pun.i &= 0xFFFF0000U;
-    return pun.f;
-}
-
-static av_always_inline void predict(PredictorState *ps, float *coef,
-                                     int output_enable)
-{
-    const float a     = 0.953125; // 61.0 / 64
-    const float alpha = 0.90625;  // 29.0 / 32
-    float e0, e1;
-    float pv;
-    float k1, k2;
-    float   r0 = ps->r0,     r1 = ps->r1;
-    float cor0 = ps->cor0, cor1 = ps->cor1;
-    float var0 = ps->var0, var1 = ps->var1;
-
-    k1 = var0 > 1 ? cor0 * flt16_even(a / var0) : 0;
-    k2 = var1 > 1 ? cor1 * flt16_even(a / var1) : 0;
-
-    pv = flt16_round(k1 * r0 + k2 * r1);
-    if (output_enable)
-        *coef += pv;
-
-    e0 = *coef;
-    e1 = e0 - k1 * r0;
-
-    ps->cor1 = flt16_trunc(alpha * cor1 + r1 * e1);
-    ps->var1 = flt16_trunc(alpha * var1 + 0.5f * (r1 * r1 + e1 * e1));
-    ps->cor0 = flt16_trunc(alpha * cor0 + r0 * e0);
-    ps->var0 = flt16_trunc(alpha * var0 + 0.5f * (r0 * r0 + e0 * e0));
-
-    ps->r1 = flt16_trunc(a * (r0 - k1 * e0));
-    ps->r0 = flt16_trunc(a * e0);
-}
-
-/**
- * Apply AAC-Main style frequency domain prediction.
- */
-static void apply_prediction(AACContext *ac, SingleChannelElement *sce)
-{
-    int sfb, k;
-
-    if (!sce->ics.predictor_initialized) {
-        reset_all_predictors(sce->predictor_state);
-        sce->ics.predictor_initialized = 1;
-    }
-
-    if (sce->ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {
-        for (sfb = 0; sfb < ff_aac_pred_sfb_max[ac->m4ac.sampling_index]; sfb++) {
-            for (k = sce->ics.swb_offset[sfb]; k < sce->ics.swb_offset[sfb + 1]; k++) {
-                predict(&sce->predictor_state[k], &sce->coeffs[k],
-                        sce->ics.predictor_present && sce->ics.prediction_used[sfb]);
-            }
-        }
-        if (sce->ics.predictor_reset_group)
-            reset_predictor_group(sce->predictor_state, sce->ics.predictor_reset_group);
-    } else
-        reset_all_predictors(sce->predictor_state);
-}
-
-/**
- * Decode an individual_channel_stream payload; reference: table 4.44.
- *
- * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
- * @param   scale_flag      scalable [1] or non-scalable [0] AAC (Unused until scalable AAC is implemented.)
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_ics(AACContext *ac, SingleChannelElement *sce,
-                      GetBitContext *gb, int common_window, int scale_flag)
-{
-    Pulse pulse;
-    TemporalNoiseShaping    *tns = &sce->tns;
-    IndividualChannelStream *ics = &sce->ics;
-    float *out = sce->coeffs;
-    int global_gain, pulse_present = 0;
-
-    /* This assignment is to silence a GCC warning about the variable being used
-     * uninitialized when in fact it always is.
-     */
-    pulse.num_pulse = 0;
-
-    global_gain = get_bits(gb, 8);
-
-    if (!common_window && !scale_flag) {
-        if (decode_ics_info(ac, ics, gb, 0) < 0)
-            return -1;
-    }
-
-    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)
-        return -1;
-    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)
-        return -1;
-
-    pulse_present = 0;
-    if (!scale_flag) {
-        if ((pulse_present = get_bits1(gb))) {
-            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-                av_log(ac->avctx, AV_LOG_ERROR, "Pulse tool not allowed in eight short sequence.\n");
-                return -1;
-            }
-            if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) {
-                av_log(ac->avctx, AV_LOG_ERROR, "Pulse data corrupt or invalid.\n");
-                return -1;
-            }
-        }
-        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))
-            return -1;
-        if (get_bits1(gb)) {
-            av_log_missing_feature(ac->avctx, "SSR", 1);
-            return -1;
-        }
-    }
-
-    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)
-        return -1;
-
-    if (ac->m4ac.object_type == AOT_AAC_MAIN && !common_window)
-        apply_prediction(ac, sce);
-
-    return 0;
-}
-
-/**
- * Mid/Side stereo decoding; reference: 4.6.8.1.3.
- */
-static void apply_mid_side_stereo(AACContext *ac, ChannelElement *cpe)
-{
-    const IndividualChannelStream *ics = &cpe->ch[0].ics;
-    float *ch0 = cpe->ch[0].coeffs;
-    float *ch1 = cpe->ch[1].coeffs;
-    int g, i, group, idx = 0;
-    const uint16_t *offsets = ics->swb_offset;
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb; i++, idx++) {
-            if (cpe->ms_mask[idx] &&
-                    cpe->ch[0].band_type[idx] < NOISE_BT && cpe->ch[1].band_type[idx] < NOISE_BT) {
-                for (group = 0; group < ics->group_len[g]; group++) {
-                    ac->dsp.butterflies_float(ch0 + group * 128 + offsets[i],
-                                              ch1 + group * 128 + offsets[i],
-                                              offsets[i+1] - offsets[i]);
-                }
-            }
-        }
-        ch0 += ics->group_len[g] * 128;
-        ch1 += ics->group_len[g] * 128;
-    }
-}
-
-/**
- * intensity stereo decoding; reference: 4.6.8.2.3
- *
- * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
- *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
- *                      [3] reserved for scalable AAC
- */
-static void apply_intensity_stereo(AACContext *ac, ChannelElement *cpe, int ms_present)
-{
-    const IndividualChannelStream *ics = &cpe->ch[1].ics;
-    SingleChannelElement         *sce1 = &cpe->ch[1];
-    float *coef0 = cpe->ch[0].coeffs, *coef1 = cpe->ch[1].coeffs;
-    const uint16_t *offsets = ics->swb_offset;
-    int g, group, i, idx = 0;
-    int c;
-    float scale;
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb;) {
-            if (sce1->band_type[idx] == INTENSITY_BT || sce1->band_type[idx] == INTENSITY_BT2) {
-                const int bt_run_end = sce1->band_type_run_end[idx];
-                for (; i < bt_run_end; i++, idx++) {
-                    c = -1 + 2 * (sce1->band_type[idx] - 14);
-                    if (ms_present)
-                        c *= 1 - 2 * cpe->ms_mask[idx];
-                    scale = c * sce1->sf[idx];
-                    for (group = 0; group < ics->group_len[g]; group++)
-                        ac->dsp.vector_fmul_scalar(coef1 + group * 128 + offsets[i],
-                                                   coef0 + group * 128 + offsets[i],
-                                                   scale,
-                                                   offsets[i + 1] - offsets[i]);
-                }
-            } else {
-                int bt_run_end = sce1->band_type_run_end[idx];
-                idx += bt_run_end - i;
-                i    = bt_run_end;
-            }
-        }
-        coef0 += ics->group_len[g] * 128;
-        coef1 += ics->group_len[g] * 128;
-    }
-}
-
-/**
- * Decode a channel_pair_element; reference: table 4.4.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_cpe(AACContext *ac, GetBitContext *gb, ChannelElement *cpe)
-{
-    int i, ret, common_window, ms_present = 0;
-
-    common_window = get_bits1(gb);
-    if (common_window) {
-        if (decode_ics_info(ac, &cpe->ch[0].ics, gb, 1))
-            return -1;
-        i = cpe->ch[1].ics.use_kb_window[0];
-        cpe->ch[1].ics = cpe->ch[0].ics;
-        cpe->ch[1].ics.use_kb_window[1] = i;
-        if (cpe->ch[1].ics.predictor_present && (ac->m4ac.object_type != AOT_AAC_MAIN))
-            if ((cpe->ch[1].ics.ltp.present = get_bits(gb, 1)))
-                decode_ltp(ac, &cpe->ch[1].ics.ltp, gb, cpe->ch[1].ics.max_sfb);
-        ms_present = get_bits(gb, 2);
-        if (ms_present == 3) {
-            av_log(ac->avctx, AV_LOG_ERROR, "ms_present = 3 is reserved.\n");
-            return -1;
-        } else if (ms_present)
-            decode_mid_side_stereo(cpe, gb, ms_present);
-    }
-    if ((ret = decode_ics(ac, &cpe->ch[0], gb, common_window, 0)))
-        return ret;
-    if ((ret = decode_ics(ac, &cpe->ch[1], gb, common_window, 0)))
-        return ret;
-
-    if (common_window) {
-        if (ms_present)
-            apply_mid_side_stereo(ac, cpe);
-        if (ac->m4ac.object_type == AOT_AAC_MAIN) {
-            apply_prediction(ac, &cpe->ch[0]);
-            apply_prediction(ac, &cpe->ch[1]);
-        }
-    }
-
-    apply_intensity_stereo(ac, cpe, ms_present);
-    return 0;
-}
-
-static const float cce_scale[] = {
-    1.09050773266525765921, //2^(1/8)
-    1.18920711500272106672, //2^(1/4)
-    M_SQRT2,
-    2,
-};
-
-/**
- * Decode coupling_channel_element; reference: table 4.8.
- *
- * @return  Returns error status. 0 - OK, !0 - error
- */
-static int decode_cce(AACContext *ac, GetBitContext *gb, ChannelElement *che)
-{
-    int num_gain = 0;
-    int c, g, sfb, ret;
-    int sign;
-    float scale;
-    SingleChannelElement *sce = &che->ch[0];
-    ChannelCoupling     *coup = &che->coup;
-
-    coup->coupling_point = 2 * get_bits1(gb);
-    coup->num_coupled = get_bits(gb, 3);
-    for (c = 0; c <= coup->num_coupled; c++) {
-        num_gain++;
-        coup->type[c] = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;
-        coup->id_select[c] = get_bits(gb, 4);
-        if (coup->type[c] == TYPE_CPE) {
-            coup->ch_select[c] = get_bits(gb, 2);
-            if (coup->ch_select[c] == 3)
-                num_gain++;
-        } else
-            coup->ch_select[c] = 2;
-    }
-    coup->coupling_point += get_bits1(gb) || (coup->coupling_point >> 1);
-
-    sign  = get_bits(gb, 1);
-    scale = cce_scale[get_bits(gb, 2)];
-
-    if ((ret = decode_ics(ac, sce, gb, 0, 0)))
-        return ret;
-
-    for (c = 0; c < num_gain; c++) {
-        int idx  = 0;
-        int cge  = 1;
-        int gain = 0;
-        float gain_cache = 1.;
-        if (c) {
-            cge = coup->coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
-            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;
-            gain_cache = powf(scale, -gain);
-        }
-        if (coup->coupling_point == AFTER_IMDCT) {
-            coup->gain[c][0] = gain_cache;
-        } else {
-            for (g = 0; g < sce->ics.num_window_groups; g++) {
-                for (sfb = 0; sfb < sce->ics.max_sfb; sfb++, idx++) {
-                    if (sce->band_type[idx] != ZERO_BT) {
-                        if (!cge) {
-                            int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
-                            if (t) {
-                                int s = 1;
-                                t = gain += t;
-                                if (sign) {
-                                    s  -= 2 * (t & 0x1);
-                                    t >>= 1;
-                                }
-                                gain_cache = powf(scale, -t) * s;
-                            }
-                        }
-                        coup->gain[c][idx] = gain_cache;
-                    }
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-/**
- * Parse whether channels are to be excluded from Dynamic Range Compression; reference: table 4.53.
- *
- * @return  Returns number of bytes consumed.
- */
-static int decode_drc_channel_exclusions(DynamicRangeControl *che_drc,
-                                         GetBitContext *gb)
-{
-    int i;
-    int num_excl_chan = 0;
-
-    do {
-        for (i = 0; i < 7; i++)
-            che_drc->exclude_mask[num_excl_chan++] = get_bits1(gb);
-    } while (num_excl_chan < MAX_CHANNELS - 7 && get_bits1(gb));
-
-    return num_excl_chan / 7;
-}
-
-/**
- * Decode dynamic range information; reference: table 4.52.
- *
- * @param   cnt length of TYPE_FIL syntactic element in bytes
- *
- * @return  Returns number of bytes consumed.
- */
-static int decode_dynamic_range(DynamicRangeControl *che_drc,
-                                GetBitContext *gb, int cnt)
-{
-    int n             = 1;
-    int drc_num_bands = 1;
-    int i;
+#include "fixed_dsp.h"
+#include "libavutil/opt.h"
 
-    /* pce_tag_present? */
-    if (get_bits1(gb)) {
-        che_drc->pce_instance_tag  = get_bits(gb, 4);
-        skip_bits(gb, 4); // tag_reserved_bits
-        n++;
-    }
-
-    /* excluded_chns_present? */
-    if (get_bits1(gb)) {
-        n += decode_drc_channel_exclusions(che_drc, gb);
-    }
-
-    /* drc_bands_present? */
-    if (get_bits1(gb)) {
-        che_drc->band_incr            = get_bits(gb, 4);
-        che_drc->interpolation_scheme = get_bits(gb, 4);
-        n++;
-        drc_num_bands += che_drc->band_incr;
-        for (i = 0; i < drc_num_bands; i++) {
-            che_drc->band_top[i] = get_bits(gb, 8);
-            n++;
-        }
-    }
-
-    /* prog_ref_level_present? */
-    if (get_bits1(gb)) {
-        che_drc->prog_ref_level = get_bits(gb, 7);
-        skip_bits1(gb); // prog_ref_level_reserved_bits
-        n++;
-    }
-
-    for (i = 0; i < drc_num_bands; i++) {
-        che_drc->dyn_rng_sgn[i] = get_bits1(gb);
-        che_drc->dyn_rng_ctl[i] = get_bits(gb, 7);
-        n++;
-    }
-
-    return n;
-}
-
-/**
- * Decode extension data (incomplete); reference: table 4.51.
- *
- * @param   cnt length of TYPE_FIL syntactic element in bytes
- *
- * @return Returns number of bytes consumed
- */
-static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt,
-                                    ChannelElement *che, enum RawDataBlockType elem_type)
-{
-    int crc_flag = 0;
-    int res = cnt;
-    switch (get_bits(gb, 4)) { // extension type
-    case EXT_SBR_DATA_CRC:
-        crc_flag++;
-    case EXT_SBR_DATA:
-        if (!che) {
-            av_log(ac->avctx, AV_LOG_ERROR, "SBR was found before the first channel element.\n");
-            return res;
-        } else if (!ac->m4ac.sbr) {
-            av_log(ac->avctx, AV_LOG_ERROR, "SBR signaled to be not-present but was found in the bitstream.\n");
-            skip_bits_long(gb, 8 * cnt - 4);
-            return res;
-        } else if (ac->m4ac.sbr == -1 && ac->output_configured == OC_LOCKED) {
-            av_log(ac->avctx, AV_LOG_ERROR, "Implicit SBR was found with a first occurrence after the first frame.\n");
-            skip_bits_long(gb, 8 * cnt - 4);
-            return res;
-        } else if (ac->m4ac.ps == -1 && ac->output_configured < OC_LOCKED && ac->avctx->channels == 1) {
-            ac->m4ac.sbr = 1;
-            ac->m4ac.ps = 1;
-            output_configure(ac, ac->che_pos, ac->che_pos, ac->m4ac.chan_config, ac->output_configured);
-        } else {
-            ac->m4ac.sbr = 1;
-        }
-        res = ff_decode_sbr_extension(ac, &che->sbr, gb, crc_flag, cnt, elem_type);
-        break;
-    case EXT_DYNAMIC_RANGE:
-        res = decode_dynamic_range(&ac->che_drc, gb, cnt);
+#include "avcodec.h"
+#include "internal.h"
+#include "get_bits.h"                                                                                                                                    
+#include "fft.h"                                                                                                                                         
+#include "fmtconvert.h"                                                                                                                                  
+#include "lpc.h"                                                                                                                                         
+#include "kbdwin.h"                                                                                                                                      
+#include "sinewin.h"                                                                                                                                     
+                                                                                                                                                         
+#include "aac.h"                                                                                                                                         
+#include "aactab.h"                                                                                                                                      
+#include "aacdectab.h"                                                                                                                                   
+#include "cbrt_tablegen.h"                                                                                                                               
+#include "sbr.h"                                                                                                                                         
+#include "aacsbr.h"                                                                                                                                      
+#include "mpeg4audio.h"                                                                                                                                  
+#include "aacadtsdec.h"                                                                                                                                  
+//#include "libavutil/intfloat.h"                                                                                                                          
+                                                                                                                                                         
+#include <assert.h>                                                                                                                                      
+#include <errno.h>                                                                                                                                       
+#include <math.h>                                                                                                                                        
+#include <string.h>             
+#define ENTER() //do{av_log(NULL,AV_LOG_INFO,"%s:ENTER in line %d\n", __FUNCTION__,__LINE__);}while(0)
+#define LEAVE() //do{av_log(NULL,AV_LOG_INFO,"%s:LEAVE in line %d\n", __FUNCTION__,__LINE__);}while(0)
+#define SHOWD(d) av_log(NULL,AV_LOG_INFO,"%d ", d)
+#define SHOWX(x) av_log(NULL,AV_LOG_INFO,"%04x ", x)
+#define SHOWC(c) av_log(NULL,AV_LOG_INFO,"%c ", c)
+#define SHOWS(s) av_log(NULL,AV_LOG_INFO,"%s\n", s)
+static VLC vlc_scalefactors;                                                                                                                             
+static VLC vlc_spectral[11];                                                                                                                             
+                                                                                                                                                         
+static int output_configure(AACContext *ac,                                                                                                              
+                            uint8_t layout_map[MAX_ELEM_ID*4][3], int tags,                                                                              
+                            enum OCStatus oc_type, int get_new_frame);                                                                                   
+                                                                                                                                                         
+#define overread_err "Input buffer exhausted before END element found\n"                                                                                                                            
+                                                                                                                                                         
+static av_always_inline void reset_predict_state(PredictorState *ps)                                                                                     
+{                                                                                                                                                        
+    ps->r0.mant   = 0;                                                                                                                                   
+    ps->r0.expo   = 0;                                                                                                                                   
+    ps->r1.mant   = 0;                                                                                                                                   
+    ps->r1.expo   = 0;                                                                                                                                   
+    ps->cor0.mant = 0;                                                                                                                                   
+    ps->cor0.expo = 0;                                                                                                                                   
+    ps->cor1.mant = 0;                                                                                                                                   
+    ps->cor1.expo = 0;                                                                                                                                   
+    ps->var0.mant = 0x20000000;                                                                                                                          
+    ps->var0.expo = 1;                                                                                                                                   
+    ps->var1.mant = 0x20000000;                                                                                                                          
+    ps->var1.expo = 1;                                                                                                                                   
+}                                                                                                                                                        
+                                                                                                                                                         
+int exp2tab[4] = { Q31(1.0000000000/2), Q31(1.1892071150/2), Q31(1.4142135624/2), Q31(1.6817928305/2) };  // 2^0, 2^0.25, 2^0.5, 2^0.75                  
+                                                                                                                                                         
+static inline int *DEC_SPAIR(int *dst, unsigned idx)                                                                                                     
+{                                                                                                                                                        
+  dst[0] = (idx & 15) - 4;                                                                                                                               
+  dst[1] = (idx>>4 & 15) - 4;                                                                                                                            
+                                                                                                                                                         
+  return dst + 2;                                                                                                                                        
+}                                                                                                                                                        
+                                                                                                                                                         
+                                                                                                                                                  
+                                                                                                                                                         
+static inline int *DEC_UPAIR(int *dst, unsigned idx, unsigned sign)                                                                                      
+{                                                                                                                                                        
+  dst[0] = (idx & 15) * (1 - (((int)sign>>1)<<1));                                                                                                       
+  dst[1] = (idx>>4 & 15) * (1 - (((int)sign&1)<<1));                                                                                                     
+                                                                                                                                                         
+  return dst + 2;                                                                                                                                        
+}                                                                                                                                                        
+                                                                                                                                                         
+static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)                                                                                      
+{                                                                                                                                                        
+  unsigned nz = idx >> 12;                                                                                                                               
+                                                                                                                                                         
+  dst[0] = (idx & 3) * (1 + (((int)sign>>31)<<1));                                                                                                       
+  sign <<= nz & 1; nz >>= 1;                                                                                                                             
+  dst[1] = (idx>>2 & 3) * (1 + (((int)sign>>31)<<1));                                                                                                    
+  sign <<= nz & 1; nz >>= 1;                                                                                                                             
+  dst[2] = (idx>>4 & 3) * (1 + (((int)sign>>31)<<1));                                                                                                    
+  sign <<= nz & 1; nz >>= 1;                                                                                                                             
+  dst[3] = (idx>>6 & 3) * (1 + (((int)sign>>31)<<1));                                                                                                    
+                                                                                                                                                         
+  return dst + 4;                                                                                                                                        
+}                                                                                                                                                        
+                                                                                                                                                         
+static void vector_pow43(int *coefs, int len)                                                                                                            
+{                                                                                                                                                        
+  int i, coef;                                                                                                                                           
+                                                                                                                                                         
+  for (i=0; i<len; i++) {                                                                                                                                
+    coef = coefs[i];                                                                                                                                     
+    if (coef < 0)                                                                                                                                        
+      coef = -(int)cbrt_tab[-coef];                                                                                                                      
+    else                                                                                                                                                 
+      coef = (int)cbrt_tab[coef];                                                                                                                        
+    coefs[i] = coef;                                                                                                                                     
+  }                                                                                                                                                      
+}                                                                                                                                                        
+                                                                                                                                                         
+static void subband_scale(int *dst, int *src, int scale, int offset, int len)                                                                            
+{                                                                                                                                                        
+  int64_t accu;                                                                                                                                          
+  int ssign = scale < 0 ? -1 : 1;                                                                                                                        
+  int s = FFABS(scale), round;                                                                                                                           
+  int i, out, c = exp2tab[s & 3];                                                                                                                        
+                                                                                                                                                         
+  s = offset - (s >> 2);                                                                                                                                 
+                                                                                                                                                         
+  if (s > 0) {                                                                                                                                           
+    round = 1 << (s-1);                                                                                                                                  
+    for (i=0; i<len; i++) {                                                                                                                              
+      accu = (int64_t)src[i] * c;                                                                                                                        
+      out = (int)(accu >> 32);                                                                                                                           
+      dst[i] = ((out+round) >> s) * ssign;                                                                                                               
+    }                                                                                                                                                    
+  }                                                                                                                                                      
+  else {                                                                                                                                                 
+    s = s + 32;                                                                                                                                          
+    round = 1 << (s-1);                                                                                                                                  
+    for (i=0; i<len; i++) {                                                                                                                              
+      accu = (int64_t)src[i] * c;                                                                                                                        
+      out = (int)((accu+round) >> s);                                                                                                                    
+      dst[i] = out * ssign;                                                                                                                              
+    }                                                                                                                                                    
+  }                                                                                                                                                      
+}                                                                                                                                                        
+                                                                                                                                                         
+static void noise_scale(int *coefs, int scale, int band_energy, int len)                                                                                 
+{                                                                                                                                                        
+  int64_t accu;                                                                                                                                          
+  int ssign = scale < 0 ? -1 : 1;                                                                                                                        
+  int s = FFABS(scale), round;                                                                                                                           
+  int i, out, c = exp2tab[s & 3];                                                                                                                        
+  int nlz = 0;                                                                                                                                           
+                                                                                                                                                         
+  while (band_energy > 0x7fff) {                                                                                                                         
+    band_energy >>= 1;                                                                                                                                   
+    nlz++;                                                                                                                                               
+  }                                                                                                                                                      
+  c /= band_energy;                                                                                                                                      
+  s = 21 + nlz - (s >> 2);                                                                                                                               
+                                                                                                                                                         
+  if (s > 0) {                                                                                                                                           
+    round = 1 << (s-1);                                                                                                                                  
+    for (i=0; i<len; i++) {                                                                                                                              
+      accu = (int64_t)coefs[i] * c;                                                                                                                      
+      out = (int)(accu >> 32);                                                                                                                           
+      coefs[i] = ((out+round) >> s) * ssign;                                                                                                             
+    }                                                                                                                                                    
+  }                                                                                                                                                      
+  else {                                                                                                                                                 
+    s = s + 32;                                                                                                                                          
+    round = 1 << (s-1);                                                                                                                                  
+    for (i=0; i<len; i++) {                                                                                                                              
+      accu = (int64_t)coefs[i] * c;                                                                                                                      
+      out = (int)((accu+round) >> s);                                                                                                                    
+      coefs[i] = out * ssign;                                                                                                                            
+    }                                                                                                                                                    
+  }                                                                                                                                                      
+}                                                                                                                                                        
+                                                                                                                                                         
+static av_always_inline aac_float_t flt16_round(aac_float_t pf)                                                                                          
+{                                                                                                                                                        
+    aac_float_t tmp;                                                                                                                                     
+    int s;                                                                                                                                               
+                                                                                                                                                         
+    tmp.expo = pf.expo;                                                                                                                                  
+    s = pf.mant >> 31;                                                                                                                                   
+    tmp.mant = (pf.mant ^ s) - s;                                                                                                                        
+    tmp.mant = (tmp.mant + 0x00200000U) & 0xFFC00000U;                                                                                                   
+    tmp.mant = (tmp.mant ^ s) - s;                                                                                                                       
+                                                                                                                                                         
+    return tmp;                                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+static av_always_inline aac_float_t flt16_even(aac_float_t pf)                                                                                           
+{                                                                                                                                                        
+    aac_float_t tmp;                                                                                                                                     
+    int s;                                                                                                                                               
+                                                                                                                                                         
+    tmp.expo = pf.expo;                                                                                                                                  
+    s = pf.mant >> 31;                                                                                                                                   
+    tmp.mant = (pf.mant ^ s) - s;                                                                                                                        
+    tmp.mant = (tmp.mant + 0x001FFFFFU + (tmp.mant & 0x00400000U >> 16)) & 0xFFC00000U;                                                                  
+    tmp.mant = (tmp.mant ^ s) - s;                                                                                                                       
+                                                                                                                                                         
+    return tmp;                                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+static av_always_inline aac_float_t flt16_trunc(aac_float_t pf)                                                                                          
+{                                                                                                                                                        
+    aac_float_t pun;                                                                                                                                     
+    int s;                                                                                                                                               
+                                                                                                                                                         
+    pun.expo = pf.expo;                                                                                                                                  
+    s = pf.mant >> 31;                                                                                                                                   
+    pun.mant = (pf.mant ^ s) - s;                                                                                                                        
+    pun.mant = pun.mant & 0xFFC00000U;                                                                                                                   
+    pun.mant = (pun.mant ^ s) - s;                                                                                                                       
+                                                                                                                                                         
+    return pun;                                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+static av_always_inline void predict(PredictorState *ps, int *coef,                                                                                      
+                                     int output_enable)                                                                                                  
+{                                                                                                                                                        
+    const aac_float_t a     = { 1023410176, 0 };  // 61.0 / 64                                                                                           
+    const aac_float_t alpha = {  973078528, 0 };  // 29.0 / 32                                                                                           
+    aac_float_t e0, e1;                                                                                                                                  
+    aac_float_t pv;                                                                                                                                      
+    aac_float_t k1, k2;                                                                                                                                  
+    aac_float_t   r0 = ps->r0,     r1 = ps->r1;                                                                                                          
+    aac_float_t cor0 = ps->cor0, cor1 = ps->cor1;                                                                                                        
+    aac_float_t var0 = ps->var0, var1 = ps->var1;                                                                                                        
+    aac_float_t tmp;                                                                                                                                     
+                                                                                                                                                         
+    if (var0.expo > 1 || (var0.expo == 1 && var0.mant > 0x20000000)) {                                                                                   
+      tmp = float_recip(var0);                                                                                                                           
+      k1 = float_mul(cor0, flt16_even(float_mul(a, tmp)));                                                                                               
+    }                                                                                                                                                    
+    else {                                                                                                                                               
+      k1.mant = 0;                                                                                                                                       
+      k1.expo = 0;                                                                                                                                       
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (var1.expo > 1 || (var1.expo == 1 && var1.mant > 0x20000000)) {                                                                                   
+      tmp = float_recip(var1);                                                                                                                           
+      k2 = float_mul(cor1, flt16_even(float_mul(a, tmp)));                                                                                               
+    }                                                                                                                                                    
+    else {                                                                                                                                               
+      k2.mant = 0;                                                                                                                                       
+      k2.expo = 0;                                                                                                                                       
+    }                                                                                                                                                    
+                                                                                                                                                         
+    tmp = float_mul(k1, r0);                                                                                                                             
+    pv = flt16_round(float_add(tmp, float_mul(k2, r1)));                                                                                                 
+    if (output_enable) {                                                                                                                                 
+      int shift = 28 - pv.expo;                                                                                                                          
+                                                                                                                                                         
+      if (shift < 31)                                                                                                                                    
+        *coef += (pv.mant + (1<<(shift-1))) >> shift;                                                                                                    
+    }                                                                                                                                                    
+                                                                                                                                                         
+    e0 = int2float(*coef, 28);                                                                                                                           
+    e1 = float_sub(e0, tmp);                                                                                                                             
+                                                                                                                                                         
+    ps->cor1 = flt16_trunc(float_add(float_mul(alpha, cor1), float_mul(r1, e1)));                                                                        
+    tmp = float_add(float_mul(r1, r1), float_mul(e1, e1));                                                                                               
+    tmp.expo--;                                                                                                                                          
+    ps->var1 = flt16_trunc(float_add(float_mul(alpha, var1), tmp));                                                                                      
+    ps->cor0 = flt16_trunc(float_add(float_mul(alpha, cor0), float_mul(r0, e0)));                                                                        
+    tmp = float_add(float_mul(r0, r0), float_mul(e0, e0));                                                                                               
+    tmp.expo--;                                                                                                                                          
+    ps->var0 = flt16_trunc(float_add(float_mul(alpha, var0), tmp));                                                                                      
+                                                                                                                                                         
+    ps->r1 = flt16_trunc(float_mul(a, float_sub(r0, float_mul(k1, e0))));                                                                                
+    ps->r0 = flt16_trunc(float_mul(a, e0));                                                                                                              
+}                                                                                                                                                        
+                                                                                                                                                         
+                                                                                                                                                         
+static const int cce_scale_fixed[8] = {                                                                                                                  
+    Q30(1.0),          //2^(0/8)                                                                                                                         
+    Q30(1.0905077327), //2^(1/8)                                                                                                                         
+    Q30(1.1892071150), //2^(2/8)                                                                                                                         
+    Q30(1.2968395547), //2^(3/8)                                                                                                                         
+    Q30(1.4142135624), //2^(4/8)                                                                                                                         
+    Q30(1.5422108254), //2^(5/8)                                                                                                                         
+    Q30(1.6817928305), //2^(6/8)                                                                                                                         
+    Q30(1.8340080864), //2^(7/8)                                                                                                                         
+};                                                                                                                                                       
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Apply dependent channel coupling (applied before IMDCT).                                                                                              
+ *                                                                                                                                                       
+ *  <at> param   index   index into coupling gain array                                                                                                  
+ */                                                                                                                                                      
+static void apply_dependent_coupling_fixed(AACContext *ac,                                                                                               
+                                     SingleChannelElement *target,                                                                                       
+                                     ChannelElement *cce, int index)                                                                                     
+{                                                                                                                                                        
+    IndividualChannelStream *ics = &cce->ch[0].ics;                                                                                                      
+    const uint16_t *offsets = ics->swb_offset;                                                                                                           
+    int *dest = target->coeffs;                                                                                                                          
+    const int *src = cce->ch[0].coeffs;                                                                                                                  
+    int g, i, group, k, idx = 0;                                                                                                                         
+    if (ac->oc[1].m4ac.object_type == AOT_AAC_LTP) {                                                                                                     
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                  
+               "Dependent coupling is not supported together with LTP\n");                                                                               
+        return;                                                                                                                                          
+    }                                                                                                                                                    
+    for (g = 0; g < ics->num_window_groups; g++) {                                                                                                       
+        for (i = 0; i < ics->max_sfb; i++, idx++) {                                                                                                      
+            if (cce->ch[0].band_type[idx] != ZERO_BT) {                                                                                                  
+                const int gain = cce->coup.gain[index][idx];                                                                                             
+                int shift, round, c, tmp;                                                                                                                
+                int64_t accu;                                                                                                                            
+                                                                                                                                                         
+                if (gain < 0) {                                                                                                                          
+                  c = -cce_scale_fixed[-gain & 7];                                                                                                       
+                  shift = (-gain-1024) >> 3;                                                                                                             
+                }                                                                                                                                        
+                else {                                                                                                                                   
+                  c = cce_scale_fixed[gain & 7];                                                                                                         
+                  shift = (gain-1024) >> 3;                                                                                                              
+                }                                                                                                                                        
+                                                                                                                                                         
+                if (shift < 0) {                                                                                                                         
+                  shift = -shift;                                                                                                                        
+                  round = 1 << (shift - 1);                                                                                                              
+                                                                                                                                                         
+                  for (group = 0; group < ics->group_len[g]; group++) {                                                                                  
+                      for (k = offsets[i]; k < offsets[i + 1]; k++) {                                                                                    
+                          // XXX dsputil-ize                                                                                                             
+                          accu = (int64_t)src[group * 128 + k]*c;                                                                                        
+                          tmp = (int)((accu + 0x20000000) >> 30);                                                                                        
+                          dest[group * 128 + k] += (tmp + round) >> shift;                                                                               
+                      }                                                                                                                                  
+                  }                                                                                                                                      
+                }                                                                                                                                        
+                else {                                                                                                                                   
+                  for (group = 0; group < ics->group_len[g]; group++) {                                                                                  
+                      for (k = offsets[i]; k < offsets[i + 1]; k++) {                                                                                    
+                          // XXX dsputil-ize                                                                                                             
+                          accu = (int64_t)src[group * 128 + k]*c;                                                                                        
+                          tmp = (int)((accu + 0x20000000) >> 30);                                                                                        
+                          dest[group * 128 + k] += tmp << shift;                                                                                         
+                      }                                                                                                                                  
+                  }                                                                                                                                      
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+        dest += ics->group_len[g] * 128;                                                                                                                 
+        src  += ics->group_len[g] * 128;                                                                                                                 
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Apply independent channel coupling (applied after IMDCT).                                                                                             
+ *                                                                                                                                                       
+ *  <at> param   index   index into coupling gain array                                                                                                  
+ */                                                                                                                                                      
+static void apply_independent_coupling_fixed(AACContext *ac,                                                                                             
+                                       SingleChannelElement *target,                                                                                     
+                                       ChannelElement *cce, int index)                                                                                   
+{                                                                                                                                                        
+    int i, c, shift, round, tmp;                                                                                                                         
+    const int gain = cce->coup.gain[index][0];                                                                                                           
+    const int *src = cce->ch[0].ret;                                                                                                                     
+    int *dest = target->ret;                                                                                                                             
+    const int len = 1024 << (ac->oc[1].m4ac.sbr == 1);                                                                                                   
+    int64_t accu;                                                                                                                                        
+                                             //  av_log(NULL, AV_LOG_ERROR, "Too mssssssssssssssssssssssssssssssssssss\n");                  
+    c = cce_scale_fixed[gain & 7];                                                                                                                       
+    shift = (gain-1024) >> 3;                                                                                                                            
+    if (shift < 0) {                                                                                                                                     
+      shift = -shift;                                                                                                                                    
+      round = 1 << (shift - 1);                                                                                                                          
+                                                                                                                                                         
+      for (i = 0; i < len; i++) {                                                                                                                        
+          accu = (long long)src[i]*c;                                                                                                                    
+          tmp = (int)((accu + 0x20000000) >> 30);                                                                                                        
+          dest[i] += (tmp + round) >> shift;                                                                                                             
+      }                                                                                                                                                  
+    }                                                                                                                                                    
+    else {                                                                                                                                               
+      for (i = 0; i < len; i++) {                                                                                                                        
+          accu = (long long)src[i]*c;                                                                                                                    
+          tmp = (int)((accu + 0x20000000) >> 30);                                                                                                        
+          dest[i] += tmp << shift;                                                                                                                       
+      }                                                                                                                                                  
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+         static int count_channels(uint8_t (*layout)[3], int tags)                                                                                                
+{                                                                                                                                                        
+    int i, sum = 0;                                                                                                                                      
+    for (i = 0; i < tags; i++) {                                                                                                                         
+        int syn_ele = layout[i][0];                                                                                                                      
+        int pos     = layout[i][2];                                                                                                                      
+        sum += (1 + (syn_ele == TYPE_CPE)) *                                                                                                             
+               (pos != AAC_CHANNEL_OFF && pos != AAC_CHANNEL_CC);                                                                                        
+    }                                                                                                                                                    
+    return sum;                                                                                                                                          
+}                                                                                                                                                        
+static inline int *DEC_SQUAD(int *dst, unsigned idx)                                                                                                     
+{                                                                                                                                                        
+  dst[0] = (idx & 3) - 1;                                                                                                                                
+  dst[1] = (idx>>2 & 3) - 1;                                                                                                                             
+  dst[2] = (idx>>4 & 3) - 1;                                                                                                                             
+  dst[3] = (idx>>6 & 3) - 1;                                                                                                                             
+                                                                                                                                                         
+  return dst + 4;                                                                                                                                        
+}                                                                                                                                  
+/**                                                                                                                                                      
+ * Check for the channel element in the current channel position configuration.                                                                          
+ * If it exists, make sure the appropriate element is allocated and map the                                                                              
+ * channel order to match the internal FFmpeg channel layout.                                                                                            
+ *                                                                                                                                                       
+ *  <at> param   che_pos current channel position configuration                                                                                          
+ *  <at> param   type channel element type                                                                                                               
+ *  <at> param   id channel element id                                                                                                                   
+ *  <at> param   channels count of the number of channels in the configuration                                                                           
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static av_cold int che_configure(AACContext *ac,                                                                                                         
+                                 enum ChannelPosition che_pos,                                                                                           
+                                 int type, int id, int *channels)                                                                                        
+{                                                                                                                                                        
+    if (*channels >= MAX_CHANNELS)                                                                                                                       
+        return AVERROR_INVALIDDATA;                                                                                                                      
+    if (che_pos) {          //av_log(NULL,AV_LOG_INFO,"-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa-\n");                                                              
+        if (!ac->che[type][id]) {   //av_log(NULL,AV_LOG_INFO,"-bbbbbbbbbbbbbbbbbb-\n");                                              
+            if (!(ac->che[type][id] = av_mallocz(sizeof(ChannelElement))))                                                                               
+                return AVERROR(ENOMEM);                                                                                                                  
+            AAC_RENAME(ff_aac_sbr_ctx_init)(ac, &ac->che[type][id]->sbr);                                                                                
+        }                                                                                                                                                
+        if (type != TYPE_CCE) {                 //av_log(NULL,AV_LOG_INFO,"-bbbbbbbbbbbbbbbbbbb-\n");  
+            if (*channels >= MAX_CHANNELS - (type == TYPE_CPE || (type == TYPE_SCE && ac->oc[1].m4ac.ps == 1))) {                                        
+                av_log(ac->avctx, AV_LOG_ERROR, "Too many channels\n");                                                                                  
+                return AVERROR_INVALIDDATA;                                                                                                              
+            }                                                                                                                                            
+            ac->output_element[(*channels)++] = ac->che[type][id]->ch[0].ret;//&ac->che[type][id]->ch[0];
+            //ac->output_data[(*channels)++] = ac->che[type][id]->ch[0].ret;                                                                               
+            if (type == TYPE_CPE ||                                                                                                                      
+                (type == TYPE_SCE && ac->oc[1].m4ac.ps == 1)) { //av_log(NULL,AV_LOG_INFO,"-ccccccccccccccccccccc-\n");  
+                ac->output_element[(*channels)++] = ac->che[type][id]->ch[1].ret;//&ac->che[type][id]->ch[1];
+                //ac->output_data[(*channels)++] = ac->che[type][id]->ch[1].ret;
+            } 
+        }                                                                                                                                                
+    } else {   //av_log(NULL,AV_LOG_INFO,"-dddddddddddddddddddd-\n");
+        if (ac->che[type][id])                                                                                                                           
+            AAC_RENAME(ff_aac_sbr_ctx_close)(&ac->che[type][id]->sbr);                                                                                   
+        av_freep(&ac->che[type][id]);                                                                                                                    
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+static void ff_init_buffer_info(AVCodecContext *s, AVFrame *frame)
+{
+    if (s->pkt) {
+        frame->pkt_pts = s->pkt->pts;
+        frame->pkt_pos = s->pkt->pos;
+        frame->pkt_duration = s->pkt->duration;
+        frame->pkt_size = s->pkt->size;
+    } else {
+        frame->pkt_pts = AV_NOPTS_VALUE;
+        frame->pkt_pos = -1;
+        frame->pkt_duration = 0;
+        frame->pkt_size = -1;
+    }
+    frame->reordered_opaque = s->reordered_opaque;
+
+    switch (s->codec->type) {
+    case AVMEDIA_TYPE_VIDEO:
+        frame->width               = s->width;
+        frame->height              = s->height;
+        frame->format              = s->pix_fmt;
+        frame->sample_aspect_ratio = s->sample_aspect_ratio;
         break;
-    case EXT_FILL:
-    case EXT_FILL_DATA:
-    case EXT_DATA_ELEMENT:
-    default:
-        skip_bits_long(gb, 8 * cnt - 4);
+    case AVMEDIA_TYPE_AUDIO:
+        frame->sample_rate    = s->sample_rate;
+        frame->format         = s->sample_fmt;
+        frame->channel_layout = s->channel_layout;
+        frame->channels       = s->channels;
         break;
-    };
-    return res;
-}
-
-/**
- * Decode Temporal Noise Shaping filter coefficients and apply all-pole filters; reference: 4.6.9.3.
- *
- * @param   decode  1 if tool is used normally, 0 if tool is used in LTP.
- * @param   coef    spectral coefficients
- */
-static void apply_tns(float coef[1024], TemporalNoiseShaping *tns,
-                      IndividualChannelStream *ics, int decode)
-{
-    const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb);
-    int w, filt, m, i;
-    int bottom, top, order, start, end, size, inc;
-    float lpc[TNS_MAX_ORDER];
-    float tmp[TNS_MAX_ORDER];
-
-    for (w = 0; w < ics->num_windows; w++) {
-        bottom = ics->num_swb;
-        for (filt = 0; filt < tns->n_filt[w]; filt++) {
-            top    = bottom;
-            bottom = FFMAX(0, top - tns->length[w][filt]);
-            order  = tns->order[w][filt];
-            if (order == 0)
-                continue;
-
-            // tns_decode_coef
-            compute_lpc_coefs(tns->coef[w][filt], order, lpc, 0, 0, 0);
-
-            start = ics->swb_offset[FFMIN(bottom, mmm)];
-            end   = ics->swb_offset[FFMIN(   top, mmm)];
-            if ((size = end - start) <= 0)
-                continue;
-            if (tns->direction[w][filt]) {
-                inc = -1;
-                start = end - 1;
-            } else {
-                inc = 1;
-            }
-            start += w * 128;
-
-            if (decode) {
-                // ar filter
-                for (m = 0; m < size; m++, start += inc)
-                    for (i = 1; i <= FFMIN(m, order); i++)
-                        coef[start] -= coef[start - i * inc] * lpc[i - 1];
-            } else {
-                // ma filter
-                for (m = 0; m < size; m++, start += inc) {
-                    tmp[0] = coef[start];
-                    for (i = 1; i <= FFMIN(m, order); i++)
-                        coef[start] += tmp[i] * lpc[i - 1];
-                    for (i = order; i > 0; i--)
-                        tmp[i] = tmp[i - 1];
-                }
-            }
-        }
     }
 }
 
-/**
- *  Apply windowing and MDCT to obtain the spectral
- *  coefficient from the predicted sample by LTP.
- */
-static void windowing_and_mdct_ltp(AACContext *ac, float *out,
-                                   float *in, IndividualChannelStream *ics)
+static int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame)
 {
-    const float *lwindow      = ics->use_kb_window[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;
-    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;
-    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;
-    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;
+    ff_init_buffer_info(avctx, frame);
 
-    if (ics->window_sequence[0] != LONG_STOP_SEQUENCE) {
-        ac->dsp.vector_fmul(in, in, lwindow_prev, 1024);
-    } else {
-        memset(in, 0, 448 * sizeof(float));
-        ac->dsp.vector_fmul(in + 448, in + 448, swindow_prev, 128);
-    }
-    if (ics->window_sequence[0] != LONG_START_SEQUENCE) {
+    return avcodec_default_get_buffer(avctx, frame);
+}
+static int frame_configure_elements(AVCodecContext *avctx)                                                                                               
+{                                                                                                                                                        
+    AACContext *ac = avctx->priv_data;                                                                                                                   
+    int type, id, ch, ret;                                                                                                                               
+                                                                                                                                                         
+    /* set channel pointers to internal buffers by default                                                                                             
+    for (type = 0; type < 4; type++) {                                                                                                                   
+        for (id = 0; id < MAX_ELEM_ID; id++) {                                                                                                           
+            ChannelElement *che = ac->che[type][id];                                                                                                     
+            if (che) {                                                                                                                                   
+                che->ch[0].ret = che->ch[0].ret_buf;                                                                                                     
+                che->ch[1].ret = che->ch[1].ret_buf;                                                                                                     
+            }                                                                                                                                            
+        }                                                                                                                                                
+    } */                                                 
+                                                                                                                                                         
+    /* get output buffer                                                                                                                               
+    av_frame_unref(ac->frame);                                                                                                                          
+    ac->frame.nb_samples = 2048;                                                                                                                        
+    if ((ret = ff_get_buffer(avctx, &ac->frame)) < 0)                                                                                                  
+        return ret;                  */                                                                                                                     
+                                                                                                                                                         
+    /* map output channel pointers to AVFrame data                                                                                                     
+    for (ch = 0; ch < avctx->channels; ch++) {                                                                                                           
+        if (ac->output_element[ch])                                                                      
+            ac->output_element[ch]->ret = (INTFLOAT *)ac->frame.extended_data[ch];                                                                     
+    }                    */                                                                                                                                
+                                                                                                                                                         
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+struct elem_to_channel {                                                                                                                                 
+    uint64_t av_position;                                                                                                                                
+    uint8_t syn_ele;                                                                                                                                     
+    uint8_t elem_id;                                                                                                                                     
+    uint8_t aac_position;                                                                                                                                
+};                                                                                                                                                       
+                                                                                                                                                         
+static int assign_pair(struct elem_to_channel e2c_vec[MAX_ELEM_ID],                                                                                      
+                       uint8_t (*layout_map)[3], int offset, uint64_t left,                                                                              
+    uint64_t right, int pos)                                                                                                                             
+{                                                                                                                                                        
+    if (layout_map[offset][0] == TYPE_CPE) {                                                                                                             
+        e2c_vec[offset] = (struct elem_to_channel) {                                                                                                     
+            .av_position = left | right, .syn_ele = TYPE_CPE,                                                                                            
+            .elem_id = layout_map[offset    ][1], .aac_position = pos };                                                                                 
+        return 1;                                                                                                                                        
+    } else {                                                                                                                                             
+        e2c_vec[offset]   = (struct elem_to_channel) {                                                                                                   
+            .av_position = left, .syn_ele = TYPE_SCE,                                                                                                    
+            .elem_id = layout_map[offset    ][1], .aac_position = pos };                                                                                 
+        e2c_vec[offset + 1] = (struct elem_to_channel) {                                                                                                 
+            .av_position = right, .syn_ele = TYPE_SCE,                                                                                                   
+            .elem_id = layout_map[offset + 1][1], .aac_position = pos };                                                                                 
+        return 2;                                                                                                                                        
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) {                                                            
+    int num_pos_channels = 0;                                                                                                                            
+    int first_cpe = 0;                                                                                                                                   
+    int sce_parity = 0;                                                                                                                                  
+    int i;                                                                                                                                               
+    for (i = *current; i < tags; i++) {                                                                                                                  
+        if (layout_map[i][2] != pos)                                                                                                                     
+            break;                                                                                                                                       
+        if (layout_map[i][0] == TYPE_CPE) {                                                                                                              
+            if (sce_parity) {                                                                                                                            
+                if (pos == AAC_CHANNEL_FRONT && !first_cpe) {                                                                                            
+                    sce_parity = 0;                                                                                                                      
+                } else {                                                                                                                                 
+                    return -1;                                                                                                                           
+                }                                                                                                                                        
+            }                                                                                                                                            
+            num_pos_channels += 2;                                                                                                                       
+            first_cpe = 1;                                                                                                                               
+        } else {                                                                                                                                         
+            num_pos_channels++;                                                                                                                          
+            sce_parity ^= 1;                                                                                                                             
+        }                                                                                                                                                
+    }                                                                                                                                                    
+    if (sce_parity &&                                                                                                                                    
+        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))                                                                            
+            return -1;                                                                                                                                   
+    *current = i;                                                                                                                                        
+    return num_pos_channels;                                                                                                                             
+}                                                                                                                                                        
+                                                                                                                                                         
+static uint64_t sniff_channel_order(uint8_t (*layout_map)[3], int tags)                                                                                  
+{                                                                                                                                                        
+    int i, n, total_non_cc_elements;                                                                                                                     
+    struct elem_to_channel e2c_vec[4*MAX_ELEM_ID] = {{ 0 }};                                                                                             
+    int num_front_channels, num_side_channels, num_back_channels;                                                                                        
+    uint64_t layout;                                                                                                                                     
+                                                                                                                                                         
+    if (FF_ARRAY_ELEMS(e2c_vec) < tags)                                                                                                                  
+        return 0;                                                                                                                                        
+                                                                                                                                                         
+    i = 0;                                                                                                                                               
+    num_front_channels =                                                                                                                                 
+        count_paired_channels(layout_map, tags, AAC_CHANNEL_FRONT, &i);                                                                                  
+    if (num_front_channels < 0)                                                                                                                          
+        return 0;                                                                                                                                        
+    num_side_channels =                                                                                                                                  
+        count_paired_channels(layout_map, tags, AAC_CHANNEL_SIDE, &i);                                                                                   
+    if (num_side_channels < 0)                                                                                                                           
+        return 0;                                                                                                                                        
+    num_back_channels =                                                                                                                                  
+        count_paired_channels(layout_map, tags, AAC_CHANNEL_BACK, &i);                                                                                   
+    if (num_back_channels < 0)                                                                                                                           
+        return 0;                                                                                                                                        
+                                                                                                                                                         
+    i = 0;                                                                                                                                               
+    if (num_front_channels & 1) {                                                                                                                        
+        e2c_vec[i] = (struct elem_to_channel) {                                                                                                          
+            .av_position = AV_CH_FRONT_CENTER, .syn_ele = TYPE_SCE,                                                                                      
+            .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_FRONT };                                                                            
+        i++;                                                                                                                                             
+        num_front_channels--;                                                                                                                            
+    }                                                                                                                                                    
+    if (num_front_channels >= 4) {                                                                                                                       
+        i += assign_pair(e2c_vec, layout_map, i,                                                                                                         
+                         AV_CH_FRONT_LEFT_OF_CENTER,                                                                                                     
+                         AV_CH_FRONT_RIGHT_OF_CENTER,                                                                                                    
+                         AAC_CHANNEL_FRONT);                                                                                                             
+        num_front_channels -= 2;                                                                                                                         
+    }                                                                                                                                                    
+    if (num_front_channels >= 2) {                                                                                                                       
+        i += assign_pair(e2c_vec, layout_map, i,                                                                                                         
+                         AV_CH_FRONT_LEFT,                                                                                                               
+                         AV_CH_FRONT_RIGHT,                                                                                                              
+                         AAC_CHANNEL_FRONT);                                                                                                             
+        num_front_channels -= 2;                                                                                                                         
+    }                                                                                                                                                    
+    while (num_front_channels >= 2) {                                                                                                                    
+        i += assign_pair(e2c_vec, layout_map, i,                                                                                                         
+                         UINT64_MAX,                                                                                                                     
+                         UINT64_MAX,                                                                                                                     
+                         AAC_CHANNEL_FRONT);                                                                                                             
+        num_front_channels -= 2;                                                                                                                         
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (num_side_channels >= 2) {                                                                                                                        
+        i += assign_pair(e2c_vec, layout_map, i,                                                                                                         
+                         AV_CH_SIDE_LEFT,                                                                                                                
+                         AV_CH_SIDE_RIGHT,                                                                                                               
+                         AAC_CHANNEL_FRONT);                                                                                                             
+        num_side_channels -= 2;                                                                                                                          
+    }                                                                                                                                                    
+    while (num_side_channels >= 2) {                                                                                                                     
+        i += assign_pair(e2c_vec, layout_map, i,                                                                                                         
+                         UINT64_MAX,                                                                                                                     
+                         UINT64_MAX,                                                                                                                     
+                         AAC_CHANNEL_SIDE);                                                                                                              
+        num_side_channels -= 2;                                                                                                                          
+    }                                                                                                                                                    
+                                                                                                                                                         
+    while (num_back_channels >= 4) {                                                                                                                     
+        i += assign_pair(e2c_vec, layout_map, i,                                                                                                         
+                         UINT64_MAX,                                                                                                                     
+                         UINT64_MAX,                                                                                                                     
+                         AAC_CHANNEL_BACK);                                                                                                              
+        num_back_channels -= 2;                                                                                                                          
+    }                                                                                                                                                    
+    if (num_back_channels >= 2) {                                                                                                                        
+        i += assign_pair(e2c_vec, layout_map, i,                                                                                                         
+                         AV_CH_BACK_LEFT,                                                                                                                
+                         AV_CH_BACK_RIGHT,                                                                                                               
+                         AAC_CHANNEL_BACK);                                                                                                              
+        num_back_channels -= 2;                                                                                                                          
+    }                                                                                                                                                    
+    if (num_back_channels) {                                                                                                                             
+        e2c_vec[i] = (struct elem_to_channel) {                                                                                                          
+          .av_position = AV_CH_BACK_CENTER, .syn_ele = TYPE_SCE,                                                                                         
+          .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_BACK };                                                                               
+        i++;                                                                                                                                             
+        num_back_channels--;                                                                                                                             
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (i < tags && layout_map[i][2] == AAC_CHANNEL_LFE) {                                                                                               
+        e2c_vec[i] = (struct elem_to_channel) {                                                                                                          
+          .av_position = AV_CH_LOW_FREQUENCY, .syn_ele = TYPE_LFE,                                                                                       
+          .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_LFE };                                                                                
+        i++;                                                                                                                                             
+    }                                                                                                                                                    
+    while (i < tags && layout_map[i][2] == AAC_CHANNEL_LFE) {                                                                                            
+        e2c_vec[i] = (struct elem_to_channel) {                                                                                                          
+          .av_position = UINT64_MAX, .syn_ele = TYPE_LFE,                                                                                                
+          .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_LFE };                                                                                
+        i++;                                                                                                                                             
+    }                                                                                                                                                    
+                                                                                                                                                         
+    // Must choose a stable sort                                                                                                                         
+    total_non_cc_elements = n = i;                                                                                                                       
+    do {                                                                                                                                                 
+        int next_n = 0;                                                                                                                                  
+        for (i = 1; i < n; i++) {                                                                                                                        
+            if (e2c_vec[i-1].av_position > e2c_vec[i].av_position) {                                                                                     
+                FFSWAP(struct elem_to_channel, e2c_vec[i-1], e2c_vec[i]);                                                                                
+                next_n = i;                                                                                                                              
+            }                                                                                                                                            
+        }                                                                                                                                                
+        n = next_n;                                                                                                                                      
+    } while (n > 0);                                                                                                                                     
+                                                                                                                                                         
+    layout = 0;                                                                                                                                          
+    for (i = 0; i < total_non_cc_elements; i++) {                                                                                                        
+        layout_map[i][0] = e2c_vec[i].syn_ele;                                                                                                           
+        layout_map[i][1] = e2c_vec[i].elem_id;                                                                                                           
+        layout_map[i][2] = e2c_vec[i].aac_position;                                                                                                      
+        if (e2c_vec[i].av_position != UINT64_MAX) {                                                                                                      
+            layout |= e2c_vec[i].av_position;                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    return layout;                                                                                                                                       
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Save current output configuration if and only if it has been locked.                                                                                  
+ */                                                                                                                                                      
+static void push_output_configuration(AACContext *ac) {                                                                                                  
+    if (ac->oc[1].status == OC_LOCKED) {                                                                                                                 
+        ac->oc[0] = ac->oc[1];                                                                                                                           
+    }                                                                                                                                                    
+    ac->oc[1].status = OC_NONE;                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Restore the previous output configuration if and only if the current                                                                                  
+ * configuration is unlocked.                                                                                                                            
+ */                                                                                                                                                      
+static void pop_output_configuration(AACContext *ac) {                                                                                                   
+    if (ac->oc[1].status != OC_LOCKED && ac->oc[0].status != OC_NONE) {                                                                                  
+        ac->oc[1] = ac->oc[0];                                                                                                                           
+        ac->avctx->channels = ac->oc[1].channels;                                                                                                        
+        ac->avctx->channel_layout = ac->oc[1].channel_layout;                                                                                            
+        output_configure(ac, ac->oc[1].layout_map, ac->oc[1].layout_map_tags,                                                                            
+                         ac->oc[1].status, 0);                                                                                                           
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Configure output channel order based on the current program configuration element.                                                                    
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int output_configure(AACContext *ac,                                                                                                              
+                            uint8_t layout_map[MAX_ELEM_ID*4][3], int tags,                                                                              
+                            enum OCStatus oc_type, int get_new_frame)                                                                                    
+{                                                                                                                                                        
+    AVCodecContext *avctx = ac->avctx;                                                                                                                   
+    int i, channels = 0, ret;                                                                                                                            
+    uint64_t layout = 0;                                                                                                                                 
+                                                                                                                                                         
+    if (ac->oc[1].layout_map != layout_map) {                                                                                                            
+        memcpy(ac->oc[1].layout_map, layout_map, tags * sizeof(layout_map[0]));                                                                          
+        ac->oc[1].layout_map_tags = tags;                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    // Try to sniff a reasonable channel order, otherwise output the                                                                                     
+    // channels in the order the PCE declared them.                                                                                                      
+    if (avctx->request_channel_layout != AV_CH_LAYOUT_NATIVE)                                                                                            
+        layout = sniff_channel_order(layout_map, tags);                                                                                                  
+    for (i = 0; i < tags; i++) {                                                                                                                         
+        int type =     layout_map[i][0];                                                                                                                 
+        int id =       layout_map[i][1];                                                                                                                 
+        int position = layout_map[i][2];                                                                                                                 
+        // Allocate or free elements depending on if they are in the                                                                                     
+        // current program configuration.                                                                                                                
+        ret = che_configure(ac, position, type, id, &channels);                                                                                          
+        if (ret < 0)                                                                                                                                     
+            return ret;                                                                                                                                  
+    }                                                                                                                                                    
+    if (ac->oc[1].m4ac.ps == 1 && channels == 2) {                                                                                                       
+        if (layout == AV_CH_FRONT_CENTER) {                                                                                                              
+            layout = AV_CH_FRONT_LEFT|AV_CH_FRONT_RIGHT;                                                                                                 
+        } else {                                                                                                                                         
+            layout = 0;                                                                                                                                  
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    memcpy(ac->tag_che_map, ac->che, 4 * MAX_ELEM_ID * sizeof(ac->che[0][0]));                                                                           
+    if (layout) avctx->channel_layout = layout;                                                                                                          
+    ac->oc[1].channel_layout = layout;                                                                                                                   
+    avctx->channels = ac->oc[1].channels = channels;                                                                                                     
+    ac->oc[1].status = oc_type;                                                                                                                          
+                                                                                                                                                         
+   /* if (get_new_frame) {                                                                                                                                 
+        if ((ret = frame_configure_elements(ac->avctx)) < 0)                                                                                             
+            return ret;                                                                                                                                  
+    }*/
+                                                                                                                                                         
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+static void flush(AVCodecContext *avctx)                                                                                                                 
+{                                                                                                                                                        
+    AACContext *ac= avctx->priv_data;                                                                                                                    
+    int type, i, j;                                                                                                                                      
+                                                                                                                                                         
+    for (type = 3; type >= 0; type--) {                                                                                                                  
+        for (i = 0; i < MAX_ELEM_ID; i++) {                                                                                                              
+            ChannelElement *che = ac->che[type][i];                                                                                                      
+            if (che) {                                                                                                                                   
+                for (j = 0; j <= 1; j++) {                                                                                                               
+                    memset(che->ch[j].saved, 0, sizeof(che->ch[j].saved));                                                                               
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Set up channel positions based on a default channel configuration                                                                                     
+ * as specified in table 1.17.                                                                                                                           
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int set_default_channel_config(AVCodecContext *avctx,                                                                                             
+                                              uint8_t (*layout_map)[3],                                                                                  
+                                              int *tags,                                                                                                 
+                                              int channel_config)                                                                                        
+{                                                                                                                                                        
+    if (channel_config < 1 || channel_config > 7) {                                                                                                      
+        av_log(avctx, AV_LOG_ERROR, "invalid default channel configuration (%d)\n",                                                                      
+               channel_config);                                                                                                                          
+        return -1;                                                                                                                                       
+    }                                                                                                                                                    
+    *tags = tags_per_config[channel_config];                                                                                                             
+    memcpy(layout_map, aac_channel_layout_map[channel_config-1], *tags * sizeof(*layout_map));                                                           
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+static ChannelElement *get_che(AACContext *ac, int type, int elem_id)                                                                                    
+{                                                                                                                                                        
+    // For PCE based channel configurations map the channels solely based on tags.                                                                       
+    if (!ac->oc[1].m4ac.chan_config) {                                                                                                                   
+        return ac->tag_che_map[type][elem_id];                                                                                                           
+    }                                                                                                                                                    
+    // Allow single CPE stereo files to be signalled with mono configuration.                                                                            
+    if (!ac->tags_mapped && type == TYPE_CPE && ac->oc[1].m4ac.chan_config == 1) {                                                                       
+        uint8_t layout_map[MAX_ELEM_ID*4][3];                                                                                                            
+        int layout_map_tags;                                                                                                                             
+        push_output_configuration(ac);                                                                                                                   
+                                                                                                                                                         
+        av_log(ac->avctx, AV_LOG_DEBUG, "mono with CPE\n");                                                                                              
+                                                                                                                                                         
+        if (set_default_channel_config(ac->avctx, layout_map, &layout_map_tags,                                                                          
+                                       2) < 0)                                                                                                           
+            return NULL;                                                                                                                                 
+        if (output_configure(ac, layout_map, layout_map_tags,                                                                                            
+                             OC_TRIAL_FRAME, 1) < 0)                                                                                                     
+            return NULL;                                                                                                                                 
+                                                                                                                                                         
+        ac->oc[1].m4ac.chan_config = 2;                                                                                                                  
+        ac->oc[1].m4ac.ps = 0;                                                                                                                           
+    }                                                                                                                                                    
+    // And vice-versa                                                                                                                                    
+    if (!ac->tags_mapped && type == TYPE_SCE && ac->oc[1].m4ac.chan_config == 2) {                                                                       
+        uint8_t layout_map[MAX_ELEM_ID*4][3];                                                                                                            
+        int layout_map_tags;                                                                                                                             
+        push_output_configuration(ac);                                                                                                                   
+                                                                                                                                                         
+        av_log(ac->avctx, AV_LOG_DEBUG, "stereo with SCE\n");                                                                                            
+                                                                                                                                                         
+        if (set_default_channel_config(ac->avctx, layout_map, &layout_map_tags,                                                                          
+                                       1) < 0)                                                                                                           
+            return NULL;                                                                                                                                 
+        if (output_configure(ac, layout_map, layout_map_tags,                                                                                            
+                             OC_TRIAL_FRAME, 1) < 0)                                                                                                     
+            return NULL;                                                                                                                                 
+                                                                                                                                                         
+        ac->oc[1].m4ac.chan_config = 1;                                                                                                                  
+        if (ac->oc[1].m4ac.sbr)                                                                                                                          
+            ac->oc[1].m4ac.ps = -1;                                                                                                                      
+    }                                                                                                                                                    
+    // For indexed channel configurations map the channels solely based on position.                                                                     
+    switch (ac->oc[1].m4ac.chan_config) {                                                                                                                
+    case 7:                                                                                                                                              
+        if (ac->tags_mapped == 3 && type == TYPE_CPE) {                                                                                                  
+            ac->tags_mapped++;                                                                                                                           
+            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][2];                                                                            
+        }                                                                                                                                                
+    case 6:                                                                                                                                              
+        /* Some streams incorrectly code 5.1 audio as SCE[0] CPE[0] CPE[1] SCE[1]                                                                        
+           instead of SCE[0] CPE[0] CPE[1] LFE[0]. If we seem to have                                                                                    
+           encountered such a stream, transfer the LFE[0] element to the SCE[1]'s mapping */                                                             
+        if (ac->tags_mapped == tags_per_config[ac->oc[1].m4ac.chan_config] - 1 && (type == TYPE_LFE || type == TYPE_SCE)) {                              
+            ac->tags_mapped++;                                                                                                                           
+            return ac->tag_che_map[type][elem_id] = ac->che[TYPE_LFE][0];                                                                                
+        }                                                                                                                                                
+    case 5:                                                                                                                                              
+        if (ac->tags_mapped == 2 && type == TYPE_CPE) {                                                                                                  
+            ac->tags_mapped++;                                                                                                                           
+            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][1];                                                                            
+        }                                                                                                                                                
+    case 4:                                                                                                                                              
+        if (ac->tags_mapped == 2 && ac->oc[1].m4ac.chan_config == 4 && type == TYPE_SCE) {                                                               
+            ac->tags_mapped++;                                                                                                                           
+            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][1];                                                                            
+        }                                                                                                                                                
+    case 3:                                                                                                                                              
+    case 2:                                                                                                                                              
+        if (ac->tags_mapped == (ac->oc[1].m4ac.chan_config != 2) && type == TYPE_CPE) {                                                                  
+            ac->tags_mapped++;                                                                                                                           
+            return ac->tag_che_map[TYPE_CPE][elem_id] = ac->che[TYPE_CPE][0];                                                                            
+        } else if (ac->oc[1].m4ac.chan_config == 2) {                                                                                                    
+            return NULL;                                                                                                                                 
+        }                                                                                                                                                
+    case 1:                                                                                                                                              
+        if (!ac->tags_mapped && type == TYPE_SCE) {                                                                                                      
+            ac->tags_mapped++;                                                                                                                           
+            return ac->tag_che_map[TYPE_SCE][elem_id] = ac->che[TYPE_SCE][0];                                                                            
+        }                                                                                                                                                
+    default:                                                                                                                                             
+        return NULL;                                                                                                                                     
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode an array of 4 bit element IDs, optionally interleaved with a stereo/mono switching bit.                                                        
+ *                                                                                                                                                       
+ *  <at> param type speaker type/position for these channels                                                                                             
+ */                                                                                                                                                      
+static void decode_channel_map(uint8_t layout_map[][3],                                                                                                  
+                               enum ChannelPosition type,                                                                                                
+                               GetBitContext *gb, int n)                                                                                                 
+{                                                                                                                                                        
+    while (n--) {                                                                                                                                        
+        enum RawDataBlockType syn_ele;                                                                                                                   
+        switch (type) {                                                                                                                                  
+        case AAC_CHANNEL_FRONT:                                                                                                                          
+        case AAC_CHANNEL_BACK:                                                                                                                           
+        case AAC_CHANNEL_SIDE:                                                                                                                           
+            syn_ele = get_bits1(gb);                                                                                                                     
+            break;                                                                                                                                       
+        case AAC_CHANNEL_CC:                                                                                                                             
+            skip_bits1(gb);                                                                                                                              
+            syn_ele = TYPE_CCE;                                                                                                                          
+            break;                                                                                                                                       
+        case AAC_CHANNEL_LFE:                                                                                                                            
+            syn_ele = TYPE_LFE;                                                                                                                          
+            break;                                                                                                                                       
+        default:                                                                                                                                         
+            av_assert0(0);                                                                                                                               
+        }                                                                                                                                                
+        layout_map[0][0] = syn_ele;                                                                                                                      
+        layout_map[0][1] = get_bits(gb, 4);                                                                                                              
+        layout_map[0][2] = type;                                                                                                                         
+        layout_map++;                                                                                                                                    
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode program configuration element; reference: table 4.2.                                                                                           
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,                                                                                     
+                      uint8_t (*layout_map)[3],                                                                                                          
+                      GetBitContext *gb)                                                                                                                 
+{                                                                                                                                                        
+    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;                                                                  
+    int comment_len;                                                                                                                                     
+    int tags;                                                                                                                                            
+                                                                                                                                                         
+    skip_bits(gb, 2);  // object_type                                                                                                                    
+                                                                                                                                                         
+    sampling_index = get_bits(gb, 4);                                                                                                                    
+    if (m4ac->sampling_index != sampling_index)                                                                                                          
+        av_log(avctx, AV_LOG_WARNING, "Sample rate index in program config element does not match the sample rate index configured by the container.\n");
+                                                                                                                                                         
+    num_front       = get_bits(gb, 4);                                                                                                                   
+    num_side        = get_bits(gb, 4);                                                                                                                   
+    num_back        = get_bits(gb, 4);                                                                                                                   
+    num_lfe         = get_bits(gb, 2);                                                                                                                   
+    num_assoc_data  = get_bits(gb, 3);                                                                                                                   
+    num_cc          = get_bits(gb, 4);                                                                                                                   
+                                                                                                                                                         
+    if (get_bits1(gb))                                                                                                                                   
+        skip_bits(gb, 4); // mono_mixdown_tag                                                                                                            
+    if (get_bits1(gb))                                                                                                                                   
+        skip_bits(gb, 4); // stereo_mixdown_tag                                                                                                          
+                                                                                                                                                         
+    if (get_bits1(gb))                                                                                                                                   
+        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround                                                                                     
+                                                                                                                                                         
+    if (get_bits_left(gb) < 4 * (num_front + num_side + num_back + num_lfe + num_assoc_data + num_cc)) {                                                 
+        av_log(avctx, AV_LOG_ERROR, "decode_pce: " overread_err);                                                                                        
+        return -1;                                                                                                                                       
+    }                                                                                                                                                    
+    decode_channel_map(layout_map       , AAC_CHANNEL_FRONT, gb, num_front);                                                                             
+    tags = num_front;                                                                                                                                    
+    decode_channel_map(layout_map + tags, AAC_CHANNEL_SIDE,  gb, num_side);                                                                              
+    tags += num_side;                                                                                                                                    
+    decode_channel_map(layout_map + tags, AAC_CHANNEL_BACK,  gb, num_back);                                                                              
+    tags += num_back;                                                                                                                                    
+    decode_channel_map(layout_map + tags, AAC_CHANNEL_LFE,   gb, num_lfe);                                                                               
+    tags += num_lfe;                                                                                                                                     
+                                                                                                                                                         
+    skip_bits_long(gb, 4 * num_assoc_data);                                                                                                              
+                                                                                                                                                         
+    decode_channel_map(layout_map + tags, AAC_CHANNEL_CC,    gb, num_cc);                                                                                
+    tags += num_cc;                                                                                                                                      
+                                                                                                                                                         
+    align_get_bits(gb);                                                                                                                                  
+                                                                                                                                                         
+    /* comment field, first byte is length */                                                                                                            
+    comment_len = get_bits(gb, 8) * 8;                                                                                                                   
+    if (get_bits_left(gb) < comment_len) {                                                                                                               
+        av_log(avctx, AV_LOG_ERROR, "decode_pce: " overread_err);                                                                                        
+        return -1;                                                                                                                                       
+    }                                                                                                                                                    
+    skip_bits_long(gb, comment_len);                                                                                                                     
+    return tags;                                                                                                                                         
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode GA "General Audio" specific configuration; reference: table 4.1.                                                                               
+ *                                                                                                                                                       
+ *  <at> param   ac          pointer to AACContext, may be null                                                                                          
+ *  <at> param   avctx       pointer to AVCCodecContext, used for logging                                                                                
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_ga_specific_config(AACContext *ac, AVCodecContext *avctx,                                                                              
+                                     GetBitContext *gb,                                                                                                  
+                                     MPEG4AudioConfig *m4ac,                                                                                             
+                                     int channel_config)                                                                                                 
+{                                                                                                                                                        
+    int extension_flag, ret;                                                                                                                             
+    uint8_t layout_map[MAX_ELEM_ID*4][3];                                                                                                                
+    int tags = 0;                                                                                                                                        
+                                                                                                                                                         
+    if (get_bits1(gb)) { // frameLengthFlag                                                                                                              
+        av_log_missing_feature(avctx, "960/120 MDCT window", 1);                                                                                            
+        return AVERROR_PATCHWELCOME;                                                                                                                     
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (get_bits1(gb))       // dependsOnCoreCoder                                                                                                       
+        skip_bits(gb, 14);   // coreCoderDelay                                                                                                           
+    extension_flag = get_bits1(gb);                                                                                                                      
+                                                                                                                                                         
+    if (m4ac->object_type == AOT_AAC_SCALABLE ||                                                                                                         
+        m4ac->object_type == AOT_ER_AAC_SCALABLE)                                                                                                        
+        skip_bits(gb, 3);     // layerNr                                                                                                                 
+                                                                                                                                                         
+    if (channel_config == 0) {                                                                                                                           
+        skip_bits(gb, 4);  // element_instance_tag                                                                                                       
+        tags = decode_pce(avctx, m4ac, layout_map, gb);                                                                                                  
+        if (tags < 0)                                                                                                                                    
+            return tags;                                                                                                                                 
+    } else {                                                                                                                                             
+        if ((ret = set_default_channel_config(avctx, layout_map, &tags, channel_config)))                                                                
+            return ret;                                                                                                                                  
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (count_channels(layout_map, tags) > 1) {                                                                                                          
+        m4ac->ps = 0;                                                                                                                                    
+    } else if (m4ac->sbr == 1 && m4ac->ps == -1)                                                                                                         
+        m4ac->ps = 1;                                                                                                                                    
+                                                                                                                                                         
+    if (ac && (ret = output_configure(ac, layout_map, tags, OC_GLOBAL_HDR, 0)))                                                                          
+        return ret;                                                                                                                                      
+                                                                                                                                                         
+    if (extension_flag) {                                                                                                                                
+        switch (m4ac->object_type) {                                                                                                                     
+        case AOT_ER_BSAC:                                                                                                                                
+            skip_bits(gb, 5);    // numOfSubFrame                                                                                                        
+            skip_bits(gb, 11);   // layer_length                                                                                                         
+            break;                                                                                                                                       
+        case AOT_ER_AAC_LC:                                                                                                                              
+        case AOT_ER_AAC_LTP:                                                                                                                             
+        case AOT_ER_AAC_SCALABLE:                                                                                                                        
+        case AOT_ER_AAC_LD:                                                                                                                              
+            skip_bits(gb, 3);  /* aacSectionDataResilienceFlag                                                                                           
+                                    * aacScalefactorDataResilienceFlag                                                                                   
+                                    * aacSpectralDataResilienceFlag                                                                                      
+                                    */                                                                                                                   
+            break;                                                                                                                                       
+        }                                                                                                                                                
+        skip_bits1(gb);    // extensionFlag3 (TBD in version 3)                                                                                          
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+
+/**                                                                                                                                                      
+ * Decode audio specific configuration; reference: table 1.13.                                                                                           
+ *                                                                                                                                                       
+ *  <at> param   ac          pointer to AACContext, may be null                                                                                          
+ *  <at> param   avctx       pointer to AVCCodecContext, used for logging                                                                                
+ *  <at> param   m4ac        pointer to MPEG4AudioConfig, used for parsing                                                                               
+ *  <at> param   data        pointer to buffer holding an audio specific config                                                                          
+ *  <at> param   bit_size    size of audio specific config or data in bits                                                                               
+ *  <at> param   sync_extension look for an appended sync extension                                                                                      
+ *                                                                                                                                                       
+ *  <at> return  Returns error status or number of consumed bits. <0 - error                                                                             
+ */                                                                                                                                                      
+static int decode_audio_specific_config(AACContext *ac,                                                                                                  
+                                        AVCodecContext *avctx,                                                                                           
+                                        MPEG4AudioConfig *m4ac,                                                                                          
+                                        const uint8_t *data, int bit_size,                                                                               
+                                        int sync_extension)                                                                                              
+{                                                                                                                                                        
+    GetBitContext gb;                                                                                                                                    
+    int i;                                                                                                                                               
+    int ret;                                                                                                                                             
+                                                                                                                                                         
+    av_dlog(avctx, "audio specific config size %d\n", bit_size >> 3);                                                                                    
+    for (i = 0; i < bit_size >> 3; i++)                                                                                                                  
+         av_dlog(avctx, "%02x ", data[i]);                                                                                                               
+    av_dlog(avctx, "\n");                                                                                                                                
+                                                                                                                                                         
+    init_get_bits(&gb, data, bit_size); //init_get_bits_fixed(&gb, data, data_size * 8);
+                                                                                                                                                         
+    if ((i = ff_mpeg4audio_get_config(m4ac, data, bit_size)) < 0)
+    //if ((i = avpriv_mpeg4audio_get_config1(m4ac, data, bit_size, sync_extension)) < 0) 
+        return -1;                                                                                                                                       
+    if (m4ac->sampling_index > 12) {                                                                                                                     
+        av_log(avctx, AV_LOG_ERROR, "invalid sampling rate index %d\n", m4ac->sampling_index);                                                           
+        return -1;                                                                                                                                       
+    }                                                                                                                                                    
+                                                                                                                                                         
+    skip_bits_long(&gb, i);                                                                                                                              
+                                                                                                                                                         
+    switch (m4ac->object_type) {                                                                                                                         
+    case AOT_AAC_MAIN:                                                                                                                                   
+    case AOT_AAC_LC:                                                                                                                                     
+    case AOT_AAC_LTP:                                                                                                                                    
+        if (decode_ga_specific_config(ac, avctx, &gb, m4ac, m4ac->chan_config))                                                                          
+            return -1;                                                                                                                                   
+        break;                                                                                                                                           
+    default:                                                                                                                                             
+        av_log(avctx, AV_LOG_ERROR, "Audio object type %s%d is not supported.\n",                                                                        
+               m4ac->sbr == 1? "SBR+" : "", m4ac->object_type);                                                                                          
+        return -1;                                                                                                                                       
+    }                                                                                                                                                    
+                                                                                                                                                         
+    av_dlog(avctx, "AOT %d chan config %d sampling index %d (%d) SBR %d PS %d\n",                                                                        
+            m4ac->object_type, m4ac->chan_config, m4ac->sampling_index,                                                                                  
+            m4ac->sample_rate, m4ac->sbr, m4ac->ps);                                                                                                     
+                                                                                                                                                         
+    return get_bits_count(&gb);                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * linear congruential pseudorandom number generator                                                                                                     
+ *                                                                                                                                                       
+ *  <at> param   previous_val    pointer to the current state of the generator                                                                           
+ *                                                                                                                                                       
+ *  <at> return  Returns a 32-bit pseudorandom integer                                                                                                   
+ */                                                                                                                                                      
+static av_always_inline int lcg_random(unsigned previous_val)                                                                                            
+{                                                                                                                                                        
+    union { unsigned u; int s; } v = { previous_val * 1664525u + 1013904223 };                                                                           
+    return v.s;                                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+                                                                                                                                                         
+static void reset_all_predictors(PredictorState *ps)                                                                                                     
+{                                                                                                                                                        
+    int i;                                                                                                                                               
+    for (i = 0; i < MAX_PREDICTORS; i++)                                                                                                                 
+        reset_predict_state(&ps[i]);                                                                                                                     
+}                                                                                                                                                        
+                                                                                                                                                         
+static int sample_rate_idx (int rate)                                                                                                                    
+{                                                                                                                                                        
+         if (92017 <= rate) return 0;                                                                                                                    
+    else if (75132 <= rate) return 1;                                                                                                                    
+    else if (55426 <= rate) return 2;                                                                                                                    
+    else if (46009 <= rate) return 3;                                                                                                                    
+    else if (37566 <= rate) return 4;                                                                                                                    
+    else if (27713 <= rate) return 5;                                                                                                                    
+    else if (23004 <= rate) return 6;                                                                                                                    
+    else if (18783 <= rate) return 7;                                                                                                                    
+    else if (13856 <= rate) return 8;                                                                                                                    
+    else if (11502 <= rate) return 9;                                                                                                                    
+    else if (9391  <= rate) return 10;                                                                                                                   
+    else                    return 11;                                                                                                                   
+}                                                                                                                                                        
+                                                                                                                                                         
+static void reset_predictor_group(PredictorState *ps, int group_num)                                                                                     
+{                                                                                                                                                        
+    int i;                                                                                                                                               
+    for (i = group_num - 1; i < MAX_PREDICTORS; i += 30)                                                                                                 
+        reset_predict_state(&ps[i]);                                                                                                                     
+}                                                                                                                                                        
+                                                                                                                                                         
+#define AAC_INIT_VLC_STATIC(num, size) \                                                                                                                 
+    INIT_VLC_STATIC(&vlc_spectral[num], 8, ff_aac_spectral_sizes[num], \                                                                                 
+         ff_aac_spectral_bits[num], sizeof( ff_aac_spectral_bits[num][0]), sizeof( ff_aac_spectral_bits[num][0]), \                                      
+        ff_aac_spectral_codes[num], sizeof(ff_aac_spectral_codes[num][0]), sizeof(ff_aac_spectral_codes[num][0]), \                                      
+        size);                                                                                                                                           
+                                                                                                                                                         
+static void aacdec_init(AACContext *ac);                                                                                                                 
+                                                                                                                                                         
+static av_cold int aac_decode_init(AVCodecContext *avctx)                                                                                                
+{                                                                                                                                                        
+    AACContext *ac = avctx->priv_data;                                                                                                                   
+                                                                                                                                                         
+    ac->avctx = avctx;                                                                                                                                   
+    ac->oc[1].m4ac.sample_rate = avctx->sample_rate;                                                                                                     
+                                                                                                                                                         
+    aacdec_init(ac);                                                                                                                                     
+#if CONFIG_AAC_FIXED                                                                                                                                     
+    avctx->sample_fmt = AV_SAMPLE_FMT_S32;                                                                                                              
+#else                                                                                                                                                    
+    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;                                                                                                              
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                                                                                                                                                         
+    if (avctx->extradata_size > 0) {                                                                                                                     
+        if (decode_audio_specific_config(ac, ac->avctx, &ac->oc[1].m4ac,                                                                                 
+                                         avctx->extradata,                                                                                               
+                                         avctx->extradata_size*8, 1) < 0)                                                                                
+            return -1;                                                                                                                                   
+    } else {                                                                                                                                             
+        int sr, i;                                                                                                                                       
+        uint8_t layout_map[MAX_ELEM_ID*4][3];                                                                                                            
+        int layout_map_tags;                                                                                                                             
+                                                                                                                                                         
+        sr = sample_rate_idx(avctx->sample_rate);                                                                                                        
+        ac->oc[1].m4ac.sampling_index = sr;                                                                                                              
+        ac->oc[1].m4ac.channels = avctx->channels;                                                                                                       
+        ac->oc[1].m4ac.sbr = -1;                                                                                                                         
+        ac->oc[1].m4ac.ps = -1;                                                                                                                          
+                                                                                                                                                         
+        for (i = 0; i < FF_ARRAY_ELEMS(ff_mpeg4audio_channels); i++)                                                                                     
+            if (ff_mpeg4audio_channels[i] == avctx->channels)                                                                                            
+                break;                                                                                                                                   
+        if (i == FF_ARRAY_ELEMS(ff_mpeg4audio_channels)) {                                                                                               
+            i = 0;                                                                                                                                       
+        }                                                                                                                                                
+        ac->oc[1].m4ac.chan_config = i;                                                                                                                  
+                                                                                                                                                         
+        if (ac->oc[1].m4ac.chan_config) {                                                                                                                
+            int ret = set_default_channel_config(avctx, layout_map,                                                                                      
+                &layout_map_tags, ac->oc[1].m4ac.chan_config);                                                                                           
+            if (!ret)                                                                                                                                    
+                output_configure(ac, layout_map, layout_map_tags,                                                                                        
+                                 OC_GLOBAL_HDR, 0);                                                                                                      
+            /*else if (avctx->err_recognition & AV_EF_EXPLODE)                                                                                             
+                return AVERROR_INVALIDDATA;*/
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (avctx->channels > MAX_CHANNELS) {                                                                                                                
+        av_log(avctx, AV_LOG_ERROR, "Too many channels\n");                                                                                              
+        return AVERROR_INVALIDDATA;                                                                                                                      
+    }                                                                                                                                                    
+                                                                                                                                                         
+    AAC_INIT_VLC_STATIC( 0, 304);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 1, 270);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 2, 550);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 3, 300);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 4, 328);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 5, 294);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 6, 306);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 7, 268);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 8, 510);                                                                                                                        
+    AAC_INIT_VLC_STATIC( 9, 366);                                                                                                                        
+    AAC_INIT_VLC_STATIC(10, 462);                                                                                                                        
+                                                                                                                                                         
+    AAC_RENAME(ff_aac_sbr_init)();                                                                                                                       
+                                                                                                                                                         
+    dsputil_init(&ac->dsp, avctx); // TODO: remove this                                                                                               
+    ff_fmt_convert_init(&ac->fmt_conv, avctx);                                                                                                           
+
+#if CONFIG_AAC_FIXED
+//av_log(NULL, AV_LOG_INFO, "Too mssssssssssssssssssssssssssssssssssss\n");
+    avpriv_fixed_dsp_init(&ac->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);                                                                                
+#else                                                                                                                                                    
+    avpriv_float_dsp_init(&ac->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);                                                                                
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                                                                                                                                                         
+    ac->random_state = 0x1f2e3d4c;                                                                                                                       
+                                                                                                                                                         
+    ff_aac_tableinit();                                                                                                                                  
+                                                                                                                                                         
+    INIT_VLC_STATIC(&vlc_scalefactors,7,FF_ARRAY_ELEMS(ff_aac_scalefactor_code),                                                                         
+                    ff_aac_scalefactor_bits, sizeof(ff_aac_scalefactor_bits[0]), sizeof(ff_aac_scalefactor_bits[0]),                                     
+                    ff_aac_scalefactor_code, sizeof(ff_aac_scalefactor_code[0]), sizeof(ff_aac_scalefactor_code[0]),                                     
+                    352);                                                                                                                                
+                                                                                                                                                         
+    AAC_RENAME_32(ff_mdct_init)(&ac->mdct,       11, 1, 1.0 / RANGE15(1024.0));                                                                          
+    AAC_RENAME_32(ff_mdct_init)(&ac->mdct_small,  8, 1, 1.0 / RANGE15(128.0));                                                                           
+    AAC_RENAME_32(ff_mdct_init)(&ac->mdct_ltp,   11, 0, RANGE15(-2.0));                                                                                  
+    // window initialization                                                                                                                             
+    AAC_RENAME(ff_kbd_window_init)(AAC_RENAME(ff_aac_kbd_long_1024), 4.0, 1024);                                                                         
+    AAC_RENAME(ff_kbd_window_init)(AAC_RENAME(ff_aac_kbd_short_128), 6.0, 128);                                                                          
+    AAC_RENAME(ff_init_ff_sine_windows)(10);                                                                                                             
+    AAC_RENAME(ff_init_ff_sine_windows)( 7);                                                                                                             
+                                                                                                                                                         
+    AAC_RENAME(cbrt_tableinit)();                                                                                                                        
+                                                                                                                                                         
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Skip data_stream_element; reference: table 4.10.                                                                                                      
+ */                                                                                                                                                      
+static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)                                                                                   
+{                                                                                                                                                        
+    int byte_align = get_bits1(gb);                                                                                                                      
+    int count = get_bits(gb, 8);                                                                                                                         
+    if (count == 255)                                                                                                                                    
+        count += get_bits(gb, 8);                                                                                                                        
+    if (byte_align)                                                                                                                                      
+        align_get_bits(gb);                                                                                                                              
+                                                                                                                                                         
+    if (get_bits_left(gb) < 8 * count) {                                                                                                                 
+        av_log(ac->avctx, AV_LOG_ERROR, "skip_data_stream_element: "overread_err);                                                                       
+        return -1;                                                                                                                                       
+    }                                                                                                                                                    
+    skip_bits_long(gb, 8 * count);                                                                                                                       
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+static int decode_prediction(AACContext *ac, IndividualChannelStream *ics,                                                                               
+                             GetBitContext *gb)                                                                                                          
+{                                                                                                                                                        
+    int sfb;                                                                                                                                             
+    if (get_bits1(gb)) {                                                                                                                                 
+        ics->predictor_reset_group = get_bits(gb, 5);                                                                                                    
+        if (ics->predictor_reset_group == 0 || ics->predictor_reset_group > 30) {                                                                        
+            av_log(ac->avctx, AV_LOG_ERROR, "Invalid Predictor Reset Group.\n");                                                                         
+            return -1;                                                                                                                                   
+        }                                                                                                                                                
+    }                                                                                                                                                    
+    for (sfb = 0; sfb < FFMIN(ics->max_sfb, ff_aac_pred_sfb_max[ac->oc[1].m4ac.sampling_index]); sfb++) {                                                
+        ics->prediction_used[sfb] = get_bits1(gb);                                                                                                       
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode Long Term Prediction data; reference: table 4.xx.                                                                                              
+ */                                                                                                                                                      
+static void decode_ltp(LongTermPrediction *ltp,                                                                                                          
+                       GetBitContext *gb, uint8_t max_sfb)                                                                                               
+{                                                                                                                                                        
+    int sfb;                                                                                                                                             
+                                                                                                                                                         
+    ltp->lag  = get_bits(gb, 11);                                                                                                                        
+    ltp->coef = ltp_coef[get_bits(gb, 3)];                                                                                                               
+    for (sfb = 0; sfb < FFMIN(max_sfb, MAX_LTP_LONG_SFB); sfb++)                                                                                         
+        ltp->used[sfb] = get_bits1(gb);                                                                                                                  
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode Individual Channel Stream info; reference: table 4.6.                                                                                          
+ */                                                                                                                                                      
+static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,                                                                                 
+                           GetBitContext *gb)                                                                                                            
+{                                                                                                                                                        
+    if (get_bits1(gb)) {                                                                                                                                 
+        av_log(ac->avctx, AV_LOG_ERROR, "Reserved bit set.\n");                                                                                          
+        return AVERROR_INVALIDDATA;                                                                                                                      
+    }                                                                                                                                                    
+    ics->window_sequence[1] = ics->window_sequence[0];                                                                                                   
+    ics->window_sequence[0] = get_bits(gb, 2);                                                                                                           
+    ics->use_kb_window[1]   = ics->use_kb_window[0];                                                                                                     
+    ics->use_kb_window[0]   = get_bits1(gb);                                                                                                             
+    ics->num_window_groups  = 1;                                                                                                                         
+    ics->group_len[0]       = 1;                                                                                                                         
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                                                                                               
+        int i;                                                                                                                                           
+        ics->max_sfb = get_bits(gb, 4);                                                                                                                  
+        for (i = 0; i < 7; i++) {                                                                                                                        
+            if (get_bits1(gb)) {                                                                                                                         
+                ics->group_len[ics->num_window_groups - 1]++;                                                                                            
+            } else {                                                                                                                                     
+                ics->num_window_groups++;                                                                                                                
+                ics->group_len[ics->num_window_groups - 1] = 1;                                                                                          
+            }                                                                                                                                            
+        }                                                                                                                                                
+        ics->num_windows       = 8;                                                                                                                      
+        ics->swb_offset        =    ff_swb_offset_128[ac->oc[1].m4ac.sampling_index];                                                                    
+        ics->num_swb           =   ff_aac_num_swb_128[ac->oc[1].m4ac.sampling_index];                                                                    
+        ics->tns_max_bands     = ff_tns_max_bands_128[ac->oc[1].m4ac.sampling_index];                                                                    
+        ics->predictor_present = 0;                                                                                                                      
+    } else {                                                                                                                                             
+        ics->max_sfb               = get_bits(gb, 6);                                                                                                    
+        ics->num_windows           = 1;                                                                                                                  
+        ics->swb_offset            =    ff_swb_offset_1024[ac->oc[1].m4ac.sampling_index];                                                               
+        ics->num_swb               =   ff_aac_num_swb_1024[ac->oc[1].m4ac.sampling_index];                                                               
+        ics->tns_max_bands         = ff_tns_max_bands_1024[ac->oc[1].m4ac.sampling_index];                                                               
+        ics->predictor_present     = get_bits1(gb);                                                                                                      
+        ics->predictor_reset_group = 0;                                                                                                                  
+        if (ics->predictor_present) {                                                                                                                    
+            if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN) {                                                                                            
+                if (decode_prediction(ac, ics, gb)) {                                                                                                    
+                    goto fail;                                                                                                                           
+                }                                                                                                                                        
+            } else if (ac->oc[1].m4ac.object_type == AOT_AAC_LC) {                                                                                       
+                av_log(ac->avctx, AV_LOG_ERROR, "Prediction is not allowed in AAC-LC.\n");                                                               
+                goto fail;                                                                                                                               
+            } else {                                                                                                                                     
+                if ((ics->ltp.present = get_bits(gb, 1)))                                                                                                
+                    decode_ltp(&ics->ltp, gb, ics->max_sfb);                                                                                             
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (ics->max_sfb > ics->num_swb) {                                                                                                                   
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                  
+               "Number of scalefactor bands in group (%d) exceeds limit (%d).\n",                                                                        
+               ics->max_sfb, ics->num_swb);                                                                                                              
+        goto fail;                                                                                                                                       
+    }                                                                                                                                                    
+                                                                                                                                                         
+    return 0;                                                                                                                                            
+fail:                                                                                                                                                    
+    ics->max_sfb = 0;                                                                                                                                    
+    return AVERROR_INVALIDDATA;                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode band types (section_data payload); reference: table 4.46.                                                                                      
+ *                                                                                                                                                       
+ *  <at> param   band_type           array of the used band type                                                                                         
+ *  <at> param   band_type_run_end   array of the last scalefactor band of a band type run                                                               
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_band_types(AACContext *ac, enum BandType band_type[120],                                                                               
+                             int band_type_run_end[120], GetBitContext *gb,                                                                              
+                             IndividualChannelStream *ics)                                                                                               
+{                                                                                                                                                        
+    int g, idx = 0;                                                                                                                                      
+    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;                                                                          
+    for (g = 0; g < ics->num_window_groups; g++) {                                                                                                       
+        int k = 0;                                                                                                                                       
+        while (k < ics->max_sfb) {                                                                                                                       
+            uint8_t sect_end = k;                                                                                                                        
+            int sect_len_incr;                                                                                                                           
+            int sect_band_type = get_bits(gb, 4);                                                                                                        
+            if (sect_band_type == 12) {                                                                                                                  
+                av_log(ac->avctx, AV_LOG_ERROR, "invalid band type\n");                                                                                  
+                return -1;                                                                                                                               
+            }                                                                                                                                            
+            do {                                                                                                                                         
+                sect_len_incr = get_bits(gb, bits);                                                                                                      
+                sect_end += sect_len_incr;                                                                                                               
+                if (get_bits_left(gb) < 0) {                                                                                                             
+                    av_log(ac->avctx, AV_LOG_ERROR, "decode_band_types: "overread_err);                                                                  
+                    return -1;                                                                                                                           
+                }                                                                                                                                        
+                if (sect_end > ics->max_sfb) {                                                                                                           
+                    av_log(ac->avctx, AV_LOG_ERROR,                                                                                                      
+                           "Number of bands (%d) exceeds limit (%d).\n",                                                                                 
+                           sect_end, ics->max_sfb);                                                                                                      
+                    return -1;                                                                                                                           
+                }                                                                                                                                        
+            } while (sect_len_incr == (1 << bits) - 1);                                                                                                  
+            for (; k < sect_end; k++) {                                                                                                                  
+                band_type        [idx]   = sect_band_type;                                                                                               
+                band_type_run_end[idx++] = sect_end;                                                                                                     
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode scalefactors; reference: table 4.47.                                                                                                           
+ *                                                                                                                                                       
+ *  <at> param   global_gain         first scalefactor value as scalefactors are differentially coded                                                    
+ *  <at> param   band_type           array of the used band type                                                                                         
+ *  <at> param   band_type_run_end   array of the last scalefactor band of a band type run                                                               
+ *  <at> param   sf                  array of scalefactors or intensity stereo positions                                                                 
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_scalefactors(AACContext *ac, INTFLOAT sf[120], GetBitContext *gb,                                                                      
+                               unsigned int global_gain,                                                                                                 
+                               IndividualChannelStream *ics,                                                                                             
+                               enum BandType band_type[120],                                                                                             
+                               int band_type_run_end[120])                                                                                               
+{                                                                                                                                                        
+    int g, i, idx = 0;                                                                                                                                   
+    int offset[3] = { global_gain, global_gain - 90, 0 };                                                                                                
+    int clipped_offset;                                                                                                                                  
+    int noise_flag = 1;                                                                                                                                  
+    for (g = 0; g < ics->num_window_groups; g++) {                                                                                                       
+        for (i = 0; i < ics->max_sfb;) {                                                                                                                 
+            int run_end = band_type_run_end[idx];                                                                                                        
+            if (band_type[idx] == ZERO_BT) {                                                                                                             
+                for (; i < run_end; i++, idx++)                                                                                                          
+                    sf[idx] = FIXR(0.);                                                                                                                  
+            } else if ((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) {                                                          
+                for (; i < run_end; i++, idx++) {                                                                                                        
+                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;                                                                        
+                    clipped_offset = av_clip(offset[2], -155, 100);                                                                                      
+                    if (offset[2] != clipped_offset) {                                                                                                   
+                        av_log_ask_for_sample(ac->avctx, "Intensity stereo "
+                                "position clipped (%d -> %d).\nIf you heard an "
+                                "audible artifact, there may be a bug in the "
+                                "decoder. ", offset[2], clipped_offset);                                                                             
+                    }                                                                                                                                    
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                    sf[idx] = 100 - clipped_offset;                                                                                                      
+#else                                                                                                                                                    
+                    sf[idx] = ff_aac_pow2sf_tab[-clipped_offset + POW_SF2_ZERO];                                                                         
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                }                                                                                                                                        
+            } else if (band_type[idx] == NOISE_BT) {                                                                                                     
+                for (; i < run_end; i++, idx++) {                                                                                                        
+                    if (noise_flag-- > 0)                                                                                                                
+                        offset[1] += get_bits(gb, 9) - 256;                                                                                              
+                    else                                                                                                                                 
+                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;                                                                    
+                    clipped_offset = av_clip(offset[1], -100, 155);                                                                                      
+                    if (offset[1] != clipped_offset) {                                                                                                   
+                         av_log_ask_for_sample(ac->avctx, "Noise gain clipped "
+                                "(%d -> %d).\nIf you heard an audible "
+                                "artifact, there may be a bug in the decoder. ",
+                                offset[1], clipped_offset);                                                                              
+                    }                                                                                                                                    
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                    sf[idx] = -(100 + clipped_offset);                                                                                                   
+#else                                                                                                                                                    
+                    sf[idx] = -ff_aac_pow2sf_tab[clipped_offset + POW_SF2_ZERO];                                                                         
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                }                                                                                                                                        
+            } else {                                                                                                                                     
+                for (; i < run_end; i++, idx++) {                                                                                                        
+                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;                                                                        
+                    if (offset[0] > 255U) {                                                                                                              
+                        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                  
+                               "Scalefactor (%d) out of range.\n", offset[0]);                                                                           
+                        return -1;                                                                                                                       
+                    }                                                                                                                                    
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                    sf[idx] = -offset[0];                                                                                                                
+#else                                                                                                                                                    
+                    sf[idx] = -ff_aac_pow2sf_tab[offset[0] - 100 + POW_SF2_ZERO];                                                                        
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode pulse data; reference: table 4.7.                                                                                                              
+ */                                                                                                                                                      
+static int decode_pulses(Pulse *pulse, GetBitContext *gb,                                                                                                
+                         const uint16_t *swb_offset, int num_swb)                                                                                        
+{                                                                                                                                                        
+    int i, pulse_swb;                                                                                                                                    
+    pulse->num_pulse = get_bits(gb, 2) + 1;                                                                                                              
+    pulse_swb        = get_bits(gb, 6);                                                                                                                  
+    if (pulse_swb >= num_swb)                                                                                                                            
+        return -1;                                                                                                                                       
+    pulse->pos[0]    = swb_offset[pulse_swb];                                                                                                            
+    pulse->pos[0]   += get_bits(gb, 5);                                                                                                                  
+    if (pulse->pos[0] > 1023)                                                                                                                            
+        return -1;                                                                                                                                       
+    pulse->amp[0]    = get_bits(gb, 4);                                                                                                                  
+    for (i = 1; i < pulse->num_pulse; i++) {                                                                                                             
+        pulse->pos[i] = get_bits(gb, 5) + pulse->pos[i - 1];                                                                                             
+        if (pulse->pos[i] > 1023)                                                                                                                        
+            return -1;                                                                                                                                   
+        pulse->amp[i] = get_bits(gb, 4);                                                                                                                 
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode Temporal Noise Shaping data; reference: table 4.48.                                                                                            
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_tns(AACContext *ac, TemporalNoiseShaping *tns,                                                                                         
+                      GetBitContext *gb, const IndividualChannelStream *ics)                                                                             
+{                                                                                                                                                        
+    int w, filt, i, coef_len, coef_res, coef_compress;                                                                                                   
+    const int is8 = ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE;                                                                                     
+    const int tns_max_order = is8 ? 7 : ac->oc[1].m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;                                                            
+    for (w = 0; w < ics->num_windows; w++) {                                                                                                             
+        if ((tns->n_filt[w] = get_bits(gb, 2 - is8))) {                                                                                                  
+            coef_res = get_bits1(gb);                                                                                                                    
+                                                                                                                                                         
+            for (filt = 0; filt < tns->n_filt[w]; filt++) {                                                                                              
+                int tmp2_idx;                                                                                                                            
+                tns->length[w][filt] = get_bits(gb, 6 - 2 * is8);                                                                                        
+                                                                                                                                                         
+                if ((tns->order[w][filt] = get_bits(gb, 5 - 2 * is8)) > tns_max_order) {                                                                 
+                    av_log(ac->avctx, AV_LOG_ERROR, "TNS filter order %d is greater than maximum %d.\n",                                                 
+                           tns->order[w][filt], tns_max_order);                                                                                          
+                    tns->order[w][filt] = 0;                                                                                                             
+                    return -1;                                                                                                                           
+                }                                                                                                                                        
+                if (tns->order[w][filt]) {                                                                                                               
+                    tns->direction[w][filt] = get_bits1(gb);                                                                                             
+                    coef_compress = get_bits1(gb);                                                                                                       
+                    coef_len = coef_res + 3 - coef_compress;                                                                                             
+                    tmp2_idx = 2 * coef_compress + coef_res;                                                                                             
+                                                                                                                                                         
+                    for (i = 0; i < tns->order[w][filt]; i++)                                                                                            
+                        tns->coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];                                                          
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode Mid/Side data; reference: table 4.54.                                                                                                          
+ *                                                                                                                                                       
+ *  <at> param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;                                                                     
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;                                                                          
+ *                      [3] reserved for scalable AAC                                                                                                    
+ */                                                                                                                                                      
+static void decode_mid_side_stereo(ChannelElement *cpe, GetBitContext *gb,                                                                               
+                                   int ms_present)                                                                                                       
+{                                                                                                                                                        
+    int idx;                                                                                                                                             
+    if (ms_present == 1) {                                                                                                                               
+        for (idx = 0; idx < cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb; idx++)                                                            
+            cpe->ms_mask[idx] = get_bits1(gb);                                                                                                           
+    } else if (ms_present == 2) {                                                                                                                        
+        memset(cpe->ms_mask, 1,  sizeof(cpe->ms_mask[0]) * cpe->ch[0].ics.num_window_groups * cpe->ch[0].ics.max_sfb);                                   
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode spectral data; reference: table 4.50.                                                                                                          
+ * Dequantize and scale spectral data; reference: 4.6.3.3.                                                                                               
+ *                                                                                                                                                       
+ *  <at> param   coef            array of dequantized, scaled spectral data                                                                              
+ *  <at> param   sf              array of scalefactors or intensity stereo positions                                                                     
+ *  <at> param   pulse_present   set if pulses are present                                                                                               
+ *  <at> param   pulse           pointer to pulse data struct                                                                                            
+ *  <at> param   band_type       array of the used band type                                                                                             
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_spectrum_and_dequant(AACContext *ac, INTFLOAT coef[1024],                                                                              
+                                       GetBitContext *gb, const INTFLOAT sf[120],                                                                        
+                                       int pulse_present, const Pulse *pulse,                                                                            
+                                       const IndividualChannelStream *ics,                                                                               
+                                       enum BandType band_type[120])                                                                                     
+{                                                                                                                                                        
+    int i, k, g, idx = 0;                                                                                                                                
+    const int c = 1024 / ics->num_windows;                                                                                                               
+    const uint16_t *offsets = ics->swb_offset;                                                                                                           
+    INTFLOAT *coef_base = coef;                                                                                                                          
+                                                                                                                                                         
+    for (g = 0; g < ics->num_windows; g++)                                                                                                               
+        memset(coef + g * 128 + offsets[ics->max_sfb], 0, sizeof(INTFLOAT) * (c - offsets[ics->max_sfb]));                                               
+                                                                                                                                                         
+    for (g = 0; g < ics->num_window_groups; g++) {                                                                                                       
+        unsigned g_len = ics->group_len[g];                                                                                                              
+                                                                                                                                                         
+        for (i = 0; i < ics->max_sfb; i++, idx++) {                                                                                                      
+            const unsigned cbt_m1 = band_type[idx] - 1;                                                                                                  
+            INTFLOAT *cfo = coef + offsets[i];                                                                                                           
+            int off_len = offsets[i + 1] - offsets[i];                                                                                                   
+            int group;                                                                                                                                   
+                                                                                                                                                         
+            if (cbt_m1 >= INTENSITY_BT2 - 1) {                                                                                                           
+                for (group = 0; group < (AAC_SIGNE)g_len; group++, cfo+=128) {                                                                           
+                    memset(cfo, 0, off_len * sizeof(INTFLOAT));                                                                                          
+                }                                                                                                                                        
+            } else if (cbt_m1 == NOISE_BT - 1) {                                                                                                         
+                for (group = 0; group < (AAC_SIGNE)g_len; group++, cfo+=128) {                                                                           
+#if !CONFIG_AAC_FIXED                                                                                                                                    
+                    float scale;                                                                                                                         
+#endif /* !CONFIG_AAC_FIXED */                                                                                                                           
+                    INTFLOAT band_energy;                                                                                                                
+                                                                                                                                                         
+                    for (k = 0; k < off_len; k++) {                                                                                                      
+                        ac->random_state  = lcg_random(ac->random_state);                                                                                
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                        cfo[k] = ac->random_state >> 3;                                                                                                  
+                                                                                                                                                         
+#else                                                                                                                                                    
+                        cfo[k] = ac->random_state;                                                                                                       
+                                                                                                                           
+                    }         
+                  band_energy = ac->dsp.scalarproduct_float(cfo, cfo, off_len);  
+#endif /* CONFIG_AAC_FIXED */    
+#if CONFIG_AAC_FIXED 
+                    }                                                                                                                                 
+                    band_energy = ac->fdsp.AAC_RENAME2(scalarproduct)(cfo, cfo, off_len);                                                                
+                                                                                                                                    
+                    band_energy = fixed_sqrt(band_energy, 31);                                                                                           
+                    noise_scale(cfo, sf[idx], band_energy, off_len);                                                                                     
+#else                                                                                                                                                    
+                    scale = sf[idx] / sqrtf(band_energy);                                                                                                
+                    ac->fdsp.vector_fmul_scalar(cfo, cfo, scale, off_len);                                                                               
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                }                                                                                                                                        
+            } else {                                                                                                                                     
+#if !CONFIG_AAC_FIXED                                                                                                                                    
+                const float *vq = ff_aac_codebook_vector_vals[cbt_m1];                                                                                   
+#endif /* !CONFIG_AAC_FIXED */                                                                                                                           
+                const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];                                                                      
+                VLC_TYPE (*vlc_tab)[2] = vlc_spectral[cbt_m1].table;                                                                                     
+                OPEN_READER(re, gb);                                                                                                                     
+                                                                                                                                                         
+                switch (cbt_m1 >> 1) {                                                                                                                   
+                case 0:                                                                                                                                  
+                    for (group = 0; group < (AAC_SIGNE)g_len; group++, cfo+=128) {                                                                       
+                        INTFLOAT *cf = cfo;                                                                                                              
+                        int len = off_len;                                                                                                               
+                                                                                                                                                         
+                        do {                                                                                                                             
+                            int code;                                                                                                                    
+                            unsigned cb_idx;                                                                                                             
+                                                                                                                                                         
+                            UPDATE_CACHE(re, gb);                                                                                                        
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);                                                                                        
+                            cb_idx = cb_vector_idx[code];                                                                                                
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                            cf = DEC_SQUAD(cf, cb_idx);                                                                                                  
+#else                                                                                                                                                    
+                            cf = VMUL4(cf, vq, cb_idx, sf + idx);                                                                                        
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                        } while (len -= 4);                                                                                                              
+                    }                                                                                                                                    
+                    break;                                                                                                                               
+                                                                                                                                                         
+                case 1:                                                                                                                                  
+                    for (group = 0; group < (AAC_SIGNE)g_len; group++, cfo+=128) {                                                                       
+                        INTFLOAT *cf = cfo;                                                                                                              
+                        int len = off_len;                                                                                                               
+                                                                                                                                                         
+                        do {                                                                                                                             
+                            int code;                                                                                                                    
+                            unsigned nnz;                                                                                                                
+                            unsigned cb_idx;                                                                                                             
+                            uint32_t bits;                                                                                                               
+                                                                                                                                                         
+                            UPDATE_CACHE(re, gb);                                                                                                        
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);                                                                                        
+                            cb_idx = cb_vector_idx[code];                                                                                                
+                            nnz = cb_idx >> 8 & 15;                                                                                                      
+                            bits = nnz ? GET_CACHE(re, gb) : 0;                                                                                          
+                            LAST_SKIP_BITS(re, gb, nnz);                                                                                                 
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                            cf = DEC_UQUAD(cf, cb_idx, bits);                                                                                            
+#else                                                                                                                                                    
+                            cf = VMUL4S(cf, vq, cb_idx, bits, sf + idx);                                                                                 
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                        } while (len -= 4);                                                                                                              
+                    }                                                                                                                                    
+                    break;                                                                                                                               
+                                                                                                                                                         
+                case 2:                                                                                                                                  
+                    for (group = 0; group < (AAC_SIGNE)g_len; group++, cfo+=128) {                                                                       
+                        INTFLOAT *cf = cfo;                                                                                                              
+                        int len = off_len;                                                                                                               
+                                                                                                                                                         
+                        do {                                                                                                                             
+                            int code;                                                                                                                    
+                            unsigned cb_idx;                                                                                                             
+                                                                                                                                                         
+                            UPDATE_CACHE(re, gb);                                                                                                        
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);                                                                                        
+                            cb_idx = cb_vector_idx[code];                                                                                                
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                            cf = DEC_SPAIR(cf, cb_idx);                                                                                                  
+#else                                                                                                                                                    
+                            cf = VMUL2(cf, vq, cb_idx, sf + idx);                                                                                        
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                        } while (len -= 2);                                                                                                              
+                    }                                                                                                                                    
+                    break;                                                                                                                               
+                                                                                                                                                         
+                case 3:                                                                                                                                  
+                case 4:                                                                                                                                  
+                    for (group = 0; group < (AAC_SIGNE)g_len; group++, cfo+=128) {                                                                       
+                        INTFLOAT *cf = cfo;                                                                                                              
+                        int len = off_len;                                                                                                               
+                                                                                                                                                         
+                        do {                                                                                                                             
+                            int code;                                                                                                                    
+                            unsigned nnz;                                                                                                                
+                            unsigned cb_idx;                                                                                                             
+                            unsigned sign;                                                                                                               
+                                                                                                                                                         
+                            UPDATE_CACHE(re, gb);                                                                                                        
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);                                                                                        
+                            cb_idx = cb_vector_idx[code];                                                                                                
+                            nnz = cb_idx >> 8 & 15;                                                                                                      
+                            sign = nnz ? SHOW_UBITS(re, gb, nnz) << (cb_idx >> 12) : 0;                                                                  
+                            LAST_SKIP_BITS(re, gb, nnz);                                                                                                 
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                            cf = DEC_UPAIR(cf, cb_idx, sign);                                                                                            
+#else                                                                                                                                                    
+                            cf = VMUL2S(cf, vq, cb_idx, sign, sf + idx);                                                                                 
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                        } while (len -= 2);                                                                                                              
+                    }                                                                                                                                    
+                    break;                                                                                                                               
+                                                                                                                                                         
+                default:                                                                                                                                 
+                    for (group = 0; group < (AAC_SIGNE)g_len; group++, cfo+=128) {                                                                       
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                        int *icf = cfo;                                                                                                                  
+                        int v;                                                                                                                           
+#else                                                                                                                                                    
+                        float *cf = cfo;                                                                                                                 
+                        uint32_t *icf = (uint32_t *) cf;                                                                                                 
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                        int len = off_len;                                                                                                               
+                                                                                                                                                         
+                        do {                                                                                                                             
+                            int code;                                                                                                                    
+                            unsigned nzt, nnz;                                                                                                           
+                            unsigned cb_idx;                                                                                                             
+                            uint32_t bits;                                                                                                               
+                            int j;                                                                                                                       
+                            UPDATE_CACHE(re, gb);                                                                                                        
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);                                                                                        
+                                                                                                                                                         
+                            if (!code) {                                                                                                                 
+                                *icf++ = 0;                                                                                                              
+                                *icf++ = 0;                                                                                                              
+                                continue;                                                                                                                
+                            }                                                                                                                            
+                                                                                                                                                         
+                            cb_idx = cb_vector_idx[code];                                                                                                
+                            nnz = cb_idx >> 12;                                                                                                          
+                            nzt = cb_idx >> 8;                                                                                                           
+                            bits = SHOW_UBITS(re, gb, nnz) << (32-nnz);                                                                                  
+                            LAST_SKIP_BITS(re, gb, nnz);                                                                                                 
+                                                                                                                                                         
+                            for (j = 0; j < 2; j++) {                                                                                                    
+                                if (nzt & 1<<j) {                                                                                                        
+                                    uint32_t b;                                                                                                          
+                                    int n;                                                                                                               
+                                    /* The total length of escape_sequence must be < 22 bits according                                                   
+                                       to the specification (i.e. max is 111111110xxxxxxxxxxxx). */                                                      
+                                    UPDATE_CACHE(re, gb);                                                                                                
+                                    b = GET_CACHE(re, gb);                                                                                               
+                                    b = 31 - av_log2(~b);                                                                                                
+                                                                                                                                                         
+                                    if (b > 8) {                                                                                                         
+                                        av_log(ac->avctx, AV_LOG_ERROR, "error in spectral data, ESC overflow\n");                                       
+                                        return -1;                                                                                                       
+                                    }                                                                                                                    
+                                                                                                                                                         
+                                    SKIP_BITS(re, gb, b + 1);                                                                                            
+                                    b += 4;                                                                                                              
+                                    n = (1 << b) + SHOW_UBITS(re, gb, b);                                                                                
+                                    LAST_SKIP_BITS(re, gb, b);                                                                                           
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                                    v = n;                                                                                                               
+                                    if (bits & 1U<<31)                                                                                                   
+                                      v = -v;                                                                                                            
+                                    *icf++ = v;                                                                                                          
+#else                                                                                                                                                    
+                                    *icf++ = cbrt_tab[n] | (bits & 1U<<31);                                                                              
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                                    bits <<= 1;                                                                                                          
+                                } else {                                                                                                                 
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                                    v = cb_idx & 15;                                                                                                     
+                                    if (bits & 1U<<31)                                                                                                   
+                                      v = -v;                                                                                                            
+                                    *icf++ = v;                                                                                                          
+#else                                                                                                                                                    
+                                    unsigned v = ((const uint32_t*)vq)[cb_idx & 15];                                                                     
+                                    *icf++ = (bits & 1U<<31) | v;                                                                                        
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                                    bits <<= !!v;                                                                                                        
+                                }                                                                                                                        
+                                cb_idx >>= 4;                                                                                                            
+                            }                                                                                                                            
+                        } while (len -= 2);                                                                                                              
+#if !CONFIG_AAC_FIXED                                                                                                                                    
+                        ac->fdsp.vector_fmul_scalar(cfo, cfo, sf[idx], off_len);                                                                         
+#endif /* !CONFIG_AAC_FIXED */                                                                                                                           
+                    }                                                                                                                                    
+                }                                                                                                                                        
+                                                                                                                                                         
+                CLOSE_READER(re, gb);                                                                                                                    
+            }                                                                                                                                            
+        }                                                                                                                                                
+        coef += g_len << 7;                                                                                                                              
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (pulse_present) {                                                                                                                                 
+        idx = 0;                                                                                                                                         
+        for (i = 0; i < pulse->num_pulse; i++) {                                                                                                         
+            INTFLOAT co = coef_base[ pulse->pos[i] ];                                                                                                    
+            while (offsets[idx + 1] <= pulse->pos[i])                                                                                                    
+                idx++;                                                                                                                                   
+            if (band_type[idx] != NOISE_BT && sf[idx]) {                                                                                                 
+                INTFLOAT ico = -pulse->amp[i];                                                                                                           
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                if (co) {                                                                                                                                
+                    ico = co + (co > 0 ? -ico : ico);                                                                                                    
+                }                                                                                                                                        
+                coef_base[ pulse->pos[i] ] = ico;                                                                                                        
+#else                                                                                                                                                    
+                if (co) {                                                                                                                                
+                    co /= sf[idx];                                                                                                                       
+                    ico = co / sqrtf(sqrtf(fabsf(co))) + (co > 0 ? -ico : ico);                                                                          
+                }                                                                                                                                        
+                coef_base[ pulse->pos[i] ] = cbrtf(fabsf(ico)) * ico * sf[idx];                                                                          
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+#if CONFIG_AAC_FIXED                                                                                                                                     
+    coef = coef_base;                                                                                                                                    
+    idx = 0;                                                                                                                                             
+    for (g = 0; g < ics->num_window_groups; g++) {                                                                                                       
+        unsigned g_len = ics->group_len[g];                                                                                                              
+                                                                                                                                                         
+        for (i = 0; i < ics->max_sfb; i++, idx++) {                                                                                                      
+            const unsigned cbt_m1 = band_type[idx] - 1;                                                                                                  
+            int *cfo = coef + offsets[i];                                                                                                                
+            int off_len = offsets[i + 1] - offsets[i];                                                                                                   
+            int group;                                                                                                                                   
+                                                                                                                                                         
+            if (cbt_m1 < NOISE_BT - 1) {                                                                                                                 
+                for (group = 0; group < (int)g_len; group++, cfo+=128) {                                                                                 
+                    vector_pow43(cfo, off_len);                                                                                                      
+                    ac->subband_scale(cfo, cfo, sf[idx], 34, off_len);                                                                                   
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+        coef += g_len << 7;                                                                                                                              
+    }                                                                                                                                                    
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Apply AAC-Main style frequency domain prediction.                                                                                                     
+ */                                                                                                                                                      
+static void apply_prediction(AACContext *ac, SingleChannelElement *sce)                                                                                  
+{                                                                                                                                                        
+    int sfb, k;                                                                                                                                          
+                                                                                                                                                         
+    if (!sce->ics.predictor_initialized) {                                                                                                               
+        reset_all_predictors(sce->predictor_state);                                                                                                      
+        sce->ics.predictor_initialized = 1;                                                                                                              
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (sce->ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {                                                                                           
+        for (sfb = 0; sfb < ff_aac_pred_sfb_max[ac->oc[1].m4ac.sampling_index]; sfb++) {                                                                 
+            for (k = sce->ics.swb_offset[sfb]; k < sce->ics.swb_offset[sfb + 1]; k++) {                                                                  
+                predict(&sce->predictor_state[k], &sce->coeffs[k],                                                                                       
+                        sce->ics.predictor_present && sce->ics.prediction_used[sfb]);                                                                    
+            }                                                                                                                                            
+        }                                                                                                                                                
+        if (sce->ics.predictor_reset_group)                                                                                                              
+            reset_predictor_group(sce->predictor_state, sce->ics.predictor_reset_group);                                                                 
+    } else                                                                                                                                               
+        reset_all_predictors(sce->predictor_state);                                                                                                      
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode an individual_channel_stream payload; reference: table 4.44.                                                                                   
+ *                                                                                                                                                       
+ *  <at> param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.                                    
+ *  <at> param   scale_flag      scalable [1] or non-scalable [0] AAC (Unused until scalable AAC is implemented.)                                        
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_ics(AACContext *ac, SingleChannelElement *sce,                                                                                         
+                      GetBitContext *gb, int common_window, int scale_flag)                                                                              
+{                                                                                                                                                        
+    Pulse pulse;                                                                                                                                         
+    TemporalNoiseShaping    *tns = &sce->tns;                                                                                                            
+    IndividualChannelStream *ics = &sce->ics;                                                                                                            
+    INTFLOAT *out = sce->coeffs;                                                                                                                         
+    int global_gain, pulse_present = 0;                                                                                                                  
+                                                                                                                                                         
+    /* This assignment is to silence a GCC warning about the variable being used                                                                         
+     * uninitialized when in fact it always is.                                                                                                          
+     */                                                                                                                                                  
+    pulse.num_pulse = 0;                                                                                                                                 
+                                                                                                                                                         
+    global_gain = get_bits(gb, 8);                                                                                                                       
+                                                                                                                                                         
+    if (!common_window && !scale_flag) {                                                                                                                 
+        if (decode_ics_info(ac, ics, gb) < 0)                                                                                                            
+            return AVERROR_INVALIDDATA;                                                                                                                  
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)                                                                      
+        return -1;                                                                                                                                       
+    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)                                              
+        return -1;                                                                                                                                       
+                                                                                                                                                         
+    pulse_present = 0;                                                                                                                                   
+    if (!scale_flag) {                                                                                                                                   
+        if ((pulse_present = get_bits1(gb))) {                                                                                                           
+            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                                                                                       
+                av_log(ac->avctx, AV_LOG_ERROR, "Pulse tool not allowed in eight short sequence.\n");                                                    
+                return -1;                                                                                                                               
+            }                                                                                                                                            
+            if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) {                                                                              
+                av_log(ac->avctx, AV_LOG_ERROR, "Pulse data corrupt or invalid.\n");                                                                     
+                return -1;                                                                                                                               
+            }                                                                                                                                            
+        }                                                                                                                                                
+        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))                                                                              
+            return -1;                                                                                                                                   
+        if (get_bits1(gb)) {                                                                                                                             
+            av_log_missing_feature(ac->avctx, "SSR", 1);                                                                                                    
+            return AVERROR_PATCHWELCOME;                                                                                                                 
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)                                               
+        return -1;                                                                                                                                       
+                                                                                                                                                         
+    if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN && !common_window)                                                                                    
+        apply_prediction(ac, sce);                                                                                                                       
+                                                                                                                                                         
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Mid/Side stereo decoding; reference: 4.6.8.1.3.                                                                                                       
+ */                                                                                                                                                      
+static void apply_mid_side_stereo(AACContext *ac, ChannelElement *cpe)                                                                                   
+{                                                                                                                                                        
+    const IndividualChannelStream *ics = &cpe->ch[0].ics;                                                                                                
+    INTFLOAT *ch0 = cpe->ch[0].coeffs;                                                                                                                   
+    INTFLOAT *ch1 = cpe->ch[1].coeffs;                                                                                                                   
+    int g, i, group, idx = 0;                                                                                                                            
+    const uint16_t *offsets = ics->swb_offset;                                                                                                           
+    for (g = 0; g < ics->num_window_groups; g++) {                                                                                                       
+        for (i = 0; i < ics->max_sfb; i++, idx++) {                                                                                                      
+            if (cpe->ms_mask[idx] &&                                                                                                                     
+                    cpe->ch[0].band_type[idx] < NOISE_BT && cpe->ch[1].band_type[idx] < NOISE_BT) {                                                      
+                for (group = 0; group < ics->group_len[g]; group++) {
+#if CONFIG_AAC_FIXED                                                                                     
+                    ac->fdsp.AAC_RENAME2(butterflies)(ch0 + group * 128 + offsets[i],                                                                    
+                                               ch1 + group * 128 + offsets[i],                                                                           
+                                               offsets[i+1] - offsets[i]);                                                                               
+#else
+                    ac->dsp.butterflies_float(ch0 + group * 128 + offsets[i],
+                                              ch1 + group * 128 + offsets[i],
+                                              offsets[i+1] - offsets[i]);
+#endif
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+        ch0 += ics->group_len[g] * 128;                                                                                                                  
+        ch1 += ics->group_len[g] * 128;                                                                                                                  
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * intensity stereo decoding; reference: 4.6.8.2.3                                                                                                       
+ *                                                                                                                                                       
+ *  <at> param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;                                                                     
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;                                                                          
+ *                      [3] reserved for scalable AAC                                                                                                    
+ */                                                                                                                                                      
+static void apply_intensity_stereo(AACContext *ac, ChannelElement *cpe, int ms_present)                                                                  
+{                                                                                                                                                        
+    const IndividualChannelStream *ics = &cpe->ch[1].ics;                                                                                                
+    SingleChannelElement         *sce1 = &cpe->ch[1];                                                                                                    
+    INTFLOAT *coef0 = cpe->ch[0].coeffs, *coef1 = cpe->ch[1].coeffs;                                                                                     
+    const uint16_t *offsets = ics->swb_offset;                                                                                                           
+    int g, group, i, idx = 0;                                                                                                                            
+    int c;                                                                                                                                               
+    INTFLOAT scale;                                                                                                                                      
+    for (g = 0; g < ics->num_window_groups; g++) {                                                                                                       
+        for (i = 0; i < ics->max_sfb;) {                                                                                                                 
+            if (sce1->band_type[idx] == INTENSITY_BT || sce1->band_type[idx] == INTENSITY_BT2) {                                                         
+                const int bt_run_end = sce1->band_type_run_end[idx];                                                                                     
+                for (; i < bt_run_end; i++, idx++) {                                                                                                     
+                    c = -1 + 2 * (sce1->band_type[idx] - 14);                                                                                            
+                    if (ms_present)                                                                                                                      
+                        c *= 1 - 2 * cpe->ms_mask[idx];                                                                                                  
+                    scale = c * sce1->sf[idx];                                                                                                           
+                    for (group = 0; group < ics->group_len[g]; group++)                                                                                  
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                        ac->subband_scale(coef1 + group * 128 + offsets[i],                                                                              
+                                      coef0 + group * 128 + offsets[i],                                                                                  
+                                      scale,                                                                                                             
+                                      23,                                                                                                                
+                                      offsets[i + 1] - offsets[i]);                                                                                      
+#else                                                                                                                                                    
+                        ac->fdsp.vector_fmul_scalar(coef1 + group * 128 + offsets[i],                                                                    
+                                                    coef0 + group * 128 + offsets[i],                                                                    
+                                                    scale,                                                                                               
+                                                    offsets[i + 1] - offsets[i]);                                                                        
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+                }                                                                                                                                        
+            } else {                                                                                                                                     
+                int bt_run_end = sce1->band_type_run_end[idx];                                                                                           
+                idx += bt_run_end - i;                                                                                                                   
+                i    = bt_run_end;                                                                                                                       
+            }                                                                                                                                            
+        }                                                                                                                                                
+        coef0 += ics->group_len[g] * 128;                                                                                                                
+        coef1 += ics->group_len[g] * 128;                                                                                                                
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode a channel_pair_element; reference: table 4.4.                                                                                                  
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_cpe(AACContext *ac, GetBitContext *gb, ChannelElement *cpe)                                                                            
+{                                                                                                                                                        
+    int i, ret, common_window, ms_present = 0;                                                                                                           
+                                                                                                                                                         
+    common_window = get_bits1(gb);                                                                                                                       
+    if (common_window) {                                                                                                                                 
+        if (decode_ics_info(ac, &cpe->ch[0].ics, gb))                                                                                                    
+            return AVERROR_INVALIDDATA;                                                                                                                  
+        i = cpe->ch[1].ics.use_kb_window[0];                                                                                                             
+        cpe->ch[1].ics = cpe->ch[0].ics;                                                                                                                 
+        cpe->ch[1].ics.use_kb_window[1] = i;                                                                                                             
+        if (cpe->ch[1].ics.predictor_present && (ac->oc[1].m4ac.object_type != AOT_AAC_MAIN))                                                            
+            if ((cpe->ch[1].ics.ltp.present = get_bits(gb, 1)))                                                                                          
+                decode_ltp(&cpe->ch[1].ics.ltp, gb, cpe->ch[1].ics.max_sfb);                                                                             
+        ms_present = get_bits(gb, 2);                                                                                                                    
+        if (ms_present == 3) {                                                                                                                           
+            av_log(ac->avctx, AV_LOG_ERROR, "ms_present = 3 is reserved.\n");                                                                            
+            return -1;                                                                                                                                   
+        } else if (ms_present)                                                                                                                           
+            decode_mid_side_stereo(cpe, gb, ms_present);                                                                                                 
+    }                                                                                                                                                    
+    if ((ret = decode_ics(ac, &cpe->ch[0], gb, common_window, 0)))                                                                                       
+        return ret;                                                                                                                                      
+    if ((ret = decode_ics(ac, &cpe->ch[1], gb, common_window, 0)))                                                                                       
+        return ret;                                                                                                                                      
+                                                                                                                                                         
+    if (common_window) {                                                                                                                                 
+        if (ms_present)                                                                                                                                  
+            apply_mid_side_stereo(ac, cpe);                                                                                                              
+        if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN) {                                                                                                
+            apply_prediction(ac, &cpe->ch[0]);                                                                                                           
+            apply_prediction(ac, &cpe->ch[1]);                                                                                                           
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    apply_intensity_stereo(ac, cpe, ms_present);                                                                                                         
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode coupling_channel_element; reference: table 4.8.                                                                                                
+ *                                                                                                                                                       
+ *  <at> return  Returns error status. 0 - OK, !0 - error                                                                                                
+ */                                                                                                                                                      
+static int decode_cce(AACContext *ac, GetBitContext *gb, ChannelElement *che)                                                                            
+{                                                                                                                                                        
+    int num_gain = 0;                                                                                                                                    
+    int c, g, sfb, ret;                                                                                                                                  
+    int sign;                                                                                                                                            
+    INTFLOAT scale;                                                                                                                                      
+    SingleChannelElement *sce = &che->ch[0];                                                                                                             
+    ChannelCoupling     *coup = &che->coup;                                                                                                              
+                                                                                                                                                         
+    coup->coupling_point = 2 * get_bits1(gb);                                                                                                            
+    coup->num_coupled = get_bits(gb, 3);                                                                                                                 
+    for (c = 0; c <= coup->num_coupled; c++) {                                                                                                           
+        num_gain++;                                                                                                                                      
+        coup->type[c] = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;                                                                                             
+        coup->id_select[c] = get_bits(gb, 4);                                                                                                            
+        if (coup->type[c] == TYPE_CPE) {                                                                                                                 
+            coup->ch_select[c] = get_bits(gb, 2);                                                                                                        
+            if (coup->ch_select[c] == 3)                                                                                                                 
+                num_gain++;                                                                                                                              
+        } else                                                                                                                                           
+            coup->ch_select[c] = 2;                                                                                                                      
+    }                                                                                                                                                    
+    coup->coupling_point += get_bits1(gb) || (coup->coupling_point >> 1);                                                                                
+                                                                                                                                                         
+    sign  = get_bits(gb, 1);                                                                                                                             
+    scale = AAC_RENAME(cce_scale)[get_bits(gb, 2)];                                                                                                      
+                                                                                                                                                         
+    if ((ret = decode_ics(ac, sce, gb, 0, 0)))                                                                                                           
+        return ret;                                                                                                                                      
+                                                                                                                                                         
+    for (c = 0; c < num_gain; c++) {                                                                                                                     
+        int idx  = 0;                                                                                                                                    
+        int cge  = 1;                                                                                                                                    
+        int gain = 0;                                                                                                                                    
+        INTFLOAT gain_cache = FIXR10(1.);                                                                                                                
+        if (c) {                                                                                                                                         
+            cge = coup->coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);                                                                               
+            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;                                                                             
+            gain_cache = GET_GAIN(scale, gain);                                                                                                          
+        }                                                                                                                                                
+        if (coup->coupling_point == AFTER_IMDCT) {                                                                                                       
+            coup->gain[c][0] = gain_cache;                                                                                                               
+        } else {                                                                                                                                         
+            for (g = 0; g < sce->ics.num_window_groups; g++) {                                                                                           
+                for (sfb = 0; sfb < sce->ics.max_sfb; sfb++, idx++) {                                                                                    
+                    if (sce->band_type[idx] != ZERO_BT) {                                                                                                
+                        if (!cge) {                                                                                                                      
+                            int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;                                                                     
+                            if (t) {                                                                                                                     
+                                int s = 1;                                                                                                               
+                                t = gain += t;                                                                                                           
+                                if (sign) {                                                                                                              
+                                    s  -= 2 * (t & 0x1);                                                                                                 
+                                    t >>= 1;                                                                                                             
+                                }                                                                                                                        
+                                gain_cache = GET_GAIN(scale, t) * s;                                                                                     
+                            }                                                                                                                            
+                        }                                                                                                                                
+                        coup->gain[c][idx] = gain_cache;                                                                                                 
+                    }                                                                                                                                    
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Parse whether channels are to be excluded from Dynamic Range Compression; reference: table 4.53.                                                      
+ *                                                                                                                                                       
+ *  <at> return  Returns number of bytes consumed.                                                                                                       
+ */                                                                                                                                                      
+static int decode_drc_channel_exclusions(DynamicRangeControl *che_drc,                                                                                   
+                                         GetBitContext *gb)                                                                                              
+{                                                                                                                                                        
+    int i;                                                                                                                                               
+    int num_excl_chan = 0;                                                                                                                               
+                                                                                                                                                         
+    do {                                                                                                                                                 
+        for (i = 0; i < 7; i++)                                                                                                                          
+            che_drc->exclude_mask[num_excl_chan++] = get_bits1(gb);                                                                                      
+    } while (num_excl_chan < MAX_CHANNELS - 7 && get_bits1(gb));                                                                                         
+                                                                                                                                                         
+    return num_excl_chan / 7;                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode dynamic range information; reference: table 4.52.                                                                                              
+ *                                                                                                                                                       
+ *  <at> return  Returns number of bytes consumed.                                                                                                       
+ */                                                                                                                                                      
+static int decode_dynamic_range(DynamicRangeControl *che_drc,                                                                                            
+                                GetBitContext *gb)                                                                                                       
+{                                                                                                                                                        
+    int n             = 1;                                                                                                                               
+    int drc_num_bands = 1;                                                                                                                               
+    int i;                                                                                                                                               
+                                                                                                                                                         
+    /* pce_tag_present? */                                                                                                                               
+    if (get_bits1(gb)) {                                                                                                                                 
+        che_drc->pce_instance_tag  = get_bits(gb, 4);                                                                                                    
+        skip_bits(gb, 4); // tag_reserved_bits                                                                                                           
+        n++;                                                                                                                                             
+    }                                                                                                                                                    
+                                                                                                                                                         
+    /* excluded_chns_present? */                                                                                                                         
+    if (get_bits1(gb)) {                                                                                                                                 
+        n += decode_drc_channel_exclusions(che_drc, gb);                                                                                                 
+    }                                                                                                                                                    
+                                                                                                                                                         
+    /* drc_bands_present? */                                                                                                                             
+    if (get_bits1(gb)) {                                                                                                                                 
+        che_drc->band_incr            = get_bits(gb, 4);                                                                                                 
+        che_drc->interpolation_scheme = get_bits(gb, 4);                                                                                                 
+        n++;                                                                                                                                             
+        drc_num_bands += che_drc->band_incr;                                                                                                             
+        for (i = 0; i < drc_num_bands; i++) {                                                                                                            
+            che_drc->band_top[i] = get_bits(gb, 8);                                                                                                      
+            n++;                                                                                                                                         
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    /* prog_ref_level_present? */                                                                                                                        
+    if (get_bits1(gb)) {                                                                                                                                 
+        che_drc->prog_ref_level = get_bits(gb, 7);                                                                                                       
+        skip_bits1(gb); // prog_ref_level_reserved_bits                                                                                                  
+        n++;                                                                                                                                             
+    }                                                                                                                                                    
+                                                                                                                                                         
+    for (i = 0; i < drc_num_bands; i++) {                                                                                                                
+        che_drc->dyn_rng_sgn[i] = get_bits1(gb);                                                                                                         
+        che_drc->dyn_rng_ctl[i] = get_bits(gb, 7);                                                                                                       
+        n++;                                                                                                                                             
+    }                                                                                                                                                    
+                                                                                                                                                         
+    return n;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+/*static int decode_fill(AACContext *ac, GetBitContext *gb, int len) {                                                                                     
+    uint8_t buf[256];                                                                                                                                    
+    int i, major, minor;                                                                                                                                 
+                                                                                                                                                         
+    if (len < 13+7*8)                                                                                                                                    
+        goto unknown;                                                                                                                                    
+                                                                                                                                                         
+    get_bits(gb, 13); len -= 13;                                                                                                                         
+                                                                                                                                                         
+    for(i=0; i+1<sizeof(buf) && len>=8; i++, len-=8)                                                                                                     
+        buf[i] = get_bits(gb, 8);                                                                                                                        
+                                                                                                                                                         
+    buf[i] = 0;                                                                                                                                          
+    if (ac->avctx->debug & FF_DEBUG_PICT_INFO)                                                                                                           
+        av_log(ac->avctx, AV_LOG_DEBUG, "FILL:%s\n", buf);                                                                                               
+                                                                                                                                                         
+    if (sscanf(buf, "libfaac %d.%d", &major, &minor) == 2){                                                                                              
+        ac->avctx->internal->skip_samples = 1024;                                                                                                        
+    }                                                                                                                                                    
+                                                                                                                                                         
+unknown:                                                                                                                                                 
+    skip_bits_long(gb, len);                                                                                                                             
+                                                                                                                                                         
+    return 0;                                                                                                                                            
+}  */
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode extension data (incomplete); reference: table 4.51.                                                                                            
+ *                                                                                                                                                       
+ *  <at> param   cnt length of TYPE_FIL syntactic element in bytes                                                                                       
+ *                                                                                                                                                       
+ *  <at> return Returns number of bytes consumed                                                                                                         
+ */                                                                                                                                                      
+static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt,                                                                          
+                                    ChannelElement *che, enum RawDataBlockType elem_type)                                                                
+{                                                                                                                                                        
+    int crc_flag = 0;                                                                                                                                    
+    int res = cnt;                                                                                                                                       
+    switch (get_bits(gb, 4)) { // extension type                                                                                                         
+    case EXT_SBR_DATA_CRC:                                                                                                                               
+        crc_flag++;                                                                                                                                      
+    case EXT_SBR_DATA:                                                                                                                                   
+        if (!che) {                                                                                                                                      
+            av_log(ac->avctx, AV_LOG_ERROR, "SBR was found before the first channel element.\n");                                                        
+            return res;                                                                                                                                  
+        } else if (!ac->oc[1].m4ac.sbr) {                                                                                                                
+            av_log(ac->avctx, AV_LOG_ERROR, "SBR signaled to be not-present but was found in the bitstream.\n");                                         
+            skip_bits_long(gb, 8 * cnt - 4);                                                                                                             
+            return res;                                                                                                                                  
+        } else if (ac->oc[1].m4ac.sbr == -1 && ac->oc[1].status == OC_LOCKED) {                                                                          
+            av_log(ac->avctx, AV_LOG_ERROR, "Implicit SBR was found with a first occurrence after the first frame.\n");                                  
+            skip_bits_long(gb, 8 * cnt - 4);                                                                                                             
+            return res;                                                                                                                                  
+        } else if (ac->oc[1].m4ac.ps == -1 && ac->oc[1].status < OC_LOCKED && ac->avctx->channels == 1) {                                                
+            ac->oc[1].m4ac.sbr = 1;                                                                                                                      
+            ac->oc[1].m4ac.ps = 1;                                                                                                                       
+            output_configure(ac, ac->oc[1].layout_map, ac->oc[1].layout_map_tags,                                                                        
+                             ac->oc[1].status, 1);                                                                                                       
+        } else {                                                                                                                                         
+            ac->oc[1].m4ac.sbr = 1;                                                                                                                      
+        }                                                                                                                                                
+        res = AAC_RENAME(ff_decode_sbr_extension)(ac, &che->sbr, gb, crc_flag, cnt, elem_type);                                                          
+        break;                                                                                                                                           
+    case EXT_DYNAMIC_RANGE:                                                                                                                              
+        res = decode_dynamic_range(&ac->che_drc, gb);                                                                                                    
+        break;                                                                                                                                           
+    case EXT_FILL:                                                                                                                                       
+    /*    decode_fill(ac, gb, 8 * cnt - 4);                                                                                                                
+        break;       */                                                                                                                                    
+    case EXT_FILL_DATA:                                                                                                                                  
+    case EXT_DATA_ELEMENT:                                                                                                                               
+    default:                                                                                                                                             
+        skip_bits_long(gb, 8 * cnt - 4);                                                                                                                 
+        break;                                                                                                                                           
+    };                                                                                                                                                   
+    return res;                                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Decode Temporal Noise Shaping filter coefficients and apply all-pole filters; reference: 4.6.9.3.                                                     
+ *                                                                                                                                                       
+ *  <at> param   decode  1 if tool is used normally, 0 if tool is used in LTP.                                                                           
+ *  <at> param   coef    spectral coefficients                                                                                                           
+ */                                                                                                                                                      
+static void apply_tns(INTFLOAT coef[1024], TemporalNoiseShaping *tns,                                                                                    
+                      IndividualChannelStream *ics, int decode)                                                                                          
+{                                                                                                                                                        
+    const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb);                                                                                             
+    int w, filt, m, i;                                                                                                                                   
+    int bottom, top, order, start, end, size, inc;                                                                                                       
+    INTFLOAT lpc[TNS_MAX_ORDER];                                                                                                                         
+    INTFLOAT tmp[TNS_MAX_ORDER+1];                                                                                                                       
+                                                                                                                                                         
+    for (w = 0; w < ics->num_windows; w++) {                                                                                                             
+        bottom = ics->num_swb;                                                                                                                           
+        for (filt = 0; filt < tns->n_filt[w]; filt++) {                                                                                                  
+            top    = bottom;                                                                                                                             
+            bottom = FFMAX(0, top - tns->length[w][filt]);                                                                                               
+            order  = tns->order[w][filt];                                                                                                                
+            if (order == 0)                                                                                                                              
+                continue;                                                                                                                                
+                                                                                                                                                         
+            // tns_decode_coef                                                                                                                           
+            AAC_RENAME(compute_lpc_coefs)(tns->coef[w][filt], order, lpc, 0, 0, 0);                                                                      
+                                                                                                                                                         
+            start = ics->swb_offset[FFMIN(bottom, mmm)];                                                                                                 
+            end   = ics->swb_offset[FFMIN(   top, mmm)];                                                                                                 
+            if ((size = end - start) <= 0)                                                                                                               
+                continue;                                                                                                                                
+            if (tns->direction[w][filt]) {                                                                                                               
+                inc = -1;                                                                                                                                
+                start = end - 1;                                                                                                                         
+            } else {                                                                                                                                     
+                inc = 1;                                                                                                                                 
+            }                                                                                                                                            
+            start += w * 128;                                                                                                                            
+                                                                                                                                                         
+            if (decode) {                                                                                                                                
+                // ar filter                                                                                                                             
+                for (m = 0; m < size; m++, start += inc)                                                                                                 
+                    for (i = 1; i <= FFMIN(m, order); i++)                                                                                               
+                        coef[start] -= AAC_MUL26(coef[start - i * inc], lpc[i - 1]);                                                                     
+            } else {                                                                                                                                     
+                // ma filter                                                                                                                             
+                for (m = 0; m < size; m++, start += inc) {                                                                                               
+                    tmp[0] = coef[start];                                                                                                                
+                    for (i = 1; i <= FFMIN(m, order); i++)                                                                                               
+                        coef[start] += AAC_MUL26(tmp[i], lpc[i - 1]);                                                                                    
+                    for (i = order; i > 0; i--)                                                                                                          
+                        tmp[i] = tmp[i - 1];                                                                                                             
+                }                                                                                                                                        
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ *  Apply windowing and MDCT to obtain the spectral                                                                                                      
+ *  coefficient from the predicted sample by LTP.                                                                                                        
+ */                                                                                                                                                      
+static void windowing_and_mdct_ltp(AACContext *ac, INTFLOAT *out,                                                                                        
+                                   INTFLOAT *in, IndividualChannelStream *ics)                                                                           
+{                                                                                                                                                        
+    const INTFLOAT *lwindow      = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_long_1024) : AAC_RENAME(ff_sine_1024);                                  
+    const INTFLOAT *swindow      = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128);                                   
+    const INTFLOAT *lwindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_long_1024) : AAC_RENAME(ff_sine_1024);                                  
+    const INTFLOAT *swindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128);                                   
+                                                                                                                                                         
+    if (ics->window_sequence[0] != LONG_STOP_SEQUENCE) {                                                                                                 
+        ac->fdsp.AAC_RENAME(vector_fmul)(in, in, lwindow_prev, 1024);                                                                                    
+    } else {                                                                                                                                             
+        memset(in, 0, 448 * sizeof(INTFLOAT));                                                                                                           
+        ac->fdsp.AAC_RENAME(vector_fmul)(in + 448, in + 448, swindow_prev, 128);                                                                         
+    }                                                                                                                                                    
+    if (ics->window_sequence[0] != LONG_START_SEQUENCE) { 
+#if CONFIG_AAC_FIXED                                                               
+        ac->fdsp.AAC_RENAME(vector_fmul_reverse)(in + 1024, in + 1024, lwindow, 1024);                                                                   
+#else
         ac->dsp.vector_fmul_reverse(in + 1024, in + 1024, lwindow, 1024);
+#endif
     } else {
+#if CONFIG_AAC_FIXED                                                                                                                                             
+        ac->fdsp.AAC_RENAME(vector_fmul_reverse)(in + 1024 + 448, in + 1024 + 448, swindow, 128);                                                        
+#else
         ac->dsp.vector_fmul_reverse(in + 1024 + 448, in + 1024 + 448, swindow, 128);
-        memset(in + 1024 + 576, 0, 448 * sizeof(float));
-    }
-    ac->mdct_ltp.mdct_calc(&ac->mdct_ltp, out, in);
-}
-
-/**
- * Apply the long term prediction
- */
-static void apply_ltp(AACContext *ac, SingleChannelElement *sce)
-{
-    const LongTermPrediction *ltp = &sce->ics.ltp;
-    const uint16_t *offsets = sce->ics.swb_offset;
-    int i, sfb;
-
-    if (sce->ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {
-        float *predTime = sce->ret;
-        float *predFreq = ac->buf_mdct;
-        int16_t num_samples = 2048;
-
-        if (ltp->lag < 1024)
-            num_samples = ltp->lag + 1024;
-        for (i = 0; i < num_samples; i++)
-            predTime[i] = sce->ltp_state[i + 2048 - ltp->lag] * ltp->coef;
-        memset(&predTime[i], 0, (2048 - i) * sizeof(float));
-
-        windowing_and_mdct_ltp(ac, predFreq, predTime, &sce->ics);
-
-        if (sce->tns.present)
-            apply_tns(predFreq, &sce->tns, &sce->ics, 0);
-
-        for (sfb = 0; sfb < FFMIN(sce->ics.max_sfb, MAX_LTP_LONG_SFB); sfb++)
-            if (ltp->used[sfb])
-                for (i = offsets[sfb]; i < offsets[sfb + 1]; i++)
-                    sce->coeffs[i] += predFreq[i];
-    }
-}
-
-/**
- * Update the LTP buffer for next frame
- */
-static void update_ltp(AACContext *ac, SingleChannelElement *sce)
-{
-    IndividualChannelStream *ics = &sce->ics;
-    float *saved     = sce->saved;
-    float *saved_ltp = sce->coeffs;
-    const float *lwindow = ics->use_kb_window[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;
-    const float *swindow = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;
-    int i;
-
-    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        memcpy(saved_ltp,       saved, 512 * sizeof(float));
-        memset(saved_ltp + 576, 0,     448 * sizeof(float));
+#endif
+        memset(in + 1024 + 576, 0, 448 * sizeof(INTFLOAT));                                                                                              
+    }                                                                                                                                                    
+    ac->mdct_ltp.mdct_calc(&ac->mdct_ltp, out, in);                                                                                                      
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Apply the long term prediction                                                                                                                        
+ */                                                                                                                                                      
+static void apply_ltp(AACContext *ac, SingleChannelElement *sce)                                                                                         
+{                                                                                                                                                        
+    const LongTermPrediction *ltp = &sce->ics.ltp;                                                                                                       
+    const uint16_t *offsets = sce->ics.swb_offset;                                                                                                       
+    int i, sfb;                                                                                                                                          
+                                                                                                                                                         
+    if (sce->ics.window_sequence[0] != EIGHT_SHORT_SEQUENCE) {                                                                                           
+        INTFLOAT *predTime = sce->ret;                                                                                                                   
+        INTFLOAT *predFreq = ac->buf_mdct;                                                                                                               
+        int16_t num_samples = 2048;                                                                                                                      
+                                                                                                                                                         
+        if (ltp->lag < 1024)                                                                                                                             
+            num_samples = ltp->lag + 1024;                                                                                                               
+        for (i = 0; i < num_samples; i++)                                                                                                                
+            predTime[i] = AAC_MUL30(sce->ltp_state[i + 2048 - ltp->lag], ltp->coef);                                                                     
+        memset(&predTime[i], 0, (2048 - i) * sizeof(INTFLOAT));                                                                                          
+       windowing_and_mdct_ltp(ac, predFreq, predTime, &sce->ics);
+                                                                                                 
+        if (sce->tns.present)                                                                                                                            
+            apply_tns(predFreq, &sce->tns, &sce->ics, 0);                                                                                            
+                                                                                                                                                         
+        for (sfb = 0; sfb < FFMIN(sce->ics.max_sfb, MAX_LTP_LONG_SFB); sfb++)                                                                            
+            if (ltp->used[sfb])                                                                                                                          
+                for (i = offsets[sfb]; i < offsets[sfb + 1]; i++)                                                                                        
+                    sce->coeffs[i] += predFreq[i];                                                                                                       
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Update the LTP buffer for next frame                                                                                                                  
+ */                                                                                                                                                      
+static void update_ltp(AACContext *ac, SingleChannelElement *sce)                                                                                        
+{                                                                                                                                                        
+    IndividualChannelStream *ics = &sce->ics;                                                                                                            
+    INTFLOAT *saved     = sce->saved;                                                                                                                    
+    INTFLOAT *saved_ltp = sce->coeffs;                                                                                                                   
+    const INTFLOAT *lwindow = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_long_1024) : AAC_RENAME(ff_sine_1024);                                       
+    const INTFLOAT *swindow = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128);                                        
+    int i;                                                                                                                                               
+                                                                                                                                                         
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                                                                                               
+        memcpy(saved_ltp,       saved, 512 * sizeof(INTFLOAT));                                                                                          
+        memset(saved_ltp + 576, 0,     448 * sizeof(INTFLOAT));
+#if CONFIG_AAC_FIXED                          
+        ac->fdsp.AAC_RENAME(vector_fmul_reverse)(saved_ltp + 448, ac->buf_mdct + 960,     &swindow[64],      64);
+#else
         ac->dsp.vector_fmul_reverse(saved_ltp + 448, ac->buf_mdct + 960,     &swindow[64],      64);
-        for (i = 0; i < 64; i++)
-            saved_ltp[i + 512] = ac->buf_mdct[1023 - i] * swindow[63 - i];
-    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {
-        memcpy(saved_ltp,       ac->buf_mdct + 512, 448 * sizeof(float));
-        memset(saved_ltp + 576, 0,                  448 * sizeof(float));
+#endif                 
+        for (i = 0; i < 64; i++)                                                                                                                         
+            saved_ltp[i + 512] = AAC_MUL31(ac->buf_mdct[1023 - i], swindow[63 - i]);                                                                     
+    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {                                                                                         
+        memcpy(saved_ltp,       ac->buf_mdct + 512, 448 * sizeof(INTFLOAT));                                                                             
+        memset(saved_ltp + 576, 0,                  448 * sizeof(INTFLOAT));
+#if CONFIG_AAC_FIXED                                                                              
+        ac->fdsp.AAC_RENAME(vector_fmul_reverse)(saved_ltp + 448, ac->buf_mdct + 960,     &swindow[64],      64);                                        
+#else
         ac->dsp.vector_fmul_reverse(saved_ltp + 448, ac->buf_mdct + 960,     &swindow[64],      64);
-        for (i = 0; i < 64; i++)
-            saved_ltp[i + 512] = ac->buf_mdct[1023 - i] * swindow[63 - i];
-    } else { // LONG_STOP or ONLY_LONG
+#endif
+        for (i = 0; i < 64; i++)                                                                                                                         
+            saved_ltp[i + 512] = AAC_MUL31(ac->buf_mdct[1023 - i], swindow[63 - i]);                                                                     
+    } else { // LONG_STOP or ONLY_LONG                                                                                                                   
+#if CONFIG_AAC_FIXED 
+        ac->fdsp.AAC_RENAME(vector_fmul_reverse)(saved_ltp,       ac->buf_mdct + 512,     &lwindow[512],     512);                                       
+#else
         ac->dsp.vector_fmul_reverse(saved_ltp,       ac->buf_mdct + 512,     &lwindow[512],     512);
-        for (i = 0; i < 512; i++)
-            saved_ltp[i + 512] = ac->buf_mdct[1023 - i] * lwindow[511 - i];
-    }
-
-    memcpy(sce->ltp_state,      sce->ltp_state+1024, 1024 * sizeof(*sce->ltp_state));
-    memcpy(sce->ltp_state+1024, sce->ret,            1024 * sizeof(*sce->ltp_state));
-    memcpy(sce->ltp_state+2048, saved_ltp,           1024 * sizeof(*sce->ltp_state));
-}
-
-/**
- * Conduct IMDCT and windowing.
- */
-static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce)
-{
-    IndividualChannelStream *ics = &sce->ics;
-    float *in    = sce->coeffs;
-    float *out   = sce->ret;
-    float *saved = sce->saved;
-    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;
-    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;
-    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;
-    float *buf  = ac->buf_mdct;
-    float *temp = ac->temp;
-    int i;
-
-    // imdct
-    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        for (i = 0; i < 1024; i += 128)
-            ac->mdct_small.imdct_half(&ac->mdct_small, buf + i, in + i);
-    } else
-        ac->mdct.imdct_half(&ac->mdct, buf, in);
-
-    /* window overlapping
-     * NOTE: To simplify the overlapping code, all 'meaningless' short to long
-     * and long to short transitions are considered to be short to short
-     * transitions. This leaves just two cases (long to long and short to short)
-     * with a little special sauce for EIGHT_SHORT_SEQUENCE.
-     */
-    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&
+#endif
+        for (i = 0; i < 512; i++)                                                                                                                        
+            saved_ltp[i + 512] = AAC_MUL31(ac->buf_mdct[1023 - i], lwindow[511 - i]);                                                                    
+    }                                                                                                                                                    
+                                                                                                                                                         
+    memcpy(sce->ltp_state,      sce->ltp_state+1024, 1024 * sizeof(*sce->ltp_state));                                                                    
+    memcpy(sce->ltp_state+1024, sce->ret,            1024 * sizeof(*sce->ltp_state));                                                                    
+    memcpy(sce->ltp_state+2048, saved_ltp,           1024 * sizeof(*sce->ltp_state));                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Conduct IMDCT and windowing.                                                                                                                          
+ */                                                                                                                                                      
+static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce)                                                                               
+{                                                                                                                                                        
+    IndividualChannelStream *ics = &sce->ics;                                                                                                            
+    INTFLOAT *in    = sce->coeffs;                                                                                                                       
+    INTFLOAT *out   = sce->ret;                                                                                                                          
+    INTFLOAT *saved = sce->saved;                                                                                                                        
+    const INTFLOAT *swindow      = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128);                                   
+    const INTFLOAT *lwindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_long_1024) : AAC_RENAME(ff_sine_1024);                                  
+    const INTFLOAT *swindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128);                                   
+    INTFLOAT *buf  = ac->buf_mdct;                                                                                                                       
+    INTFLOAT *temp = ac->temp;                                                                                                                           
+    int i;                                                                                                                                               
+                                                                                                                                                         
+    // imdct                                                                                                                                             
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                                                                                               
+        for (i = 0; i < 1024; i += 128)                                                                                                                  
+            ac->mdct_small.imdct_half(&ac->mdct_small, buf + i, in + i);                                                                                 
+    } else {                                                                                                                                             
+        ac->mdct.imdct_half(&ac->mdct, buf, in);                                                                                                         
+#if CONFIG_AAC_FIXED                                                                                                                                     
+        for (i=0; i<1024; i++)                                                                                                                           
+          buf[i] = (buf[i] + 4) >> 3;                                                                                                                    
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+    }                                                                                                                                                    
+                                                                                                                                                         
+    /* window overlapping                                                                                                                                
+     * NOTE: To simplify the overlapping code, all 'meaningless' short to long                                                                           
+     * and long to short transitions are considered to be short to short                                                                                 
+     * transitions. This leaves just two cases (long to long and short to short)                                                                         
+     * with a little special sauce for EIGHT_SHORT_SEQUENCE.                                                                                             
+     */                                                                                                                                                  
+    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&                                              
             (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {
+#if CONFIG_AAC_FIXED                                        
+        vector_fmul_window_fixed_aac(    out,               saved,            buf,         lwindow_prev, 512);                                
+#else
         ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, 512);
-    } else {
-        memcpy(                        out,               saved,            448 * sizeof(float));
-
-        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+#endif
+    } else {                                                                                                                                             
+        memcpy(                                     out,               saved,            448 * sizeof(INTFLOAT));                                        
+                                                                                                                                                         
+        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { 
+#if CONFIG_AAC_FIXED                                                                                            
+            vector_fmul_window_fixed_aac(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, 64);                                 
+            vector_fmul_window_fixed_aac(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      64);                                 
+            vector_fmul_window_fixed_aac(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      64);                                 
+            vector_fmul_window_fixed_aac(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      64);                                 
+            vector_fmul_window_fixed_aac(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      64);                                 
+#else
             ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, 64);
             ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      64);
             ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      64);
             ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      64);
             ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      64);
-            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));
-        } else {
+#endif
+            memcpy(                     out + 448 + 4*128, temp, 64 * sizeof(INTFLOAT));                                                                 
+        } else { 
+#if CONFIG_AAC_FIXED                                                                                  
+            vector_fmul_window_fixed_aac(out + 448,         saved + 448,      buf,         swindow_prev, 64);                                 
+#else
             ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, 64);
-            memcpy(                    out + 576,         buf + 64,         448 * sizeof(float));
-        }
-    }
-
-    // buffer update
-    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
-        memcpy(                    saved,       temp + 64,         64 * sizeof(float));
+#endif
+            memcpy(                     out + 576,         buf + 64,         448 * sizeof(INTFLOAT));                                                    
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    // buffer update                                                                                                                                     
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                                                                                               
+        memcpy(                     saved,       temp + 64,         64 * sizeof(INTFLOAT));   
+#if CONFIG_AAC_FIXED                                                           
+        vector_fmul_window_fixed_aac(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 64);                                                
+        vector_fmul_window_fixed_aac(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 64);                                                
+        vector_fmul_window_fixed_aac(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 64);                                                
+#else
         ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 64);
         ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 64);
         ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 64);
-        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
-    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {
-        memcpy(                    saved,       buf + 512,        448 * sizeof(float));
-        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));
-    } else { // LONG_STOP or ONLY_LONG
-        memcpy(                    saved,       buf + 512,        512 * sizeof(float));
-    }
-}
-
-/**
- * Apply dependent channel coupling (applied before IMDCT).
- *
- * @param   index   index into coupling gain array
- */
-static void apply_dependent_coupling(AACContext *ac,
-                                     SingleChannelElement *target,
-                                     ChannelElement *cce, int index)
-{
-    IndividualChannelStream *ics = &cce->ch[0].ics;
-    const uint16_t *offsets = ics->swb_offset;
-    float *dest = target->coeffs;
-    const float *src = cce->ch[0].coeffs;
-    int g, i, group, k, idx = 0;
-    if (ac->m4ac.object_type == AOT_AAC_LTP) {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Dependent coupling is not supported together with LTP\n");
-        return;
-    }
-    for (g = 0; g < ics->num_window_groups; g++) {
-        for (i = 0; i < ics->max_sfb; i++, idx++) {
-            if (cce->ch[0].band_type[idx] != ZERO_BT) {
-                const float gain = cce->coup.gain[index][idx];
-                for (group = 0; group < ics->group_len[g]; group++) {
-                    for (k = offsets[i]; k < offsets[i + 1]; k++) {
-                        // XXX dsputil-ize
-                        dest[group * 128 + k] += gain * src[group * 128 + k];
-                    }
-                }
-            }
-        }
-        dest += ics->group_len[g] * 128;
-        src  += ics->group_len[g] * 128;
-    }
-}
-
-/**
- * Apply independent channel coupling (applied after IMDCT).
- *
- * @param   index   index into coupling gain array
- */
-static void apply_independent_coupling(AACContext *ac,
-                                       SingleChannelElement *target,
-                                       ChannelElement *cce, int index)
-{
-    int i;
-    const float gain = cce->coup.gain[index][0];
-    const float *src = cce->ch[0].ret;
-    float *dest = target->ret;
-    const int len = 1024 << (ac->m4ac.sbr == 1);
-
-    for (i = 0; i < len; i++)
-        dest[i] += gain * src[i];
-}
-
-/**
- * channel coupling transformation interface
- *
- * @param   apply_coupling_method   pointer to (in)dependent coupling function
- */
-static void apply_channel_coupling(AACContext *ac, ChannelElement *cc,
-                                   enum RawDataBlockType type, int elem_id,
-                                   enum CouplingPoint coupling_point,
-                                   void (*apply_coupling_method)(AACContext *ac, SingleChannelElement *target, ChannelElement *cce, int index))
-{
-    int i, c;
-
-    for (i = 0; i < MAX_ELEM_ID; i++) {
-        ChannelElement *cce = ac->che[TYPE_CCE][i];
-        int index = 0;
-
-        if (cce && cce->coup.coupling_point == coupling_point) {
-            ChannelCoupling *coup = &cce->coup;
-
-            for (c = 0; c <= coup->num_coupled; c++) {
-                if (coup->type[c] == type && coup->id_select[c] == elem_id) {
-                    if (coup->ch_select[c] != 1) {
-                        apply_coupling_method(ac, &cc->ch[0], cce, index);
-                        if (coup->ch_select[c] != 0)
-                            index++;
-                    }
-                    if (coup->ch_select[c] != 2)
-                        apply_coupling_method(ac, &cc->ch[1], cce, index++);
-                } else
-                    index += 1 + (coup->ch_select[c] == 3);
-            }
-        }
-    }
-}
-
-/**
- * Convert spectral data to float samples, applying all supported tools as appropriate.
- */
-static void spectral_to_sample(AACContext *ac)
-{
-    int i, type;
-    for (type = 3; type >= 0; type--) {
+#endif
+        memcpy(                     saved + 448, buf + 7*128 + 64,  64 * sizeof(INTFLOAT));                                                              
+    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {                                                                                         
+        memcpy(                     saved,       buf + 512,        448 * sizeof(INTFLOAT));                                                              
+        memcpy(                     saved + 448, buf + 7*128 + 64,  64 * sizeof(INTFLOAT));                                                              
+    } else { // LONG_STOP or ONLY_LONG                                                                                                                   
+        memcpy(                     saved,       buf + 512,        512 * sizeof(INTFLOAT));                                                              
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * channel coupling transformation interface                                                                                                             
+ *                                                                                                                                                       
+ *  <at> param   apply_coupling_method   pointer to (in)dependent coupling function                                                                      
+ */                                                                                                                                                      
+static void apply_channel_coupling(AACContext *ac, ChannelElement *cc,                                                                                   
+                                   enum RawDataBlockType type, int elem_id,                                                                              
+                                   enum CouplingPoint coupling_point,                                                                                    
+                                   void (*apply_coupling_method)(AACContext *ac, SingleChannelElement *target, ChannelElement *cce, int index))          
+{                                                                                                                                                        
+    int i, c;                                                                                                                                            
+                                                                                                                                                         
+    for (i = 0; i < MAX_ELEM_ID; i++) {                                                                                                                  
+        ChannelElement *cce = ac->che[TYPE_CCE][i];                                                                                                      
+        int index = 0;                                                                                                                                   
+                                                                                                                                                         
+        if (cce && cce->coup.coupling_point == coupling_point) {                                                                                         
+            ChannelCoupling *coup = &cce->coup;                                                                                                          
+                                                                                                                                                         
+            for (c = 0; c <= coup->num_coupled; c++) {                                                                                                   
+                if (coup->type[c] == type && coup->id_select[c] == elem_id) {                                                                            
+                    if (coup->ch_select[c] != 1) {                                                                                                       
+                        apply_coupling_method(ac, &cc->ch[0], cce, index);                                                                               
+                        if (coup->ch_select[c] != 0)                                                                                                     
+                            index++;                                                                                                                     
+                    }                                                                                                                                    
+                    if (coup->ch_select[c] != 2)                                                                                                         
+                        apply_coupling_method(ac, &cc->ch[1], cce, index++);                                                                             
+                } else                                                                                                                                   
+                    index += 1 + (coup->ch_select[c] == 3);                                                                                              
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+/**                                                                                                                                                      
+ * Convert spectral data to samples, applying all supported tools as appropriate.                                                                        
+ */static int cccc=0;                                    
+static void spectral_to_sample(AACContext *ac)                                                                                                           
+{                                                                                                                                                        
+    int i, type;                                                                                                                                         
+    for (type = 3; type >= 0; type--) {                                                                                                                  
         for (i = 0; i < MAX_ELEM_ID; i++) {
-            ChannelElement *che = ac->che[type][i];
-            if (che) {
+            ChannelElement *che = ac->che[type][i];                                                                                                      
+            if (che) { 
                 if (type <= TYPE_CPE)
-                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, apply_dependent_coupling);
-                if (ac->m4ac.object_type == AOT_AAC_LTP) {
+                    apply_channel_coupling(ac, che, type, i, BEFORE_TNS, AAC_RENAME(apply_dependent_coupling));                                          
+                if (ac->oc[1].m4ac.object_type == AOT_AAC_LTP) {
                     if (che->ch[0].ics.predictor_present) {
                         if (che->ch[0].ics.ltp.present)
-                            apply_ltp(ac, &che->ch[0]);
-                        if (che->ch[1].ics.ltp.present && type == TYPE_CPE)
-                            apply_ltp(ac, &che->ch[1]);
+                            apply_ltp(ac, &che->ch[0]);                                                                                              
+                        if (che->ch[1].ics.ltp.present && type == TYPE_CPE)                                                                              
+                            apply_ltp(ac, &che->ch[1]);                                                                                              
                     }
                 }
-                if (che->ch[0].tns.present)
-                    apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1);
+                if (che->ch[0].tns.present) 
+                    apply_tns(che->ch[0].coeffs, &che->ch[0].tns, &che->ch[0].ics, 1);                                                               
                 if (che->ch[1].tns.present)
-                    apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1);
+                    apply_tns(che->ch[1].coeffs, &che->ch[1].tns, &che->ch[1].ics, 1);                                                               
                 if (type <= TYPE_CPE)
-                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, apply_dependent_coupling);
-                if (type != TYPE_CCE || che->coup.coupling_point == AFTER_IMDCT) {
+                    apply_channel_coupling(ac, che, type, i, BETWEEN_TNS_AND_IMDCT, AAC_RENAME(apply_dependent_coupling));                               
+                if (type != TYPE_CCE || che->coup.coupling_point == AFTER_IMDCT) { 
                     imdct_and_windowing(ac, &che->ch[0]);
-                    if (ac->m4ac.object_type == AOT_AAC_LTP)
+                    if (ac->oc[1].m4ac.object_type == AOT_AAC_LTP)
                         update_ltp(ac, &che->ch[0]);
                     if (type == TYPE_CPE) {
                         imdct_and_windowing(ac, &che->ch[1]);
-                        if (ac->m4ac.object_type == AOT_AAC_LTP)
-                            update_ltp(ac, &che->ch[1]);
-                    }
-                    if (ac->m4ac.sbr > 0) {
-                        ff_sbr_apply(ac, &che->sbr, type, che->ch[0].ret, che->ch[1].ret);
+                        if (ac->oc[1].m4ac.object_type == AOT_AAC_LTP)
+                            update_ltp(ac, &che->ch[1]);                                                                                             
+                    } 
+                    if (ac->oc[1].m4ac.sbr > 0) {
+                        AAC_RENAME(ff_sbr_apply)(ac, &che->sbr, type, che->ch[0].ret, che->ch[1].ret);                                                   
                     }
                 }
-                if (type <= TYPE_CCE)
-                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, apply_independent_coupling);
-            }
-        }
-    }
-}
-
-static int parse_adts_frame_header(AACContext *ac, GetBitContext *gb)
-{
-    int size;
-    AACADTSHeaderInfo hdr_info;
-
-    size = ff_aac_parse_header(gb, &hdr_info);
-    if (size > 0) {
-        if (ac->output_configured != OC_LOCKED && hdr_info.chan_config) {
-            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-            ac->m4ac.chan_config = hdr_info.chan_config;
-            if (set_default_channel_config(ac->avctx, new_che_pos, hdr_info.chan_config))
-                return -7;
-            if (output_configure(ac, ac->che_pos, new_che_pos, hdr_info.chan_config, OC_TRIAL_FRAME))
-                return -7;
-        } else if (ac->output_configured != OC_LOCKED) {
-            ac->output_configured = OC_NONE;
-        }
-        if (ac->output_configured != OC_LOCKED) {
-            ac->m4ac.sbr = -1;
-            ac->m4ac.ps  = -1;
-        }
-        ac->m4ac.sample_rate     = hdr_info.sample_rate;
-        ac->m4ac.sampling_index  = hdr_info.sampling_index;
-        ac->m4ac.object_type     = hdr_info.object_type;
-        if (!ac->avctx->sample_rate)
-            ac->avctx->sample_rate = hdr_info.sample_rate;
-        if (hdr_info.num_aac_frames == 1) {
-            if (!hdr_info.crc_absent)
-                skip_bits(gb, 16);
-        } else {
-            av_log_missing_feature(ac->avctx, "More than one AAC RDB per ADTS frame is", 0);
-            return -1;
-        }
-    }
-    return size;
-}
-
-static int aac_decode_frame_int(AVCodecContext *avctx, void *data,
-                                int *data_size, GetBitContext *gb)
-{
-    AACContext *ac = avctx->priv_data;
-    ChannelElement *che = NULL, *che_prev = NULL;
-    enum RawDataBlockType elem_type, elem_type_prev = TYPE_END;
-    int err, elem_id, data_size_tmp;
-    int samples = 0, multiplier, audio_found = 0;
-
-    if (show_bits(gb, 12) == 0xfff) {
-        if (parse_adts_frame_header(ac, gb) < 0) {
-            av_log(avctx, AV_LOG_ERROR, "Error decoding AAC frame header.\n");
-            return -1;
-        }
-        if (ac->m4ac.sampling_index > 12) {
-            av_log(ac->avctx, AV_LOG_ERROR, "invalid sampling rate index %d\n", ac->m4ac.sampling_index);
-            return -1;
-        }
-    }
-
-    ac->tags_mapped = 0;
-    // parse
-    while ((elem_type = get_bits(gb, 3)) != TYPE_END) {
-        elem_id = get_bits(gb, 4);
-
-        if (elem_type < TYPE_DSE) {
-            if (!(che=get_che(ac, elem_type, elem_id))) {
-                av_log(ac->avctx, AV_LOG_ERROR, "channel element %d.%d is not allocated\n",
-                       elem_type, elem_id);
-                return -1;
-            }
-            samples = 1024;
-        }
-
-        switch (elem_type) {
-
-        case TYPE_SCE:
-            err = decode_ics(ac, &che->ch[0], gb, 0, 0);
-            audio_found = 1;
-            break;
-
-        case TYPE_CPE:
-            err = decode_cpe(ac, gb, che);
-            audio_found = 1;
-            break;
-
-        case TYPE_CCE:
-            err = decode_cce(ac, gb, che);
-            break;
-
-        case TYPE_LFE:
-            err = decode_ics(ac, &che->ch[0], gb, 0, 0);
-            audio_found = 1;
-            break;
-
-        case TYPE_DSE:
-            err = skip_data_stream_element(ac, gb);
-            break;
-
-        case TYPE_PCE: {
-            enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
-            memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
-            if ((err = decode_pce(avctx, &ac->m4ac, new_che_pos, gb)))
-                break;
-            if (ac->output_configured > OC_TRIAL_PCE)
-                av_log(avctx, AV_LOG_ERROR,
-                       "Not evaluating a further program_config_element as this construct is dubious at best.\n");
-            else
-                err = output_configure(ac, ac->che_pos, new_che_pos, 0, OC_TRIAL_PCE);
-            break;
-        }
-
-        case TYPE_FIL:
-            if (elem_id == 15)
-                elem_id += get_bits(gb, 8) - 1;
-            if (get_bits_left(gb) < 8 * elem_id) {
-                    av_log(avctx, AV_LOG_ERROR, overread_err);
-                    return -1;
-            }
-            while (elem_id > 0)
-                elem_id -= decode_extension_payload(ac, gb, elem_id, che_prev, elem_type_prev);
-            err = 0; /* FIXME */
-            break;
-
-        default:
-            err = -1; /* should not happen, but keeps compiler happy */
-            break;
-        }
-
-        che_prev       = che;
-        elem_type_prev = elem_type;
-
-        if (err)
-            return err;
-
-        if (get_bits_left(gb) < 3) {
-            av_log(avctx, AV_LOG_ERROR, overread_err);
-            return -1;
-        }
+                if (type <= TYPE_CCE)                                                                                                                    
+                    apply_channel_coupling(ac, che, type, i, AFTER_IMDCT, AAC_RENAME(apply_independent_coupling));                                       
+                                                                                                                                                         
+#if CONFIG_AAC_FIXED                                                                                                                                     
+                {                                                                                                                                        
+                int j; 
+                /* preparation for resampler */                                                                                                          
+                for(j = 0; j<2048; j++){                                                                                                                 
+                    che->ch[0].ret[j] = (int32_t)av_clipl_int32((int64_t)che->ch[0].ret[j]<<6)+0x8000; 
+                    che->ch[1].ret[j] = (int32_t)av_clipl_int32((int64_t)che->ch[1].ret[j]<<6)+0x8000;
+                }                                                                                                                                        
+                } //av_log(NULL,AV_LOG_INFO," \n================type=%d=======i=%d=======\n",type,i);
+#endif /* CONFIG_AAC_FIXED */                                                                                                                            
+            }                                                                                                                                            
+        }                                                                                                                                                
+    }
+
+}                                                                                                                                                        
+                                                                                                                                                         
+static int parse_adts_frame_header(AACContext *ac, GetBitContext *gb)                                                                                    
+{                                                                                                                                                        
+    int size;                                                                                                                                            
+    AACADTSHeaderInfo hdr_info;                                                                                                                          
+    uint8_t layout_map[MAX_ELEM_ID*4][3];                                                                                                                
+    int layout_map_tags;                                                                                                                                 
+                                                                                                                                                         
+    size = ff_aac_parse_header(gb, &hdr_info);                                                                                                       
+    if (size > 0) {                                                                                                                                      
+        if (!ac->warned_num_aac_frames && hdr_info.num_aac_frames != 1) {                                                                                
+            // This is 2 for "VLB " audio in NSV files.                                                                                                  
+            // See samples/nsv/vlb_audio.                                                                                                                
+            av_log_missing_feature(ac->avctx, "More than one AAC RDB per ADTS frame", 0);                                                                       
+            ac->warned_num_aac_frames = 1;                                                                                                               
+        }                                                                                                                                                
+        push_output_configuration(ac);                                                                                                                   
+        if (hdr_info.chan_config) {                                                                                                                      
+            ac->oc[1].m4ac.chan_config = hdr_info.chan_config;                                                                                           
+            if (set_default_channel_config(ac->avctx, layout_map,                                                                                        
+                    &layout_map_tags, hdr_info.chan_config))                                                                                             
+                return -7;                                                                                                                               
+            if (output_configure(ac, layout_map, layout_map_tags,                                                                                        
+                                 FFMAX(ac->oc[1].status, OC_TRIAL_FRAME), 0))                                                                            
+                return -7;                                                                                                                               
+        } else {                                                                                                                                         
+            ac->oc[1].m4ac.chan_config = 0;                                                                                                              
+            /**                                                                                                                                          
+             * dual mono frames in Japanese DTV can have chan_config 0                                                                                   
+             * WITHOUT specifying PCE.                                                                                                                   
+             *  thus, set dual mono as default.                                                                                                          
+             */                                                                                                                                          
+            if (ac->dmono_mode && ac->oc[0].status == OC_NONE) {                                                                                         
+                layout_map_tags = 2;                                                                                                                     
+                layout_map[0][0] = layout_map[1][0] = TYPE_SCE;                                                                                          
+                layout_map[0][2] = layout_map[1][2] = AAC_CHANNEL_FRONT;                                                                                 
+                layout_map[0][1] = 0;                                                                                                                    
+                layout_map[1][1] = 1;                                                                                                                    
+                if (output_configure(ac, layout_map, layout_map_tags,                                                                                    
+                                     OC_TRIAL_FRAME, 0))                                                                                                 
+                    return -7;                                                                                                                           
+            }                                                                                                                                            
+        }                                                                                                                                                
+        ac->oc[1].m4ac.sample_rate     = hdr_info.sample_rate;                                                                                           
+        ac->oc[1].m4ac.sampling_index  = hdr_info.sampling_index;                                                                                        
+        ac->oc[1].m4ac.object_type     = hdr_info.object_type;                                                                                           
+        if (ac->oc[0].status != OC_LOCKED ||                                                                                                             
+            ac->oc[0].m4ac.chan_config != hdr_info.chan_config ||                                                                                        
+            ac->oc[0].m4ac.sample_rate != hdr_info.sample_rate) {                                                                                        
+            ac->oc[1].m4ac.sbr = -1;                                                                                                                     
+            ac->oc[1].m4ac.ps  = -1;                                                                                                                     
+        }                                                                                                                                                
+        if (!hdr_info.crc_absent)                                                                                                                        
+            skip_bits(gb, 16);                                                                                                                           
+    }                                                                                                                                                    
+    return size;                                                                                                                                         
+}                                                                                                                                                        
+                                                                                                                                                         
+static int aac_decode_frame_int(AVCodecContext *avctx, void *data,                                                                                       
+                                int *got_frame_ptr, GetBitContext *gb, AVPacket *avpkt)                                                                  
+{                                                                                                                                                        
+    AACContext *ac = avctx->priv_data;                                                                                                                   
+    ChannelElement *che = NULL, *che_prev = NULL;                                                                                                        
+    enum RawDataBlockType elem_type, elem_type_prev = TYPE_END;                                                                                          
+    int err, elem_id;
+    int16_t *out_samples_s16 = data;
+    int samples = 0, multiplier, audio_found = 0, pce_found = 0;                                                                                         
+    int is_dmono, sce_count = 0,j;                                                                                                                         
+                                                                                                                                                         
+   // ac->frame = *(AVFrame *)data;                                                                                                                                    
+                                                                                                                                                         
+    if (show_bits(gb, 12) == 0xfff) {                                                                                                                    
+        if (parse_adts_frame_header(ac, gb) < 0) {                                                                                                       
+            av_log(avctx, AV_LOG_ERROR, "Error decoding AAC frame header.\n");                                                                           
+            err = -1;                                                                                                                                    
+            goto fail;                                                                                                                                   
+        }                                                                                                                                                
+        if (ac->oc[1].m4ac.sampling_index > 12) {                                                                                                        
+            av_log(ac->avctx, AV_LOG_ERROR, "invalid sampling rate index %d\n", ac->oc[1].m4ac.sampling_index);                                          
+            err = -1;                                                                                                                                    
+            goto fail;                                                                                                                                   
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    /*if (frame_configure_elements(avctx) < 0) {                                                                                                           
+        err = -1;                                                                                                                                        
+        goto fail;                                                                                                                                       
+    } */                                                                            
+                                                                                                                                                         
+    ac->tags_mapped = 0;                                                                                                                                 
+    // parse                                                                                                                                             
+    while ((elem_type = get_bits(gb, 3)) != TYPE_END) {                                                                                                  
+        elem_id = get_bits(gb, 4);                                                                                                                       
+                                                                                                                                                         
+        if (elem_type < TYPE_DSE) {                                                                                                                      
+            if (!(che=get_che(ac, elem_type, elem_id))) {                                                                                                
+                av_log(ac->avctx, AV_LOG_ERROR, "channel element %d.%d is not allocated\n",                                                              
+                       elem_type, elem_id);                                                                                                              
+                err = -1;                                                                                                                                
+                goto fail;                                                                                                                               
+            }                                                                                                                                            
+            samples = 1024;                                                                                                                              
+        }                                                                                                                                                
+                                                                                                                                                         
+        switch (elem_type) {                                                                                                                             
+                                                                                                                                                         
+        case TYPE_SCE:                                                                                                                                   
+            err = decode_ics(ac, &che->ch[0], gb, 0, 0);                                                                                                 
+            audio_found = 1;                                                                                                                             
+            sce_count++;                                                                                                                                 
+            break;                                                                                                                                       
+                                                                                                                                                         
+        case TYPE_CPE:                                                                                                                                   
+            err = decode_cpe(ac, gb, che);                                                                                                               
+            audio_found = 1;                                                                                                                             
+            break;                                                                                                                                       
+                                                                                                                                                         
+        case TYPE_CCE:                                                                                                                                   
+            err = decode_cce(ac, gb, che);                                                                                                               
+            break;                                                                                                                                       
+                                                                                                                                                         
+        case TYPE_LFE:                                                                                                                                   
+            err = decode_ics(ac, &che->ch[0], gb, 0, 0);                                                                                                 
+            audio_found = 1;                                                                                                                             
+            break;                                                                                                                                       
+                                                                                                                                                         
+        case TYPE_DSE:                                                                                                                                   
+            err = skip_data_stream_element(ac, gb);                                                                                                      
+            break;                                                                                                                                       
+                                                                                                                                                         
+        case TYPE_PCE: {                                                                                                                                 
+            uint8_t layout_map[MAX_ELEM_ID*4][3];                                                                                                        
+            int tags;                                                                                                                                    
+            push_output_configuration(ac);                                                                                                               
+            tags = decode_pce(avctx, &ac->oc[1].m4ac, layout_map, gb);                                                                                   
+            if (tags < 0) {                                                                                                                              
+                err = tags;                                                                                                                              
+                break;                                                                                                                                   
+            }                                                                                                                                            
+            if (pce_found) {                                                                                                                             
+                av_log(avctx, AV_LOG_ERROR,                                                                                                              
+                       "Not evaluating a further program_config_element as this construct is dubious at best.\n");                                       
+            } else {                                                                                                                                     
+                err = output_configure(ac, layout_map, tags, OC_TRIAL_PCE, 1);                                                                           
+                if (!err)                                                                                                                                
+                    ac->oc[1].m4ac.chan_config = 0;                                                                                                      
+                pce_found = 1;                                                                                                                           
+            }                                                                                                                                            
+            break;                                                                                                                                       
+        }                                                                                                                                                
+                                                                                                                                                         
+        case TYPE_FIL:                                                                                                                                   
+            if (elem_id == 15)                                                                                                                           
+                elem_id += get_bits(gb, 8) - 1;                                                                                                          
+            if (get_bits_left(gb) < 8 * elem_id) {                                                                                                       
+                    av_log(avctx, AV_LOG_ERROR, "TYPE_FIL: "overread_err);                                                                               
+                    err = -1;                                                                                                                            
+                    goto fail;                                                                                                                           
+            }                                                                                                                                            
+            while (elem_id > 0)                                                                                                                          
+                elem_id -= decode_extension_payload(ac, gb, elem_id, che_prev, elem_type_prev);                                                          
+            err = 0; /* FIXME */                                                                                                                         
+            break;                                                                                                                                       
+                                                                                                                                                         
+        default:                                                                                                                                         
+            err = -1; /* should not happen, but keeps compiler happy */                                                                                  
+            break;                                                                                                                                       
+        }                                                                                                                                                
+                                                                                                                                                         
+        che_prev       = che;                                                                                                                            
+        elem_type_prev = elem_type;                                                                                                                      
+                                                                                                                                                         
+        if (err)                                                                                                                                         
+            goto fail;                                                                                                                                   
+                                                                                                                                                         
+        if (get_bits_left(gb) < 3) {                                                                                                                     
+            av_log(avctx, AV_LOG_ERROR, overread_err);                                                                                                   
+            err = -1;                                                                                                                                    
+            goto fail;                                                                                                                                   
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    spectral_to_sample(ac);                                                                                                                              
+                                                                                                                                                         
+    multiplier = (ac->oc[1].m4ac.sbr == 1) ? ac->oc[1].m4ac.ext_sample_rate > ac->oc[1].m4ac.sample_rate : 0;                                            
+    samples <<= multiplier; 
+    /* for dual-mono audio (SCE + SCE) */                                                                                                                
+    is_dmono = ac->dmono_mode && sce_count == 2 &&                                                                                                       
+               ac->oc[1].channel_layout == (AV_CH_FRONT_LEFT | AV_CH_FRONT_RIGHT); 
+                                                                      
+    if (ac->oc[1].status && audio_found) {                                                                                                               
+        avctx->sample_rate = ac->oc[1].m4ac.sample_rate << multiplier;
+        avctx->frame_size = samples;                                                                                                                     
+        ac->oc[1].status = OC_LOCKED;                                                                                                                    
     }
 
-    spectral_to_sample(ac);
-
-    multiplier = (ac->m4ac.sbr == 1) ? ac->m4ac.ext_sample_rate > ac->m4ac.sample_rate : 0;
-    samples <<= multiplier;
-    if (ac->output_configured < OC_LOCKED) {
-        avctx->sample_rate = ac->m4ac.sample_rate << multiplier;
-        avctx->frame_size = samples;
-    }
-
-    data_size_tmp = samples * avctx->channels *
-                    av_get_bytes_per_sample(avctx->sample_fmt);
-    if (*data_size < data_size_tmp) {
-        av_log(avctx, AV_LOG_ERROR,
-               "Output buffer too small (%d) or trying to output too many samples (%d) for this frame.\n",
-               *data_size, data_size_tmp);
-        return -1;
+    if (samples) {
+        ac->frame.nb_samples = samples;
+        *(AVFrame *)data = ac->frame;
     }
-    *data_size = data_size_tmp;
 
+    *got_frame_ptr = samples * avctx->channels *
+                    av_get_bytes_per_sample(avctx->sample_fmt);//S16
+//    if(cccc>5)
+ /*  for(j = 0; j < 128; j++)
+    {
+        av_log(NULL,AV_LOG_INFO," [%d]%08x, ",j,*((ac->output_element)[0]+j),*((ac->output_element)[1]+j));
+    }av_log(NULL,AV_LOG_INFO,"\n--------------------------------\n");*/
     if (samples) {
         if (avctx->sample_fmt == AV_SAMPLE_FMT_FLT)
-            ac->fmt_conv.float_interleave(data, (const float **)ac->output_data,
-                                          samples, avctx->channels);
+         fixed_to_int16_interleave_aac(out_samples_s16, (const int **)ac->output_element,
+                                          samples, avctx->channels,multiplier);
         else
-            ac->fmt_conv.float_to_int16_interleave(data, (const float **)ac->output_data,
-                                                   samples, avctx->channels);
-    }
-
-    if (ac->output_configured && audio_found)
-        ac->output_configured = OC_LOCKED;
-
-    return 0;
-}
-
-static int aac_decode_frame(AVCodecContext *avctx, void *data,
-                            int *data_size, AVPacket *avpkt)
-{
-    const uint8_t *buf = avpkt->data;
-    int buf_size = avpkt->size;
-    GetBitContext gb;
-    int buf_consumed;
-    int buf_offset;
-    int err;
-
-    init_get_bits(&gb, buf, buf_size * 8);
-
-    if ((err = aac_decode_frame_int(avctx, data, data_size, &gb)) < 0)
-        return err;
-
-    buf_consumed = (get_bits_count(&gb) + 7) >> 3;
-    for (buf_offset = buf_consumed; buf_offset < buf_size; buf_offset++)
-        if (buf[buf_offset])
-            break;
-
-    return buf_size > buf_offset ? buf_consumed : buf_size;
-}
-
-static av_cold int aac_decode_close(AVCodecContext *avctx)
-{
-    AACContext *ac = avctx->priv_data;
-    int i, type;
-
-    for (i = 0; i < MAX_ELEM_ID; i++) {
-        for (type = 0; type < 4; type++) {
-            if (ac->che[type][i])
-                ff_aac_sbr_ctx_close(&ac->che[type][i]->sbr);
-            av_freep(&ac->che[type][i]);
-        }
-    }
-
-    ff_mdct_end(&ac->mdct);
-    ff_mdct_end(&ac->mdct_small);
-    ff_mdct_end(&ac->mdct_ltp);
-    return 0;
-}
-
-
-#define LOAS_SYNC_WORD   0x2b7       ///< 11 bits LOAS sync word
-
-struct LATMContext {
-    AACContext      aac_ctx;             ///< containing AACContext
-    int             initialized;         ///< initilized after a valid extradata was seen
-
-    // parser data
-    int             audio_mux_version_A; ///< LATM syntax version
-    int             frame_length_type;   ///< 0/1 variable/fixed frame length
-    int             frame_length;        ///< frame length for fixed frame length
-};
-
-static inline uint32_t latm_get_value(GetBitContext *b)
-{
-    int length = get_bits(b, 2);
-
-    return get_bits_long(b, (length+1)*8);
-}
-
-static int latm_decode_audio_specific_config(struct LATMContext *latmctx,
-                                             GetBitContext *gb)
-{
-    AVCodecContext *avctx = latmctx->aac_ctx.avctx;
-    MPEG4AudioConfig m4ac;
-    int  config_start_bit = get_bits_count(gb);
-    int     bits_consumed, esize;
-
-    if (config_start_bit % 8) {
-        av_log_missing_feature(latmctx->aac_ctx.avctx, "audio specific "
-                               "config not byte aligned.\n", 1);
-        return AVERROR_INVALIDDATA;
-    } else {
-        bits_consumed =
-            decode_audio_specific_config(NULL, avctx, &m4ac,
-                                         gb->buffer + (config_start_bit / 8),
-                                         get_bits_left(gb) / 8);
-
-        if (bits_consumed < 0)
-            return AVERROR_INVALIDDATA;
-
-        esize = (bits_consumed+7) / 8;
-
-        if (avctx->extradata_size <= esize) {
-            av_free(avctx->extradata);
-            avctx->extradata = av_malloc(esize + FF_INPUT_BUFFER_PADDING_SIZE);
-            if (!avctx->extradata)
-                return AVERROR(ENOMEM);
-        }
-
-        avctx->extradata_size = esize;
-        memcpy(avctx->extradata, gb->buffer + (config_start_bit/8), esize);
-        memset(avctx->extradata+esize, 0, FF_INPUT_BUFFER_PADDING_SIZE);
-
-        skip_bits_long(gb, bits_consumed);
-    }
-
-    return bits_consumed;
-}
-
-static int read_stream_mux_config(struct LATMContext *latmctx,
-                                  GetBitContext *gb)
-{
-    int ret, audio_mux_version = get_bits(gb, 1);
-
-    latmctx->audio_mux_version_A = 0;
-    if (audio_mux_version)
-        latmctx->audio_mux_version_A = get_bits(gb, 1);
-
-    if (!latmctx->audio_mux_version_A) {
-
-        if (audio_mux_version)
-            latm_get_value(gb);                 // taraFullness
-
-        skip_bits(gb, 1);                       // allStreamSameTimeFraming
-        skip_bits(gb, 6);                       // numSubFrames
-        // numPrograms
-        if (get_bits(gb, 4)) {                  // numPrograms
-            av_log_missing_feature(latmctx->aac_ctx.avctx,
-                                   "multiple programs are not supported\n", 1);
-            return AVERROR_PATCHWELCOME;
-        }
-
-        // for each program (which there is only on in DVB)
-
-        // for each layer (which there is only on in DVB)
-        if (get_bits(gb, 3)) {                   // numLayer
-            av_log_missing_feature(latmctx->aac_ctx.avctx,
-                                   "multiple layers are not supported\n", 1);
-            return AVERROR_PATCHWELCOME;
-        }
-
-        // for all but first stream: use_same_config = get_bits(gb, 1);
-        if (!audio_mux_version) {
-            if ((ret = latm_decode_audio_specific_config(latmctx, gb)) < 0)
-                return ret;
-        } else {
-            int ascLen = latm_get_value(gb);
-            if ((ret = latm_decode_audio_specific_config(latmctx, gb)) < 0)
-                return ret;
-            ascLen -= ret;
-            skip_bits_long(gb, ascLen);
-        }
-
-        latmctx->frame_length_type = get_bits(gb, 3);
-        switch (latmctx->frame_length_type) {
-        case 0:
-            skip_bits(gb, 8);       // latmBufferFullness
-            break;
-        case 1:
-            latmctx->frame_length = get_bits(gb, 9);
-            break;
-        case 3:
-        case 4:
-        case 5:
-            skip_bits(gb, 6);       // CELP frame length table index
-            break;
-        case 6:
-        case 7:
-            skip_bits(gb, 1);       // HVXC frame length table index
-            break;
-        }
-
-        if (get_bits(gb, 1)) {                  // other data
-            if (audio_mux_version) {
-                latm_get_value(gb);             // other_data_bits
-            } else {
-                int esc;
-                do {
-                    esc = get_bits(gb, 1);
-                    skip_bits(gb, 8);
-                } while (esc);
-            }
-        }
-
-        if (get_bits(gb, 1))                     // crc present
-            skip_bits(gb, 8);                    // config_crc
-    }
-
-    return 0;
-}
-
-static int read_payload_length_info(struct LATMContext *ctx, GetBitContext *gb)
-{
-    uint8_t tmp;
-
-    if (ctx->frame_length_type == 0) {
-        int mux_slot_length = 0;
-        do {
-            tmp = get_bits(gb, 8);
-            mux_slot_length += tmp;
-        } while (tmp == 255);
-        return mux_slot_length;
-    } else if (ctx->frame_length_type == 1) {
-        return ctx->frame_length;
-    } else if (ctx->frame_length_type == 3 ||
-               ctx->frame_length_type == 5 ||
-               ctx->frame_length_type == 7) {
-        skip_bits(gb, 2);          // mux_slot_length_coded
-    }
-    return 0;
-}
-
-static int read_audio_mux_element(struct LATMContext *latmctx,
-                                  GetBitContext *gb)
-{
-    int err;
-    uint8_t use_same_mux = get_bits(gb, 1);
-    if (!use_same_mux) {
-        if ((err = read_stream_mux_config(latmctx, gb)) < 0)
-            return err;
-    } else if (!latmctx->aac_ctx.avctx->extradata) {
-        av_log(latmctx->aac_ctx.avctx, AV_LOG_DEBUG,
-               "no decoder config found\n");
-        return AVERROR(EAGAIN);
-    }
-    if (latmctx->audio_mux_version_A == 0) {
-        int mux_slot_length_bytes = read_payload_length_info(latmctx, gb);
-        if (mux_slot_length_bytes * 8 > get_bits_left(gb)) {
-            av_log(latmctx->aac_ctx.avctx, AV_LOG_ERROR, "incomplete frame\n");
-            return AVERROR_INVALIDDATA;
-        } else if (mux_slot_length_bytes * 8 + 256 < get_bits_left(gb)) {
-            av_log(latmctx->aac_ctx.avctx, AV_LOG_ERROR,
-                   "frame length mismatch %d << %d\n",
-                   mux_slot_length_bytes * 8, get_bits_left(gb));
-            return AVERROR_INVALIDDATA;
-        }
-    }
-    return 0;
-}
-
-
-static int latm_decode_frame(AVCodecContext *avctx, void *out, int *out_size,
-                             AVPacket *avpkt)
-{
-    struct LATMContext *latmctx = avctx->priv_data;
-    int                 muxlength, err;
-    GetBitContext       gb;
-
-    if (avpkt->size == 0)
-        return 0;
-
-    init_get_bits(&gb, avpkt->data, avpkt->size * 8);
-
-    // check for LOAS sync word
-    if (get_bits(&gb, 11) != LOAS_SYNC_WORD)
-        return AVERROR_INVALIDDATA;
-
-    muxlength = get_bits(&gb, 13) + 3;
-    // not enough data, the parser should have sorted this
-    if (muxlength > avpkt->size)
-        return AVERROR_INVALIDDATA;
-
-    if ((err = read_audio_mux_element(latmctx, &gb)) < 0)
-        return err;
-
-    if (!latmctx->initialized) {
-        if (!avctx->extradata) {
-            *out_size = 0;
-            return avpkt->size;
-        } else {
-            aac_decode_close(avctx);
-            if ((err = aac_decode_init(avctx)) < 0)
-                return err;
-            latmctx->initialized = 1;
-        }
-    }
-
-    if (show_bits(&gb, 12) == 0xfff) {
-        av_log(latmctx->aac_ctx.avctx, AV_LOG_ERROR,
-               "ADTS header detected, probably as result of configuration "
-               "misparsing\n");
-        return AVERROR_INVALIDDATA;
-    }
-
-    if ((err = aac_decode_frame_int(avctx, out, out_size, &gb)) < 0)
-        return err;
-
-    return muxlength;
-}
-
-av_cold static int latm_decode_init(AVCodecContext *avctx)
-{
-    struct LATMContext *latmctx = avctx->priv_data;
-    int ret;
-
-    ret = aac_decode_init(avctx);
-
-    if (avctx->extradata_size > 0) {
-        latmctx->initialized = !ret;
-    } else {
-        latmctx->initialized = 0;
-    }
-
-    return ret;
-}
-
-
-AVCodec ff_aac_decoder = {
-    "aac",
-    AVMEDIA_TYPE_AUDIO,
-    CODEC_ID_AAC,
-    sizeof(AACContext),
-    aac_decode_init,
-    NULL,
-    aac_decode_close,
-    aac_decode_frame,
-    .long_name = NULL_IF_CONFIG_SMALL("Advanced Audio Coding"),
-    .sample_fmts = (const enum AVSampleFormat[]) {
-        AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE
-    },
-    .channel_layouts = aac_channel_layout,
-};
-
-/*
-    Note: This decoder filter is intended to decode LATM streams transferred
-    in MPEG transport streams which only contain one program.
-    To do a more complex LATM demuxing a separate LATM demuxer should be used.
+            fixed_to_int16_interleave_aac(out_samples_s16, (const int **)ac->output_element,
+                                           samples, avctx->channels,multiplier);
+    }/* */
+
+    /*if (multiplier) {                                                                                                                                    
+        int side_size;                                                                                                                                   
+        const uint8_t *side = av_packet_get_side_data(avpkt, AV_PKT_DATA_SKIP_SAMPLES, &side_size);                                                      
+        if (side && side_size>=4)                                                                                                                        
+            AV_WL32(side, 2*AV_RL32(side));                                                                                                              
+    }*/
+    return 0;                                                                                                                                            
+fail:                                                                                                                                                    
+    pop_output_configuration(ac);                                                                                                                        
+    return err;                                                                                                                                          
+}                                                                                                                                                        
+                                                                                                                                                         
+static int aac_decode_frame(AVCodecContext *avctx, void *data,                                                                                           
+                            int *got_frame_ptr, AVPacket *avpkt)                                                                                         
+{                                                                                                                                                        
+    AACContext *ac = avctx->priv_data;                                                                                                                   
+    const uint8_t *buf = avpkt->data;                                                                                                                    
+    int buf_size = avpkt->size;                                                                                                                          
+    GetBitContext gb;                                                                                                                                    
+    int buf_consumed;                                                                                                                                    
+    int buf_offset;                                                                                                                                      
+    int err;                                                                                                                                             
+    int new_extradata_size;                                                                                                                              
+ /*   const uint8_t *new_extradata = av_packet_get_side_data(avpkt,                                                                                        
+                                       AV_PKT_DATA_NEW_EXTRADATA,                                                                                        
+                                       &new_extradata_size);                                                                                             
+    int jp_dualmono_size;                                                                                                                                
+    const uint8_t *jp_dualmono   = av_packet_get_side_data(avpkt,                                                                                        
+                                       AV_PKT_DATA_JP_DUALMONO,                                                                                          
+                                       &jp_dualmono_size);                                                                                               
+                                                                                                                                                         
+    if (new_extradata && 0) {                                                                                                                            
+        av_free(avctx->extradata);                                                                                                                       
+        avctx->extradata = av_mallocz(new_extradata_size +                                                                                               
+                                      FF_INPUT_BUFFER_PADDING_SIZE);                                                                                     
+        if (!avctx->extradata)                                                                                                                           
+            return AVERROR(ENOMEM);                                                                                                                      
+        avctx->extradata_size = new_extradata_size;                                                                                                      
+        memcpy(avctx->extradata, new_extradata, new_extradata_size);                                                                                     
+        push_output_configuration(ac);                                                                                                                   
+        if (decode_audio_specific_config(ac, ac->avctx, &ac->oc[1].m4ac,                                                                                 
+                                         avctx->extradata,                                                                                               
+                                         avctx->extradata_size*8, 1) < 0) {                                                                              
+            pop_output_configuration(ac);                                                                                                                
+            return AVERROR_INVALIDDATA;                                                                                                                  
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    ac->dmono_mode = 0;                                                                                                                                  
+    if (jp_dualmono && jp_dualmono_size > 0)                                                                                                             
+        ac->dmono_mode =  1 + *jp_dualmono;                                                                                                              
+    if (ac->force_dmono_mode >= 0)                                                                                                                       
+        ac->dmono_mode = ac->force_dmono_mode;                                                                                                           
+                                                                                                                                                         
+    if (INT_MAX / 8 <= buf_size)                                                                                                                         
+        return AVERROR_INVALIDDATA;*/
+                                                                                                                                                         
+    init_get_bits(&gb, buf, buf_size * 8);                                                                                                               
+                                                                                                                                                         
+    if ((err = aac_decode_frame_int(avctx, data, got_frame_ptr, &gb, avpkt)) < 0)                                                                        
+        return err;                                                                                                                                      
+                                                                                                                                                         
+    buf_consumed = (get_bits_count(&gb) + 7) >> 3;                                                                                                       
+    for (buf_offset = buf_consumed; buf_offset < buf_size; buf_offset++)                                                                                 
+        if (buf[buf_offset])                                                                                                                             
+            break;                                                                                                                                       
+                                                                                                                                                         
+    return buf_size > buf_offset ? buf_consumed : buf_size;                                                                                              
+}                                                                                                                                                        
+                                                                                                                                                         
+static av_cold int aac_decode_close(AVCodecContext *avctx)                                                                                               
+{                                                                                                                                                        
+    AACContext *ac = avctx->priv_data;                                                                                                                   
+    int i, type;                                                                                                                                         
+                                                                                                                                                         
+    for (i = 0; i < MAX_ELEM_ID; i++) {                                                                                                                  
+        for (type = 0; type < 4; type++) {                                                                                                               
+            if (ac->che[type][i])                                                                                                                        
+                AAC_RENAME(ff_aac_sbr_ctx_close)(&ac->che[type][i]->sbr);                                                                                
+            av_freep(&ac->che[type][i]);                                                                                                                 
+        }                                                                                                                                                
+    }                                                                                                                                                    
+                                                                                                                                                         
+    ff_mdct_end(&ac->mdct);                                                                                                                              
+    ff_mdct_end(&ac->mdct_small);                                                                                                                        
+    ff_mdct_end(&ac->mdct_ltp);                                                                                                                          
+    return 0;                                                                                                                                            
+}                                                                                                                                                        
+                                                                                                                                                         
+static void aacdec_init(AACContext *c)                                                                                                                   
+{                                                                                                                                                        
+  //  c->imdct_and_windowing                      = imdct_and_windowing;                                                                                   
+   // c->apply_ltp                                = apply_ltp;                                                                                             
+   // c->apply_tns                                = apply_tns;                                                                                             
+    //c->windowing_and_mdct_ltp                   = windowing_and_mdct_ltp;                                                                                
+   // c->update_ltp                               = update_ltp;                                                                                            
+#if CONFIG_AAC_FIXED                                                                                                                                     
+    c->vector_pow43                             = vector_pow43;                                                                                          
+    c->imdct_and_windowing_fixed                = imdct_and_windowing;                                                                                   
+    c->subband_scale                            = subband_scale;                                                                                         
+#endif                                                                                                                                                   
+                                                                                                                                                         
+    /*if(ARCH_MIPS)                                                                                                                                        
+        ff_aacdec_init_mips(c);       */                                                                                                                   
+}                                                                                                                                                        
+/**                                                                                                                                                      
+ * AVOptions for Japanese DTV specific extensions (ADTS only)                                                                                            
+ */                                                                                                                                                      
+/*#define AACDEC_FLAGS AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_AUDIO_PARAM                                                                                
+static const AVOption options[] = {                                                                                                                      
+    {"dual_mono_mode", "Select the channel to decode for dual mono",                                                                                     
+     offsetof(AACContext, force_dmono_mode), AV_OPT_TYPE_INT, {.i64=-1}, -1, 2,                                                                          
+     AACDEC_FLAGS, "dual_mono_mode"},                                                                                                                    
+                                                                                                                                                         
+    {"auto", "autoselection",            0, AV_OPT_TYPE_CONST, {.i64=-1}, INT_MIN, INT_MAX, AACDEC_FLAGS, "dual_mono_mode"},                             
+    {"main", "Select Main/Left channel", 0, AV_OPT_TYPE_CONST, {.i64= 1}, INT_MIN, INT_MAX, AACDEC_FLAGS, "dual_mono_mode"},                             
+    {"sub" , "Select Sub/Right channel", 0, AV_OPT_TYPE_CONST, {.i64= 2}, INT_MIN, INT_MAX, AACDEC_FLAGS, "dual_mono_mode"},                             
+    {"both", "Select both channels",     0, AV_OPT_TYPE_CONST, {.i64= 0}, INT_MIN, INT_MAX, AACDEC_FLAGS, "dual_mono_mode"},                             
+                                                                                                                                                         
+    {NULL},                                                                                                                                              
+};                                                                                                                                                       
+                                                                                                                                                         
+static const AVClass aac_decoder_class = {                                                                                                               
+    .class_name = "AAC decoder",                                                                                                                         
+    .item_name  = av_default_item_name,                                                                                                                  
+    .option     = options,                                                                                                                               
+    .version    = LIBAVUTIL_VERSION_INT,                                                                                                                 
+};                                                                                                                          
 */
-AVCodec ff_aac_latm_decoder = {
-    .name = "aac_latm",
-    .type = AVMEDIA_TYPE_AUDIO,
-    .id   = CODEC_ID_AAC_LATM,
-    .priv_data_size = sizeof(struct LATMContext),
-    .init   = latm_decode_init,
-    .close  = aac_decode_close,
-    .decode = latm_decode_frame,
-    .long_name = NULL_IF_CONFIG_SMALL("AAC LATM (Advanced Audio Codec LATM syntax)"),
-    .sample_fmts = (const enum AVSampleFormat[]) {
-        AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE
-    },
-    .channel_layouts = aac_channel_layout,
-};
+AVCodec ff_aac_decoder = {                                                                                                                         
+    .name            = "aac",                                                                                                                      
+    .type            = AVMEDIA_TYPE_AUDIO,                                                                                                               
+    .id              = CODEC_ID_AAC,                                                                                                                  
+    .priv_data_size  = sizeof(AACContext),                                                                                                               
+    .init            = aac_decode_init,                                                                                                                  
+    .close           = aac_decode_close,                                                                                                                 
+    .decode          = aac_decode_frame,                                                                                                                 
+    .long_name       = NULL_IF_CONFIG_SMALL("AAC (Advanced Audio Coding)"),                                                                              
+    .sample_fmts     = (const enum AVSampleFormat[]) {                                                                                                   
+        AV_SAMPLE_FMT_S32P, AV_SAMPLE_FMT_NONE                                                                                                           
+    },                                                                                                                                                   
+    .capabilities    = CODEC_CAP_CHANNEL_CONF | CODEC_CAP_DR1,                                                                                           
+    .channel_layouts = aac_channel_layout,                                                                                                               
+    .flush = flush,                                                                                                                                      
+};            
diff -uNr ffmpeg-0.7.12/libavcodec/aacdectab.h ffmpeg-0.7.12-140902/libavcodec/aacdectab.h
--- ffmpeg-0.7.12/libavcodec/aacdectab.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacdectab.h	2014-09-02 16:53:25.000000000 +0800
@@ -38,39 +38,37 @@
 /* @name ltp_coef
  * Table of the LTP coefficients
  */
-static const float ltp_coef[8] = {
-    0.570829, 0.696616, 0.813004, 0.911304,
-    0.984900, 1.067894, 1.194601, 1.369533,
-};
-
+static const INTFLOAT ltp_coef[8] = {                                                                                                                    
+    Q30(0.570829f), Q30(0.696616f), Q30(0.813004f), Q30(0.911304f),                                                                                      
+    Q30(0.984900f), Q30(1.067894f), Q30(1.194601f), Q30(1.369533f),                                                                                      
+ };   
 /* @name tns_tmp2_map
  * Tables of the tmp2[] arrays of LPC coefficients used for TNS.
  * The suffix _M_N[] indicate the values of coef_compress and coef_res
  * respectively.
  * @{
  */
-static const float tns_tmp2_map_1_3[4] = {
-     0.00000000, -0.43388373,  0.64278758,  0.34202015,
-};
-
-static const float tns_tmp2_map_0_3[8] = {
-     0.00000000, -0.43388373, -0.78183150, -0.97492790,
-     0.98480773,  0.86602539,  0.64278758,  0.34202015,
-};
-
-static const float tns_tmp2_map_1_4[8] = {
-     0.00000000, -0.20791170, -0.40673664, -0.58778524,
-     0.67369562,  0.52643216,  0.36124167,  0.18374951,
-};
-
-static const float tns_tmp2_map_0_4[16] = {
-     0.00000000, -0.20791170, -0.40673664, -0.58778524,
-    -0.74314481, -0.86602539, -0.95105654, -0.99452192,
-     0.99573416,  0.96182561,  0.89516330,  0.79801720,
-     0.67369562,  0.52643216,  0.36124167,  0.18374951,
+static const INTFLOAT tns_tmp2_map_1_3[4] = {
+      Q31(0.00000000f), Q31(-0.43388373f),  Q31(0.64278758f),  Q31(0.34202015f),  
 };
 
-static const float * const tns_tmp2_map[4] = {
+static const INTFLOAT tns_tmp2_map_0_3[8] = {                                                                                                            
+     Q31(0.00000000f), Q31(-0.43388373f), Q31(-0.78183150f), Q31(-0.97492790f),                                                                          
+     Q31(0.98480773f), Q31( 0.86602539f), Q31( 0.64278758f), Q31( 0.34202015f),                                                                          
+ };     
+
+static const INTFLOAT tns_tmp2_map_1_4[8] = {                                                                                                            
+     Q31(0.00000000f), Q31(-0.20791170f), Q31(-0.40673664f), Q31(-0.58778524f),                                                                          
+     Q31(0.67369562f), Q31( 0.52643216f), Q31( 0.36124167f), Q31( 0.18374951f),                                                                          
+}; 
+
+static const INTFLOAT tns_tmp2_map_0_4[16] = {                                                                                                           
+    Q31( 0.00000000f), Q31(-0.20791170f), Q31(-0.40673664f), Q31(-0.58778524f),                                                                          
+    Q31(-0.74314481f), Q31(-0.86602539f), Q31(-0.95105654f), Q31(-0.99452192f),                                                                          
+    Q31( 0.99573416f), Q31( 0.96182561f), Q31( 0.89516330f), Q31( 0.79801720f),                                                                          
+    Q31( 0.67369562f), Q31( 0.52643216f), Q31( 0.36124167f), Q31( 0.18374951f),                                                                          
+ };  
+static const INTFLOAT * const tns_tmp2_map[4] = {   
     tns_tmp2_map_0_3,
     tns_tmp2_map_0_4,
     tns_tmp2_map_1_3,
@@ -80,17 +78,17 @@
 
 static const int8_t tags_per_config[16] = { 0, 1, 1, 2, 3, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0 };
 
-static const uint8_t aac_channel_layout_map[7][5][2] = {
-    { { TYPE_SCE, 0 }, },
-    { { TYPE_CPE, 0 }, },
-    { { TYPE_CPE, 0 }, { TYPE_SCE, 0 }, },
-    { { TYPE_CPE, 0 }, { TYPE_SCE, 0 }, { TYPE_SCE, 1 }, },
-    { { TYPE_CPE, 0 }, { TYPE_SCE, 0 }, { TYPE_CPE, 1 }, },
-    { { TYPE_CPE, 0 }, { TYPE_SCE, 0 }, { TYPE_LFE, 0 }, { TYPE_CPE, 1 }, },
-    { { TYPE_CPE, 0 }, { TYPE_SCE, 0 }, { TYPE_LFE, 0 }, { TYPE_CPE, 2 }, { TYPE_CPE, 1 }, },
+static const uint8_t aac_channel_layout_map[7][5][3] = {
+    { { TYPE_SCE, 0, AAC_CHANNEL_FRONT }, },
+    { { TYPE_CPE, 0, AAC_CHANNEL_FRONT }, },
+    { { TYPE_SCE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 0, AAC_CHANNEL_FRONT }, },
+    { { TYPE_SCE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 0, AAC_CHANNEL_FRONT }, { TYPE_SCE, 1, AAC_CHANNEL_BACK }, },
+    { { TYPE_SCE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 1, AAC_CHANNEL_BACK }, },
+    { { TYPE_SCE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 1, AAC_CHANNEL_BACK }, { TYPE_LFE, 0, AAC_CHANNEL_LFE  }, },
+    { { TYPE_SCE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 0, AAC_CHANNEL_FRONT }, { TYPE_CPE, 1, AAC_CHANNEL_FRONT }, { TYPE_CPE, 2, AAC_CHANNEL_BACK }, { TYPE_LFE, 0, AAC_CHANNEL_LFE  }, },
 };
 
-static const int64_t aac_channel_layout[8] = {
+static const uint64_t aac_channel_layout[8] = {
     AV_CH_LAYOUT_MONO,
     AV_CH_LAYOUT_STEREO,
     AV_CH_LAYOUT_SURROUND,
diff -uNr ffmpeg-0.7.12/libavcodec/aac.h ffmpeg-0.7.12-140902/libavcodec/aac.h
--- ffmpeg-0.7.12/libavcodec/aac.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aac.h	2014-09-05 14:02:11.140625000 +0800
@@ -30,6 +30,58 @@
 #ifndef AVCODEC_AAC_H
 #define AVCODEC_AAC_H
 
+#ifndef CONFIG_AAC_FIXED
+#define CONFIG_AAC_FIXED 0                                                                                                                               
+#endif
+
+#if CONFIG_AAC_FIXED
+
+#define CONFIG_FFT_FLOAT    0
+#define CONFIG_FFT_FIXED_32 1
+
+#define AAC_RENAME(x)       x ## _fixed
+#define AAC_RENAME2(x)      x ## _fixed
+#define AAC_RENAME_32(x)    x ## _fixed_32
+#define INTFLOAT int
+#define SHORTFLOAT int16_t
+#define AAC_FLOAT aac_float_t
+#define AAC_SIGNE           int
+#define FIXR(a)             ((int)((a) * 1 + 0.5))
+#define FIXR10(a)           ((int)((a) * 1024.0 + 0.5))
+#define Q23(a)              (int)((a) * 8388608.0 + 0.5)
+#define Q30(x)              (int)((x)*1073741824.0 + 0.5)
+#define Q31(x)              (int)((x)*2147483648.0 + 0.5)
+#define RANGE15(x)          x
+#define GET_GAIN(x, y)      (-(y) << (x)) + 1024
+#define AAC_MUL26(x, y)     (int)(((int64_t)(x) * (y) + 0x2000000) >> 26)
+#define AAC_MUL30(x, y)     (int)(((int64_t)(x) * (y) + 0x20000000) >> 30)
+#define AAC_MUL31(x, y)     (int)(((int64_t)(x) * (y) + 0x40000000) >> 31)
+
+#else
+
+#define CONFIG_FFT_FLOAT    1
+#define CONFIG_FFT_FIXED_32 0
+
+#define AAC_RENAME(x)       x
+#define AAC_RENAME2(x)      x ## _float
+#define AAC_RENAME_32(x)    x
+#define INTFLOAT float
+#define SHORTFLOAT float
+#define AAC_FLOAT float
+#define AAC_SIGNE           unsigned
+#define FIXR(x)             ((float)(x))
+#define FIXR10(x)           ((float)(x))
+#define Q23(x)              x
+#define Q30(x)              x
+#define Q31(x)              x
+#define RANGE15(x)          (32768.0 * (x))
+#define GET_GAIN(x, y)      powf((x), -(y))
+#define AAC_MUL26(x, y)     ((x) * (y))
+#define AAC_MUL30(x, y)     ((x) * (y))
+#define AAC_MUL31(x, y)     ((x) * (y))
+
+#endif /* CONFIG_AAC_FIXED */
+
 #include "avcodec.h"
 #include "dsputil.h"
 #include "fft.h"
@@ -37,6 +89,7 @@
 #include "sbr.h"
 #include "fmtconvert.h"
 
+#include "fixed_dsp.h"
 #include <stdint.h>
 
 #define MAX_CHANNELS 64
@@ -84,6 +137,7 @@
 #define IS_CODEBOOK_UNSIGNED(x) ((x - 1) & 10)
 
 enum ChannelPosition {
+    AAC_CHANNEL_OFF   = 0,
     AAC_CHANNEL_FRONT = 1,
     AAC_CHANNEL_SIDE  = 2,
     AAC_CHANNEL_BACK  = 3,
@@ -111,16 +165,25 @@
     OC_LOCKED,      //< Output configuration locked in place
 };
 
+typedef struct OutputConfiguration {
+    MPEG4AudioConfig m4ac;
+    uint8_t layout_map[MAX_ELEM_ID*4][3];
+    int layout_map_tags;
+    int channels;
+    uint64_t channel_layout;
+    enum OCStatus status;
+} OutputConfiguration;
+
 /**
  * Predictor State
  */
-typedef struct {
-    float cor0;
-    float cor1;
-    float var0;
-    float var1;
-    float r0;
-    float r1;
+typedef struct PredictorState {
+    AAC_FLOAT cor0;                                                                                                                                      
+    AAC_FLOAT cor1;                                                                                                                                      
+    AAC_FLOAT var0;                                                                                                                                      
+    AAC_FLOAT var1;                                                                                                                                      
+    AAC_FLOAT r0;                                                                                                                                        
+    AAC_FLOAT r1; 
 } PredictorState;
 
 #define MAX_PREDICTORS 672
@@ -131,21 +194,20 @@
 #define SCALE_MAX_DIFF   60    ///< maximum scalefactor difference allowed by standard
 #define SCALE_DIFF_ZERO  60    ///< codebook index corresponding to zero scalefactor indices difference
 #define POW_SF2_ZERO    200    ///< ff_aac_pow2sf_tab index corresponding to pow(2, 0);
-
 /**
  * Long Term Prediction
  */
-typedef struct {
+typedef struct LongTermPrediction {
     int8_t present;
     int16_t lag;
-    float coef;
+    INTFLOAT coef;
     int8_t used[MAX_LTP_LONG_SFB];
 } LongTermPrediction;
 
 /**
  * Individual Channel Stream
  */
-typedef struct {
+typedef struct IndividualChannelStream {
     uint8_t max_sfb;            ///< number of scalefactor bands per group
     enum WindowSequence window_sequence[2];
     uint8_t use_kb_window[2];   ///< If set, use Kaiser-Bessel window, otherwise use a sinus window.
@@ -166,19 +228,19 @@
 /**
  * Temporal Noise Shaping
  */
-typedef struct {
+typedef struct TemporalNoiseShaping {
     int present;
     int n_filt[8];
     int length[8][4];
     int direction[8][4];
     int order[8][4];
-    float coef[8][4][TNS_MAX_ORDER];
+    INTFLOAT coef[8][4][TNS_MAX_ORDER];
 } TemporalNoiseShaping;
 
 /**
  * Dynamic Range Control - decoded from the bitstream but not processed further.
  */
-typedef struct {
+typedef struct DynamicRangeControl {
     int pce_instance_tag;                           ///< Indicates with which program the DRC info is associated.
     int dyn_rng_sgn[17];                            ///< DRC sign information; 0 - positive, 1 - negative
     int dyn_rng_ctl[17];                            ///< DRC magnitude information
@@ -191,7 +253,7 @@
                                                      */
 } DynamicRangeControl;
 
-typedef struct {
+typedef struct Pulse {
     int num_pulse;
     int start;
     int pos[4];
@@ -201,7 +263,7 @@
 /**
  * coupling parameters
  */
-typedef struct {
+typedef struct ChannelCoupling {
     enum CouplingPoint coupling_point;  ///< The point during decoding at which coupling is applied.
     int num_coupled;       ///< number of target elements
     enum RawDataBlockType type[8];   ///< Type of channel element to be coupled - SCE or CPE.
@@ -209,32 +271,34 @@
     int ch_select[8];      /**< [0] shared list of gains; [1] list of gains for right channel;
                             *   [2] list of gains for left channel; [3] lists of gains for both channels
                             */
-    float gain[16][120];
+    INTFLOAT gain[16][120];
 } ChannelCoupling;
 
 /**
  * Single Channel Element - used for both SCE and LFE elements.
  */
-typedef struct {
+typedef struct SingleChannelElement {
     IndividualChannelStream ics;
     TemporalNoiseShaping tns;
     Pulse pulse;
     enum BandType band_type[128];                   ///< band types
     int band_type_run_end[120];                     ///< band type run end points
-    float sf[120];                                  ///< scalefactors
+    INTFLOAT sf[120];                               ///< scalefactors  
     int sf_idx[128];                                ///< scalefactor indices (used by encoder)
     uint8_t zeroes[128];                            ///< band is not coded (used by encoder)
-    DECLARE_ALIGNED(32, float,   coeffs)[1024];     ///< coefficients for IMDCT
-    DECLARE_ALIGNED(32, float,   saved)[1024];      ///< overlap
-    DECLARE_ALIGNED(32, float,   ret)[2048];        ///< PCM output
-    DECLARE_ALIGNED(16, float,   ltp_state)[3072];  ///< time signal for LTP
+    DECLARE_ALIGNED(32, INTFLOAT,   coeffs)[1024];     ///< coefficients for IMDCT                                                                       
+    DECLARE_ALIGNED(32, INTFLOAT,   saved)[1024];      ///< overlap                                                                                      
+  //  DECLARE_ALIGNED(32, INTFLOAT,   ret_buf)[2048];    ///< PCM output buffer                                                                            
+    DECLARE_ALIGNED(32, int,   temp_sbr)[2048];    ///< PCM intermediate buffer for SBR                                                                  
+    DECLARE_ALIGNED(16, INTFLOAT,   ltp_state)[3072];  ///< time signal for LTP  
     PredictorState predictor_state[MAX_PREDICTORS];
+    DECLARE_ALIGNED(32, INTFLOAT,   ret)[2048];                               ///< PCM output
 } SingleChannelElement;
 
 /**
  * channel element - generic struct for SCE/CPE/CCE/LFE
  */
-typedef struct {
+typedef struct ChannelElement {
     // CPE specific
     int common_window;        ///< Set if channels share a common 'IndividualChannelStream' in bitstream.
     int     ms_mode;          ///< Signals mid/side stereo flags coding mode (used by encoder)
@@ -246,13 +310,14 @@
     SpectralBandReplication sbr;
 } ChannelElement;
 
+typedef struct AACContext AACContext;
 /**
  * main AAC context
  */
-typedef struct {
+struct AACContext {
+    AVClass        *class;
     AVCodecContext *avctx;
-
-    MPEG4AudioConfig m4ac;
+    AVFrame frame;
 
     int is_saved;                 ///< Set if elements have stored overlap from previous frame.
     DynamicRangeControl che_drc;
@@ -261,9 +326,6 @@
      * @name Channel element related data
      * @{
      */
-    enum ChannelPosition che_pos[4][MAX_ELEM_ID]; /**< channel element channel mapping with the
-                                                   *   first index as the first 4 raw data block types
-                                                   */
     ChannelElement          *che[4][MAX_ELEM_ID];
     ChannelElement  *tag_che_map[4][MAX_ELEM_ID];
     int tags_mapped;
@@ -274,7 +336,7 @@
      * (We do not want to have these on the stack.)
      * @{
      */
-    DECLARE_ALIGNED(32, float, buf_mdct)[1024];
+    DECLARE_ALIGNED(32, INTFLOAT, buf_mdct)[1024];
     /** @} */
 
     /**
@@ -286,6 +348,13 @@
     FFTContext mdct_ltp;
     DSPContext dsp;
     FmtConvertContext fmt_conv;
+
+//#if CONFIG_AAC_FIXED
+    AVFixedDSPContext fdsp;                                                                                                                              
+//#else
+   //  AVFloatDSPContext fdsp;
+//#endif /* CONFIG_AAC_FIXED */
+
     int random_state;
     /** @} */
 
@@ -293,12 +362,53 @@
      * @name Members used for output interleaving
      * @{
      */
-    float *output_data[MAX_CHANNELS];                 ///< Points to each element's 'ret' buffer (PCM output).
+    INTFLOAT *output_element[MAX_CHANNELS]; ///< Points to each SingleChannelElement
     /** @} */
 
-    DECLARE_ALIGNED(32, float, temp)[128];
 
-    enum OCStatus output_configured;
-} AACContext;
+    /**
+     * @name Japanese DTV specific extension
+     * @{
+     */
+    int force_dmono_mode;///< 0->not dmono, 1->use first channel, 2->use second channel
+    int dmono_mode;      ///< 0->not dmono, 1->use first channel, 2->use second channel
+    /** @} */
+
+    DECLARE_ALIGNED(32, INTFLOAT, temp)[128];
+
+    OutputConfiguration oc[2];
+    int warned_num_aac_frames;
+    void (*imdct_and_windowing)(AACContext *ac, SingleChannelElement *sce);                                                                              
+    void (*apply_ltp)(AACContext *ac, SingleChannelElement *sce);                                                                                        
+
+    void (*apply_tns)(INTFLOAT coef[1024], TemporalNoiseShaping *tns,                                                                                    
+                       IndividualChannelStream *ics, int decode);                                                                                         
+    void (*windowing_and_mdct_ltp)(AACContext *ac, INTFLOAT *out,                                                                                        
+                                  INTFLOAT *in, IndividualChannelStream *ics);                                                                          
+    void (*update_ltp)(AACContext *ac, SingleChannelElement *sce);                                                                                       
+    void (*vector_pow43)(int *coefs, int len);                                                                                                           
+    void (*subband_scale)(int *dst, int *src, int scale, int offset, int len);                                                                           
+    void (*imdct_and_windowing_fixed)(AACContext *ac, SingleChannelElement *sce);
+
+};
+
+ typedef struct AACSBRContext {                                                                                                                              
+     int (*sbr_lf_gen)(AACContext *ac, SpectralBandReplication *sbr,                                                                                         
+                      INTFLOAT X_low[32][40][2], const INTFLOAT W[2][32][32][2],                                                                            
+                       int buf_idx);                                                                                                                         
+                                                                                                  
+    void (*sbr_hf_assemble)(INTFLOAT Y1[38][64][2],                                                                                                         
+                            const INTFLOAT X_high[64][40][2],                                                                                               
+                             SpectralBandReplication *sbr, SBRData *ch_data,                                                                                 
+                             const int e_a[2]);                                                                                                              
+    int (*sbr_x_gen)(SpectralBandReplication *sbr, INTFLOAT X[2][38][64],                                                                                   
+                     const INTFLOAT Y0[38][64][2], const INTFLOAT Y1[38][64][2],                                                                            
+                     const INTFLOAT X_low[32][40][2], int ch);                                                                                              
+     void (*sbr_hf_inverse_filter)(SBRDSPContext *dsp,                                                                                                       
+                                  INTFLOAT (*alpha0)[2], INTFLOAT (*alpha1)[2],                                                                             
+                                  const INTFLOAT X_low[32][40][2], int k0);                                                                                 
+ } AACSBRContext;  
+
 
+extern int exp2tab[4];
 #endif /* AVCODEC_AAC_H */
diff -uNr ffmpeg-0.7.12/libavcodec/aacps.c ffmpeg-0.7.12-140902/libavcodec/aacps.c
--- ffmpeg-0.7.12/libavcodec/aacps.c	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacps.c	2014-09-02 15:14:06.000000000 +0800
@@ -1,6 +1,6 @@
 /*
  * MPEG-4 Parametric Stereo decoding functions
- * Copyright (c) 2010 Alex Converse <alex.converse@gmail.com>
+ * Copyright (c) 2010 Alex Converse <alex.converse <at> gmail.com>
  *
  * This file is part of FFmpeg.
  *
@@ -19,18 +19,28 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#define CONFIG_AAC_FIXED 1
+
+
 #include <stdint.h>
 #include "libavutil/common.h"
 #include "libavutil/mathematics.h"
 #include "avcodec.h"
 #include "get_bits.h"
 #include "aacps.h"
-#include "aacps_tablegen.h"
+#if CONFIG_AAC_FIXED
+#include "aacps_fixed_tablegen.h"
+#include "dsputil.h"
+#else
+#include "libavutil/internal.h"
+ #include "aacps_tablegen.h"
+#endif /* CONFIG_AAC_FIXED */
 #include "aacpsdata.c"
+#include "dsputil.h"
 
-#define PS_BASELINE 0  //< Operate in Baseline PS mode
-                       //< Baseline implies 10 or 20 stereo bands,
-                       //< mixing mode A, and no ipd/opd
+#define PS_BASELINE 0  ///< Operate in Baseline PS mode
+                       ///< Baseline implies 10 or 20 stereo bands,
+                       ///< mixing mode A, and no ipd/opd
 
 #define numQMFSlots 32 //numTimeSlots * RATE
 
@@ -69,19 +79,19 @@
 
 static VLC vlc_ps[10];
 
-/**
- * Read Inter-channel Intensity Difference/Inter-Channel Coherence/
- * Inter-channel Phase Difference/Overall Phase Difference parameters from the
- * bitstream.
- *
- * @param avctx contains the current codec context
- * @param gb    pointer to the input bitstream
- * @param ps    pointer to the Parametric Stereo context
- * @param par   pointer to the parameter to be read
- * @param e     envelope to decode
- * @param dt    1: time delta-coded, 0: frequency delta-coded
- */
 #define READ_PAR_DATA(PAR, OFFSET, MASK, ERR_CONDITION) \
+/** \
+ * Read Inter-channel Intensity Difference/Inter-Channel Coherence/ \
+ * Inter-channel Phase Difference/Overall Phase Difference parameters from the \
+ * bitstream. \
+ * \
+ * @param avctx contains the current codec context \
+ * @param gb    pointer to the input bitstream \
+ * @param ps    pointer to the Parametric Stereo context \
+ * @param PAR   pointer to the parameter to be read \
+ * @param e     envelope to decode \
+ * @param dt    1: time delta-coded, 0: frequency delta-coded \
+ */ \
 static int read_ ## PAR ## _data(AVCodecContext *avctx, GetBitContext *gb, PSContext *ps, \
                         int8_t (*PAR)[PS_MAX_NR_IIDICC], int table_idx, int e, int dt) \
 { \
@@ -116,7 +126,7 @@
 READ_PAR_DATA(iid,    huff_offset[table_idx],    0, FFABS(ps->iid_par[e][b]) > 7 + 8 * ps->iid_quant)
 READ_PAR_DATA(icc,    huff_offset[table_idx],    0, ps->icc_par[e][b] > 7U)
 READ_PAR_DATA(ipdopd,                      0, 0x07, 0)
-
+static void AAC_RENAME(stereo_processing)(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34);
 static int ps_read_extension_data(GetBitContext *gb, PSContext *ps, int ps_extension_id)
 {
     int e;
@@ -138,7 +148,7 @@
     return get_bits_count(gb) - count;
 }
 
-static void ipdopd_reset(int8_t *opd_hist, int8_t *ipd_hist)
+static void ipdopd_reset(int8_t *ipd_hist, int8_t *opd_hist)
 {
     int i;
     for (i = 0; i < PS_MAX_NR_IPDOPD; i++) {
@@ -147,7 +157,7 @@
     }
 }
 
-int ff_ps_read_data(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)
+int AAC_RENAME(ff_ps_read_data)(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)
 {
     int e;
     int bit_count_start = get_bits_count(gb_host);
@@ -223,7 +233,7 @@
             cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);
         }
         if (cnt < 0) {
-            av_log(avctx, AV_LOG_ERROR, "ps extension overflow %d", cnt);
+            av_log(avctx, AV_LOG_ERROR, "ps extension overflow %d\n", cnt);
             goto err;
         }
         skip_bits(gb, cnt);
@@ -235,6 +245,7 @@
     if (!ps->num_env || ps->border_position[ps->num_env] < numQMFSlots - 1) {
         //Create a fake envelope
         int source = ps->num_env ? ps->num_env - 1 : ps->num_env_old - 1;
+        int b;
         if (source >= 0 && source != ps->num_env) {
             if (ps->enable_iid) {
                 memcpy(ps->iid_par+ps->num_env, ps->iid_par+source, sizeof(ps->iid_par[0]));
@@ -247,6 +258,22 @@
                 memcpy(ps->opd_par+ps->num_env, ps->opd_par+source, sizeof(ps->opd_par[0]));
             }
         }
+        if (ps->enable_iid){
+            for (b = 0; b < ps->nr_iid_par; b++) {
+                if (FFABS(ps->iid_par[ps->num_env][b]) > 7 + 8 * ps->iid_quant) {
+                    av_log(avctx, AV_LOG_ERROR, "iid_par invalid\n");
+                    goto err;
+                }
+            }
+        }
+        if (ps->enable_icc){
+            for (b = 0; b < ps->nr_iid_par; b++) {
+                if (ps->icc_par[ps->num_env][b] > 7U) {
+                    av_log(avctx, AV_LOG_ERROR, "icc_par invalid\n");
+                    goto err;
+                }
+            }
+        }
         ps->num_env++;
         ps->border_position[ps->num_env] = numQMFSlots - 1;
     }
@@ -275,14 +302,47 @@
 err:
     ps->start = 0;
     skip_bits_long(gb_host, bits_left);
+    memset(ps->iid_par, 0, sizeof(ps->iid_par));
+    memset(ps->icc_par, 0, sizeof(ps->icc_par));
+    memset(ps->ipd_par, 0, sizeof(ps->ipd_par));
+    memset(ps->opd_par, 0, sizeof(ps->opd_par));
     return bits_left;
 }
 
 /** Split one subband into 2 subsubbands with a symmetric real filter.
  * The filter must have its non-center even coefficients equal to zero. */
-static void hybrid2_re(float (*in)[2], float (*out)[32][2], const float filter[7], int len, int reverse)
+static void AAC_RENAME(hybrid2_re)(INTFLOAT (*in)[2], INTFLOAT (*out)[32][2], const INTFLOAT filter[8], int len, int reverse)
 {
     int i, j;
+#if CONFIG_AAC_FIXED
+    long long accu_re, accu_im;
+
+    for (i = 0; i < len; i++, in++) {
+        int re_in;      //real inphase
+        int re_op;      //real out of phase
+        int im_in;      //imag inphase
+        int im_op;      //imag out of phase
+
+        accu_re = (long long)filter[6] * in[6][0];
+        re_in = (int)((accu_re + 0x40000000) >> 31);
+        accu_im = (long long)filter[6] * in[6][1];
+        im_in = (int)((accu_im + 0x40000000) >> 31);
+
+        accu_re = 0;
+        accu_im = 0;
+        for (j = 0; j < 6; j += 2) {
+           accu_re += (long long)filter[j+1] * (in[j+1][0] + in[12-j-1][0]);
+            accu_im += (long long)filter[j+1] * (in[j+1][1] + in[12-j-1][1]);
+        }
+        re_op = (int)((accu_re + 0x40000000) >> 31);
+        im_op = (int)((accu_im + 0x40000000) >> 31);
+
+        out[ reverse][i][0] = re_in + re_op;
+        out[ reverse][i][1] = im_in + im_op;
+        out[!reverse][i][0] = re_in - re_op;
+        out[!reverse][i][1] = im_in - im_op;
+    }
+#else
     for (i = 0; i < len; i++, in++) {
         float re_in = filter[6] * in[6][0];          //real inphase
         float re_op = 0.0f;                          //real out of phase
@@ -297,29 +357,18 @@
         out[!reverse][i][0] = re_in - re_op;
         out[!reverse][i][1] = im_in - im_op;
     }
+#endif
 }
 
 /** Split one subband into 6 subsubbands with a complex filter */
-static void hybrid6_cx(float (*in)[2], float (*out)[32][2], const float (*filter)[7][2], int len)
+static void hybrid6_cx(PSDSPContext *dsp, INTFLOAT (*in)[2], INTFLOAT (*out)[32][2], const INTFLOAT (*filter)[8][2], int len)
 {
-    int i, j, ssb;
+    int i;
     int N = 8;
-    float temp[8][2];
+    LOCAL_ALIGNED_16(INTFLOAT, temp, [8], [2]);
 
     for (i = 0; i < len; i++, in++) {
-        for (ssb = 0; ssb < N; ssb++) {
-            float sum_re = filter[ssb][6][0] * in[6][0], sum_im = filter[ssb][6][0] * in[6][1];
-            for (j = 0; j < 6; j++) {
-                float in0_re = in[j][0];
-                float in0_im = in[j][1];
-                float in1_re = in[12-j][0];
-                float in1_im = in[12-j][1];
-                sum_re += filter[ssb][j][0] * (in0_re + in1_re) - filter[ssb][j][1] * (in0_im - in1_im);
-                sum_im += filter[ssb][j][0] * (in0_im + in1_im) + filter[ssb][j][1] * (in0_re - in1_re);
-            }
-            temp[ssb][0] = sum_re;
-            temp[ssb][1] = sum_im;
-        }
+        dsp->AAC_RENAME(hybrid_analysis)(temp, in, filter, 1, N);
         out[0][i][0] = temp[6][0];
         out[0][i][1] = temp[6][1];
         out[1][i][0] = temp[7][0];
@@ -335,28 +384,18 @@
     }
 }
 
-static void hybrid4_8_12_cx(float (*in)[2], float (*out)[32][2], const float (*filter)[7][2], int N, int len)
+static void hybrid4_8_12_cx(PSDSPContext *dsp, INTFLOAT (*in)[2], INTFLOAT (*out)[32][2], const INTFLOAT (*filter)[8][2], int N, int len)
 {
-    int i, j, ssb;
+    int i;
 
     for (i = 0; i < len; i++, in++) {
-        for (ssb = 0; ssb < N; ssb++) {
-            float sum_re = filter[ssb][6][0] * in[6][0], sum_im = filter[ssb][6][0] * in[6][1];
-            for (j = 0; j < 6; j++) {
-                float in0_re = in[j][0];
-                float in0_im = in[j][1];
-                float in1_re = in[12-j][0];
-                float in1_im = in[12-j][1];
-                sum_re += filter[ssb][j][0] * (in0_re + in1_re) - filter[ssb][j][1] * (in0_im - in1_im);
-                sum_im += filter[ssb][j][0] * (in0_im + in1_im) + filter[ssb][j][1] * (in0_re - in1_re);
-            }
-            out[ssb][i][0] = sum_re;
-            out[ssb][i][1] = sum_im;
-        }
+        dsp->AAC_RENAME(hybrid_analysis)(out[0] + i, in, filter, 32, N);
     }
 }
 
-static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)
+static void hybrid_analysis(PSDSPContext *dsp, INTFLOAT out[91][32][2],
+                            INTFLOAT in[5][44][2], INTFLOAT L[2][38][64],
+                            int is34, int len)
 {
     int i, j;
     for (i = 0; i < 5; i++) {
@@ -366,27 +405,17 @@
         }
     }
     if (is34) {
-        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);
-        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);
-        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);
-        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);
-        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);
-        for (i = 0; i < 59; i++) {
-            for (j = 0; j < len; j++) {
-                out[i+32][j][0] = L[0][j][i+5];
-                out[i+32][j][1] = L[1][j][i+5];
-            }
-        }
+        hybrid4_8_12_cx(dsp, in[0], out,    f34_0_12, 12, len);
+        hybrid4_8_12_cx(dsp, in[1], out+12, f34_1_8,   8, len);
+        hybrid4_8_12_cx(dsp, in[2], out+20, f34_2_4,   4, len);
+        hybrid4_8_12_cx(dsp, in[3], out+24, f34_2_4,   4, len);
+        hybrid4_8_12_cx(dsp, in[4], out+28, f34_2_4,   4, len);
+        dsp->AAC_RENAME(hybrid_analysis_ileave)(out + 27, L, 5, len);
     } else {
-        hybrid6_cx(in[0], out, f20_0_8, len);
-        hybrid2_re(in[1], out+6, g1_Q2, len, 1);
-        hybrid2_re(in[2], out+8, g1_Q2, len, 0);
-        for (i = 0; i < 61; i++) {
-            for (j = 0; j < len; j++) {
-                out[i+10][j][0] = L[0][j][i+3];
-                out[i+10][j][1] = L[1][j][i+3];
-            }
-        }
+        hybrid6_cx(dsp, in[0], out, f20_0_8, len);
+        AAC_RENAME(hybrid2_re)(in[1], out+6, g1_Q2, len, 1);
+        AAC_RENAME(hybrid2_re)(in[2], out+8, g1_Q2, len, 0);
+        dsp->AAC_RENAME(hybrid_analysis_ileave)(out + 7, L, 3, len);
     }
     //update in_buf
     for (i = 0; i < 5; i++) {
@@ -394,7 +423,8 @@
     }
 }
 
-static void hybrid_synthesis(float out[2][38][64], float in[91][32][2], int is34, int len)
+static void hybrid_synthesis(PSDSPContext *dsp, INTFLOAT out[2][38][64],
+                             INTFLOAT in[91][32][2], int is34, int len)
 {
     int i, n;
     if (is34) {
@@ -418,12 +448,7 @@
                 out[1][n][4] += in[28+i][n][1];
             }
         }
-        for (i = 0; i < 59; i++) {
-            for (n = 0; n < len; n++) {
-                out[0][n][i+5] = in[i+32][n][0];
-                out[1][n][i+5] = in[i+32][n][1];
-            }
-        }
+        dsp->AAC_RENAME(hybrid_synthesis_deint)(out, in + 27, 5, len);
     } else {
         for (n = 0; n < len; n++) {
             out[0][n][0] = in[0][n][0] + in[1][n][0] + in[2][n][0] +
@@ -435,17 +460,12 @@
             out[0][n][2] = in[8][n][0] + in[9][n][0];
             out[1][n][2] = in[8][n][1] + in[9][n][1];
         }
-        for (i = 0; i < 61; i++) {
-            for (n = 0; n < len; n++) {
-                out[0][n][i+3] = in[i+10][n][0];
-                out[1][n][i+3] = in[i+10][n][1];
-            }
-        }
+        dsp->AAC_RENAME(hybrid_synthesis_deint)(out, in + 7, 3, len);
     }
 }
 
 /// All-pass filter decay slope
-#define DECAY_SLOPE      0.05f
+#define DECAY_SLOPE      Q30(0.05f)
 /// Number of frequency bands that can be addressed by the parameter index, b(k)
 static const int   NR_PAR_BANDS[]      = { 20, 34 };
 /// Number of frequency bands that can be addressed by the sub subband index, k
@@ -498,8 +518,36 @@
     }
 }
 
-static void map_val_34_to_20(float par[PS_MAX_NR_IIDICC])
-{
+static void AAC_RENAME(map_val_34_to_20)(INTFLOAT par[PS_MAX_NR_IIDICC])
+ {
+#if CONFIG_AAC_FIXED
+    long long accu;
+
+    accu = (long long)(par[ 0] + (par[ 1]>>1)) * 1431655765;
+    par[ 0] = (int)((accu + 0x40000000) >> 31);
+    accu = (long long)((par[ 1]>>1) + par[ 2]) * 1431655765;
+    par[ 1] = (int)((accu + 0x40000000) >> 31);
+    accu = (long long)(par[ 3] + (par[ 4]>>1)) * 1431655765;
+    par[ 2] = (int)((accu + 0x40000000) >> 31);
+    accu = (long long)((par[ 4]>>1) + par[ 5]) * 1431655765;
+    par[ 3] = (int)((accu + 0x40000000) >> 31);
+    par[ 4] = ((par[ 6]>>1) + (par[ 7]>>1));
+    par[ 5] = ((par[ 8]>>1) + (par[ 9]>>1));
+    par[ 6] = par[10];
+    par[ 7] = par[11];
+    par[ 8] = ((par[12]>>1) + (par[13]>>1));
+    par[ 9] = ((par[14]>>1) + (par[15]>>1));
+    par[10] = par[16];
+    par[11] = par[17];
+    par[12] = par[18];
+    par[13] = par[19];
+    par[14] = ((par[20]>>1) + (par[21]>>1));
+    par[15] = ((par[22]>>1) + (par[23]>>1));
+    par[16] = ((par[24]>>1) + (par[25]>>1));
+    par[17] = ((par[26]>>1) + (par[27]>>1));
+    par[18] = (((par[28]+2)>>2) + ((par[29]+2)>>2) + ((par[30]+2)>>2) + ((par[31]+2)>>2));
+    par[19] = ((par[32]>>1) + (par[33]>>1));
+#else
     par[ 0] = (2*par[ 0] +   par[ 1]) * 0.33333333f;
     par[ 1] = (  par[ 1] + 2*par[ 2]) * 0.33333333f;
     par[ 2] = (2*par[ 3] +   par[ 4]) * 0.33333333f;
@@ -520,6 +568,7 @@
     par[17] = (  par[26] +   par[27]) * 0.5f;
     par[18] = (  par[28] +   par[29] +   par[30] +   par[31]) * 0.25f;
     par[19] = (  par[32] +   par[33]) * 0.5f;
+#endif
 }
 
 static void map_idx_10_to_34(int8_t *par_mapped, const int8_t *par, int full)
@@ -604,7 +653,7 @@
     par_mapped[ 0] =  par[ 0];
 }
 
-static void map_val_20_to_34(float par[PS_MAX_NR_IIDICC])
+static void map_val_20_to_34(INTFLOAT par[PS_MAX_NR_IIDICC])
 {
     par[33] =  par[19];
     par[32] =  par[19];
@@ -635,32 +684,48 @@
     par[ 7] =  par[ 4];
     par[ 6] =  par[ 4];
     par[ 5] =  par[ 3];
-    par[ 4] = (par[ 2] + par[ 3]) * 0.5f;
+#if CONFIG_AAC_FIXED
+    par[ 4] = (par[ 2] >> 1) + (par[ 3] >> 1);
     par[ 3] =  par[ 2];
     par[ 2] =  par[ 1];
-    par[ 1] = (par[ 0] + par[ 1]) * 0.5f;
+    par[ 1] = (par[ 0] >> 1) + (par[ 1] >> 1);
     par[ 0] =  par[ 0];
-}
-
-static void decorrelation(PSContext *ps, float (*out)[32][2], const float (*s)[32][2], int is34)
-{
-    float power[34][PS_QMF_TIME_SLOTS] = {{0}};
-    float transient_gain[34][PS_QMF_TIME_SLOTS];
+#else
+     par[ 4] = (par[ 2] + par[ 3]) * 0.5f;
+     par[ 3] =  par[ 2];
+     par[ 2] =  par[ 1];
+     par[ 1] = (par[ 0] + par[ 1]) * 0.5f;
+#endif /* CONFIG_AAC_FIXED */
+}
+
+static void AAC_RENAME(decorrelation)(PSContext *ps, INTFLOAT (*out)[32][2], const INTFLOAT (*s)[32][2], int is34)
+ {
+#if CONFIG_AAC_FIXED
+    int power[34][PS_QMF_TIME_SLOTS];
+    int transient_gain[34][PS_QMF_TIME_SLOTS];
+    int *peak_decay_nrg = ps->peak_decay_nrg;
+    int *power_smooth = ps->power_smooth;
+    int *peak_decay_diff_smooth = ps->peak_decay_diff_smooth;
+    int (*delay)[PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2] = ps->delay;
+    int (*ap_delay)[PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2] = ps->ap_delay;
+    const int peak_decay_factor = 1644818582;
+#else
+    LOCAL_ALIGNED_16(float, power, [34], [PS_QMF_TIME_SLOTS]);
+    LOCAL_ALIGNED_16(float, transient_gain, [34], [PS_QMF_TIME_SLOTS]);
     float *peak_decay_nrg = ps->peak_decay_nrg;
     float *power_smooth = ps->power_smooth;
     float *peak_decay_diff_smooth = ps->peak_decay_diff_smooth;
     float (*delay)[PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2] = ps->delay;
     float (*ap_delay)[PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2] = ps->ap_delay;
-    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
     const float peak_decay_factor = 0.76592833836465f;
     const float transient_impact  = 1.5f;
-    const float a_smooth          = 0.25f; //< Smoothing coefficient
+    const float a_smooth          = 0.25f; ///< Smoothing coefficient
+#endif /* CONFIG_AAC_FIXED */
+    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
     int i, k, m, n;
     int n0 = 0, nL = 32;
-    static const int link_delay[] = { 3, 4, 5 };
-    static const float a[] = { 0.65143905753106f,
-                               0.56471812200776f,
-                               0.48954165955695f };
+
+    memset(power, 0, 34 * sizeof(*power));
 
     if (is34 != ps->is34bands_old) {
         memset(ps->peak_decay_nrg,         0, sizeof(ps->peak_decay_nrg));
@@ -670,14 +735,39 @@
         memset(ps->ap_delay,               0, sizeof(ps->ap_delay));
     }
 
-    for (n = n0; n < nL; n++) {
-        for (k = 0; k < NR_BANDS[is34]; k++) {
-            int i = k_to_i[k];
-            power[i][n] += s[k][n][0] * s[k][n][0] + s[k][n][1] * s[k][n][1];
-        }
+    for (k = 0; k < NR_BANDS[is34]; k++) {
+        int i = k_to_i[k];
+        ps->dsp.AAC_RENAME(add_squares)(power[i], s[k], nL - n0);
     }
 
     //Transient detection
+#if CONFIG_AAC_FIXED
+    for (i = 0; i < NR_PAR_BANDS[is34]; i++) {
+        for (n = n0; n < nL; n++) {
+            long long accu;
+            int decayed_peak;
+            int denom;
+
+            accu = (long long)peak_decay_factor * peak_decay_nrg[i];
+            decayed_peak = (int)((accu + 0x40000000) >> 31);
+            peak_decay_nrg[i] = FFMAX(decayed_peak, power[i][n]);
+            power_smooth[i] += (power[i][n] - power_smooth[i] + 2) >> 2;
+            peak_decay_diff_smooth[i] += (peak_decay_nrg[i] - power[i][n] - peak_decay_diff_smooth[i] + 2) >> 2;
+            denom = peak_decay_diff_smooth[i] + (peak_decay_diff_smooth[i] >> 1);
+            if (denom > power_smooth[i]) {
+              int p = power_smooth[i];
+              while (denom < 0x40000000) {
+                denom <<= 1;
+                p <<= 1;
+              }
+              transient_gain[i][n] = p / (denom >> 16);
+            }
+            else {
+              transient_gain[i][n] = 1 << 16;
+            }
+        }
+    }
+#else
     for (i = 0; i < NR_PAR_BANDS[is34]; i++) {
         for (n = n0; n < nL; n++) {
             float decayed_peak = peak_decay_factor * peak_decay_nrg[i];
@@ -690,6 +780,7 @@
                                          power_smooth[i] / denom : 1.0f;
         }
     }
+#endif /* CONFIG_AAC_FIXED */
 
     //Decorrelation and transient reduction
     //                         PS_AP_LINKS - 1
@@ -701,55 +792,46 @@
     //d[k][z] (out) = transient_gain_mapped[k][z] * H[k][z] * s[k][z]
     for (k = 0; k < NR_ALLPASS_BANDS[is34]; k++) {
         int b = k_to_i[k];
+#if CONFIG_AAC_FIXED
+        int g_decay_slope;
+
+        if (k - DECAY_CUTOFF[is34] <= 0) {
+          g_decay_slope = 1 << 30;
+        }
+        else if (k - DECAY_CUTOFF[is34] >= 20) {
+          g_decay_slope = 0;
+        }
+        else {
+          g_decay_slope = (1 << 30) - DECAY_SLOPE * (k - DECAY_CUTOFF[is34]);
+        }
+#else
         float g_decay_slope = 1.f - DECAY_SLOPE * (k - DECAY_CUTOFF[is34]);
-        float ag[PS_AP_LINKS];
         g_decay_slope = av_clipf(g_decay_slope, 0.f, 1.f);
+#endif /* CONFIG_AAC_FIXED */
         memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
         memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
         for (m = 0; m < PS_AP_LINKS; m++) {
             memcpy(ap_delay[k][m],   ap_delay[k][m]+numQMFSlots,           5*sizeof(ap_delay[k][m][0]));
-            ag[m] = a[m] * g_decay_slope;
-        }
-        for (n = n0; n < nL; n++) {
-            float in_re = delay[k][n+PS_MAX_DELAY-2][0] * phi_fract[is34][k][0] -
-                          delay[k][n+PS_MAX_DELAY-2][1] * phi_fract[is34][k][1];
-            float in_im = delay[k][n+PS_MAX_DELAY-2][0] * phi_fract[is34][k][1] +
-                          delay[k][n+PS_MAX_DELAY-2][1] * phi_fract[is34][k][0];
-            for (m = 0; m < PS_AP_LINKS; m++) {
-                float a_re                = ag[m] * in_re;
-                float a_im                = ag[m] * in_im;
-                float link_delay_re       = ap_delay[k][m][n+5-link_delay[m]][0];
-                float link_delay_im       = ap_delay[k][m][n+5-link_delay[m]][1];
-                float fractional_delay_re = Q_fract_allpass[is34][k][m][0];
-                float fractional_delay_im = Q_fract_allpass[is34][k][m][1];
-                ap_delay[k][m][n+5][0] = in_re;
-                ap_delay[k][m][n+5][1] = in_im;
-                in_re = link_delay_re * fractional_delay_re - link_delay_im * fractional_delay_im - a_re;
-                in_im = link_delay_re * fractional_delay_im + link_delay_im * fractional_delay_re - a_im;
-                ap_delay[k][m][n+5][0] += ag[m] * in_re;
-                ap_delay[k][m][n+5][1] += ag[m] * in_im;
-            }
-            out[k][n][0] = transient_gain[b][n] * in_re;
-            out[k][n][1] = transient_gain[b][n] * in_im;
         }
+        ps->dsp.AAC_RENAME(decorrelate)(out[k], delay[k] + PS_MAX_DELAY - 2, ap_delay[k],
+                                phi_fract[is34][k], Q_fract_allpass[is34][k],
+                                transient_gain[b], g_decay_slope, nL - n0);
     }
     for (; k < SHORT_DELAY_BAND[is34]; k++) {
+        int i = k_to_i[k];
         memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
         memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
-        for (n = n0; n < nL; n++) {
-            //H = delay 14
-            out[k][n][0] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-14][0];
-            out[k][n][1] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-14][1];
-        }
+        //H = delay 14
+       ps->dsp.AAC_RENAME(mul_pair_single)(out[k], delay[k] + PS_MAX_DELAY - 14,
+                                 transient_gain[i], nL - n0);
     }
     for (; k < NR_BANDS[is34]; k++) {
+        int i = k_to_i[k];
         memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));
         memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));
-        for (n = n0; n < nL; n++) {
-            //H = delay 1
-            out[k][n][0] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-1][0];
-            out[k][n][1] = transient_gain[k_to_i[k]][n] * delay[k][n+PS_MAX_DELAY-1][1];
-        }
+        //H = delay 1
+       ps->dsp.AAC_RENAME(mul_pair_single)(out[k], delay[k] + PS_MAX_DELAY - 1,
+                                 transient_gain[i], nL - n0);
     }
 }
 
@@ -791,14 +873,82 @@
     }
 }
 
-static void stereo_processing(PSContext *ps, float (*l)[32][2], float (*r)[32][2], int is34)
+
+int AAC_RENAME(ff_ps_apply)(AVCodecContext *avctx, PSContext *ps, INTFLOAT L[2][38][64], INTFLOAT R[2][38][64], int top)
 {
-    int e, b, k, n;
+    LOCAL_ALIGNED_16(INTFLOAT, Lbuf, [91], [32][2]);
+    LOCAL_ALIGNED_16(INTFLOAT, Rbuf, [91], [32][2]);
+    const int len = 32;
+    int is34 = ps->is34bands;
+
+    top += NR_BANDS[is34] - 64;
+    memset(ps->delay+top, 0, (NR_BANDS[is34] - top)*sizeof(ps->delay[0]));
+    if (top < NR_ALLPASS_BANDS[is34])
+        memset(ps->ap_delay + top, 0, (NR_ALLPASS_BANDS[is34] - top)*sizeof(ps->ap_delay[0]));
+
+    hybrid_analysis(&ps->dsp, Lbuf, ps->in_buf, L, is34, len);
+    AAC_RENAME(decorrelation)(ps, Rbuf, Lbuf, is34);
+    AAC_RENAME(stereo_processing)(ps, Lbuf, Rbuf, is34);
+    hybrid_synthesis(&ps->dsp, L, Lbuf, is34, len);
+    hybrid_synthesis(&ps->dsp, R, Rbuf, is34, len);
+
+    return 0;
+}
 
-    float (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;
-    float (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;
-    float (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;
-    float (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;
+#define PS_INIT_VLC_STATIC(num, size) \
+    INIT_VLC_STATIC(&vlc_ps[num], 9, ps_tmp[num].table_size / ps_tmp[num].elem_size,    \
+                    ps_tmp[num].ps_bits, 1, 1,                                          \
+                    ps_tmp[num].ps_codes, ps_tmp[num].elem_size, ps_tmp[num].elem_size, \
+                    size);
+
+#define PS_VLC_ROW(name) \
+    { name ## _codes, name ## _bits, sizeof(name ## _codes), sizeof(name ## _codes[0]) }
+
+av_cold void AAC_RENAME(ff_ps_init)(void) {
+    // Syntax initialization
+    static const struct {
+        const void *ps_codes, *ps_bits;
+        const unsigned int table_size, elem_size;
+    } ps_tmp[] = {
+        PS_VLC_ROW(huff_iid_df1),
+        PS_VLC_ROW(huff_iid_dt1),
+        PS_VLC_ROW(huff_iid_df0),
+        PS_VLC_ROW(huff_iid_dt0),
+        PS_VLC_ROW(huff_icc_df),
+        PS_VLC_ROW(huff_icc_dt),
+        PS_VLC_ROW(huff_ipd_df),
+        PS_VLC_ROW(huff_ipd_dt),
+        PS_VLC_ROW(huff_opd_df),
+        PS_VLC_ROW(huff_opd_dt),
+    };
+
+    PS_INIT_VLC_STATIC(0, 1544);
+    PS_INIT_VLC_STATIC(1,  832);
+    PS_INIT_VLC_STATIC(2, 1024);
+    PS_INIT_VLC_STATIC(3, 1036);
+    PS_INIT_VLC_STATIC(4,  544);
+    PS_INIT_VLC_STATIC(5,  544);
+    PS_INIT_VLC_STATIC(6,  512);
+    PS_INIT_VLC_STATIC(7,  512);
+    PS_INIT_VLC_STATIC(8,  512);
+    PS_INIT_VLC_STATIC(9,  512);
+
+    ps_tableinit();
+}
+
+av_cold void AAC_RENAME(ff_ps_ctx_init)(PSContext *ps)
+{
+    ff_psdsp_init(&ps->dsp);
+}
+
+static void stereo_processing_fixed(PSContext *ps, int (*l)[32][2], int (*r)[32][2], int is34)
+{
+    int e, b, k;
+    long long accu;
+    int (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;
+    int (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;
+    int (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;
+    int (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;
     int8_t *opd_hist = ps->opd_hist;
     int8_t *ipd_hist = ps->ipd_hist;
     int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];
@@ -810,7 +960,7 @@
     int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;
     int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;
     const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
-    const float (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;
+    const int (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;
 
     //Remapping
     if (ps->num_env_old) {
@@ -850,14 +1000,14 @@
             remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);
         }
         if (ps->is34bands_old) {
-            map_val_34_to_20(H11[0][0]);
-            map_val_34_to_20(H11[1][0]);
-            map_val_34_to_20(H12[0][0]);
-            map_val_34_to_20(H12[1][0]);
-            map_val_34_to_20(H21[0][0]);
-            map_val_34_to_20(H21[1][0]);
-            map_val_34_to_20(H22[0][0]);
-            map_val_34_to_20(H22[1][0]);
+            map_val_34_to_20_fixed(H11[0][0]);
+            map_val_34_to_20_fixed(H11[1][0]);
+            map_val_34_to_20_fixed(H12[0][0]);
+            map_val_34_to_20_fixed(H12[1][0]);
+            map_val_34_to_20_fixed(H21[0][0]);
+            map_val_34_to_20_fixed(H21[1][0]);
+            map_val_34_to_20_fixed(H22[0][0]);
+            map_val_34_to_20_fixed(H22[1][0]);
             ipdopd_reset(ipd_hist, opd_hist);
         }
     }
@@ -865,7 +1015,8 @@
     //Mixing
     for (e = 0; e < ps->num_env; e++) {
         for (b = 0; b < NR_PAR_BANDS[is34]; b++) {
-            float h11, h12, h21, h22;
+            int h11, h12, h21, h22;
+
             h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];
             h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];
             h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];
@@ -873,27 +1024,39 @@
             if (!PS_BASELINE && ps->enable_ipdopd && b < ps->nr_ipdopd_par) {
                 //The spec say says to only run this smoother when enable_ipdopd
                 //is set but the reference decoder appears to run it constantly
-                float h11i, h12i, h21i, h22i;
-                float ipd_adj_re, ipd_adj_im;
+                int h11i, h12i, h21i, h22i;
+                int ipd_adj_re, ipd_adj_im;
                 int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];
                 int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];
-                float opd_re = pd_re_smooth[opd_idx];
-                float opd_im = pd_im_smooth[opd_idx];
-                float ipd_re = pd_re_smooth[ipd_idx];
-                float ipd_im = pd_im_smooth[ipd_idx];
+                int opd_re = pd_re_smooth[opd_idx];
+                int opd_im = pd_im_smooth[opd_idx];
+                int ipd_re = pd_re_smooth[ipd_idx];
+                int ipd_im = pd_im_smooth[ipd_idx];
                 opd_hist[b] = opd_idx & 0x3F;
                 ipd_hist[b] = ipd_idx & 0x3F;
 
-                ipd_adj_re = opd_re*ipd_re + opd_im*ipd_im;
-                ipd_adj_im = opd_im*ipd_re - opd_re*ipd_im;
-                h11i = h11 * opd_im;
-                h11  = h11 * opd_re;
-                h12i = h12 * ipd_adj_im;
-                h12  = h12 * ipd_adj_re;
-                h21i = h21 * opd_im;
-                h21  = h21 * opd_re;
-                h22i = h22 * ipd_adj_im;
-                h22  = h22 * ipd_adj_re;
+                accu  = (long long)opd_re*ipd_re;
+                accu += (long long)opd_im*ipd_im;
+                ipd_adj_re = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)opd_im*ipd_re;
+                accu -= (long long)opd_re*ipd_im;
+                ipd_adj_im = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h11 * opd_im;
+                h11i = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h11 * opd_re;
+                h11 = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h12 * ipd_adj_im;
+                h12i = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h12 * ipd_adj_re;
+                h12 = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h21 * opd_im;
+                h21i = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h21 * opd_re;
+                h21 = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h22 * ipd_adj_im;
+                h22i = (int)((accu + 0x20000000) >> 30);
+                accu  = (long long)h22 * ipd_adj_re;
+                h22 = (int)((accu + 0x20000000) >> 30);
                 H11[1][e+1][b] = h11i;
                 H12[1][e+1][b] = h12i;
                 H21[1][e+1][b] = h21i;
@@ -905,136 +1068,61 @@
             H22[0][e+1][b] = h22;
         }
         for (k = 0; k < NR_BANDS[is34]; k++) {
-            float h11r, h12r, h21r, h22r;
-            float h11i, h12i, h21i, h22i;
-            float h11r_step, h12r_step, h21r_step, h22r_step;
-            float h11i_step, h12i_step, h21i_step, h22i_step;
+            int h[2][4];
+            int h_step[2][4];
             int start = ps->border_position[e];
             int stop  = ps->border_position[e+1];
-            float width = 1.f / (stop - start);
+            int width = 1073741824 / (stop - start);
+            width <<= 1;
             b = k_to_i[k];
-            h11r = H11[0][e][b];
-            h12r = H12[0][e][b];
-            h21r = H21[0][e][b];
-            h22r = H22[0][e][b];
+            h[0][0] = H11[0][e][b];
+            h[0][1] = H12[0][e][b];
+            h[0][2] = H21[0][e][b];
+            h[0][3] = H22[0][e][b];
             if (!PS_BASELINE && ps->enable_ipdopd) {
             //Is this necessary? ps_04_new seems unchanged
-            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {
-                h11i = -H11[1][e][b];
-                h12i = -H12[1][e][b];
-                h21i = -H21[1][e][b];
-                h22i = -H22[1][e][b];
-            } else {
-                h11i = H11[1][e][b];
-                h12i = H12[1][e][b];
-                h21i = H21[1][e][b];
-                h22i = H22[1][e][b];
-            }
+                if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {
+                    h[1][0] = -H11[1][e][b];
+                    h[1][1] = -H12[1][e][b];
+                    h[1][2] = -H21[1][e][b];
+                    h[1][3] = -H22[1][e][b];
+                } else {
+                    h[1][0] = H11[1][e][b];
+                    h[1][1] = H12[1][e][b];
+                    h[1][2] = H21[1][e][b];
+                    h[1][3] = H22[1][e][b];
+                }
             }
             //Interpolation
-            h11r_step = (H11[0][e+1][b] - h11r) * width;
-            h12r_step = (H12[0][e+1][b] - h12r) * width;
-            h21r_step = (H21[0][e+1][b] - h21r) * width;
-            h22r_step = (H22[0][e+1][b] - h22r) * width;
+            accu  = (long long)H11[0][e+1][b] * width;
+            accu -= (long long)h[0][0] * width;
+            h_step[0][0] = (int)((accu + 0x40000000) >> 31);
+            accu  = (long long)H12[0][e+1][b] * width;
+            accu -= (long long)h[0][1] * width;
+            h_step[0][1] = (int)((accu + 0x40000000) >> 31);
+            accu  = (long long)H21[0][e+1][b] * width;
+            accu -= (long long)h[0][2] * width;
+            h_step[0][2] = (int)((accu + 0x40000000) >> 31);
+            accu  = (long long)H22[0][e+1][b] * width;
+            accu -= (long long)h[0][3] * width;
+            h_step[0][3] = (int)((accu + 0x40000000) >> 31);
             if (!PS_BASELINE && ps->enable_ipdopd) {
-                h11i_step = (H11[1][e+1][b] - h11i) * width;
-                h12i_step = (H12[1][e+1][b] - h12i) * width;
-                h21i_step = (H21[1][e+1][b] - h21i) * width;
-                h22i_step = (H22[1][e+1][b] - h22i) * width;
-            }
-            for (n = start + 1; n <= stop; n++) {
-                //l is s, r is d
-                float l_re = l[k][n][0];
-                float l_im = l[k][n][1];
-                float r_re = r[k][n][0];
-                float r_im = r[k][n][1];
-                h11r += h11r_step;
-                h12r += h12r_step;
-                h21r += h21r_step;
-                h22r += h22r_step;
-                if (!PS_BASELINE && ps->enable_ipdopd) {
-                    h11i += h11i_step;
-                    h12i += h12i_step;
-                    h21i += h21i_step;
-                    h22i += h22i_step;
-
-                    l[k][n][0] = h11r*l_re + h21r*r_re - h11i*l_im - h21i*r_im;
-                    l[k][n][1] = h11r*l_im + h21r*r_im + h11i*l_re + h21i*r_re;
-                    r[k][n][0] = h12r*l_re + h22r*r_re - h12i*l_im - h22i*r_im;
-                    r[k][n][1] = h12r*l_im + h22r*r_im + h12i*l_re + h22i*r_re;
-                } else {
-                    l[k][n][0] = h11r*l_re + h21r*r_re;
-                    l[k][n][1] = h11r*l_im + h21r*r_im;
-                    r[k][n][0] = h12r*l_re + h22r*r_re;
-                    r[k][n][1] = h12r*l_im + h22r*r_im;
-                }
+                accu  = (long long)H11[1][e+1][b] * width;
+                accu -= (long long)h[1][0] * width;
+                h_step[1][0] = (int)((accu + 0x40000000) >> 31);
+                accu  = (long long)H12[1][e+1][b] * width;
+                accu -= (long long)h[1][1] * width;
+                h_step[1][1] = (int)((accu + 0x40000000) >> 31);
+                accu  = (long long)H21[1][e+1][b] * width;
+                accu -= (long long)h[1][2] * width;
+                h_step[1][2] = (int)((accu + 0x40000000) >> 31);
+                accu  = (long long)H22[1][e+1][b] * width;
+                accu -= (long long)h[1][3] * width;
+                h_step[1][3] = (int)((accu + 0x40000000) >> 31);
             }
+            ps->dsp.stereo_interpolate_fixed[!PS_BASELINE && ps->enable_ipdopd](
+                l[k] + start + 1, r[k] + start + 1,
+                h, h_step, stop - start);
         }
     }
 }
-
-int ff_ps_apply(AVCodecContext *avctx, PSContext *ps, float L[2][38][64], float R[2][38][64], int top)
-{
-    float Lbuf[91][32][2];
-    float Rbuf[91][32][2];
-    const int len = 32;
-    int is34 = ps->is34bands;
-
-    top += NR_BANDS[is34] - 64;
-    memset(ps->delay+top, 0, (NR_BANDS[is34] - top)*sizeof(ps->delay[0]));
-    if (top < NR_ALLPASS_BANDS[is34])
-        memset(ps->ap_delay + top, 0, (NR_ALLPASS_BANDS[is34] - top)*sizeof(ps->ap_delay[0]));
-
-    hybrid_analysis(Lbuf, ps->in_buf, L, is34, len);
-    decorrelation(ps, Rbuf, Lbuf, is34);
-    stereo_processing(ps, Lbuf, Rbuf, is34);
-    hybrid_synthesis(L, Lbuf, is34, len);
-    hybrid_synthesis(R, Rbuf, is34, len);
-
-    return 0;
-}
-
-#define PS_INIT_VLC_STATIC(num, size) \
-    INIT_VLC_STATIC(&vlc_ps[num], 9, ps_tmp[num].table_size / ps_tmp[num].elem_size,    \
-                    ps_tmp[num].ps_bits, 1, 1,                                          \
-                    ps_tmp[num].ps_codes, ps_tmp[num].elem_size, ps_tmp[num].elem_size, \
-                    size);
-
-#define PS_VLC_ROW(name) \
-    { name ## _codes, name ## _bits, sizeof(name ## _codes), sizeof(name ## _codes[0]) }
-
-av_cold void ff_ps_init(void) {
-    // Syntax initialization
-    static const struct {
-        const void *ps_codes, *ps_bits;
-        const unsigned int table_size, elem_size;
-    } ps_tmp[] = {
-        PS_VLC_ROW(huff_iid_df1),
-        PS_VLC_ROW(huff_iid_dt1),
-        PS_VLC_ROW(huff_iid_df0),
-        PS_VLC_ROW(huff_iid_dt0),
-        PS_VLC_ROW(huff_icc_df),
-        PS_VLC_ROW(huff_icc_dt),
-        PS_VLC_ROW(huff_ipd_df),
-        PS_VLC_ROW(huff_ipd_dt),
-        PS_VLC_ROW(huff_opd_df),
-        PS_VLC_ROW(huff_opd_dt),
-    };
-
-    PS_INIT_VLC_STATIC(0, 1544);
-    PS_INIT_VLC_STATIC(1,  832);
-    PS_INIT_VLC_STATIC(2, 1024);
-    PS_INIT_VLC_STATIC(3, 1036);
-    PS_INIT_VLC_STATIC(4,  544);
-    PS_INIT_VLC_STATIC(5,  544);
-    PS_INIT_VLC_STATIC(6,  512);
-    PS_INIT_VLC_STATIC(7,  512);
-    PS_INIT_VLC_STATIC(8,  512);
-    PS_INIT_VLC_STATIC(9,  512);
-
-    ps_tableinit();
-}
-
-av_cold void ff_ps_ctx_init(PSContext *ps)
-{
-}
diff -uNr ffmpeg-0.7.12/libavcodec/aacpsdata.c ffmpeg-0.7.12-140902/libavcodec/aacpsdata.c
--- ffmpeg-0.7.12/libavcodec/aacpsdata.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacpsdata.c	2014-09-02 15:16:52.000000000 +0800
@@ -157,7 +157,7 @@
     33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33
 };
 
-static const float g1_Q2[] = {
-    0.0f,  0.01899487526049f, 0.0f, -0.07293139167538f,
-    0.0f,  0.30596630545168f, 0.5f
+static const INTFLOAT g1_Q2[] = {
+    Q31(0.0f),  Q31(0.01899487526049f), Q31(0.0f), Q31(-0.07293139167538f),
+    Q31(0.0f),  Q31(0.30596630545168f), Q31(0.5f)
 };
diff -uNr ffmpeg-0.7.12/libavcodec/aacpsdsp.c ffmpeg-0.7.12-140902/libavcodec/aacpsdsp.c
--- ffmpeg-0.7.12/libavcodec/aacpsdsp.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacpsdsp.c	2014-09-02 16:55:33.000000000 +0800
@@ -0,0 +1,433 @@
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 1
+#define CONFIG_AAC_FIXED 1
+#define CONFIG_FIXED 1
+//jh
+#include "aacpsdsp.h"
+
+static void ps_add_squares_c(float *dst, const float (*src)[2], int n)
+{
+    int i;
+    for (i = 0; i < n; i++)
+        dst[i] += src[i][0] * src[i][0] + src[i][1] * src[i][1];
+}
+
+static void ps_add_squares_fixed_c(int *dst, const int (*src)[2], int n)
+{
+    int i;
+    long long accu;
+
+    for (i = 0; i < n; i++) {
+        accu  = (long long)src[i][0] * src[i][0];
+       accu += (long long)src[i][1] * src[i][1];
+        dst[i] += (int)((accu + 0x8000000) >> 28);
+    }
+}
+
+static void ps_mul_pair_single_c(float (*dst)[2], float (*src0)[2], float *src1,
+                                 int n)
+{
+    int i;
+    for (i = 0; i < n; i++) {
+        dst[i][0] = src0[i][0] * src1[i];
+        dst[i][1] = src0[i][1] * src1[i];
+    }
+}
+
+static void ps_mul_pair_single_fixed_c(int (*dst)[2], int (*src0)[2], int *src1,
+                                     int n)
+{
+    int i;
+    long long accu;
+
+    for (i = 0; i < n; i++) {
+        accu = (long long)src0[i][0] * src1[i];
+        dst[i][0] = (int)((accu + 0x8000) >> 16);
+        accu = (long long)src0[i][1] * src1[i];
+        dst[i][1] = (int)((accu + 0x8000) >> 16);
+    }
+}
+
+static void ps_hybrid_analysis_c(float (*out)[2], float (*in)[2],
+                                 const float (*filter)[8][2],
+                                 int stride, int n)
+{
+    int i, j;
+
+    for (i = 0; i < n; i++) {
+        float sum_re = filter[i][6][0] * in[6][0];
+        float sum_im = filter[i][6][0] * in[6][1];
+
+        for (j = 0; j < 6; j++) {
+            float in0_re = in[j][0];
+            float in0_im = in[j][1];
+            float in1_re = in[12-j][0];
+            float in1_im = in[12-j][1];
+            sum_re += filter[i][j][0] * (in0_re + in1_re) -
+                      filter[i][j][1] * (in0_im - in1_im);
+            sum_im += filter[i][j][0] * (in0_im + in1_im) +
+                      filter[i][j][1] * (in0_re - in1_re);
+        }
+        out[i * stride][0] = sum_re;
+        out[i * stride][1] = sum_im;
+    }
+}
+
+static void ps_hybrid_analysis_fixed_c(int (*out)[2], int (*in)[2],
+                                     const int (*filter)[8][2],
+                                     int stride, int n)
+{
+    int i, j;
+    long long sum_re, sum_im;
+
+    for (i = 0; i < n; i++) {
+        sum_re = (long long)filter[i][6][0] * in[6][0];
+        sum_im = (long long)filter[i][6][0] * in[6][1];
+
+        for (j = 0; j < 6; j++) {
+            int in0_re = in[j][0];
+            int in0_im = in[j][1];
+            int in1_re = in[12-j][0];
+            int in1_im = in[12-j][1];
+            sum_re += (long long)filter[i][j][0] * (in0_re + in1_re);
+            sum_re -= (long long)filter[i][j][1] * (in0_im - in1_im);
+            sum_im += (long long)filter[i][j][0] * (in0_im + in1_im);
+            sum_im += (long long)filter[i][j][1] * (in0_re - in1_re);
+        }
+        out[i * stride][0] = (int)((sum_re + 0x40000000) >> 31);
+        out[i * stride][1] = (int)((sum_im + 0x40000000) >> 31);
+    }
+}
+
+static void ps_hybrid_analysis_ileave_c(float (*out)[32][2], float L[2][38][64],
+                                        int i, int len)
+{
+    int j;
+
+    for (; i < 64; i++) {
+        for (j = 0; j < len; j++) {
+            out[i][j][0] = L[0][j][i];
+            out[i][j][1] = L[1][j][i];
+        }
+    }
+}
+static void ps_hybrid_analysis_ileave_fixed_c(int (*out)[32][2], int L[2][38][64],
+                                            int i, int len)
+{
+    int j;
+
+    for (; i < 64; i++) {
+        for (j = 0; j < len; j++) {
+            out[i][j][0] = L[0][j][i];
+            out[i][j][1] = L[1][j][i];
+        }
+    }
+}
+static void ps_hybrid_synthesis_deint_c(float out[2][38][64],
+                                        float (*in)[32][2],
+                                        int i, int len)
+{
+    int n;
+
+    for (; i < 64; i++) {
+        for (n = 0; n < len; n++) {
+            out[0][n][i] = in[i][n][0];
+            out[1][n][i] = in[i][n][1];
+        }
+    }
+}
+static void ps_hybrid_synthesis_deint_fixed_c(int out[2][38][64],
+                                            int (*in)[32][2],
+                                            int i, int len)
+{
+    int n;
+
+    for (; i < 64; i++) {
+        for (n = 0; n < len; n++) {
+            out[0][n][i] = in[i][n][0];
+            out[1][n][i] = in[i][n][1];
+        }
+    }
+}
+static void ps_decorrelate_c(float (*out)[2], float (*delay)[2],
+                             float (*ap_delay)[PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2],
+                             const float phi_fract[2], float (*Q_fract)[2],
+                             const float *transient_gain,
+                             float g_decay_slope,
+                             int len)
+{
+    static const float a[] = { 0.65143905753106f,
+                               0.56471812200776f,
+                               0.48954165955695f };
+    float ag[PS_AP_LINKS];
+    int m, n;
+
+    for (m = 0; m < PS_AP_LINKS; m++)
+        ag[m] = a[m] * g_decay_slope;
+
+    for (n = 0; n < len; n++) {
+        float in_re = delay[n][0] * phi_fract[0] - delay[n][1] * phi_fract[1];
+        float in_im = delay[n][0] * phi_fract[1] + delay[n][1] * phi_fract[0];
+        for (m = 0; m < PS_AP_LINKS; m++) {
+            float a_re                = ag[m] * in_re;
+            float a_im                = ag[m] * in_im;
+            float link_delay_re       = ap_delay[m][n+2-m][0];
+            float link_delay_im       = ap_delay[m][n+2-m][1];
+            float fractional_delay_re = Q_fract[m][0];
+            float fractional_delay_im = Q_fract[m][1];
+            float apd_re = in_re;
+            float apd_im = in_im;
+            in_re = link_delay_re * fractional_delay_re -
+                    link_delay_im * fractional_delay_im - a_re;
+            in_im = link_delay_re * fractional_delay_im +
+                    link_delay_im * fractional_delay_re - a_im;
+            ap_delay[m][n+5][0] = apd_re + ag[m] * in_re;
+            ap_delay[m][n+5][1] = apd_im + ag[m] * in_im;
+        }
+        out[n][0] = transient_gain[n] * in_re;
+        out[n][1] = transient_gain[n] * in_im;
+    }
+}
+
+static void ps_decorrelate_fixed_c(int (*out)[2], int (*delay)[2],
+                             int (*ap_delay)[PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2],
+                             const int phi_fract[2], int (*Q_fract)[2],
+                             const int *transient_gain,
+                             int g_decay_slope,
+                             int len)
+{
+    static const int a[] = { 1398954724, 1212722933, 1051282709 };
+    int ag[PS_AP_LINKS];
+    int m, n;
+    long long accu;
+
+    for (m = 0; m < PS_AP_LINKS; m++) {
+      accu = (long long)a[m] * g_decay_slope;
+      ag[m] = (int)((accu + 0x20000000) >> 30);
+    }
+
+    for (n = 0; n < len; n++) {
+        int in_re;
+        int in_im;
+
+        accu  = (long long)delay[n][0] * phi_fract[0];
+        accu -= (long long)delay[n][1] * phi_fract[1];
+        in_re = (int)((accu + 0x20000000) >> 30);
+        accu  = (long long)delay[n][0] * phi_fract[1];
+        accu += (long long)delay[n][1] * phi_fract[0];
+        in_im = (int)((accu + 0x20000000) >> 30);
+        for (m = 0; m < PS_AP_LINKS; m++) {
+            int a_re;
+            int a_im;
+            int link_delay_re       = ap_delay[m][n+2-m][0];
+            int link_delay_im       = ap_delay[m][n+2-m][1];
+            int fractional_delay_re = Q_fract[m][0];
+            int fractional_delay_im = Q_fract[m][1];
+            int apd_re = in_re;
+            int apd_im = in_im;
+
+            accu  = (long long)ag[m] * in_re;
+            a_re = (int)((accu + 0x40000000) >> 31);
+            accu  = (long long)ag[m] * in_im;
+            a_im = (int)((accu + 0x40000000) >> 31);
+
+            accu   = (long long)link_delay_re * fractional_delay_re;
+            accu  -= (long long)link_delay_im * fractional_delay_im;
+            in_re = (int)((accu + 0x20000000) >> 30) - a_re;
+            accu   = (long long)link_delay_re * fractional_delay_im;
+            accu  += (long long)link_delay_im * fractional_delay_re;
+            in_im = (int)((accu + 0x20000000) >> 30) - a_im;
+
+            accu  = (long long)ag[m] * in_re;
+            ap_delay[m][n+5][0] = apd_re + (int)((accu + 0x40000000) >> 31);
+            accu  = (long long)ag[m] * in_im;
+            ap_delay[m][n+5][1] = apd_im + (int)((accu + 0x40000000) >> 31);
+        }
+        accu  = (long long)transient_gain[n] * in_re;
+        out[n][0] = (int)((accu + 0x8000) >> 16);
+        accu  = (long long)transient_gain[n] * in_im;
+        out[n][1] = (int)((accu + 0x8000) >> 16);
+    }
+}
+
+
+static void ps_stereo_interpolate_c(float (*l)[2], float (*r)[2],
+                                    float h[2][4], float h_step[2][4],
+                                    int len)
+{
+    float h0 = h[0][0];
+    float h1 = h[0][1];
+    float h2 = h[0][2];
+    float h3 = h[0][3];
+    float hs0 = h_step[0][0];
+    float hs1 = h_step[0][1];
+    float hs2 = h_step[0][2];
+    float hs3 = h_step[0][3];
+    int n;
+
+    for (n = 0; n < len; n++) {
+        //l is s, r is d
+        float l_re = l[n][0];
+        float l_im = l[n][1];
+        float r_re = r[n][0];
+        float r_im = r[n][1];
+        h0 += hs0;
+        h1 += hs1;
+        h2 += hs2;
+        h3 += hs3;
+        l[n][0] = h0 * l_re + h2 * r_re;
+        l[n][1] = h0 * l_im + h2 * r_im;
+        r[n][0] = h1 * l_re + h3 * r_re;
+        r[n][1] = h1 * l_im + h3 * r_im;
+    }
+}
+
+static void ps_stereo_interpolate_fixed_c(int (*l)[2], int (*r)[2],
+                                    int h[2][4], int h_step[2][4],
+                                    int len)
+{
+    int h0 = h[0][0];
+    int h1 = h[0][1];
+    int h2 = h[0][2];
+    int h3 = h[0][3];
+    int hs0 = h_step[0][0];
+    int hs1 = h_step[0][1];
+    int hs2 = h_step[0][2];
+    int hs3 = h_step[0][3];
+    int n;
+
+    for (n = 0; n < len; n++) {
+        //l is s, r is d
+        long long accu;
+        int l_re = l[n][0];
+        int l_im = l[n][1];
+        int r_re = r[n][0];
+        int r_im = r[n][1];
+        h0 += hs0;
+        h1 += hs1;
+        h2 += hs2;
+        h3 += hs3;
+        accu  = (long long)h0 * l_re;
+        accu += (long long)h2 * r_re;
+        l[n][0] = (int)((accu + 0x20000000) >> 30);
+        accu  = (long long)h0 * l_im;
+        accu += (long long)h2 * r_im;
+        l[n][1] = (int)((accu + 0x20000000) >> 30);
+        accu  = (long long)h1 * l_re;
+        accu += (long long)h3 * r_re;
+        r[n][0] = (int)((accu + 0x20000000) >> 30);
+        accu  = (long long)h1 * l_im;
+        accu += (long long)h3 * r_im;
+        r[n][1] = (int)((accu + 0x20000000) >> 30);
+    }
+}
+
+static void ps_stereo_interpolate_ipdopd_c(float (*l)[2], float (*r)[2],
+                                           float h[2][4], float h_step[2][4],
+                                           int len)
+{
+    float h00  = h[0][0],      h10  = h[1][0];
+    float h01  = h[0][1],      h11  = h[1][1];
+    float h02  = h[0][2],      h12  = h[1][2];
+    float h03  = h[0][3],      h13  = h[1][3];
+    float hs00 = h_step[0][0], hs10 = h_step[1][0];
+    float hs01 = h_step[0][1], hs11 = h_step[1][1];
+    float hs02 = h_step[0][2], hs12 = h_step[1][2];
+    float hs03 = h_step[0][3], hs13 = h_step[1][3];
+    int n;
+
+    for (n = 0; n < len; n++) {
+        //l is s, r is d
+        float l_re = l[n][0];
+        float l_im = l[n][1];
+        float r_re = r[n][0];
+        float r_im = r[n][1];
+        h00 += hs00;
+        h01 += hs01;
+        h02 += hs02;
+        h03 += hs03;
+        h10 += hs10;
+        h11 += hs11;
+        h12 += hs12;
+        h13 += hs13;
+
+        l[n][0] = h00 * l_re + h02 * r_re - h10 * l_im - h12 * r_im;
+        l[n][1] = h00 * l_im + h02 * r_im + h10 * l_re + h12 * r_re;
+        r[n][0] = h01 * l_re + h03 * r_re - h11 * l_im - h13 * r_im;
+        r[n][1] = h01 * l_im + h03 * r_im + h11 * l_re + h13 * r_re;
+    }
+}
+
+static void ps_stereo_interpolate_ipdopd_fixed_c(int (*l)[2], int (*r)[2],
+                                           int h[2][4], int h_step[2][4],
+                                           int len)
+{
+    int h00  = h[0][0],      h10  = h[1][0];
+    int h01  = h[0][1],      h11  = h[1][1];
+    int h02  = h[0][2],      h12  = h[1][2];
+    int h03  = h[0][3],      h13  = h[1][3];
+    int hs00 = h_step[0][0], hs10 = h_step[1][0];
+    int hs01 = h_step[0][1], hs11 = h_step[1][1];
+    int hs02 = h_step[0][2], hs12 = h_step[1][2];
+    int hs03 = h_step[0][3], hs13 = h_step[1][3];
+    int n;
+
+    for (n = 0; n < len; n++) {
+        //l is s, r is d
+        long long accu;
+        int l_re = l[n][0];
+        int l_im = l[n][1];
+        int r_re = r[n][0];
+        int r_im = r[n][1];
+        h00 += hs00;
+        h01 += hs01;
+        h02 += hs02;
+        h03 += hs03;
+        h10 += hs10;
+        h11 += hs11;
+        h12 += hs12;
+        h13 += hs13;
+
+        accu  = (long long)h00 * l_re;
+        accu += (long long)h02 * r_re;
+        accu -= (long long)h10 * l_im;
+        accu -= (long long)h12 * r_im;
+        l[n][0] = (int)((accu + 0x20000000) >> 30);
+        accu  = (long long)h00 * l_im;
+        accu += (long long)h02 * r_im;
+        accu += (long long)h10 * l_re;
+        accu += (long long)h12 * r_re;
+        l[n][1] = (int)((accu + 0x20000000) >> 30);
+        accu  = (long long)h01 * l_re;
+        accu += (long long)h03 * r_re;
+        accu -= (long long)h11 * l_im;
+        accu -= (long long)h13 * r_im;
+        r[n][0] = (int)((accu + 0x20000000) >> 30);
+        accu  = (long long)h01 * l_im;
+        accu += (long long)h03 * r_im;
+        accu += (long long)h11 * l_re;
+        accu += (long long)h13 * r_re;
+        r[n][1] = (int)((accu + 0x20000000) >> 30);
+    }
+}
+
+void ff_psdsp_init(PSDSPContext *s)
+{
+    s->add_squares                  = ps_add_squares_c;
+    s->add_squares_fixed            = ps_add_squares_fixed_c;
+    s->mul_pair_single              = ps_mul_pair_single_c;
+    s->mul_pair_single_fixed        = ps_mul_pair_single_fixed_c;
+    s->hybrid_analysis              = ps_hybrid_analysis_c;
+    s->hybrid_analysis_fixed        = ps_hybrid_analysis_fixed_c;
+    s->hybrid_analysis_ileave       = ps_hybrid_analysis_ileave_c;
+    s->hybrid_analysis_ileave_fixed = ps_hybrid_analysis_ileave_fixed_c;
+    s->hybrid_synthesis_deint       = ps_hybrid_synthesis_deint_c;
+    s->hybrid_synthesis_deint_fixed = ps_hybrid_synthesis_deint_fixed_c;
+    s->decorrelate                  = ps_decorrelate_c;
+    s->decorrelate_fixed            = ps_decorrelate_fixed_c;
+    s->stereo_interpolate[0]        = ps_stereo_interpolate_c;
+    s->stereo_interpolate_fixed[0]  = ps_stereo_interpolate_fixed_c;
+    s->stereo_interpolate[1]        = ps_stereo_interpolate_ipdopd_c;
+    s->stereo_interpolate_fixed[1]  = ps_stereo_interpolate_ipdopd_fixed_c;
+
+}
diff -uNr ffmpeg-0.7.12/libavcodec/aacpsdsp.h ffmpeg-0.7.12-140902/libavcodec/aacpsdsp.h
--- ffmpeg-0.7.12/libavcodec/aacpsdsp.h	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacpsdsp.h	2014-09-02 15:19:26.000000000 +0800
@@ -0,0 +1,52 @@
+#ifndef LIBAVCODEC_AACPSDSP_H
+#define LIBAVCODEC_AACPSDSP_H
+
+#define PS_QMF_TIME_SLOTS 32
+#define PS_AP_LINKS 3
+#define PS_MAX_AP_DELAY 5
+
+typedef struct PSDSPContext {
+    void (*add_squares)(float *dst, const float (*src)[2], int n);
+    void (*add_squares_fixed)(int *dst, const int (*src)[2], int n);
+    void (*mul_pair_single)(float (*dst)[2], float (*src0)[2], float *src1,
+                            int n);
+    void (*mul_pair_single_fixed)(int (*dst)[2], int (*src0)[2], int *src1,
+                            int n);
+    void (*hybrid_analysis)(float (*out)[2], float (*in)[2],
+                            const float (*filter)[8][2],
+                            int stride, int n);
+    void (*hybrid_analysis_fixed)(int (*out)[2], int (*in)[2],
+                            const int (*filter)[8][2],
+                            int stride, int n);
+    void (*hybrid_analysis_ileave)(float (*out)[32][2], float L[2][38][64],
+                                   int i, int len);
+    void (*hybrid_analysis_ileave_fixed)(int (*out)[32][2], int L[2][38][64],
+                                   int i, int len);
+    void (*hybrid_synthesis_deint)(float out[2][38][64], float (*in)[32][2],
+                                   int i, int len);
+    void (*hybrid_synthesis_deint_fixed)(int out[2][38][64], int (*in)[32][2],
+                                   int i, int len);
+    void (*decorrelate)(float (*out)[2], float (*delay)[2],
+                        float (*ap_delay)[PS_QMF_TIME_SLOTS+PS_MAX_AP_DELAY][2],
+                        const float phi_fract[2], float (*Q_fract)[2],
+                        const float *transient_gain,
+                        float g_decay_slope,
+                        int len);
+    void (*decorrelate_fixed)(int (*out)[2], int (*delay)[2],
+                        int (*ap_delay)[PS_QMF_TIME_SLOTS+PS_MAX_AP_DELAY][2],
+                        const int phi_fract[2], int (*Q_fract)[2],
+                        const int *transient_gain,
+                        int g_decay_slope,
+                        int len);
+    void (*stereo_interpolate[2])(float (*l)[2], float (*r)[2],
+                                  float h[2][4], float h_step[2][4],
+                                  int len);
+    void (*stereo_interpolate_fixed[2])(int (*l)[2], int (*r)[2],
+                                  int h[2][4], int h_step[2][4],
+                                  int len);
+} PSDSPContext;
+
+void ff_psdsp_init(PSDSPContext *s);
+void ff_psdsp_init_arm(PSDSPContext *s);
+
+#endif /* LIBAVCODEC_AACPSDSP_H */
diff -uNr ffmpeg-0.7.12/libavcodec/aacps_fixed_tablegen.c ffmpeg-0.7.12-140902/libavcodec/aacps_fixed_tablegen.c
--- ffmpeg-0.7.12/libavcodec/aacps_fixed_tablegen.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacps_fixed_tablegen.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,72 @@
+#include <stdlib.h>                 
+#define CONFIG_HARDCODED_TABLES 0                                                                         
+                                    
+#include "aacps_fixed_tablegen.h"                                                                         
+#include "tableprint.h"             
+                                    
+void write_int32_t_3d_array (const void *p, int b, int c, int d)                                          
+{                                   
+    int i;                          
+    const int32_t *f = p;           
+    for (i = 0; i < b; i++) {       
+        printf("{\n");              
+        write_uint32_t_2d_array(f, c, d);                                                                 
+        printf("},\n");             
+        f += c * d;                 
+    }                               
+}                                   
+                                    
+void write_int32_t_4d_array (const void *p, int a, int b, int c, int d)                                   
+{                                   
+    int i;                          
+    const int32_t *f = p;           
+    for (i = 0; i < a; i++) {       
+        printf("{\n");              
+        write_int32_t_3d_array(f, b, c, d);                                                               
+        printf("},\n");             
+        f += b * c * d;             
+    }                               
+}                                   
+                                    
+int main(void)                      
+{                                   
+    ps_tableinit();                 
+                                    
+    write_fileheader();             
+                                    
+    printf("static const int32_t pd_re_smooth[8*8*8] = {\n");                                             
+    write_int32_t_array(pd_re_smooth, 8*8*8);                                                             
+    printf("};\n");                 
+    printf("static const int32_t pd_im_smooth[8*8*8] = {\n");                                             
+    write_int32_t_array(pd_im_smooth, 8*8*8);                                                             
+    printf("};\n");                 
+                                    
+    printf("static const int32_t HA[46][8][4] = {\n");                                                    
+    write_int32_t_3d_array(HA, 46, 8, 4);                                                                 
+    printf("};\n");                 
+    printf("static const int32_t HB[46][8][4] = {\n");                                                    
+    write_int32_t_3d_array(HB, 46, 8, 4);                                                                 
+    printf("};\n");                 
+                                    
+    printf("static const DECLARE_ALIGNED(16, int32_t, f20_0_8)[8][8][2] = {\n");                          
+    write_int32_t_3d_array(f20_0_8, 8, 8, 2);                                                             
+    printf("};\n");                 
+    printf("static const DECLARE_ALIGNED(16, int32_t, f34_0_12)[12][8][2] = {\n");                        
+    write_int32_t_3d_array(f34_0_12, 12, 8, 2);                                                           
+    printf("};\n");                 
+    printf("static const DECLARE_ALIGNED(16, int32_t, f34_1_8)[8][8][2] = {\n");                          
+    write_int32_t_3d_array(f34_1_8, 8, 8, 2);                                                             
+    printf("};\n");                 
+    printf("static const DECLARE_ALIGNED(16, int32_t, f34_2_4)[4][8][2] = {\n");                          
+    write_int32_t_3d_array(f34_2_4, 4, 8, 2);                                                             
+    printf("};\n");                 
+                                    
+    printf("static const DECLARE_ALIGNED(16, int32_t, Q_fract_allpass)[2][50][3][2] = {\n");              
+    write_int32_t_4d_array(Q_fract_allpass, 2, 50, 3, 2);                                                 
+    printf("};\n");                 
+    printf("static const DECLARE_ALIGNED(16, int32_t, phi_fract)[2][50][2] = {\n");                       
+    write_int32_t_3d_array(phi_fract, 2, 50, 2);                                                          
+    printf("};\n");                 
+                                    
+    return 0;                       
+}
diff -uNr ffmpeg-0.7.12/libavcodec/aacps_fixed_tablegen.h ffmpeg-0.7.12-140902/libavcodec/aacps_fixed_tablegen.h
--- ffmpeg-0.7.12/libavcodec/aacps_fixed_tablegen.h	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacps_fixed_tablegen.h	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,405 @@
+#ifndef AACPS_TABLEGEN_FIXED_H      
+#define AACPS_TABLEGEN_FIXED_H      
+                                    
+#include <math.h>                   
+#include <stdint.h>                 
+                                    
+#if CONFIG_HARDCODED_TABLES         
+#define ps_tableinit()              
+#include "libavcodec/aacps_fixed_tables.h"                                                                
+#else                               
+#include "libavutil/common.h"       
+#include "libavutil/mathematics.h"                                                                        
+#include "libavutil/mem.h"          
+                                    
+#include "float_emu.h"              
+#include "float_emu_tab.c"          
+#define NR_ALLPASS_BANDS20 30       
+#define NR_ALLPASS_BANDS34 50       
+#define PS_AP_LINKS 3               
+#define Q30(x) (int)((x)*1073741824.0 + 0.5)                                                              
+#define Q31(x) (int)((x)*2147483648.0 + 0.5)                                                              
+static int pd_re_smooth[8*8*8];     
+static int pd_im_smooth[8*8*8];     
+static int HA[46][8][4];            
+static int HB[46][8][4];            
+static DECLARE_ALIGNED(16, int, f20_0_8) [ 8][8][2];                                                      
+static DECLARE_ALIGNED(16, int, f34_0_12)[12][8][2];                                                      
+static DECLARE_ALIGNED(16, int, f34_1_8) [ 8][8][2];                                                      
+static DECLARE_ALIGNED(16, int, f34_2_4) [ 4][8][2];                                                      
+static DECLARE_ALIGNED(16, int, Q_fract_allpass)[2][50][3][2];                                            
+static DECLARE_ALIGNED(16, int, phi_fract)[2][50][2];                                                     
+                                    
+static const int g0_Q8[] = {        
+    Q31(0.00746082949812f), Q31(0.02270420949825f), Q31(0.04546865930473f), Q31(0.07266113929591f),       
+    Q31(0.09885108575264f), Q31(0.11793710567217f), Q31(0.125f)                                           
+};                                  
+                                    
+static const int g0_Q12[] = {       
+    Q31(0.04081179924692f), Q31(0.03812810994926f), Q31(0.05144908135699f), Q31(0.06399831151592f),       
+    Q31(0.07428313801106f), Q31(0.08100347892914f), Q31(0.08333333333333f)                                
+};                                  
+                                    
+static const int g1_Q8[] = {        
+    Q31(0.01565675600122f), Q31(0.03752716391991f), Q31(0.05417891378782f), Q31(0.08417044116767f),       
+    Q31(0.10307344158036f), Q31(0.12222452249753f), Q31(0.125f)                                           
+};                                  
+                                    
+static const int g2_Q4[] = {        
+    Q31(-0.05908211155639f), Q31(-0.04871498374946f), Q31(0.0f),   Q31(0.07778723915851f),                
+    Q31( 0.16486303567403f), Q31( 0.23279856662996f), Q31(0.25f)                                          
+};                                  
+                                    
+static const int sintbl_4[4]   = {           0,  1073741824,           0, -1073741824 };                  
+static const int costbl_4[4]   = {  1073741824,           0, -1073741824,           0 };                  
+static const int sintbl_8[8]   = {           0,   759250125,  1073741824,   759250125,                    
+                                             0,  -759250125, -1073741824,  -759250125 };                  
+static const int costbl_8[8]   = {  1073741824,   759250125,           0,  -759250125,                    
+                                   -1073741824,  -759250125,           0,   759250125 };                  
+static const int sintbl_12[12] = {           0,   536870912,   929887697,  1073741824,                    
+                                     929887697,   536870912,           0,  -536870912,                    
+                                    -929887697, -1073741824,  -929887697,  -536870912 };                  
+static const int costbl_12[12] = {  1073741824,   929887697,   536870912,           0,                    
+                                    -536870912,  -929887697, -1073741824,  -929887697,                    
+                                    -536870912,           0,   536870912,   929887697 };                  
+                                    
+static void make_filters_from_proto(int (*filter)[8][2], const int *proto, int bands)                     
+{                                   
+                                    
+    const int *sinptr, *cosptr;     
+    int s, c, sinhalf, coshalf;     
+    int q, n;                       
+    long long accu;                 
+                                    
+    if (bands == 4) {               
+        sinptr = sintbl_4;          
+        cosptr = costbl_4;          
+        sinhalf = 759250125;        
+        coshalf = 759250125;        
+    } else if (bands == 8) {        
+        sinptr = sintbl_8;          
+        cosptr = costbl_8;          
+        sinhalf = 410903207;        
+        coshalf = 992008094;        
+    } else {                        
+        sinptr = sintbl_12;         
+        cosptr = costbl_12;         
+        sinhalf = 277904834;        
+        coshalf = 1037154959;       
+    }                               
+                                    
+    for (q = 0; q < bands; q++) {                                                                         
+        for (n = 0; n < 7; n++) {                                                                         
+            int theta = (q*(n-6) + (n>>1) - 3) % bands;                                                   
+                                    
+            if (theta < 0)          
+                theta += bands;     
+            s = sinptr[theta];      
+            c = cosptr[theta];      
+                                    
+            if (n & 1) {            
+                accu  = (long long)c * coshalf;                                                           
+                accu -= (long long)s * sinhalf;                                                           
+                theta = (int)((accu + 0x20000000) >> 30);                                                 
+                                    
+                accu  = (long long)s * coshalf;                                                           
+                accu += (long long)c * sinhalf;                                                           
+                s = (int)((accu + 0x20000000) >> 30);                                                     
+                c = theta;          
+            }                       
+            accu = (long long)proto[n] * c;                                                               
+            filter[q][n][0] = (int)((accu + 0x20000000) >> 30);                                           
+                                    
+            accu = (long long)proto[n] * s;                                                               
+            filter[q][n][1] = -(int)((accu + 0x20000000) >> 30);                                          
+        }                           
+    }                               
+}                                   
+                                    
+static void ps_tableinit(void)      
+{                                   
+    static const int ipdopd_sin[] = { Q30(0), Q30(M_SQRT1_2), Q30(1), Q30( M_SQRT1_2), Q30( 0), Q30(-M_SQRT1_2), Q30(-1), Q30(-M_SQRT1_2) };                                    
+    static const int ipdopd_cos[] = { Q30(1), Q30(M_SQRT1_2), Q30(0), Q30(-M_SQRT1_2), Q30(-1), Q30(-M_SQRT1_2), Q30( 0), Q30( M_SQRT1_2) };                                    
+    int pd0, pd1, pd2;              
+    int idx;                        
+                                    
+    static const int alpha_tab[] =                                                                        
+    {                               
+      Q30(1.5146213770f/M_PI), Q30(1.5181334019f/M_PI), Q30(1.5234849453f/M_PI), Q30(1.5369486809f/M_PI), Q30(1.5500687361f/M_PI), Q30(1.5679757595f/M_PI),                     
+      Q30(1.4455626011f/M_PI), Q30(1.4531552792f/M_PI), Q30(1.4648091793f/M_PI), Q30(1.4945238829f/M_PI), Q30(1.5239057541f/M_PI), Q30(1.5644006729f/M_PI),                     
+      Q30(1.3738563061f/M_PI), Q30(1.3851221800f/M_PI), Q30(1.4026404619f/M_PI), Q30(1.4484288692f/M_PI), Q30(1.4949874878f/M_PI), Q30(1.5604078770f/M_PI),                     
+      Q30(1.2645189762f/M_PI), Q30(1.2796478271f/M_PI), Q30(1.3038636446f/M_PI), Q30(1.3710125685f/M_PI), Q30(1.4443849325f/M_PI), Q30(1.5532352924f/M_PI),                     
+      Q30(1.1507037878f/M_PI), Q30(1.1669205427f/M_PI), Q30(1.1938756704f/M_PI), Q30(1.2754167318f/M_PI), Q30(1.3761177063f/M_PI), Q30(1.5429240465f/M_PI),                     
+      Q30(1.0079245567f/M_PI), Q30(1.0208238363f/M_PI), Q30(1.0433073044f/M_PI), Q30(1.1208510399f/M_PI), Q30(1.2424604893f/M_PI), Q30(1.5185726881f/M_PI),                     
+      Q30(0.8995233774f/M_PI), Q30(0.9069069624f/M_PI), Q30(0.9201194048f/M_PI), Q30(0.9698365927f/M_PI), Q30(1.0671583414f/M_PI), Q30(1.4647934437f/M_PI),                     
+      Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI),                     
+      Q30(0.6712729335f/M_PI), Q30(0.6638893485f/M_PI), Q30(0.6506769061f/M_PI), Q30(0.6009597182f/M_PI), Q30(0.5036380291f/M_PI), Q30(0.1060028747f/M_PI),                     
+      Q30(0.5628717542f/M_PI), Q30(0.5499725342f/M_PI), Q30(0.5274890065f/M_PI), Q30(0.4499453008f/M_PI), Q30(0.3283358216f/M_PI), Q30(0.0522236861f/M_PI),                     
+      Q30(0.4200925827f/M_PI), Q30(0.4038758278f/M_PI), Q30(0.3769206405f/M_PI), Q30(0.2953795493f/M_PI), Q30(0.1946786791f/M_PI), Q30(0.0278722942f/M_PI),                     
+      Q30(0.3062773645f/M_PI), Q30(0.2911485136f/M_PI), Q30(0.2669326365f/M_PI), Q30(0.1997837722f/M_PI), Q30(0.1264114529f/M_PI), Q30(0.0175609849f/M_PI),                     
+      Q30(0.1969399750f/M_PI), Q30(0.1856741160f/M_PI), Q30(0.1681558639f/M_PI), Q30(0.1223674342f/M_PI), Q30(0.0758088827f/M_PI), Q30(0.0103884479f/M_PI),                     
+      Q30(0.1252337098f/M_PI), Q30(0.1176410317f/M_PI), Q30(0.1059871912f/M_PI), Q30(0.0762724727f/M_PI), Q30(0.0468905345f/M_PI), Q30(0.0063956482f/M_PI),                     
+      Q30(0.0561749674f/M_PI), Q30(0.0526629239f/M_PI), Q30(0.0473113805f/M_PI), Q30(0.0338476151f/M_PI), Q30(0.0207276177f/M_PI), Q30(0.0028205961f/M_PI),                     
+      Q30(1.5676341057f/M_PI), Q30(1.5678333044f/M_PI), Q30(1.5681363344f/M_PI), Q30(1.5688960552f/M_PI), Q30(1.5696337223f/M_PI), Q30(1.5706381798f/M_PI),                     
+      Q30(1.5651730299f/M_PI), Q30(1.5655272007f/M_PI), Q30(1.5660660267f/M_PI), Q30(1.5674170256f/M_PI), Q30(1.5687289238f/M_PI), Q30(1.5705151558f/M_PI),                     
+      Q30(1.5607966185f/M_PI), Q30(1.5614265203f/M_PI), Q30(1.5623844862f/M_PI), Q30(1.5647867918f/M_PI), Q30(1.5671195984f/M_PI), Q30(1.5702962875f/M_PI),                     
+      Q30(1.5530153513f/M_PI), Q30(1.5541347265f/M_PI), Q30(1.5558375120f/M_PI), Q30(1.5601085424f/M_PI), Q30(1.5642569065f/M_PI), Q30(1.5699069500f/M_PI),                     
+      Q30(1.5391840935f/M_PI), Q30(1.5411708355f/M_PI), Q30(1.5441943407f/M_PI), Q30(1.5517836809f/M_PI), Q30(1.5591609478f/M_PI), Q30(1.5692136288f/M_PI),                     
+      Q30(1.5146213770f/M_PI), Q30(1.5181334019f/M_PI), Q30(1.5234849453f/M_PI), Q30(1.5369486809f/M_PI), Q30(1.5500687361f/M_PI), Q30(1.5679757595f/M_PI),                     
+      Q30(1.4915299416f/M_PI), Q30(1.4964480400f/M_PI), Q30(1.5039558411f/M_PI), Q30(1.5229074955f/M_PI), Q30(1.5414420366f/M_PI), Q30(1.5667995214f/M_PI),                     
+      Q30(1.4590617418f/M_PI), Q30(1.4658898115f/M_PI), Q30(1.4763505459f/M_PI), Q30(1.5029321909f/M_PI), Q30(1.5291173458f/M_PI), Q30(1.5651149750f/M_PI),                     
+      Q30(1.4136143923f/M_PI), Q30(1.4229322672f/M_PI), Q30(1.4373078346f/M_PI), Q30(1.4743183851f/M_PI), Q30(1.5113102198f/M_PI), Q30(1.5626684427f/M_PI),                     
+      Q30(1.3505556583f/M_PI), Q30(1.3628427982f/M_PI), Q30(1.3820509911f/M_PI), Q30(1.4327841997f/M_PI), Q30(1.4850014448f/M_PI), Q30(1.5590143204f/M_PI),                     
+      Q30(1.2645189762f/M_PI), Q30(1.2796478271f/M_PI), Q30(1.3038636446f/M_PI), Q30(1.3710125685f/M_PI), Q30(1.4443849325f/M_PI), Q30(1.5532352924f/M_PI),                     
+      Q30(1.1919227839f/M_PI), Q30(1.2081253529f/M_PI), Q30(1.2346779108f/M_PI), Q30(1.3123005629f/M_PI), Q30(1.4034168720f/M_PI), Q30(1.5471596718f/M_PI),                     
+      Q30(1.1061993837f/M_PI), Q30(1.1219338179f/M_PI), Q30(1.1484941244f/M_PI), Q30(1.2320860624f/M_PI), Q30(1.3421301842f/M_PI), Q30(1.5373806953f/M_PI),                     
+      Q30(1.0079245567f/M_PI), Q30(1.0208238363f/M_PI), Q30(1.0433073044f/M_PI), Q30(1.1208510399f/M_PI), Q30(1.2424604893f/M_PI), Q30(1.5185726881f/M_PI),                     
+      Q30(0.8995233774f/M_PI), Q30(0.9069069624f/M_PI), Q30(0.9201194048f/M_PI), Q30(0.9698365927f/M_PI), Q30(1.0671583414f/M_PI), Q30(1.4647934437f/M_PI),                     
+      Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI), Q30(0.7853981853f/M_PI),                     
+      Q30(0.6712729335f/M_PI), Q30(0.6638893485f/M_PI), Q30(0.6506769061f/M_PI), Q30(0.6009597182f/M_PI), Q30(0.5036380291f/M_PI), Q30(0.1060028747f/M_PI),                     
+      Q30(0.5628717542f/M_PI), Q30(0.5499725342f/M_PI), Q30(0.5274890065f/M_PI), Q30(0.4499453008f/M_PI), Q30(0.3283358216f/M_PI), Q30(0.0522236861f/M_PI),                     
+      Q30(0.4645969570f/M_PI), Q30(0.4488625824f/M_PI), Q30(0.4223022461f/M_PI), Q30(0.3387103081f/M_PI), Q30(0.2286661267f/M_PI), Q30(0.0334156826f/M_PI),                     
+      Q30(0.3788735867f/M_PI), Q30(0.3626709878f/M_PI), Q30(0.3361184299f/M_PI), Q30(0.2584958076f/M_PI), Q30(0.1673794836f/M_PI), Q30(0.0236366931f/M_PI),                     
+      Q30(0.3062773645f/M_PI), Q30(0.2911485136f/M_PI), Q30(0.2669326365f/M_PI), Q30(0.1997837722f/M_PI), Q30(0.1264114529f/M_PI), Q30(0.0175609849f/M_PI),                     
+      Q30(0.2202406377f/M_PI), Q30(0.2079535723f/M_PI), Q30(0.1887452900f/M_PI), Q30(0.1380121708f/M_PI), Q30(0.0857949182f/M_PI), Q30(0.0117820343f/M_PI),                     
+      Q30(0.1571819335f/M_PI), Q30(0.1478640437f/M_PI), Q30(0.1334884763f/M_PI), Q30(0.0964778885f/M_PI), Q30(0.0594860613f/M_PI), Q30(0.0081279324f/M_PI),                     
+      Q30(0.1117345318f/M_PI), Q30(0.1049065739f/M_PI), Q30(0.0944457650f/M_PI), Q30(0.0678641573f/M_PI), Q30(0.0416790098f/M_PI), Q30(0.0056813755f/M_PI),                     
+      Q30(0.0792663917f/M_PI), Q30(0.0743482932f/M_PI), Q30(0.0668405443f/M_PI), Q30(0.0478888862f/M_PI), Q30(0.0293543357f/M_PI), Q30(0.0039967746f/M_PI),                     
+      Q30(0.0561749674f/M_PI), Q30(0.0526629239f/M_PI), Q30(0.0473113805f/M_PI), Q30(0.0338476151f/M_PI), Q30(0.0207276177f/M_PI), Q30(0.0028205961f/M_PI),                     
+      Q30(0.0316122435f/M_PI), Q30(0.0296254847f/M_PI), Q30(0.0266019460f/M_PI), Q30(0.0190126132f/M_PI), Q30(0.0116353342f/M_PI), Q30(0.0015827164f/M_PI),                     
+      Q30(0.0177809205f/M_PI), Q30(0.0166615788f/M_PI), Q30(0.0149587989f/M_PI), Q30(0.0106877899f/M_PI), Q30(0.0065393616f/M_PI), Q30(0.0008894200f/M_PI),                     
+      Q30(0.0099996664f/M_PI), Q30(0.0093698399f/M_PI), Q30(0.0084118480f/M_PI), Q30(0.0060095116f/M_PI), Q30(0.0036767013f/M_PI), Q30(0.0005000498f/M_PI),                     
+      Q30(0.0056233541f/M_PI), Q30(0.0052691097f/M_PI), Q30(0.0047303112f/M_PI), Q30(0.0033792770f/M_PI), Q30(0.0020674451f/M_PI), Q30(0.0002811795f/M_PI),                     
+      Q30(0.0031622672f/M_PI), Q30(0.0029630491f/M_PI), Q30(0.0026600463f/M_PI), Q30(0.0019002859f/M_PI), Q30(0.0011625893f/M_PI), Q30(0.0001581155f/M_PI)                      
+    };                              
+                                    
+    static const int gamma_tab[] =                                                                        
+    {                               
+      Q30(0.0000000000f/M_PI), Q30(0.0195873566f/M_PI), Q30(0.0303316917f/M_PI), Q30(0.0448668823f/M_PI), Q30(0.0522258915f/M_PI), Q30(0.0561044961f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0433459543f/M_PI), Q30(0.0672172382f/M_PI), Q30(0.0997167900f/M_PI), Q30(0.1162951663f/M_PI), Q30(0.1250736862f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0672341362f/M_PI), Q30(0.1045235619f/M_PI), Q30(0.1558904350f/M_PI), Q30(0.1824723780f/M_PI), Q30(0.1966800541f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1011129096f/M_PI), Q30(0.1580764502f/M_PI), Q30(0.2387557179f/M_PI), Q30(0.2820728719f/M_PI), Q30(0.3058380187f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1315985769f/M_PI), Q30(0.2072522491f/M_PI), Q30(0.3188187480f/M_PI), Q30(0.3825501204f/M_PI), Q30(0.4193951190f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1603866369f/M_PI), Q30(0.2549437582f/M_PI), Q30(0.4029446840f/M_PI), Q30(0.4980689585f/M_PI), Q30(0.5615641475f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1736015975f/M_PI), Q30(0.2773745656f/M_PI), Q30(0.4461984038f/M_PI), Q30(0.5666890144f/M_PI), Q30(0.6686112881f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1784276664f/M_PI), Q30(0.2856673002f/M_PI), Q30(0.4630723596f/M_PI), Q30(0.5971632004f/M_PI), Q30(0.7603877187f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1736015975f/M_PI), Q30(0.2773745656f/M_PI), Q30(0.4461984038f/M_PI), Q30(0.5666890144f/M_PI), Q30(0.6686112881f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1603866369f/M_PI), Q30(0.2549437582f/M_PI), Q30(0.4029446840f/M_PI), Q30(0.4980689585f/M_PI), Q30(0.5615641475f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1315985769f/M_PI), Q30(0.2072522491f/M_PI), Q30(0.3188187480f/M_PI), Q30(0.3825501204f/M_PI), Q30(0.4193951190f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1011129096f/M_PI), Q30(0.1580764502f/M_PI), Q30(0.2387557179f/M_PI), Q30(0.2820728719f/M_PI), Q30(0.3058380187f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0672341362f/M_PI), Q30(0.1045235619f/M_PI), Q30(0.1558904350f/M_PI), Q30(0.1824723780f/M_PI), Q30(0.1966800541f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0433459543f/M_PI), Q30(0.0672172382f/M_PI), Q30(0.0997167900f/M_PI), Q30(0.1162951663f/M_PI), Q30(0.1250736862f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0195873566f/M_PI), Q30(0.0303316917f/M_PI), Q30(0.0448668823f/M_PI), Q30(0.0522258915f/M_PI), Q30(0.0561044961f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0011053939f/M_PI), Q30(0.0017089852f/M_PI), Q30(0.0025254129f/M_PI), Q30(0.0029398468f/M_PI), Q30(0.0031597170f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0019607407f/M_PI), Q30(0.0030395309f/M_PI), Q30(0.0044951206f/M_PI), Q30(0.0052305623f/M_PI), Q30(0.0056152637f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0034913034f/M_PI), Q30(0.0054070661f/M_PI), Q30(0.0079917293f/M_PI), Q30(0.0092999367f/M_PI), Q30(0.0099875759f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0062100487f/M_PI), Q30(0.0096135242f/M_PI), Q30(0.0142110568f/M_PI), Q30(0.0165348612f/M_PI), Q30(0.0177587029f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0110366223f/M_PI), Q30(0.0170863140f/M_PI), Q30(0.0252620988f/M_PI), Q30(0.0293955617f/M_PI), Q30(0.0315726399f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0195873566f/M_PI), Q30(0.0303316917f/M_PI), Q30(0.0448668823f/M_PI), Q30(0.0522258915f/M_PI), Q30(0.0561044961f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0275881495f/M_PI), Q30(0.0427365713f/M_PI), Q30(0.0632618815f/M_PI), Q30(0.0736731067f/M_PI), Q30(0.0791663304f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0387469754f/M_PI), Q30(0.0600636788f/M_PI), Q30(0.0890387669f/M_PI), Q30(0.1037906483f/M_PI), Q30(0.1115923747f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0541138873f/M_PI), Q30(0.0839984417f/M_PI), Q30(0.1248718798f/M_PI), Q30(0.1458375156f/M_PI), Q30(0.1569785923f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0747506917f/M_PI), Q30(0.1163287833f/M_PI), Q30(0.1738867164f/M_PI), Q30(0.2038587779f/M_PI), Q30(0.2199459076f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1011129096f/M_PI), Q30(0.1580764502f/M_PI), Q30(0.2387557179f/M_PI), Q30(0.2820728719f/M_PI), Q30(0.3058380187f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1212290376f/M_PI), Q30(0.1903949380f/M_PI), Q30(0.2907958031f/M_PI), Q30(0.3466993868f/M_PI), Q30(0.3782821596f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1418247074f/M_PI), Q30(0.2240308374f/M_PI), Q30(0.3474813402f/M_PI), Q30(0.4202919006f/M_PI), Q30(0.4637607038f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1603866369f/M_PI), Q30(0.2549437582f/M_PI), Q30(0.4029446840f/M_PI), Q30(0.4980689585f/M_PI), Q30(0.5615641475f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1736015975f/M_PI), Q30(0.2773745656f/M_PI), Q30(0.4461984038f/M_PI), Q30(0.5666890144f/M_PI), Q30(0.6686112881f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1784276664f/M_PI), Q30(0.2856673002f/M_PI), Q30(0.4630723596f/M_PI), Q30(0.5971632004f/M_PI), Q30(0.7603877187f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1736015975f/M_PI), Q30(0.2773745656f/M_PI), Q30(0.4461984038f/M_PI), Q30(0.5666890144f/M_PI), Q30(0.6686112881f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1603866369f/M_PI), Q30(0.2549437582f/M_PI), Q30(0.4029446840f/M_PI), Q30(0.4980689585f/M_PI), Q30(0.5615641475f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1418247074f/M_PI), Q30(0.2240308374f/M_PI), Q30(0.3474813402f/M_PI), Q30(0.4202919006f/M_PI), Q30(0.4637607038f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1212290376f/M_PI), Q30(0.1903949380f/M_PI), Q30(0.2907958031f/M_PI), Q30(0.3466993868f/M_PI), Q30(0.3782821596f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.1011129096f/M_PI), Q30(0.1580764502f/M_PI), Q30(0.2387557179f/M_PI), Q30(0.2820728719f/M_PI), Q30(0.3058380187f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0747506917f/M_PI), Q30(0.1163287833f/M_PI), Q30(0.1738867164f/M_PI), Q30(0.2038587779f/M_PI), Q30(0.2199459076f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0541138873f/M_PI), Q30(0.0839984417f/M_PI), Q30(0.1248718798f/M_PI), Q30(0.1458375156f/M_PI), Q30(0.1569785923f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0387469754f/M_PI), Q30(0.0600636788f/M_PI), Q30(0.0890387669f/M_PI), Q30(0.1037906483f/M_PI), Q30(0.1115923747f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0275881495f/M_PI), Q30(0.0427365713f/M_PI), Q30(0.0632618815f/M_PI), Q30(0.0736731067f/M_PI), Q30(0.0791663304f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0195873566f/M_PI), Q30(0.0303316917f/M_PI), Q30(0.0448668823f/M_PI), Q30(0.0522258915f/M_PI), Q30(0.0561044961f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0110366223f/M_PI), Q30(0.0170863140f/M_PI), Q30(0.0252620988f/M_PI), Q30(0.0293955617f/M_PI), Q30(0.0315726399f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0062100487f/M_PI), Q30(0.0096135242f/M_PI), Q30(0.0142110568f/M_PI), Q30(0.0165348612f/M_PI), Q30(0.0177587029f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0034913034f/M_PI), Q30(0.0054070661f/M_PI), Q30(0.0079917293f/M_PI), Q30(0.0092999367f/M_PI), Q30(0.0099875759f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0019607407f/M_PI), Q30(0.0030395309f/M_PI), Q30(0.0044951206f/M_PI), Q30(0.0052305623f/M_PI), Q30(0.0056152637f/M_PI),                     
+      Q30(0.0000000000f/M_PI), Q30(0.0011053939f/M_PI), Q30(0.0017089852f/M_PI), Q30(0.0025254129f/M_PI), Q30(0.0029398468f/M_PI), Q30(0.0031597170f/M_PI)                      
+    };                              
+                                    
+    static const int iid_par_dequant_c1[] = {                                                             
+        //iid_par_dequant_default                                                                         
+        Q30(1.41198278375959f), Q30(1.40313815268360f), Q30(1.38687670404960f), Q30(1.34839972492648f),   
+        Q30(1.29124937110028f), Q30(1.19603741667993f), Q30(1.10737240362323f), Q30(1),                   
+        Q30(0.87961716655242f), Q30(0.75464859232732f), Q30(0.57677990744575f), Q30(0.42640143271122f),   
+        Q30(0.27671828230984f), Q30(0.17664462766713f), Q30(0.07940162697653f),                           
+        //iid_par_dequant_fine      
+        Q30(1.41420649135832f), Q30(1.41419120222364f), Q30(1.41414285699784f), Q30(1.41399000859438f),   
+        Q30(1.41350698548044f), Q30(1.41198278375959f), Q30(1.40977302262355f), Q30(1.40539479488545f),   
+        Q30(1.39677960498402f), Q30(1.38005309967827f), Q30(1.34839972492648f), Q30(1.31392017367631f),   
+        Q30(1.26431008149654f), Q30(1.19603741667993f), Q30(1.10737240362323f), Q30(1),                   
+        Q30(0.87961716655242f), Q30(0.75464859232732f), Q30(0.63365607219232f), Q30(0.52308104267543f),   
+        Q30(0.42640143271122f), Q30(0.30895540465965f), Q30(0.22137464873077f), Q30(0.15768788954414f),   
+        Q30(0.11198225164225f), Q30(0.07940162697653f), Q30(0.04469901562677f), Q30(0.02514469318284f),   
+        Q30(0.01414142856998f), Q30(0.00795258154731f), Q30(0.00447211359449f),                           
+    };                              
+                                    
+    static const int acos_icc_invq[] = {                                                                  
+        Q31(0), Q31(0.178427635f/M_PI), Q31(0.28566733f/M_PI), Q31(0.46307236f/M_PI), Q31(0.59716315f/M_PI), Q31(0.78539816f/M_PI), Q31(1.10030855f/M_PI), Q31(1.57079633f/M_PI)
+    };                              
+    int iid, icc;                   
+                                    
+    int k, m;                       
+    static const int8_t f_center_20[] = {                                                                 
+        -3, -1, 1, 3, 5, 7, 10, 14, 18, 22,                                                               
+    };                              
+    static const int32_t f_center_34[] = {                                                                
+      Q31(  2/768.0),Q31(  6/768.0),Q31(10/768.0),Q31(14/768.0),Q31( 18/768.0),Q31( 22/768.0),Q31( 26/768.0),Q31(30/768.0),                                                     
+      Q31( 34/768.0),Q31(-10/768.0),Q31(-6/768.0),Q31(-2/768.0),Q31( 51/768.0),Q31( 57/768.0),Q31( 15/768.0),Q31(21/768.0),                                                     
+      Q31( 27/768.0),Q31( 33/768.0),Q31(39/768.0),Q31(45/768.0),Q31( 54/768.0),Q31( 66/768.0),Q31( 78/768.0),Q31(42/768.0),                                                     
+      Q31(102/768.0),Q31( 66/768.0),Q31(78/768.0),Q31(90/768.0),Q31(102/768.0),Q31(114/768.0),Q31(126/768.0),Q31(90/768.0)                                                      
+    };                              
+    static const int fractional_delay_links[] = { Q31(0.43f), Q31(0.75f), Q31(0.347f) };                  
+    const int fractional_delay_gain = Q31(0.39f);                                                         
+    long long accu;                 
+                                    
+    for (pd0 = 0; pd0 < 8; pd0++) {                                                                       
+        int pd0_re = (ipdopd_cos[pd0]+2)>>2;                                                              
+        int pd0_im = (ipdopd_sin[pd0]+2)>>2;                                                              
+        for (pd1 = 0; pd1 < 8; pd1++) {                                                                   
+            int pd1_re = ipdopd_cos[pd1] >> 1;                                                            
+            int pd1_im = ipdopd_sin[pd1] >> 1;                                                            
+            for (pd2 = 0; pd2 < 8; pd2++) {                                                               
+                int shift, round;                                                                         
+                int pd2_re = ipdopd_cos[pd2];                                                             
+                int pd2_im = ipdopd_sin[pd2];                                                             
+                int re_smooth = pd0_re + pd1_re + pd2_re;                                                 
+                int im_smooth = pd0_im + pd1_im + pd2_im;                                                 
+                                    
+                aac_float_t pd_mag = int2float(((ipdopd_cos[(pd0-pd1)&7]+8)>>4) + ((ipdopd_cos[(pd0-pd2)&7]+4)>>3) +                                                            
+                                               ((ipdopd_cos[(pd1-pd2)&7]+2)>>2) + 0x15000000, 2);         
+                pd_mag = float_div(FLOAT_1, float_sqrt(pd_mag));                                          
+                shift = 30 - pd_mag.expo;                                                                 
+                round = 1 << (shift-1);                                                                   
+                accu = (long long)re_smooth * pd_mag.mant;                                                
+                pd_re_smooth[pd0*64+pd1*8+pd2] = (int)((accu + round) >> shift);                          
+                accu = (long long)im_smooth * pd_mag.mant;                                                
+                pd_im_smooth[pd0*64+pd1*8+pd2] = (int)((accu + round) >> shift);                          
+            }                       
+        }                           
+    }                               
+                                    
+    idx = 0;                        
+    for (iid = 0; iid < 46; iid++) {                                                                      
+        int c1, c2;                 
+                                    
+        c1 = iid_par_dequant_c1[iid];                                                                     
+        if (iid < 15)               
+          c2 = iid_par_dequant_c1[14-iid];                                                                
+        else                        
+          c2 = iid_par_dequant_c1[60-iid];                                                                
+                                    
+        for (icc = 0; icc < 8; icc++) {                                                                   
+            /*if (PS_BASELINE || ps->icc_mode < 3)*/{                                                     
+                int alpha, beta;    
+                int ca, sa, cb, sb;                                                                       
+                                    
+                alpha = acos_icc_invq[icc];                                                               
+                accu = (long long)alpha * 1518500250;                                                     
+                beta = (int)((accu + 0x40000000) >> 31);                                                  
+                accu  = (long long)beta * (c1 - c2);                                                      
+                alpha >>= 1;        
+                beta = (int)((accu + 0x40000000) >> 31);                                                  
+                aac_fixed_sincos(beta + alpha, &sa, &ca);                                                 
+                aac_fixed_sincos(beta - alpha, &sb, &cb);                                                 
+                                    
+                accu = (long long)c2 * ca;                                                                
+                HA[iid][icc][0] = (int)((accu + 0x20000000) >> 30);                                       
+                accu = (long long)c1 * cb;                                                                
+                HA[iid][icc][1] = (int)((accu + 0x20000000) >> 30);                                       
+                accu = (long long)c2 * sa;                                                                
+                HA[iid][icc][2] = (int)((accu + 0x20000000) >> 30);                                       
+                accu = (long long)c1 * sb;                                                                
+                HA[iid][icc][3] = (int)((accu + 0x20000000) >> 30);                                       
+            } /* else */ {          
+                int alpha_int, gamma_int;                                                                 
+                int alpha_c_int, alpha_s_int, gamma_c_int, gamma_s_int;                                   
+                                    
+                alpha_int = alpha_tab[idx];                                                               
+                gamma_int = gamma_tab[idx];                                                               
+                                    
+                aac_fixed_sincos(alpha_int, &alpha_s_int, &alpha_c_int);                                  
+                aac_fixed_sincos(gamma_int, &gamma_s_int, &gamma_c_int);                                  
+                                    
+                accu = (long long)alpha_c_int * 1518500250;                                               
+                alpha_c_int = (int)((accu + 0x20000000) >> 30);                                           
+                accu = (long long)alpha_s_int * 1518500250;                                               
+                alpha_s_int = (int)((accu + 0x20000000) >> 30);                                           
+                                    
+                accu = (long long)alpha_c_int * gamma_c_int;                                              
+                HB[iid][icc][0] = (int)((accu + 0x20000000) >> 30);                                       
+                accu = (long long)alpha_s_int * gamma_c_int;                                              
+                HB[iid][icc][1] = (int)((accu + 0x20000000) >> 30);                                       
+                accu = (long long)alpha_s_int * gamma_s_int;                                              
+                HB[iid][icc][2] = -(int)((accu + 0x20000000) >> 30);                                      
+                accu = (long long)alpha_c_int * gamma_s_int;                                              
+                HB[iid][icc][3] = (int)((accu + 0x20000000) >> 30);                                       
+            }                       
+                                    
+            if (icc < 5 || icc > 6)                                                                       
+              idx++;                
+        }                           
+    }                               
+                                    
+    for (k = 0; k < NR_ALLPASS_BANDS20; k++) {                                                            
+        int theta, f_center;        
+        int c, s;                   
+                                    
+        if (k < FF_ARRAY_ELEMS(f_center_20))                                                              
+          f_center = f_center_20[k];                                                                      
+        else                        
+          f_center = (k << 3) - 52;                                                                       
+                                    
+        for (m = 0; m < PS_AP_LINKS; m++) {                                                               
+            accu = (long long)fractional_delay_links[m] * f_center;                                       
+            theta = (int)((accu + 8) >> 4);                                                               
+            aac_fixed_sincos(-theta, &s, &c);                                                             
+            Q_fract_allpass[0][k][m][0] = c;                                                              
+            Q_fract_allpass[0][k][m][1] = s;                                                              
+        }                           
+                                    
+        accu = (long long)fractional_delay_gain * f_center;                                               
+        theta = (int)((accu + 8) >> 4);                                                                   
+        aac_fixed_sincos(-theta, &s, &c);                                                                 
+        phi_fract[0][k][0] = c;     
+        phi_fract[0][k][1] = s;     
+    }                               
+                                    
+    for (k = 0; k < NR_ALLPASS_BANDS34; k++) {                                                            
+        int theta, f_center;        
+        int c, s;                   
+                                    
+        if (k < FF_ARRAY_ELEMS(f_center_34))                                                              
+            f_center = f_center_34[k];                                                                    
+        else                        
+            f_center = (k << 26) - (53 << 25);                                                            
+                                    
+        for (m = 0; m < PS_AP_LINKS; m++) {                                                               
+            accu = (long long)fractional_delay_links[m] * f_center;                                       
+            theta = (int)((accu + 0x10000000) >> 27);                                                     
+            aac_fixed_sincos(-theta, &s, &c);                                                             
+            Q_fract_allpass[1][k][m][0] = c;                                                              
+            Q_fract_allpass[1][k][m][1] = s;                                                              
+        }                           
+                                    
+        accu = (long long)fractional_delay_gain * f_center;                                               
+        theta = (int)((accu + 0x10000000) >> 27);                                                         
+        aac_fixed_sincos(-theta, &s, &c);                                                                 
+        phi_fract[1][k][0] = c;     
+        phi_fract[1][k][1] = s;     
+    }                               
+                                    
+    make_filters_from_proto(f20_0_8,  g0_Q8,   8);                                                        
+    make_filters_from_proto(f34_0_12, g0_Q12, 12);                                                        
+    make_filters_from_proto(f34_1_8,  g1_Q8,   8);                                                        
+    make_filters_from_proto(f34_2_4,  g2_Q4,   4);                                                        
+}                                   
+#endif /* CONFIG_HARDCODED_TABLES */                                                                      
+                                    
+#endif /* AACPS_FIXED_TABLEGEN_H */  
diff -uNr ffmpeg-0.7.12/libavcodec/aacps.h ffmpeg-0.7.12-140902/libavcodec/aacps.h
--- ffmpeg-0.7.12/libavcodec/aacps.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacps.h	2014-09-02 15:14:50.000000000 +0800
@@ -24,9 +24,28 @@
 
 #include <stdint.h>
 
+#include "aacpsdsp.h"
 #include "avcodec.h"
 #include "get_bits.h"
+#ifndef CONFIG_AAC_FIXED
+#define CONFIG_AAC_FIXED 0
+#endif
 
+#if CONFIG_AAC_FIXED
+
+#define INTFLOAT int
+#define AAC_RENAME(x)    x ## _fixed
+#define Q30(x)          (int)((x)*1073741824.0 + 0.5)
+#define Q31(x)          (int)((x)*2147483648.0 + 0.5)
+
+#else
+
+#define INTFLOAT float
+#define AAC_RENAME(x)    x
+#define Q30(x)          x
+#define Q31(x)          x
+
+#endif /* CONFIG_AAC_FIXED */
 #define PS_MAX_NUM_ENV 5
 #define PS_MAX_NR_IIDICC 34
 #define PS_MAX_NR_IPDOPD 17
@@ -37,7 +56,7 @@
 #define PS_AP_LINKS 3
 #define PS_MAX_AP_DELAY 5
 
-typedef struct {
+typedef struct PSContext {
     int    start;
     int    enable_iid;
     int    iid_quant;
@@ -52,31 +71,32 @@
     int    num_env;
     int    enable_ipdopd;
     int    border_position[PS_MAX_NUM_ENV+1];
-    int8_t iid_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Inter-channel Intensity Difference Parameters
-    int8_t icc_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Inter-Channel Coherence Parameters
+    int8_t iid_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; ///< Inter-channel Intensity Difference Parameters
+    int8_t icc_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; ///< Inter-Channel Coherence Parameters
     /* ipd/opd is iid/icc sized so that the same functions can handle both */
-    int8_t ipd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Inter-channel Phase Difference Parameters
-    int8_t opd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; //<Overall Phase Difference Parameters
+    int8_t ipd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; ///< Inter-channel Phase Difference Parameters
+    int8_t opd_par[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC]; ///< Overall Phase Difference Parameters
     int    is34bands;
     int    is34bands_old;
 
-    float  in_buf[5][44][2];
-    float  delay[PS_MAX_SSB][PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2];
-    float  ap_delay[PS_MAX_AP_BANDS][PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2];
-    float  peak_decay_nrg[34];
-    float  power_smooth[34];
-    float  peak_decay_diff_smooth[34];
-    float  H11[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
-    float  H12[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
-    float  H21[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
-    float  H22[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    DECLARE_ALIGNED(16, INTFLOAT, in_buf)[5][44][2];
+    DECLARE_ALIGNED(16, INTFLOAT, delay)[PS_MAX_SSB][PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2];
+    DECLARE_ALIGNED(16, INTFLOAT, ap_delay)[PS_MAX_AP_BANDS][PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2];
+    DECLARE_ALIGNED(16, INTFLOAT, peak_decay_nrg)[34];
+    DECLARE_ALIGNED(16, INTFLOAT, power_smooth)[34];
+    DECLARE_ALIGNED(16, INTFLOAT, peak_decay_diff_smooth)[34];
+    DECLARE_ALIGNED(16, INTFLOAT, H11)[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    DECLARE_ALIGNED(16, INTFLOAT, H12)[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    DECLARE_ALIGNED(16, INTFLOAT, H21)[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
+    DECLARE_ALIGNED(16, INTFLOAT, H22)[2][PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC];
     int8_t opd_hist[PS_MAX_NR_IIDICC];
     int8_t ipd_hist[PS_MAX_NR_IIDICC];
+    PSDSPContext dsp;
 } PSContext;
 
-void ff_ps_init(void);
-void ff_ps_ctx_init(PSContext *ps);
-int ff_ps_read_data(AVCodecContext *avctx, GetBitContext *gb, PSContext *ps, int bits_left);
-int ff_ps_apply(AVCodecContext *avctx, PSContext *ps, float L[2][38][64], float R[2][38][64], int top);
+void AAC_RENAME(ff_ps_init)(void);
+void AAC_RENAME(ff_ps_ctx_init)(PSContext *ps);
+int AAC_RENAME(ff_ps_read_data)(AVCodecContext *avctx, GetBitContext *gb, PSContext *ps, int bits_left);
+int AAC_RENAME(ff_ps_apply)(AVCodecContext *avctx, PSContext *ps, INTFLOAT L[2][38][64], INTFLOAT R[2][38][64], int top);
 
 #endif /* AVCODEC_PS_H */
diff -uNr ffmpeg-0.7.12/libavcodec/aacps_tablegen.c ffmpeg-0.7.12-140902/libavcodec/aacps_tablegen.c
--- ffmpeg-0.7.12/libavcodec/aacps_tablegen.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacps_tablegen.c	2013-10-31 11:10:02.000000000 +0800
@@ -22,7 +22,7 @@
 
 #include <stdlib.h>
 #define CONFIG_HARDCODED_TABLES 0
-#include "aacps_tablegen.h"
+#include "aacps_fixed_tablegen.h"
 #include "tableprint.h"
 
 void write_float_3d_array (const void *p, int b, int c, int d)
diff -uNr ffmpeg-0.7.12/libavcodec/aacps_tablegen.h ffmpeg-0.7.12-140902/libavcodec/aacps_tablegen.h
--- ffmpeg-0.7.12/libavcodec/aacps_tablegen.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacps_tablegen.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,212 +0,0 @@
-/*
- * Header file for hardcoded Parametric Stereo tables
- *
- * Copyright (c) 2010 Alex Converse <alex.converse@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AACPS_TABLEGEN_H
-#define AACPS_TABLEGEN_H
-
-#include <stdint.h>
-
-#if CONFIG_HARDCODED_TABLES
-#define ps_tableinit()
-#include "libavcodec/aacps_tables.h"
-#else
-#include "libavutil/common.h"
-#include "libavutil/mathematics.h"
-#define NR_ALLPASS_BANDS20 30
-#define NR_ALLPASS_BANDS34 50
-#define PS_AP_LINKS 3
-static float pd_re_smooth[8*8*8];
-static float pd_im_smooth[8*8*8];
-static float HA[46][8][4];
-static float HB[46][8][4];
-static float f20_0_8 [ 8][7][2];
-static float f34_0_12[12][7][2];
-static float f34_1_8 [ 8][7][2];
-static float f34_2_4 [ 4][7][2];
-static float Q_fract_allpass[2][50][3][2];
-static float phi_fract[2][50][2];
-
-static const float g0_Q8[] = {
-    0.00746082949812f, 0.02270420949825f, 0.04546865930473f, 0.07266113929591f,
-    0.09885108575264f, 0.11793710567217f, 0.125f
-};
-
-static const float g0_Q12[] = {
-    0.04081179924692f, 0.03812810994926f, 0.05144908135699f, 0.06399831151592f,
-    0.07428313801106f, 0.08100347892914f, 0.08333333333333f
-};
-
-static const float g1_Q8[] = {
-    0.01565675600122f, 0.03752716391991f, 0.05417891378782f, 0.08417044116767f,
-    0.10307344158036f, 0.12222452249753f, 0.125f
-};
-
-static const float g2_Q4[] = {
-    -0.05908211155639f, -0.04871498374946f, 0.0f,   0.07778723915851f,
-     0.16486303567403f,  0.23279856662996f, 0.25f
-};
-
-static void make_filters_from_proto(float (*filter)[7][2], const float *proto, int bands)
-{
-    int q, n;
-    for (q = 0; q < bands; q++) {
-        for (n = 0; n < 7; n++) {
-            double theta = 2 * M_PI * (q + 0.5) * (n - 6) / bands;
-            filter[q][n][0] = proto[n] *  cos(theta);
-            filter[q][n][1] = proto[n] * -sin(theta);
-        }
-    }
-}
-
-static void ps_tableinit(void)
-{
-    static const float ipdopd_sin[] = { 0, M_SQRT1_2, 1,  M_SQRT1_2,  0, -M_SQRT1_2, -1, -M_SQRT1_2 };
-    static const float ipdopd_cos[] = { 1, M_SQRT1_2, 0, -M_SQRT1_2, -1, -M_SQRT1_2,  0,  M_SQRT1_2 };
-    int pd0, pd1, pd2;
-
-    static const float iid_par_dequant[] = {
-        //iid_par_dequant_default
-        0.05623413251903, 0.12589254117942, 0.19952623149689, 0.31622776601684,
-        0.44668359215096, 0.63095734448019, 0.79432823472428, 1,
-        1.25892541179417, 1.58489319246111, 2.23872113856834, 3.16227766016838,
-        5.01187233627272, 7.94328234724282, 17.7827941003892,
-        //iid_par_dequant_fine
-        0.00316227766017, 0.00562341325190, 0.01,             0.01778279410039,
-        0.03162277660168, 0.05623413251903, 0.07943282347243, 0.11220184543020,
-        0.15848931924611, 0.22387211385683, 0.31622776601684, 0.39810717055350,
-        0.50118723362727, 0.63095734448019, 0.79432823472428, 1,
-        1.25892541179417, 1.58489319246111, 1.99526231496888, 2.51188643150958,
-        3.16227766016838, 4.46683592150963, 6.30957344480193, 8.91250938133745,
-        12.5892541179417, 17.7827941003892, 31.6227766016838, 56.2341325190349,
-        100,              177.827941003892, 316.227766016837,
-    };
-    static const float icc_invq[] = {
-        1, 0.937,      0.84118,    0.60092,    0.36764,   0,      -0.589,    -1
-    };
-    static const float acos_icc_invq[] = {
-        0, 0.35685527, 0.57133466, 0.92614472, 1.1943263, M_PI/2, 2.2006171, M_PI
-    };
-    int iid, icc;
-
-    int k, m;
-    static const int8_t f_center_20[] = {
-        -3, -1, 1, 3, 5, 7, 10, 14, 18, 22,
-    };
-    static const int8_t f_center_34[] = {
-         2,  6, 10, 14, 18, 22, 26, 30,
-        34,-10, -6, -2, 51, 57, 15, 21,
-        27, 33, 39, 45, 54, 66, 78, 42,
-       102, 66, 78, 90,102,114,126, 90,
-    };
-    static const float fractional_delay_links[] = { 0.43f, 0.75f, 0.347f };
-    const float fractional_delay_gain = 0.39f;
-
-    for (pd0 = 0; pd0 < 8; pd0++) {
-        float pd0_re = ipdopd_cos[pd0];
-        float pd0_im = ipdopd_sin[pd0];
-        for (pd1 = 0; pd1 < 8; pd1++) {
-            float pd1_re = ipdopd_cos[pd1];
-            float pd1_im = ipdopd_sin[pd1];
-            for (pd2 = 0; pd2 < 8; pd2++) {
-                float pd2_re = ipdopd_cos[pd2];
-                float pd2_im = ipdopd_sin[pd2];
-                float re_smooth = 0.25f * pd0_re + 0.5f * pd1_re + pd2_re;
-                float im_smooth = 0.25f * pd0_im + 0.5f * pd1_im + pd2_im;
-                float pd_mag = 1 / sqrt(im_smooth * im_smooth + re_smooth * re_smooth);
-                pd_re_smooth[pd0*64+pd1*8+pd2] = re_smooth * pd_mag;
-                pd_im_smooth[pd0*64+pd1*8+pd2] = im_smooth * pd_mag;
-            }
-        }
-    }
-
-    for (iid = 0; iid < 46; iid++) {
-        float c = iid_par_dequant[iid]; //<Linear Inter-channel Intensity Difference
-        float c1 = (float)M_SQRT2 / sqrtf(1.0f + c*c);
-        float c2 = c * c1;
-        for (icc = 0; icc < 8; icc++) {
-            /*if (PS_BASELINE || ps->icc_mode < 3)*/ {
-                float alpha = 0.5f * acos_icc_invq[icc];
-                float beta  = alpha * (c1 - c2) * (float)M_SQRT1_2;
-                HA[iid][icc][0] = c2 * cosf(beta + alpha);
-                HA[iid][icc][1] = c1 * cosf(beta - alpha);
-                HA[iid][icc][2] = c2 * sinf(beta + alpha);
-                HA[iid][icc][3] = c1 * sinf(beta - alpha);
-            } /* else */ {
-                float alpha, gamma, mu, rho;
-                float alpha_c, alpha_s, gamma_c, gamma_s;
-                rho = FFMAX(icc_invq[icc], 0.05f);
-                alpha = 0.5f * atan2f(2.0f * c * rho, c*c - 1.0f);
-                mu = c + 1.0f / c;
-                mu = sqrtf(1 + (4 * rho * rho - 4)/(mu * mu));
-                gamma = atanf(sqrtf((1.0f - mu)/(1.0f + mu)));
-                if (alpha < 0) alpha += M_PI/2;
-                alpha_c = cosf(alpha);
-                alpha_s = sinf(alpha);
-                gamma_c = cosf(gamma);
-                gamma_s = sinf(gamma);
-                HB[iid][icc][0] =  M_SQRT2 * alpha_c * gamma_c;
-                HB[iid][icc][1] =  M_SQRT2 * alpha_s * gamma_c;
-                HB[iid][icc][2] = -M_SQRT2 * alpha_s * gamma_s;
-                HB[iid][icc][3] =  M_SQRT2 * alpha_c * gamma_s;
-            }
-        }
-    }
-
-    for (k = 0; k < NR_ALLPASS_BANDS20; k++) {
-        double f_center, theta;
-        if (k < FF_ARRAY_ELEMS(f_center_20))
-            f_center = f_center_20[k] * 0.125;
-        else
-            f_center = k - 6.5f;
-        for (m = 0; m < PS_AP_LINKS; m++) {
-            theta = -M_PI * fractional_delay_links[m] * f_center;
-            Q_fract_allpass[0][k][m][0] = cos(theta);
-            Q_fract_allpass[0][k][m][1] = sin(theta);
-        }
-        theta = -M_PI*fractional_delay_gain*f_center;
-        phi_fract[0][k][0] = cos(theta);
-        phi_fract[0][k][1] = sin(theta);
-    }
-    for (k = 0; k < NR_ALLPASS_BANDS34; k++) {
-        double f_center, theta;
-        if (k < FF_ARRAY_ELEMS(f_center_34))
-            f_center = f_center_34[k] / 24.;
-        else
-            f_center = k - 26.5f;
-        for (m = 0; m < PS_AP_LINKS; m++) {
-            theta = -M_PI * fractional_delay_links[m] * f_center;
-            Q_fract_allpass[1][k][m][0] = cos(theta);
-            Q_fract_allpass[1][k][m][1] = sin(theta);
-        }
-        theta = -M_PI*fractional_delay_gain*f_center;
-        phi_fract[1][k][0] = cos(theta);
-        phi_fract[1][k][1] = sin(theta);
-    }
-
-    make_filters_from_proto(f20_0_8,  g0_Q8,   8);
-    make_filters_from_proto(f34_0_12, g0_Q12, 12);
-    make_filters_from_proto(f34_1_8,  g1_Q8,   8);
-    make_filters_from_proto(f34_2_4,  g2_Q4,   4);
-}
-#endif /* CONFIG_HARDCODED_TABLES */
-
-#endif /* AACPS_TABLEGEN_H */
diff -uNr ffmpeg-0.7.12/libavcodec/aacsbr.c ffmpeg-0.7.12-140902/libavcodec/aacsbr.c
--- ffmpeg-0.7.12/libavcodec/aacsbr.c	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacsbr.c	2014-09-04 15:56:26.404250736 +0800
@@ -1,37 +1,15 @@
-/*
- * AAC Spectral Band Replication decoding functions
- * Copyright (c) 2008-2009 Robert Swain ( rob opendot cl )
- * Copyright (c) 2009-2010 Alex Converse <alex.converse@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * AAC Spectral Band Replication decoding functions
- * @author Robert Swain ( rob opendot cl )
- */
+#define CONFIG_AAC_FIXED 1
+                                                                                                                                                            
 
 #include "aac.h"
 #include "sbr.h"
 #include "aacsbr.h"
+
 #include "aacsbrdata.h"
 #include "fft.h"
 #include "aacps.h"
+#include "sbrdsp.h"
+#include "libavutil/internal.h"
 #include "libavutil/libm.h"
 #include "libavutil/avassert.h"
 
@@ -39,1060 +17,89 @@
 #include <float.h>
 #include <math.h>
 
-#define ENVELOPE_ADJUSTMENT_OFFSET 2
-#define NOISE_FLOOR_OFFSET 6.0f
-
-/**
- * SBR VLC tables
- */
-enum {
-    T_HUFFMAN_ENV_1_5DB,
-    F_HUFFMAN_ENV_1_5DB,
-    T_HUFFMAN_ENV_BAL_1_5DB,
-    F_HUFFMAN_ENV_BAL_1_5DB,
-    T_HUFFMAN_ENV_3_0DB,
-    F_HUFFMAN_ENV_3_0DB,
-    T_HUFFMAN_ENV_BAL_3_0DB,
-    F_HUFFMAN_ENV_BAL_3_0DB,
-    T_HUFFMAN_NOISE_3_0DB,
-    T_HUFFMAN_NOISE_BAL_3_0DB,
-};
-
-/**
- * bs_frame_class - frame class of current SBR frame (14496-3 sp04 p98)
- */
-enum {
-    FIXFIX,
-    FIXVAR,
-    VARFIX,
-    VARVAR,
-};
-
-enum {
-    EXTENSION_ID_PS = 2,
-};
-
 static VLC vlc_sbr[10];
-static const int8_t vlc_sbr_lav[10] =
-    { 60, 60, 24, 24, 31, 31, 12, 12, 31, 12 };
-static const DECLARE_ALIGNED(16, float, zero64)[64];
-
-#define SBR_INIT_VLC_STATIC(num, size) \
-    INIT_VLC_STATIC(&vlc_sbr[num], 9, sbr_tmp[num].table_size / sbr_tmp[num].elem_size,     \
-                    sbr_tmp[num].sbr_bits ,                      1,                      1, \
-                    sbr_tmp[num].sbr_codes, sbr_tmp[num].elem_size, sbr_tmp[num].elem_size, \
-                    size)
 
-#define SBR_VLC_ROW(name) \
-    { name ## _codes, name ## _bits, sizeof(name ## _codes), sizeof(name ## _codes[0]) }
+static void aacsbr_func_ptr_init(AACSBRContext *c);
+static const int CONST_LN2       = Q31(0.6931471806/256);  // ln(2)/256
+static const int CONST_RECIP_LN2 = Q31(0.7213475204);      // 0.5/ln(2)
+static const int CONST_SQRT2     = Q30(0.7071067812);      // sqrt(2)/2
+static const int CONST_076923    = Q31(0.76923076923076923077f);
 
-av_cold void ff_aac_sbr_init(void)
+int fixed_log_table[10] =
 {
-    int n;
-    static const struct {
-        const void *sbr_codes, *sbr_bits;
-        const unsigned int table_size, elem_size;
-    } sbr_tmp[] = {
-        SBR_VLC_ROW(t_huffman_env_1_5dB),
-        SBR_VLC_ROW(f_huffman_env_1_5dB),
-        SBR_VLC_ROW(t_huffman_env_bal_1_5dB),
-        SBR_VLC_ROW(f_huffman_env_bal_1_5dB),
-        SBR_VLC_ROW(t_huffman_env_3_0dB),
-        SBR_VLC_ROW(f_huffman_env_3_0dB),
-        SBR_VLC_ROW(t_huffman_env_bal_3_0dB),
-        SBR_VLC_ROW(f_huffman_env_bal_3_0dB),
-        SBR_VLC_ROW(t_huffman_noise_3_0dB),
-        SBR_VLC_ROW(t_huffman_noise_bal_3_0dB),
-    };
-
-    // SBR VLC table initialization
-    SBR_INIT_VLC_STATIC(0, 1098);
-    SBR_INIT_VLC_STATIC(1, 1092);
-    SBR_INIT_VLC_STATIC(2, 768);
-    SBR_INIT_VLC_STATIC(3, 1026);
-    SBR_INIT_VLC_STATIC(4, 1058);
-    SBR_INIT_VLC_STATIC(5, 1052);
-    SBR_INIT_VLC_STATIC(6, 544);
-    SBR_INIT_VLC_STATIC(7, 544);
-    SBR_INIT_VLC_STATIC(8, 592);
-    SBR_INIT_VLC_STATIC(9, 512);
-
-    for (n = 1; n < 320; n++)
-        sbr_qmf_window_us[320 + n] = sbr_qmf_window_us[320 - n];
-    sbr_qmf_window_us[384] = -sbr_qmf_window_us[384];
-    sbr_qmf_window_us[512] = -sbr_qmf_window_us[512];
-
-    for (n = 0; n < 320; n++)
-        sbr_qmf_window_ds[n] = sbr_qmf_window_us[2*n];
-
-    ff_ps_init();
-}
+    Q31(1.0/2), Q31(1.0/3), Q31(1.0/4), Q31(1.0/5), Q31(1.0/6), Q31(1.0/7), Q31(1.0/8), Q31(1.0/9), Q31(1.0/10), Q31(1.0/11)
+};
 
-av_cold void ff_aac_sbr_ctx_init(AACContext *ac, SpectralBandReplication *sbr)
+static int fixed_log(int x)
 {
-    float mdct_scale;
-    sbr->kx[0] = sbr->kx[1] = 32; //Typo in spec, kx' inits to 32
-    sbr->data[0].e_a[1] = sbr->data[1].e_a[1] = -1;
-    sbr->data[0].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);
-    sbr->data[1].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);
-    /* SBR requires samples to be scaled to +/-32768.0 to work correctly.
-     * mdct scale factors are adjusted to scale up from +/-1.0 at analysis
-     * and scale back down at synthesis. */
-    mdct_scale = ac->avctx->sample_fmt == AV_SAMPLE_FMT_FLT ? 32768.0f : 1.0f;
-    ff_mdct_init(&sbr->mdct,     7, 1, 1.0 / (64 * mdct_scale));
-    ff_mdct_init(&sbr->mdct_ana, 7, 1, -2.0 * mdct_scale);
-    ff_ps_ctx_init(&sbr->ps);
-}
+    int i, ret, xpow, tmp;
 
-av_cold void ff_aac_sbr_ctx_close(SpectralBandReplication *sbr)
-{
-    ff_mdct_end(&sbr->mdct);
-    ff_mdct_end(&sbr->mdct_ana);
-}
+    ret = x;
+    xpow = x;
+    for (i=0; i<10; i+=2){
+        xpow = (int)(((int64_t)xpow * x + 0x4000000) >> 31);
+        tmp = (int)(((int64_t)xpow * fixed_log_table[i] + 0x4000000) >> 31);
+        ret -= tmp;
 
-static int qsort_comparison_function_int16(const void *a, const void *b)
-{
-    return *(const int16_t *)a - *(const int16_t *)b;
-}
+        xpow = (int)(((int64_t)xpow * x + 0x4000000) >> 31);
+        tmp = (int)(((int64_t)xpow * fixed_log_table[i+1] + 0x4000000) >> 31);
+        ret += tmp;
+    }
 
-static inline int in_table_int16(const int16_t *table, int last_el, int16_t needle)
-{
-    int i;
-    for (i = 0; i <= last_el; i++)
-        if (table[i] == needle)
-            return 1;
-    return 0;
+    return ret;
 }
 
-/// Limiter Frequency Band Table (14496-3 sp04 p198)
-static void sbr_make_f_tablelim(SpectralBandReplication *sbr)
+int fixed_exp_table[7] =
 {
-    int k;
-    if (sbr->bs_limiter_bands > 0) {
-        static const float bands_warped[3] = { 1.32715174233856803909f,   //2^(0.49/1.2)
-                                               1.18509277094158210129f,   //2^(0.49/2)
-                                               1.11987160404675912501f }; //2^(0.49/3)
-        const float lim_bands_per_octave_warped = bands_warped[sbr->bs_limiter_bands - 1];
-        int16_t patch_borders[7];
-        uint16_t *in = sbr->f_tablelim + 1, *out = sbr->f_tablelim;
-
-        patch_borders[0] = sbr->kx[1];
-        for (k = 1; k <= sbr->num_patches; k++)
-            patch_borders[k] = patch_borders[k-1] + sbr->patch_num_subbands[k-1];
-
-        memcpy(sbr->f_tablelim, sbr->f_tablelow,
-               (sbr->n[0] + 1) * sizeof(sbr->f_tablelow[0]));
-        if (sbr->num_patches > 1)
-            memcpy(sbr->f_tablelim + sbr->n[0] + 1, patch_borders + 1,
-                   (sbr->num_patches - 1) * sizeof(patch_borders[0]));
-
-        qsort(sbr->f_tablelim, sbr->num_patches + sbr->n[0],
-              sizeof(sbr->f_tablelim[0]),
-              qsort_comparison_function_int16);
-
-        sbr->n_lim = sbr->n[0] + sbr->num_patches - 1;
-        while (out < sbr->f_tablelim + sbr->n_lim) {
-            if (*in >= *out * lim_bands_per_octave_warped) {
-                *++out = *in++;
-            } else if (*in == *out ||
-                !in_table_int16(patch_borders, sbr->num_patches, *in)) {
-                in++;
-                sbr->n_lim--;
-            } else if (!in_table_int16(patch_borders, sbr->num_patches, *out)) {
-                *out = *in++;
-                sbr->n_lim--;
-            } else {
-                *++out = *in++;
-            }
-        }
-    } else {
-        sbr->f_tablelim[0] = sbr->f_tablelow[0];
-        sbr->f_tablelim[1] = sbr->f_tablelow[sbr->n[0]];
-        sbr->n_lim = 1;
-    }
-}
+    Q31(1.0/2), Q31(1.0/6), Q31(1.0/24), Q31(1.0/120), Q31(1.0/720), Q31(1.0/5040), Q31(1.0/40320)
+};
 
-static unsigned int read_sbr_header(SpectralBandReplication *sbr, GetBitContext *gb)
+static int fixed_exp(int x)
 {
-    unsigned int cnt = get_bits_count(gb);
-    uint8_t bs_header_extra_1;
-    uint8_t bs_header_extra_2;
-    int old_bs_limiter_bands = sbr->bs_limiter_bands;
-    SpectrumParameters old_spectrum_params;
-
-    sbr->start = 1;
-
-    // Save last spectrum parameters variables to compare to new ones
-    memcpy(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters));
-
-    sbr->bs_amp_res_header              = get_bits1(gb);
-    sbr->spectrum_params.bs_start_freq  = get_bits(gb, 4);
-    sbr->spectrum_params.bs_stop_freq   = get_bits(gb, 4);
-    sbr->spectrum_params.bs_xover_band  = get_bits(gb, 3);
-                                          skip_bits(gb, 2); // bs_reserved
-
-    bs_header_extra_1 = get_bits1(gb);
-    bs_header_extra_2 = get_bits1(gb);
-
-    if (bs_header_extra_1) {
-        sbr->spectrum_params.bs_freq_scale  = get_bits(gb, 2);
-        sbr->spectrum_params.bs_alter_scale = get_bits1(gb);
-        sbr->spectrum_params.bs_noise_bands = get_bits(gb, 2);
-    } else {
-        sbr->spectrum_params.bs_freq_scale  = 2;
-        sbr->spectrum_params.bs_alter_scale = 1;
-        sbr->spectrum_params.bs_noise_bands = 2;
-    }
+    int i, ret, xpow, tmp;
+    int64_t accu;
 
-    // Check if spectrum parameters changed
-    if (memcmp(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters)))
-        sbr->reset = 1;
-
-    if (bs_header_extra_2) {
-        sbr->bs_limiter_bands  = get_bits(gb, 2);
-        sbr->bs_limiter_gains  = get_bits(gb, 2);
-        sbr->bs_interpol_freq  = get_bits1(gb);
-        sbr->bs_smoothing_mode = get_bits1(gb);
-    } else {
-        sbr->bs_limiter_bands  = 2;
-        sbr->bs_limiter_gains  = 2;
-        sbr->bs_interpol_freq  = 1;
-        sbr->bs_smoothing_mode = 1;
+    ret = 0x800000 + x;
+    xpow = x;
+    for (i=0; i<7; i++){
+        accu = (int64_t)xpow * x;
+        xpow = (int)((accu + 0x40000) >> 23);
+        accu = (int64_t)xpow * fixed_exp_table[i];
+        tmp = (int)((accu + 0x4000000) >> 31);
+        ret += tmp;
     }
 
-    if (sbr->bs_limiter_bands != old_bs_limiter_bands && !sbr->reset)
-        sbr_make_f_tablelim(sbr);
-
-    return get_bits_count(gb) - cnt;
-}
-
-static int array_min_int16(const int16_t *array, int nel)
-{
-    int i, min = array[0];
-    for (i = 1; i < nel; i++)
-        min = FFMIN(array[i], min);
-    return min;
+    return ret;
 }
 
 static void make_bands(int16_t* bands, int start, int stop, int num_bands)
 {
     int k, previous, present;
-    float base, prod;
+    int base, prod, nz = 0;
+    int64_t accu;
+
+    base = (stop << 23) / start;
+    while (base < 0x40000000){
+        base <<= 1;
+        nz++;
+    }
+    base = fixed_log(base - 0x80000000);
+    base = (((base+128)>>8) + (8-nz)*CONST_LN2) / num_bands;
+    base = fixed_exp(base);
 
-    base = powf((float)stop / start, 1.0f / num_bands);
-    prod = start;
     previous = start;
+    prod = start << 23;
 
     for (k = 0; k < num_bands-1; k++) {
-        prod *= base;
-        present  = lrintf(prod);
+        accu = (int64_t)prod * base;
+        prod = (int)((accu + 0x400000) >> 23);
+        present = (prod + 0x400000) >> 23;
         bands[k] = present - previous;
         previous = present;
     }
     bands[num_bands-1] = stop - previous;
 }
 
-static int check_n_master(AVCodecContext *avctx, int n_master, int bs_xover_band)
-{
-    // Requirements (14496-3 sp04 p205)
-    if (n_master <= 0) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid n_master: %d\n", n_master);
-        return -1;
-    }
-    if (bs_xover_band >= n_master) {
-        av_log(avctx, AV_LOG_ERROR,
-               "Invalid bitstream, crossover band index beyond array bounds: %d\n",
-               bs_xover_band);
-        return -1;
-    }
-    return 0;
-}
-
-/// Master Frequency Band Table (14496-3 sp04 p194)
-static int sbr_make_f_master(AACContext *ac, SpectralBandReplication *sbr,
-                             SpectrumParameters *spectrum)
-{
-    unsigned int temp, max_qmf_subbands;
-    unsigned int start_min, stop_min;
-    int k;
-    const int8_t *sbr_offset_ptr;
-    int16_t stop_dk[13];
-
-    if (sbr->sample_rate < 32000) {
-        temp = 3000;
-    } else if (sbr->sample_rate < 64000) {
-        temp = 4000;
-    } else
-        temp = 5000;
-
-    start_min = ((temp << 7) + (sbr->sample_rate >> 1)) / sbr->sample_rate;
-    stop_min  = ((temp << 8) + (sbr->sample_rate >> 1)) / sbr->sample_rate;
-
-    switch (sbr->sample_rate) {
-    case 16000:
-        sbr_offset_ptr = sbr_offset[0];
-        break;
-    case 22050:
-        sbr_offset_ptr = sbr_offset[1];
-        break;
-    case 24000:
-        sbr_offset_ptr = sbr_offset[2];
-        break;
-    case 32000:
-        sbr_offset_ptr = sbr_offset[3];
-        break;
-    case 44100: case 48000: case 64000:
-        sbr_offset_ptr = sbr_offset[4];
-        break;
-    case 88200: case 96000: case 128000: case 176400: case 192000:
-        sbr_offset_ptr = sbr_offset[5];
-        break;
-    default:
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Unsupported sample rate for SBR: %d\n", sbr->sample_rate);
-        return -1;
-    }
-
-    sbr->k[0] = start_min + sbr_offset_ptr[spectrum->bs_start_freq];
-
-    if (spectrum->bs_stop_freq < 14) {
-        sbr->k[2] = stop_min;
-        make_bands(stop_dk, stop_min, 64, 13);
-        qsort(stop_dk, 13, sizeof(stop_dk[0]), qsort_comparison_function_int16);
-        for (k = 0; k < spectrum->bs_stop_freq; k++)
-            sbr->k[2] += stop_dk[k];
-    } else if (spectrum->bs_stop_freq == 14) {
-        sbr->k[2] = 2*sbr->k[0];
-    } else if (spectrum->bs_stop_freq == 15) {
-        sbr->k[2] = 3*sbr->k[0];
-    } else {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Invalid bs_stop_freq: %d\n", spectrum->bs_stop_freq);
-        return -1;
-    }
-    sbr->k[2] = FFMIN(64, sbr->k[2]);
-
-    // Requirements (14496-3 sp04 p205)
-    if (sbr->sample_rate <= 32000) {
-        max_qmf_subbands = 48;
-    } else if (sbr->sample_rate == 44100) {
-        max_qmf_subbands = 35;
-    } else if (sbr->sample_rate >= 48000)
-        max_qmf_subbands = 32;
-
-    if (sbr->k[2] - sbr->k[0] > max_qmf_subbands) {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Invalid bitstream, too many QMF subbands: %d\n", sbr->k[2] - sbr->k[0]);
-        return -1;
-    }
-
-    if (!spectrum->bs_freq_scale) {
-        int dk, k2diff;
-
-        dk = spectrum->bs_alter_scale + 1;
-        sbr->n_master = ((sbr->k[2] - sbr->k[0] + (dk&2)) >> dk) << 1;
-        if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))
-            return -1;
-
-        for (k = 1; k <= sbr->n_master; k++)
-            sbr->f_master[k] = dk;
-
-        k2diff = sbr->k[2] - sbr->k[0] - sbr->n_master * dk;
-        if (k2diff < 0) {
-            sbr->f_master[1]--;
-            sbr->f_master[2]-= (k2diff < -1);
-        } else if (k2diff) {
-            sbr->f_master[sbr->n_master]++;
-        }
-
-        sbr->f_master[0] = sbr->k[0];
-        for (k = 1; k <= sbr->n_master; k++)
-            sbr->f_master[k] += sbr->f_master[k - 1];
-
-    } else {
-        int half_bands = 7 - spectrum->bs_freq_scale;      // bs_freq_scale  = {1,2,3}
-        int two_regions, num_bands_0;
-        int vdk0_max, vdk1_min;
-        int16_t vk0[49];
-
-        if (49 * sbr->k[2] > 110 * sbr->k[0]) {
-            two_regions = 1;
-            sbr->k[1] = 2 * sbr->k[0];
-        } else {
-            two_regions = 0;
-            sbr->k[1] = sbr->k[2];
-        }
-
-        num_bands_0 = lrintf(half_bands * log2f(sbr->k[1] / (float)sbr->k[0])) * 2;
-
-        if (num_bands_0 <= 0) { // Requirements (14496-3 sp04 p205)
-            av_log(ac->avctx, AV_LOG_ERROR, "Invalid num_bands_0: %d\n", num_bands_0);
-            return -1;
-        }
-
-        vk0[0] = 0;
-
-        make_bands(vk0+1, sbr->k[0], sbr->k[1], num_bands_0);
-
-        qsort(vk0 + 1, num_bands_0, sizeof(vk0[1]), qsort_comparison_function_int16);
-        vdk0_max = vk0[num_bands_0];
-
-        vk0[0] = sbr->k[0];
-        for (k = 1; k <= num_bands_0; k++) {
-            if (vk0[k] <= 0) { // Requirements (14496-3 sp04 p205)
-                av_log(ac->avctx, AV_LOG_ERROR, "Invalid vDk0[%d]: %d\n", k, vk0[k]);
-                return -1;
-            }
-            vk0[k] += vk0[k-1];
-        }
-
-        if (two_regions) {
-            int16_t vk1[49];
-            float invwarp = spectrum->bs_alter_scale ? 0.76923076923076923077f
-                                                     : 1.0f; // bs_alter_scale = {0,1}
-            int num_bands_1 = lrintf(half_bands * invwarp *
-                                     log2f(sbr->k[2] / (float)sbr->k[1])) * 2;
-
-            make_bands(vk1+1, sbr->k[1], sbr->k[2], num_bands_1);
-
-            vdk1_min = array_min_int16(vk1 + 1, num_bands_1);
-
-            if (vdk1_min < vdk0_max) {
-                int change;
-                qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);
-                change = FFMIN(vdk0_max - vk1[1], (vk1[num_bands_1] - vk1[1]) >> 1);
-                vk1[1]           += change;
-                vk1[num_bands_1] -= change;
-            }
-
-            qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);
-
-            vk1[0] = sbr->k[1];
-            for (k = 1; k <= num_bands_1; k++) {
-                if (vk1[k] <= 0) { // Requirements (14496-3 sp04 p205)
-                    av_log(ac->avctx, AV_LOG_ERROR, "Invalid vDk1[%d]: %d\n", k, vk1[k]);
-                    return -1;
-                }
-                vk1[k] += vk1[k-1];
-            }
-
-            sbr->n_master = num_bands_0 + num_bands_1;
-            if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))
-                return -1;
-            memcpy(&sbr->f_master[0],               vk0,
-                   (num_bands_0 + 1) * sizeof(sbr->f_master[0]));
-            memcpy(&sbr->f_master[num_bands_0 + 1], vk1 + 1,
-                    num_bands_1      * sizeof(sbr->f_master[0]));
-
-        } else {
-            sbr->n_master = num_bands_0;
-            if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))
-                return -1;
-            memcpy(sbr->f_master, vk0, (num_bands_0 + 1) * sizeof(sbr->f_master[0]));
-        }
-    }
-
-    return 0;
-}
-
-/// High Frequency Generation - Patch Construction (14496-3 sp04 p216 fig. 4.46)
-static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)
-{
-    int i, k, sb = 0;
-    int msb = sbr->k[0];
-    int usb = sbr->kx[1];
-    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;
-
-    sbr->num_patches = 0;
-
-    if (goal_sb < sbr->kx[1] + sbr->m[1]) {
-        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;
-    } else
-        k = sbr->n_master;
-
-    do {
-        int odd = 0;
-        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {
-            sb = sbr->f_master[i];
-            odd = (sb + sbr->k[0]) & 1;
-        }
-
-        // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5.
-        // After this check the final number of patches can still be six which is
-        // illegal however the Coding Technologies decoder check stream has a final
-        // count of 6 patches
-        if (sbr->num_patches > 5) {
-            av_log(ac->avctx, AV_LOG_ERROR, "Too many patches: %d\n", sbr->num_patches);
-            return -1;
-        }
-
-        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);
-        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];
-
-        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {
-            usb = sb;
-            msb = sb;
-            sbr->num_patches++;
-        } else
-            msb = sbr->kx[1];
-
-        if (sbr->f_master[k] - sb < 3)
-            k = sbr->n_master;
-    } while (sb != sbr->kx[1] + sbr->m[1]);
-
-    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)
-        sbr->num_patches--;
-
-    return 0;
-}
-
-/// Derived Frequency Band Tables (14496-3 sp04 p197)
-static int sbr_make_f_derived(AACContext *ac, SpectralBandReplication *sbr)
-{
-    int k, temp;
-
-    sbr->n[1] = sbr->n_master - sbr->spectrum_params.bs_xover_band;
-    sbr->n[0] = (sbr->n[1] + 1) >> 1;
-
-    memcpy(sbr->f_tablehigh, &sbr->f_master[sbr->spectrum_params.bs_xover_band],
-           (sbr->n[1] + 1) * sizeof(sbr->f_master[0]));
-    sbr->m[1] = sbr->f_tablehigh[sbr->n[1]] - sbr->f_tablehigh[0];
-    sbr->kx[1] = sbr->f_tablehigh[0];
-
-    // Requirements (14496-3 sp04 p205)
-    if (sbr->kx[1] + sbr->m[1] > 64) {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Stop frequency border too high: %d\n", sbr->kx[1] + sbr->m[1]);
-        return -1;
-    }
-    if (sbr->kx[1] > 32) {
-        av_log(ac->avctx, AV_LOG_ERROR, "Start frequency border too high: %d\n", sbr->kx[1]);
-        return -1;
-    }
-
-    sbr->f_tablelow[0] = sbr->f_tablehigh[0];
-    temp = sbr->n[1] & 1;
-    for (k = 1; k <= sbr->n[0]; k++)
-        sbr->f_tablelow[k] = sbr->f_tablehigh[2 * k - temp];
-
-    sbr->n_q = FFMAX(1, lrintf(sbr->spectrum_params.bs_noise_bands *
-                               log2f(sbr->k[2] / (float)sbr->kx[1]))); // 0 <= bs_noise_bands <= 3
-    if (sbr->n_q > 5) {
-        av_log(ac->avctx, AV_LOG_ERROR, "Too many noise floor scale factors: %d\n", sbr->n_q);
-        return -1;
-    }
-
-    sbr->f_tablenoise[0] = sbr->f_tablelow[0];
-    temp = 0;
-    for (k = 1; k <= sbr->n_q; k++) {
-        temp += (sbr->n[0] - temp) / (sbr->n_q + 1 - k);
-        sbr->f_tablenoise[k] = sbr->f_tablelow[temp];
-    }
-
-    if (sbr_hf_calc_npatches(ac, sbr) < 0)
-        return -1;
-
-    sbr_make_f_tablelim(sbr);
-
-    sbr->data[0].f_indexnoise = 0;
-    sbr->data[1].f_indexnoise = 0;
-
-    return 0;
-}
-
-static av_always_inline void get_bits1_vector(GetBitContext *gb, uint8_t *vec,
-                                              int elements)
-{
-    int i;
-    for (i = 0; i < elements; i++) {
-        vec[i] = get_bits1(gb);
-    }
-}
-
-/** ceil(log2(index+1)) */
-static const int8_t ceil_log2[] = {
-    0, 1, 2, 2, 3, 3,
-};
-
-static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,
-                         GetBitContext *gb, SBRData *ch_data)
-{
-    int i;
-    unsigned bs_pointer = 0;
-    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots
-    int abs_bord_trail = 16;
-    int num_rel_lead, num_rel_trail;
-    unsigned bs_num_env_old = ch_data->bs_num_env;
-
-    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];
-    ch_data->bs_amp_res = sbr->bs_amp_res_header;
-    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];
-
-    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {
-    case FIXFIX:
-        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);
-        num_rel_lead                        = ch_data->bs_num_env - 1;
-        if (ch_data->bs_num_env == 1)
-            ch_data->bs_amp_res = 0;
-
-        if (ch_data->bs_num_env > 4) {
-            av_log(ac->avctx, AV_LOG_ERROR,
-                   "Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\n",
-                   ch_data->bs_num_env);
-            return -1;
-        }
-
-        ch_data->t_env[0]                   = 0;
-        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;
-
-        abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /
-                   ch_data->bs_num_env;
-        for (i = 0; i < num_rel_lead; i++)
-            ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;
-
-        ch_data->bs_freq_res[1] = get_bits1(gb);
-        for (i = 1; i < ch_data->bs_num_env; i++)
-            ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];
-        break;
-    case FIXVAR:
-        abs_bord_trail                     += get_bits(gb, 2);
-        num_rel_trail                       = get_bits(gb, 2);
-        ch_data->bs_num_env                 = num_rel_trail + 1;
-        ch_data->t_env[0]                   = 0;
-        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;
-
-        for (i = 0; i < num_rel_trail; i++)
-            ch_data->t_env[ch_data->bs_num_env - 1 - i] =
-                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;
-
-        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);
-
-        for (i = 0; i < ch_data->bs_num_env; i++)
-            ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);
-        break;
-    case VARFIX:
-        ch_data->t_env[0]                   = get_bits(gb, 2);
-        num_rel_lead                        = get_bits(gb, 2);
-        ch_data->bs_num_env                 = num_rel_lead + 1;
-        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;
-
-        for (i = 0; i < num_rel_lead; i++)
-            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;
-
-        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);
-
-        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);
-        break;
-    case VARVAR:
-        ch_data->t_env[0]                   = get_bits(gb, 2);
-        abs_bord_trail                     += get_bits(gb, 2);
-        num_rel_lead                        = get_bits(gb, 2);
-        num_rel_trail                       = get_bits(gb, 2);
-        ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;
-
-        if (ch_data->bs_num_env > 5) {
-            av_log(ac->avctx, AV_LOG_ERROR,
-                   "Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\n",
-                   ch_data->bs_num_env);
-            return -1;
-        }
-
-        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;
-
-        for (i = 0; i < num_rel_lead; i++)
-            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;
-        for (i = 0; i < num_rel_trail; i++)
-            ch_data->t_env[ch_data->bs_num_env - 1 - i] =
-                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;
-
-        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);
-
-        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);
-        break;
-    }
-
-    if (bs_pointer > ch_data->bs_num_env + 1) {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n",
-               bs_pointer);
-        return -1;
-    }
-
-    for (i = 1; i <= ch_data->bs_num_env; i++) {
-        if (ch_data->t_env[i-1] > ch_data->t_env[i]) {
-            av_log(ac->avctx, AV_LOG_ERROR, "Non monotone time borders\n");
-            return -1;
-        }
-    }
-
-    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;
-
-    ch_data->t_q[0]                     = ch_data->t_env[0];
-    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];
-    if (ch_data->bs_num_noise > 1) {
-        unsigned int idx;
-        if (ch_data->bs_frame_class == FIXFIX) {
-            idx = ch_data->bs_num_env >> 1;
-        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR
-            idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);
-        } else { // VARFIX
-            if (!bs_pointer)
-                idx = 1;
-            else if (bs_pointer == 1)
-                idx = ch_data->bs_num_env - 1;
-            else // bs_pointer > 1
-                idx = bs_pointer - 1;
-        }
-        ch_data->t_q[1] = ch_data->t_env[idx];
-    }
-
-    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev
-    ch_data->e_a[1] = -1;
-    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0
-        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;
-    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1
-        ch_data->e_a[1] = bs_pointer - 1;
-
-    return 0;
-}
-
-static void copy_sbr_grid(SBRData *dst, const SBRData *src) {
-    //These variables are saved from the previous frame rather than copied
-    dst->bs_freq_res[0]    = dst->bs_freq_res[dst->bs_num_env];
-    dst->t_env_num_env_old = dst->t_env[dst->bs_num_env];
-    dst->e_a[0]            = -(dst->e_a[1] != dst->bs_num_env);
-
-    //These variables are read from the bitstream and therefore copied
-    memcpy(dst->bs_freq_res+1, src->bs_freq_res+1, sizeof(dst->bs_freq_res)-sizeof(*dst->bs_freq_res));
-    memcpy(dst->t_env,         src->t_env,         sizeof(dst->t_env));
-    memcpy(dst->t_q,           src->t_q,           sizeof(dst->t_q));
-    dst->bs_num_env        = src->bs_num_env;
-    dst->bs_amp_res        = src->bs_amp_res;
-    dst->bs_num_noise      = src->bs_num_noise;
-    dst->bs_frame_class    = src->bs_frame_class;
-    dst->e_a[1]            = src->e_a[1];
-}
-
-/// Read how the envelope and noise floor data is delta coded
-static void read_sbr_dtdf(SpectralBandReplication *sbr, GetBitContext *gb,
-                          SBRData *ch_data)
-{
-    get_bits1_vector(gb, ch_data->bs_df_env,   ch_data->bs_num_env);
-    get_bits1_vector(gb, ch_data->bs_df_noise, ch_data->bs_num_noise);
-}
-
-/// Read inverse filtering data
-static void read_sbr_invf(SpectralBandReplication *sbr, GetBitContext *gb,
-                          SBRData *ch_data)
-{
-    int i;
-
-    memcpy(ch_data->bs_invf_mode[1], ch_data->bs_invf_mode[0], 5 * sizeof(uint8_t));
-    for (i = 0; i < sbr->n_q; i++)
-        ch_data->bs_invf_mode[0][i] = get_bits(gb, 2);
-}
-
-static void read_sbr_envelope(SpectralBandReplication *sbr, GetBitContext *gb,
-                              SBRData *ch_data, int ch)
-{
-    int bits;
-    int i, j, k;
-    VLC_TYPE (*t_huff)[2], (*f_huff)[2];
-    int t_lav, f_lav;
-    const int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;
-    const int odd = sbr->n[1] & 1;
-
-    if (sbr->bs_coupling && ch) {
-        if (ch_data->bs_amp_res) {
-            bits   = 5;
-            t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_3_0DB].table;
-            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_3_0DB];
-            f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;
-            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];
-        } else {
-            bits   = 6;
-            t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_1_5DB].table;
-            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_1_5DB];
-            f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_1_5DB].table;
-            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_1_5DB];
-        }
-    } else {
-        if (ch_data->bs_amp_res) {
-            bits   = 6;
-            t_huff = vlc_sbr[T_HUFFMAN_ENV_3_0DB].table;
-            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_3_0DB];
-            f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;
-            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];
-        } else {
-            bits   = 7;
-            t_huff = vlc_sbr[T_HUFFMAN_ENV_1_5DB].table;
-            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_1_5DB];
-            f_huff = vlc_sbr[F_HUFFMAN_ENV_1_5DB].table;
-            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_1_5DB];
-        }
-    }
-
-    for (i = 0; i < ch_data->bs_num_env; i++) {
-        if (ch_data->bs_df_env[i]) {
-            // bs_freq_res[0] == bs_freq_res[bs_num_env] from prev frame
-            if (ch_data->bs_freq_res[i + 1] == ch_data->bs_freq_res[i]) {
-                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)
-                    ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);
-            } else if (ch_data->bs_freq_res[i + 1]) {
-                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {
-                    k = (j + odd) >> 1; // find k such that f_tablelow[k] <= f_tablehigh[j] < f_tablelow[k + 1]
-                    ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);
-                }
-            } else {
-                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {
-                    k = j ? 2*j - odd : 0; // find k such that f_tablehigh[k] == f_tablelow[j]
-                    ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);
-                }
-            }
-        } else {
-            ch_data->env_facs[i + 1][0] = delta * get_bits(gb, bits); // bs_env_start_value_balance
-            for (j = 1; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)
-                ch_data->env_facs[i + 1][j] = ch_data->env_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);
-        }
-    }
-
-    //assign 0th elements of env_facs from last elements
-    memcpy(ch_data->env_facs[0], ch_data->env_facs[ch_data->bs_num_env],
-           sizeof(ch_data->env_facs[0]));
-}
-
-static void read_sbr_noise(SpectralBandReplication *sbr, GetBitContext *gb,
-                           SBRData *ch_data, int ch)
-{
-    int i, j;
-    VLC_TYPE (*t_huff)[2], (*f_huff)[2];
-    int t_lav, f_lav;
-    int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;
-
-    if (sbr->bs_coupling && ch) {
-        t_huff = vlc_sbr[T_HUFFMAN_NOISE_BAL_3_0DB].table;
-        t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_BAL_3_0DB];
-        f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;
-        f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];
-    } else {
-        t_huff = vlc_sbr[T_HUFFMAN_NOISE_3_0DB].table;
-        t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_3_0DB];
-        f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;
-        f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];
-    }
-
-    for (i = 0; i < ch_data->bs_num_noise; i++) {
-        if (ch_data->bs_df_noise[i]) {
-            for (j = 0; j < sbr->n_q; j++)
-                ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 2) - t_lav);
-        } else {
-            ch_data->noise_facs[i + 1][0] = delta * get_bits(gb, 5); // bs_noise_start_value_balance or bs_noise_start_value_level
-            for (j = 1; j < sbr->n_q; j++)
-                ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);
-        }
-    }
-
-    //assign 0th elements of noise_facs from last elements
-    memcpy(ch_data->noise_facs[0], ch_data->noise_facs[ch_data->bs_num_noise],
-           sizeof(ch_data->noise_facs[0]));
-}
-
-static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,
-                               GetBitContext *gb,
-                               int bs_extension_id, int *num_bits_left)
-{
-    switch (bs_extension_id) {
-    case EXTENSION_ID_PS:
-        if (!ac->m4ac.ps) {
-            av_log(ac->avctx, AV_LOG_ERROR, "Parametric Stereo signaled to be not-present but was found in the bitstream.\n");
-            skip_bits_long(gb, *num_bits_left); // bs_fill_bits
-            *num_bits_left = 0;
-        } else {
-#if 1
-            *num_bits_left -= ff_ps_read_data(ac->avctx, gb, &sbr->ps, *num_bits_left);
-#else
-            av_log_missing_feature(ac->avctx, "Parametric Stereo is", 0);
-            skip_bits_long(gb, *num_bits_left); // bs_fill_bits
-            *num_bits_left = 0;
-#endif
-        }
-        break;
-    default:
-        av_log_missing_feature(ac->avctx, "Reserved SBR extensions are", 1);
-        skip_bits_long(gb, *num_bits_left); // bs_fill_bits
-        *num_bits_left = 0;
-        break;
-    }
-}
-
-static int read_sbr_single_channel_element(AACContext *ac,
-                                            SpectralBandReplication *sbr,
-                                            GetBitContext *gb)
-{
-    if (get_bits1(gb)) // bs_data_extra
-        skip_bits(gb, 4); // bs_reserved
-
-    if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))
-        return -1;
-    read_sbr_dtdf(sbr, gb, &sbr->data[0]);
-    read_sbr_invf(sbr, gb, &sbr->data[0]);
-    read_sbr_envelope(sbr, gb, &sbr->data[0], 0);
-    read_sbr_noise(sbr, gb, &sbr->data[0], 0);
-
-    if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))
-        get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);
-
-    return 0;
-}
-
-static int read_sbr_channel_pair_element(AACContext *ac,
-                                          SpectralBandReplication *sbr,
-                                          GetBitContext *gb)
-{
-    if (get_bits1(gb))    // bs_data_extra
-        skip_bits(gb, 8); // bs_reserved
-
-    if ((sbr->bs_coupling = get_bits1(gb))) {
-        if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))
-            return -1;
-        copy_sbr_grid(&sbr->data[1], &sbr->data[0]);
-        read_sbr_dtdf(sbr, gb, &sbr->data[0]);
-        read_sbr_dtdf(sbr, gb, &sbr->data[1]);
-        read_sbr_invf(sbr, gb, &sbr->data[0]);
-        memcpy(sbr->data[1].bs_invf_mode[1], sbr->data[1].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));
-        memcpy(sbr->data[1].bs_invf_mode[0], sbr->data[0].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));
-        read_sbr_envelope(sbr, gb, &sbr->data[0], 0);
-        read_sbr_noise(sbr, gb, &sbr->data[0], 0);
-        read_sbr_envelope(sbr, gb, &sbr->data[1], 1);
-        read_sbr_noise(sbr, gb, &sbr->data[1], 1);
-    } else {
-        if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]) ||
-            read_sbr_grid(ac, sbr, gb, &sbr->data[1]))
-            return -1;
-        read_sbr_dtdf(sbr, gb, &sbr->data[0]);
-        read_sbr_dtdf(sbr, gb, &sbr->data[1]);
-        read_sbr_invf(sbr, gb, &sbr->data[0]);
-        read_sbr_invf(sbr, gb, &sbr->data[1]);
-        read_sbr_envelope(sbr, gb, &sbr->data[0], 0);
-        read_sbr_envelope(sbr, gb, &sbr->data[1], 1);
-        read_sbr_noise(sbr, gb, &sbr->data[0], 0);
-        read_sbr_noise(sbr, gb, &sbr->data[1], 1);
-    }
-
-    if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))
-        get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);
-    if ((sbr->data[1].bs_add_harmonic_flag = get_bits1(gb)))
-        get_bits1_vector(gb, sbr->data[1].bs_add_harmonic, sbr->n[1]);
-
-    return 0;
-}
-
-static unsigned int read_sbr_data(AACContext *ac, SpectralBandReplication *sbr,
-                                  GetBitContext *gb, int id_aac)
-{
-    unsigned int cnt = get_bits_count(gb);
-
-    if (id_aac == TYPE_SCE || id_aac == TYPE_CCE) {
-        if (read_sbr_single_channel_element(ac, sbr, gb)) {
-            sbr->start = 0;
-            return get_bits_count(gb) - cnt;
-        }
-    } else if (id_aac == TYPE_CPE) {
-        if (read_sbr_channel_pair_element(ac, sbr, gb)) {
-            sbr->start = 0;
-            return get_bits_count(gb) - cnt;
-        }
-    } else {
-        av_log(ac->avctx, AV_LOG_ERROR,
-            "Invalid bitstream - cannot apply SBR to element type %d\n", id_aac);
-        sbr->start = 0;
-        return get_bits_count(gb) - cnt;
-    }
-    if (get_bits1(gb)) { // bs_extended_data
-        int num_bits_left = get_bits(gb, 4); // bs_extension_size
-        if (num_bits_left == 15)
-            num_bits_left += get_bits(gb, 8); // bs_esc_count
-
-        num_bits_left <<= 3;
-        while (num_bits_left > 7) {
-            num_bits_left -= 2;
-            read_sbr_extension(ac, sbr, gb, get_bits(gb, 2), &num_bits_left); // bs_extension_id
-        }
-        if (num_bits_left < 0) {
-            av_log(ac->avctx, AV_LOG_ERROR, "SBR Extension over read.\n");
-        }
-        if (num_bits_left > 0)
-            skip_bits(gb, num_bits_left);
-    }
-
-    return get_bits_count(gb) - cnt;
-}
-
-static void sbr_reset(AACContext *ac, SpectralBandReplication *sbr)
-{
-    int err;
-    err = sbr_make_f_master(ac, sbr, &sbr->spectrum_params);
-    if (err >= 0)
-        err = sbr_make_f_derived(ac, sbr);
-    if (err < 0) {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "SBR reset failed. Switching SBR to pure upsampling mode.\n");
-        sbr->start = 0;
-    }
-}
-
-/**
- * Decode Spectral Band Replication extension data; reference: table 4.55.
- *
- * @param   crc flag indicating the presence of CRC checksum
- * @param   cnt length of TYPE_FIL syntactic element in bytes
- *
- * @return  Returns number of bytes consumed from the TYPE_FIL element.
- */
-int ff_decode_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,
-                            GetBitContext *gb_host, int crc, int cnt, int id_aac)
-{
-    unsigned int num_sbr_bits = 0, num_align_bits;
-    unsigned bytes_read;
-    GetBitContext gbc = *gb_host, *gb = &gbc;
-    skip_bits_long(gb_host, cnt*8 - 4);
-
-    sbr->reset = 0;
-
-    if (!sbr->sample_rate)
-        sbr->sample_rate = 2 * ac->m4ac.sample_rate; //TODO use the nominal sample rate for arbitrary sample rate support
-    if (!ac->m4ac.ext_sample_rate)
-        ac->m4ac.ext_sample_rate = 2 * ac->m4ac.sample_rate;
-
-    if (crc) {
-        skip_bits(gb, 10); // bs_sbr_crc_bits; TODO - implement CRC check
-        num_sbr_bits += 10;
-    }
-
-    //Save some state from the previous frame.
-    sbr->kx[0] = sbr->kx[1];
-    sbr->m[0] = sbr->m[1];
-
-    num_sbr_bits++;
-    if (get_bits1(gb)) // bs_header_flag
-        num_sbr_bits += read_sbr_header(sbr, gb);
-
-    if (sbr->reset)
-        sbr_reset(ac, sbr);
-
-    if (sbr->start)
-        num_sbr_bits  += read_sbr_data(ac, sbr, gb, id_aac);
-
-    num_align_bits = ((cnt << 3) - 4 - num_sbr_bits) & 7;
-    bytes_read = ((num_sbr_bits + num_align_bits + 4) >> 3);
-
-    if (bytes_read > cnt) {
-        av_log(ac->avctx, AV_LOG_ERROR,
-               "Expected to read %d SBR bytes actually read %d.\n", cnt, bytes_read);
-    }
-    return cnt;
-}
-
 /// Dequantization and stereo decoding (14496-3 sp04 p203)
 static void sbr_dequant(SpectralBandReplication *sbr, int id_aac)
 {
@@ -1100,156 +107,65 @@
     int ch;
 
     if (id_aac == TYPE_CPE && sbr->bs_coupling) {
-        float alpha      = sbr->data[0].bs_amp_res ?  1.0f :  0.5f;
-        float pan_offset = sbr->data[0].bs_amp_res ? 12.0f : 24.0f;
+        int alpha      = sbr->data[0].bs_amp_res ?  2 :  1;
+        int pan_offset = sbr->data[0].bs_amp_res ? 12 : 24;
         for (e = 1; e <= sbr->data[0].bs_num_env; e++) {
             for (k = 0; k < sbr->n[sbr->data[0].bs_freq_res[e]]; k++) {
-                float temp1 = exp2f(sbr->data[0].env_facs[e][k] * alpha + 7.0f);
-                float temp2 = exp2f((pan_offset - sbr->data[1].env_facs[e][k]) * alpha);
-                float fac   = temp1 / (1.0f + temp2);
+                aac_float_t temp1, temp2, fac;
+
+                temp1.expo = sbr->data[0].env_facs[e][k].mant * alpha + 14;
+                if (temp1.expo & 1)
+                  temp1.mant = 759250125;
+                else
+                  temp1.mant = 0x20000000;
+                temp1.expo = (temp1.expo >> 1) + 1;
+
+                temp2.expo = (pan_offset - sbr->data[1].env_facs[e][k].mant) * alpha;
+                if (temp2.expo & 1)
+                  temp2.mant = 759250125;
+                else
+                  temp2.mant = 0x20000000;
+                temp2.expo = (temp2.expo >> 1) + 1;
+                fac   = float_div(temp1, float_add(FLOAT_1, temp2));
                 sbr->data[0].env_facs[e][k] = fac;
-                sbr->data[1].env_facs[e][k] = fac * temp2;
+                sbr->data[1].env_facs[e][k] = float_mul(fac, temp2);
             }
         }
         for (e = 1; e <= sbr->data[0].bs_num_noise; e++) {
             for (k = 0; k < sbr->n_q; k++) {
-                float temp1 = exp2f(NOISE_FLOOR_OFFSET - sbr->data[0].noise_facs[e][k] + 1);
-                float temp2 = exp2f(12 - sbr->data[1].noise_facs[e][k]);
-                float fac   = temp1 / (1.0f + temp2);
+                aac_float_t temp1, temp2, fac;
+
+                temp1.expo = NOISE_FLOOR_OFFSET - sbr->data[0].noise_facs[e][k].mant + 2;
+                temp1.mant = 0x20000000;
+                temp2.expo = 12 - sbr->data[1].noise_facs[e][k].mant + 1;
+                temp2.mant = 0x20000000;
+                fac   = float_div(temp1, float_add(FLOAT_1, temp2));
                 sbr->data[0].noise_facs[e][k] = fac;
-                sbr->data[1].noise_facs[e][k] = fac * temp2;
+                sbr->data[1].noise_facs[e][k] = float_mul(fac, temp2);
             }
         }
     } else { // SCE or one non-coupled CPE
         for (ch = 0; ch < (id_aac == TYPE_CPE) + 1; ch++) {
-            float alpha = sbr->data[ch].bs_amp_res ? 1.0f : 0.5f;
+            int alpha = sbr->data[ch].bs_amp_res ? 2 : 1;
             for (e = 1; e <= sbr->data[ch].bs_num_env; e++)
-                for (k = 0; k < sbr->n[sbr->data[ch].bs_freq_res[e]]; k++)
-                    sbr->data[ch].env_facs[e][k] =
-                        exp2f(alpha * sbr->data[ch].env_facs[e][k] + 6.0f);
-            for (e = 1; e <= sbr->data[ch].bs_num_noise; e++)
-                for (k = 0; k < sbr->n_q; k++)
-                    sbr->data[ch].noise_facs[e][k] =
-                        exp2f(NOISE_FLOOR_OFFSET - sbr->data[ch].noise_facs[e][k]);
-        }
-    }
-}
-
-/**
- * Analysis QMF Bank (14496-3 sp04 p206)
- *
- * @param   x       pointer to the beginning of the first sample window
- * @param   W       array of complex-valued samples split into subbands
- */
-static void sbr_qmf_analysis(DSPContext *dsp, FFTContext *mdct, const float *in, float *x,
-                             float z[320], float W[2][32][32][2])
-{
-    int i, k;
-    memcpy(W[0], W[1], sizeof(W[0]));
-    memcpy(x    , x+1024, (320-32)*sizeof(x[0]));
-    memcpy(x+288, in,         1024*sizeof(x[0]));
-    for (i = 0; i < 32; i++) { // numTimeSlots*RATE = 16*2 as 960 sample frames
-                               // are not supported
-        dsp->vector_fmul_reverse(z, sbr_qmf_window_ds, x, 320);
-        for (k = 0; k < 64; k++) {
-            float f = z[k] + z[k + 64] + z[k + 128] + z[k + 192] + z[k + 256];
-            z[k] = f;
-        }
-        //Shuffle to IMDCT
-        z[64] = z[0];
-        for (k = 1; k < 32; k++) {
-            z[64+2*k-1] =  z[   k];
-            z[64+2*k  ] = -z[64-k];
-        }
-        z[64+63] = z[32];
+                for (k = 0; k < sbr->n[sbr->data[ch].bs_freq_res[e]]; k++){
+                    aac_float_t temp1;
 
-        mdct->imdct_half(mdct, z, z+64);
-        for (k = 0; k < 32; k++) {
-            W[1][i][k][0] = -z[63-k];
-            W[1][i][k][1] = z[k];
-        }
-        x += 32;
-    }
-}
+                    temp1.expo = alpha * sbr->data[ch].env_facs[e][k].mant + 12;
+                    if (temp1.expo & 1)
+                        temp1.mant = 759250125;
+                    else
+                        temp1.mant = 0x20000000;
+                    temp1.expo = (temp1.expo >> 1) + 1;
 
-/**
- * Synthesis QMF Bank (14496-3 sp04 p206) and Downsampled Synthesis QMF Bank
- * (14496-3 sp04 p206)
- */
-static void sbr_qmf_synthesis(DSPContext *dsp, FFTContext *mdct,
-                              float *out, float X[2][38][64],
-                              float mdct_buf[2][64],
-                              float *v0, int *v_off, const unsigned int div)
-{
-    int i, n;
-    const float *sbr_qmf_window = div ? sbr_qmf_window_ds : sbr_qmf_window_us;
-    float *v;
-    for (i = 0; i < 32; i++) {
-        if (*v_off < 128 >> div) {
-            int saved_samples = (1280 - 128) >> div;
-            memcpy(&v0[SBR_SYNTHESIS_BUF_SIZE - saved_samples], v0, saved_samples * sizeof(float));
-            *v_off = SBR_SYNTHESIS_BUF_SIZE - saved_samples - (128 >> div);
-        } else {
-            *v_off -= 128 >> div;
-        }
-        v = v0 + *v_off;
-        if (div) {
-            for (n = 0; n < 32; n++) {
-                X[0][i][   n] = -X[0][i][n];
-                X[0][i][32+n] =  X[1][i][31-n];
-            }
-            mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);
-            for (n = 0; n < 32; n++) {
-                v[     n] =  mdct_buf[0][63 - 2*n];
-                v[63 - n] = -mdct_buf[0][62 - 2*n];
-            }
-        } else {
-            for (n = 1; n < 64; n+=2) {
-                X[1][i][n] = -X[1][i][n];
-            }
-            mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);
-            mdct->imdct_half(mdct, mdct_buf[1], X[1][i]);
-            for (n = 0; n < 64; n++) {
-                v[      n] = -mdct_buf[0][63 -   n] + mdct_buf[1][  n    ];
-                v[127 - n] =  mdct_buf[0][63 -   n] + mdct_buf[1][  n    ];
-            }
-        }
-        dsp->vector_fmul_add(out, v                , sbr_qmf_window               , zero64, 64 >> div);
-        dsp->vector_fmul_add(out, v + ( 192 >> div), sbr_qmf_window + ( 64 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + ( 256 >> div), sbr_qmf_window + (128 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + ( 448 >> div), sbr_qmf_window + (192 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + ( 512 >> div), sbr_qmf_window + (256 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + ( 704 >> div), sbr_qmf_window + (320 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + ( 768 >> div), sbr_qmf_window + (384 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + ( 960 >> div), sbr_qmf_window + (448 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + (1024 >> div), sbr_qmf_window + (512 >> div), out   , 64 >> div);
-        dsp->vector_fmul_add(out, v + (1216 >> div), sbr_qmf_window + (576 >> div), out   , 64 >> div);
-        out += 64 >> div;
-    }
-}
-
-static void autocorrelate(const float x[40][2], float phi[3][2][2], int lag)
-{
-    int i;
-    float real_sum = 0.0f;
-    float imag_sum = 0.0f;
-    if (lag) {
-        for (i = 1; i < 38; i++) {
-            real_sum += x[i][0] * x[i+lag][0] + x[i][1] * x[i+lag][1];
-            imag_sum += x[i][0] * x[i+lag][1] - x[i][1] * x[i+lag][0];
-        }
-        phi[2-lag][1][0] = real_sum + x[ 0][0] * x[lag][0] + x[ 0][1] * x[lag][1];
-        phi[2-lag][1][1] = imag_sum + x[ 0][0] * x[lag][1] - x[ 0][1] * x[lag][0];
-        if (lag == 1) {
-            phi[0][0][0] = real_sum + x[38][0] * x[39][0] + x[38][1] * x[39][1];
-            phi[0][0][1] = imag_sum + x[38][0] * x[39][1] - x[38][1] * x[39][0];
-        }
-    } else {
-        for (i = 1; i < 38; i++) {
-            real_sum += x[i][0] * x[i][0] + x[i][1] * x[i][1];
+                    sbr->data[ch].env_facs[e][k] = temp1;
+                }
+            for (e = 1; e <= sbr->data[ch].bs_num_noise; e++)
+                for (k = 0; k < sbr->n_q; k++){
+                    sbr->data[ch].noise_facs[e][k].expo = NOISE_FLOOR_OFFSET - sbr->data[ch].noise_facs[e][k].mant + 1;
+                    sbr->data[ch].noise_facs[e][k].mant = 0x20000000;
+                }
         }
-        phi[2][1][0] = real_sum + x[ 0][0] * x[ 0][0] + x[ 0][1] * x[ 0][1];
-        phi[1][0][0] = real_sum + x[38][0] * x[38][0] + x[38][1] * x[38][1];
     }
 }
 
@@ -1257,52 +173,125 @@
  * (14496-3 sp04 p214)
  * Warning: This routine does not seem numerically stable.
  */
-static void sbr_hf_inverse_filter(float (*alpha0)[2], float (*alpha1)[2],
-                                  const float X_low[32][40][2], int k0)
+static void sbr_hf_inverse_filter(SBRDSPContext *dsp,
+                                  int (*alpha0)[2], int (*alpha1)[2],
+                                  const int X_low[32][40][2], int k0)
 {
     int k;
-    for (k = 0; k < k0; k++) {
-        float phi[3][2][2], dk;
-
-        autocorrelate(X_low[k], phi, 0);
-        autocorrelate(X_low[k], phi, 1);
-        autocorrelate(X_low[k], phi, 2);
+    int shift, round;
+    int64_t accu;
 
-        dk =  phi[2][1][0] * phi[1][0][0] -
-             (phi[1][1][0] * phi[1][1][0] + phi[1][1][1] * phi[1][1][1]) / 1.000001f;
-
-        if (!dk) {
-            alpha1[k][0] = 0;
-            alpha1[k][1] = 0;
+    for (k = 0; k < k0; k++) {
+        aac_float_t phi[3][2][2];
+        aac_float_t a00, a01, a10, a11;
+        aac_float_t dk;
+
+        dsp->autocorrelate_q31(X_low[k], phi);
+
+        dk = float_sub(float_mul(phi[2][1][0], phi[1][0][0]),
+             float_mul(float_add(float_mul(phi[1][1][0], phi[1][1][0]), float_mul(phi[1][1][1], phi[1][1][1])), FLOAT_0999999));
+
+        if (!dk.mant) {
+            a10 = FLOAT_0;
+            a11 = FLOAT_0;
         } else {
-            float temp_real, temp_im;
-            temp_real = phi[0][0][0] * phi[1][1][0] -
-                        phi[0][0][1] * phi[1][1][1] -
-                        phi[0][1][0] * phi[1][0][0];
-            temp_im   = phi[0][0][0] * phi[1][1][1] +
-                        phi[0][0][1] * phi[1][1][0] -
-                        phi[0][1][1] * phi[1][0][0];
-
-            alpha1[k][0] = temp_real / dk;
-            alpha1[k][1] = temp_im   / dk;
+            aac_float_t temp_real, temp_im;
+            temp_real = float_sub(float_sub(float_mul(phi[0][0][0], phi[1][1][0]),
+                                            float_mul(phi[0][0][1], phi[1][1][1])),
+                                            float_mul(phi[0][1][0], phi[1][0][0]));
+            temp_im   = float_sub(float_add(float_mul(phi[0][0][0], phi[1][1][1]),
+                                            float_mul(phi[0][0][1], phi[1][1][0])),
+                                            float_mul(phi[0][1][1], phi[1][0][0]));
+
+            a10 = float_div(temp_real, dk);
+            a11 = float_div(temp_im,   dk);
         }
 
-        if (!phi[1][0][0]) {
+        if (!phi[1][0][0].mant) {
+            a00 = FLOAT_0;
+            a01 = FLOAT_0;
+        } else {
+            aac_float_t temp_real, temp_im;
+            temp_real = float_add(phi[0][0][0], float_add(float_mul(a10, phi[1][1][0]),
+                                                          float_mul(a11, phi[1][1][1])));
+            temp_im   = float_add(phi[0][0][1], float_sub(float_mul(a11, phi[1][1][0]),
+                                                          float_mul(a10, phi[1][1][1])));
+
+            temp_real.mant = -temp_real.mant;
+            temp_im.mant   = -temp_im.mant;
+            a00 = float_div(temp_real, phi[1][0][0]);
+            a01 = float_div(temp_im,   phi[1][0][0]);
+        }
+
+        shift = a00.expo;
+        if (shift >= 3)
+            alpha0[k][0] = 0x7fffffff;
+        else {
+            a00.mant <<= 1;
+            shift = 2-shift;
+            if (shift == 0)
+                alpha0[k][0] = a00.mant;
+            else {
+                round = 1 << (shift-1);
+                alpha0[k][0] = (a00.mant + round) >> shift;
+            }
+        }
+
+        shift = a01.expo;
+        if (shift >= 3)
+            alpha0[k][1] = 0x7fffffff;
+        else {
+            a01.mant <<= 1;
+            shift = 2-shift;
+            if (shift == 0)
+                alpha0[k][1] = a01.mant;
+            else {
+                round = 1 << (shift-1);
+                alpha0[k][1] = (a01.mant + round) >> shift;
+            }
+        }
+        shift = a10.expo;
+        if (shift >= 3)
+            alpha1[k][0] = 0x7fffffff;
+        else {
+            a10.mant <<= 1;
+            shift = 2-shift;
+            if (shift == 0)
+                alpha1[k][0] = a10.mant;
+            else {
+                round = 1 << (shift-1);
+                alpha1[k][0] = (a10.mant + round) >> shift;
+            }
+        }
+
+        shift = a11.expo;
+        if (shift >= 3)
+            alpha1[k][1] = 0x7fffffff;
+        else {
+            a11.mant <<= 1;
+            shift = 2-shift;
+            if (shift == 0)
+                alpha1[k][1] = a11.mant;
+            else {
+                round = 1 << (shift-1);
+                alpha1[k][1] = (a11.mant + round) >> shift;
+            }
+        }
+
+        accu  = (int64_t)(alpha1[k][0]>>1) * (alpha1[k][0]>>1);
+        accu += (int64_t)(alpha1[k][1]>>1) * (alpha1[k][1]>>1);
+        shift = (int)((accu + 0x40000000) >> 31);
+        if (shift >= (16<<25)){
+            alpha1[k][0] = 0;
+            alpha1[k][1] = 0;
             alpha0[k][0] = 0;
             alpha0[k][1] = 0;
-        } else {
-            float temp_real, temp_im;
-            temp_real = phi[0][0][0] + alpha1[k][0] * phi[1][1][0] +
-                                       alpha1[k][1] * phi[1][1][1];
-            temp_im   = phi[0][0][1] + alpha1[k][1] * phi[1][1][0] -
-                                       alpha1[k][0] * phi[1][1][1];
-
-            alpha0[k][0] = -temp_real / phi[1][0][0];
-            alpha0[k][1] = -temp_im   / phi[1][0][0];
         }
 
-        if (alpha1[k][0] * alpha1[k][0] + alpha1[k][1] * alpha1[k][1] >= 16.0f ||
-           alpha0[k][0] * alpha0[k][0] + alpha0[k][1] * alpha0[k][1] >= 16.0f) {
+        accu  = (int64_t)(alpha0[k][0]>>1) * (alpha0[k][0]>>1);
+        accu += (int64_t)(alpha0[k][1]>>1) * (alpha0[k][1]>>1);
+        shift = (int)((accu + 0x40000000) >> 31);
+        if (shift >= (16<<25)){
             alpha1[k][0] = 0;
             alpha1[k][1] = 0;
             alpha0[k][0] = 0;
@@ -1315,233 +304,26 @@
 static void sbr_chirp(SpectralBandReplication *sbr, SBRData *ch_data)
 {
     int i;
-    float new_bw;
-    static const float bw_tab[] = { 0.0f, 0.75f, 0.9f, 0.98f };
+    int new_bw;
+    static const int bw_tab[] = { 0, 1610612736, 1932735283, 2104533975 };
+    int64_t accu;
 
     for (i = 0; i < sbr->n_q; i++) {
-        if (ch_data->bs_invf_mode[0][i] + ch_data->bs_invf_mode[1][i] == 1) {
-            new_bw = 0.6f;
-        } else
+        if (ch_data->bs_invf_mode[0][i] + ch_data->bs_invf_mode[1][i] == 1)
+            new_bw = 1288490189;
+        else
             new_bw = bw_tab[ch_data->bs_invf_mode[0][i]];
 
-        if (new_bw < ch_data->bw_array[i]) {
-            new_bw = 0.75f    * new_bw + 0.25f    * ch_data->bw_array[i];
-        } else
-            new_bw = 0.90625f * new_bw + 0.09375f * ch_data->bw_array[i];
-        ch_data->bw_array[i] = new_bw < 0.015625f ? 0.0f : new_bw;
-    }
-}
-
-/// Generate the subband filtered lowband
-static int sbr_lf_gen(AACContext *ac, SpectralBandReplication *sbr,
-                      float X_low[32][40][2], const float W[2][32][32][2])
-{
-    int i, k;
-    const int t_HFGen = 8;
-    const int i_f = 32;
-    memset(X_low, 0, 32*sizeof(*X_low));
-    for (k = 0; k < sbr->kx[1]; k++) {
-        for (i = t_HFGen; i < i_f + t_HFGen; i++) {
-            X_low[k][i][0] = W[1][i - t_HFGen][k][0];
-            X_low[k][i][1] = W[1][i - t_HFGen][k][1];
-        }
-    }
-    for (k = 0; k < sbr->kx[0]; k++) {
-        for (i = 0; i < t_HFGen; i++) {
-            X_low[k][i][0] = W[0][i + i_f - t_HFGen][k][0];
-            X_low[k][i][1] = W[0][i + i_f - t_HFGen][k][1];
-        }
-    }
-    return 0;
-}
-
-/// High Frequency Generator (14496-3 sp04 p215)
-static int sbr_hf_gen(AACContext *ac, SpectralBandReplication *sbr,
-                      float X_high[64][40][2], const float X_low[32][40][2],
-                      const float (*alpha0)[2], const float (*alpha1)[2],
-                      const float bw_array[5], const uint8_t *t_env,
-                      int bs_num_env)
-{
-    int i, j, x;
-    int g = 0;
-    int k = sbr->kx[1];
-    for (j = 0; j < sbr->num_patches; j++) {
-        for (x = 0; x < sbr->patch_num_subbands[j]; x++, k++) {
-            float alpha[4];
-            const int p = sbr->patch_start_subband[j] + x;
-            while (g <= sbr->n_q && k >= sbr->f_tablenoise[g])
-                g++;
-            g--;
-
-            if (g < 0) {
-                av_log(ac->avctx, AV_LOG_ERROR,
-                       "ERROR : no subband found for frequency %d\n", k);
-                return -1;
-            }
-
-            alpha[0] = alpha1[p][0] * bw_array[g] * bw_array[g];
-            alpha[1] = alpha1[p][1] * bw_array[g] * bw_array[g];
-            alpha[2] = alpha0[p][0] * bw_array[g];
-            alpha[3] = alpha0[p][1] * bw_array[g];
-
-            for (i = 2 * t_env[0]; i < 2 * t_env[bs_num_env]; i++) {
-                const int idx = i + ENVELOPE_ADJUSTMENT_OFFSET;
-                X_high[k][idx][0] =
-                    X_low[p][idx - 2][0] * alpha[0] -
-                    X_low[p][idx - 2][1] * alpha[1] +
-                    X_low[p][idx - 1][0] * alpha[2] -
-                    X_low[p][idx - 1][1] * alpha[3] +
-                    X_low[p][idx][0];
-                X_high[k][idx][1] =
-                    X_low[p][idx - 2][1] * alpha[0] +
-                    X_low[p][idx - 2][0] * alpha[1] +
-                    X_low[p][idx - 1][1] * alpha[2] +
-                    X_low[p][idx - 1][0] * alpha[3] +
-                    X_low[p][idx][1];
-            }
-        }
-    }
-    if (k < sbr->m[1] + sbr->kx[1])
-        memset(X_high + k, 0, (sbr->m[1] + sbr->kx[1] - k) * sizeof(*X_high));
-
-    return 0;
-}
-
-/// Generate the subband filtered lowband
-static int sbr_x_gen(SpectralBandReplication *sbr, float X[2][38][64],
-                     const float X_low[32][40][2], const float Y[2][38][64][2],
-                     int ch)
-{
-    int k, i;
-    const int i_f = 32;
-    const int i_Temp = FFMAX(2*sbr->data[ch].t_env_num_env_old - i_f, 0);
-    memset(X, 0, 2*sizeof(*X));
-    for (k = 0; k < sbr->kx[0]; k++) {
-        for (i = 0; i < i_Temp; i++) {
-            X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];
-            X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];
-        }
-    }
-    for (; k < sbr->kx[0] + sbr->m[0]; k++) {
-        for (i = 0; i < i_Temp; i++) {
-            X[0][i][k] = Y[0][i + i_f][k][0];
-            X[1][i][k] = Y[0][i + i_f][k][1];
-        }
-    }
-
-    for (k = 0; k < sbr->kx[1]; k++) {
-        for (i = i_Temp; i < 38; i++) {
-            X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];
-            X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];
-        }
-    }
-    for (; k < sbr->kx[1] + sbr->m[1]; k++) {
-        for (i = i_Temp; i < i_f; i++) {
-            X[0][i][k] = Y[1][i][k][0];
-            X[1][i][k] = Y[1][i][k][1];
-        }
-    }
-    return 0;
-}
-
-/** High Frequency Adjustment (14496-3 sp04 p217) and Mapping
- * (14496-3 sp04 p217)
- */
-static void sbr_mapping(AACContext *ac, SpectralBandReplication *sbr,
-                        SBRData *ch_data, int e_a[2])
-{
-    int e, i, m;
-
-    memset(ch_data->s_indexmapped[1], 0, 7*sizeof(ch_data->s_indexmapped[1]));
-    for (e = 0; e < ch_data->bs_num_env; e++) {
-        const unsigned int ilim = sbr->n[ch_data->bs_freq_res[e + 1]];
-        uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;
-        int k;
-
-        av_assert0(sbr->kx[1] <= table[0]);
-        for (i = 0; i < ilim; i++)
-            for (m = table[i]; m < table[i + 1]; m++)
-                sbr->e_origmapped[e][m - sbr->kx[1]] = ch_data->env_facs[e+1][i];
-
-        // ch_data->bs_num_noise > 1 => 2 noise floors
-        k = (ch_data->bs_num_noise > 1) && (ch_data->t_env[e] >= ch_data->t_q[1]);
-        for (i = 0; i < sbr->n_q; i++)
-            for (m = sbr->f_tablenoise[i]; m < sbr->f_tablenoise[i + 1]; m++)
-                sbr->q_mapped[e][m - sbr->kx[1]] = ch_data->noise_facs[k+1][i];
-
-        for (i = 0; i < sbr->n[1]; i++) {
-            if (ch_data->bs_add_harmonic_flag) {
-                const unsigned int m_midpoint =
-                    (sbr->f_tablehigh[i] + sbr->f_tablehigh[i + 1]) >> 1;
-
-                ch_data->s_indexmapped[e + 1][m_midpoint - sbr->kx[1]] = ch_data->bs_add_harmonic[i] *
-                    (e >= e_a[1] || (ch_data->s_indexmapped[0][m_midpoint - sbr->kx[1]] == 1));
-            }
-        }
-
-        for (i = 0; i < ilim; i++) {
-            int additional_sinusoid_present = 0;
-            for (m = table[i]; m < table[i + 1]; m++) {
-                if (ch_data->s_indexmapped[e + 1][m - sbr->kx[1]]) {
-                    additional_sinusoid_present = 1;
-                    break;
-                }
-            }
-            memset(&sbr->s_mapped[e][table[i] - sbr->kx[1]], additional_sinusoid_present,
-                   (table[i + 1] - table[i]) * sizeof(sbr->s_mapped[e][0]));
-        }
-    }
-
-    memcpy(ch_data->s_indexmapped[0], ch_data->s_indexmapped[ch_data->bs_num_env], sizeof(ch_data->s_indexmapped[0]));
-}
-
-/// Estimation of current envelope (14496-3 sp04 p218)
-static void sbr_env_estimate(float (*e_curr)[48], float X_high[64][40][2],
-                             SpectralBandReplication *sbr, SBRData *ch_data)
-{
-    int e, i, m;
-
-    if (sbr->bs_interpol_freq) {
-        for (e = 0; e < ch_data->bs_num_env; e++) {
-            const float recip_env_size = 0.5f / (ch_data->t_env[e + 1] - ch_data->t_env[e]);
-            int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;
-            int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;
-
-            for (m = 0; m < sbr->m[1]; m++) {
-                float sum = 0.0f;
-
-                for (i = ilb; i < iub; i++) {
-                    sum += X_high[m + sbr->kx[1]][i][0] * X_high[m + sbr->kx[1]][i][0] +
-                           X_high[m + sbr->kx[1]][i][1] * X_high[m + sbr->kx[1]][i][1];
-                }
-                e_curr[e][m] = sum * recip_env_size;
-            }
-        }
-    } else {
-        int k, p;
-
-        for (e = 0; e < ch_data->bs_num_env; e++) {
-            const int env_size = 2 * (ch_data->t_env[e + 1] - ch_data->t_env[e]);
-            int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;
-            int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;
-            const uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;
-
-            for (p = 0; p < sbr->n[ch_data->bs_freq_res[e + 1]]; p++) {
-                float sum = 0.0f;
-                const int den = env_size * (table[p + 1] - table[p]);
-
-                for (k = table[p]; k < table[p + 1]; k++) {
-                    for (i = ilb; i < iub; i++) {
-                        sum += X_high[k][i][0] * X_high[k][i][0] +
-                               X_high[k][i][1] * X_high[k][i][1];
-                    }
-                }
-                sum /= den;
-                for (k = table[p]; k < table[p + 1]; k++) {
-                    e_curr[e][k - sbr->kx[1]] = sum;
-                }
-            }
+        if (new_bw < ch_data->bw_array[i]){
+            accu  = (int64_t)new_bw * 1610612736;
+            accu += (int64_t)ch_data->bw_array[i] * 0x20000000;
+            new_bw = (int)((accu + 0x40000000) >> 31);
+        } else {
+            accu  = (int64_t)new_bw * 1946157056;
+            accu += (int64_t)ch_data->bw_array[i] * 201326592;
+            new_bw = (int)((accu + 0x40000000) >> 31);
         }
+        ch_data->bw_array[i] = new_bw < 33554432 ? 0 : new_bw;
     }
 }
 
@@ -1554,58 +336,70 @@
 {
     int e, k, m;
     // max gain limits : -3dB, 0dB, 3dB, inf dB (limiter off)
-    static const float limgain[4] = { 0.70795, 1.0, 1.41254, 10000000000 };
+    static const aac_float_t limgain[4] = { { 760155524,  0 }, { 0x20000000,  1 }, { 758351638,  1 }, { 625000000, 34 } };
 
     for (e = 0; e < ch_data->bs_num_env; e++) {
         int delta = !((e == e_a[1]) || (e == e_a[0]));
         for (k = 0; k < sbr->n_lim; k++) {
-            float gain_boost, gain_max;
-            float sum[2] = { 0.0f, 0.0f };
+            aac_float_t gain_boost, gain_max;
+            aac_float_t sum[2] = { { 0, 0}, { 0, 0 } };
             for (m = sbr->f_tablelim[k] - sbr->kx[1]; m < sbr->f_tablelim[k + 1] - sbr->kx[1]; m++) {
-                const float temp = sbr->e_origmapped[e][m] / (1.0f + sbr->q_mapped[e][m]);
-                sbr->q_m[e][m] = sqrtf(temp * sbr->q_mapped[e][m]);
-                sbr->s_m[e][m] = sqrtf(temp * ch_data->s_indexmapped[e + 1][m]);
+                const aac_float_t temp = float_div(sbr->e_origmapped[e][m], float_add(FLOAT_1, sbr->q_mapped[e][m]));
+                sbr->q_m[e][m] = float_sqrt(float_mul(temp, sbr->q_mapped[e][m]));
+                sbr->s_m[e][m] = float_sqrt(float_mul(temp, int2float(ch_data->s_indexmapped[e + 1][m], 30)));
                 if (!sbr->s_mapped[e][m]) {
-                    sbr->gain[e][m] = sqrtf(sbr->e_origmapped[e][m] /
-                                            ((1.0f + sbr->e_curr[e][m]) *
-                                             (1.0f + sbr->q_mapped[e][m] * delta)));
+                    if (delta) {
+                      sbr->gain[e][m] = float_sqrt(float_div(sbr->e_origmapped[e][m],
+                                            float_mul(float_add(FLOAT_1, sbr->e_curr[e][m]),
+                                            float_add(FLOAT_1, sbr->q_mapped[e][m]))));
+                    } else {
+                      sbr->gain[e][m] = float_sqrt(float_div(sbr->e_origmapped[e][m],
+                                            float_add(FLOAT_1, sbr->e_curr[e][m])));
+                    }
                 } else {
-                    sbr->gain[e][m] = sqrtf(sbr->e_origmapped[e][m] * sbr->q_mapped[e][m] /
-                                            ((1.0f + sbr->e_curr[e][m]) *
-                                             (1.0f + sbr->q_mapped[e][m])));
+                    sbr->gain[e][m] = float_sqrt(float_div(float_mul(sbr->e_origmapped[e][m], sbr->q_mapped[e][m]),
+                                            float_mul(float_add(FLOAT_1, sbr->e_curr[e][m]),
+                                            float_add(FLOAT_1, sbr->q_mapped[e][m]))));
                 }
             }
             for (m = sbr->f_tablelim[k] - sbr->kx[1]; m < sbr->f_tablelim[k + 1] - sbr->kx[1]; m++) {
-                sum[0] += sbr->e_origmapped[e][m];
-                sum[1] += sbr->e_curr[e][m];
+                sum[0] = float_add(sum[0], sbr->e_origmapped[e][m]);
+                sum[1] = float_add(sum[1], sbr->e_curr[e][m]);
             }
-            gain_max = limgain[sbr->bs_limiter_gains] * sqrtf((FLT_EPSILON + sum[0]) / (FLT_EPSILON + sum[1]));
-            gain_max = FFMIN(100000.f, gain_max);
+            gain_max = float_mul(limgain[sbr->bs_limiter_gains], float_sqrt(float_div(float_add(FLOAT_EPSILON, sum[0]), float_add(FLOAT_EPSILON, sum[1]))));
+            if (float_gt(gain_max, FLOAT_100000))
+              gain_max = FLOAT_100000;
             for (m = sbr->f_tablelim[k] - sbr->kx[1]; m < sbr->f_tablelim[k + 1] - sbr->kx[1]; m++) {
-                float q_m_max   = sbr->q_m[e][m] * gain_max / sbr->gain[e][m];
-                sbr->q_m[e][m]  = FFMIN(sbr->q_m[e][m], q_m_max);
-                sbr->gain[e][m] = FFMIN(sbr->gain[e][m], gain_max);
+                aac_float_t q_m_max   = float_div(float_mul(sbr->q_m[e][m], gain_max), sbr->gain[e][m]);
+                if (float_gt(sbr->q_m[e][m], q_m_max))
+                  sbr->q_m[e][m] = q_m_max;
+                if (float_gt(sbr->gain[e][m], gain_max))
+                  sbr->gain[e][m] = gain_max;
             }
-            sum[0] = sum[1] = 0.0f;
+            sum[0] = sum[1] = FLOAT_0;
             for (m = sbr->f_tablelim[k] - sbr->kx[1]; m < sbr->f_tablelim[k + 1] - sbr->kx[1]; m++) {
-                sum[0] += sbr->e_origmapped[e][m];
-                sum[1] += sbr->e_curr[e][m] * sbr->gain[e][m] * sbr->gain[e][m]
-                          + sbr->s_m[e][m] * sbr->s_m[e][m]
-                          + (delta && !sbr->s_m[e][m]) * sbr->q_m[e][m] * sbr->q_m[e][m];
-            }
-            gain_boost = sqrtf((FLT_EPSILON + sum[0]) / (FLT_EPSILON + sum[1]));
-            gain_boost = FFMIN(1.584893192f, gain_boost);
+                sum[0] = float_add(sum[0], sbr->e_origmapped[e][m]);
+                sum[1] = float_add(sum[1], float_mul(float_mul(sbr->e_curr[e][m], sbr->gain[e][m]), sbr->gain[e][m]));
+                sum[1] = float_add(sum[1], float_mul(sbr->s_m[e][m], sbr->s_m[e][m]));
+                if (delta && !sbr->s_m[e][m].mant)
+                  sum[1] = float_add(sum[1], float_mul(sbr->q_m[e][m], sbr->q_m[e][m]));
+            }
+            gain_boost = float_sqrt(float_div(float_add(FLOAT_EPSILON, sum[0]), float_add(FLOAT_EPSILON, sum[1])));
+            if (float_gt(gain_boost, FLOAT_1584893192))
+              gain_boost = FLOAT_1584893192;
+
             for (m = sbr->f_tablelim[k] - sbr->kx[1]; m < sbr->f_tablelim[k + 1] - sbr->kx[1]; m++) {
-                sbr->gain[e][m] *= gain_boost;
-                sbr->q_m[e][m]  *= gain_boost;
-                sbr->s_m[e][m]  *= gain_boost;
+                sbr->gain[e][m] = float_mul(sbr->gain[e][m], gain_boost);
+                sbr->q_m[e][m]  = float_mul(sbr->q_m[e][m], gain_boost);
+                sbr->s_m[e][m]  = float_mul(sbr->s_m[e][m], gain_boost);
             }
         }
     }
 }
 
 /// Assembling HF Signals (14496-3 sp04 p220)
-static void sbr_hf_assemble(float Y[2][38][64][2], const float X_high[64][40][2],
+static void sbr_hf_assemble(int Y1[38][64][2],
+                            const int X_high[64][40][2],
                             SpectralBandReplication *sbr, SBRData *ch_data,
                             const int e_a[2])
 {
@@ -1613,21 +407,16 @@
     const int h_SL = 4 * !sbr->bs_smoothing_mode;
     const int kx = sbr->kx[1];
     const int m_max = sbr->m[1];
-    static const float h_smooth[5] = {
-        0.33333333333333,
-        0.30150283239582,
-        0.21816949906249,
-        0.11516383427084,
-        0.03183050093751,
+    static const aac_float_t h_smooth[5] = {
+      { 715827883, -1 },
+      { 647472402, -1 },
+      { 937030863, -2 },
+      { 989249804, -3 },
+      { 546843842, -4 },
     };
-    static const int8_t phi[2][4] = {
-        {  1,  0, -1,  0}, // real
-        {  0,  1,  0, -1}, // imaginary
-    };
-    float (*g_temp)[48] = ch_data->g_temp, (*q_temp)[48] = ch_data->q_temp;
+    aac_float_t (*g_temp)[48] = ch_data->g_temp, (*q_temp)[48] = ch_data->q_temp;
     int indexnoise = ch_data->f_indexnoise;
     int indexsine  = ch_data->f_indexsine;
-    memcpy(Y[0], Y[1], sizeof(Y[0]));
 
     if (sbr->reset) {
         for (i = 0; i < h_SL; i++) {
@@ -1648,64 +437,60 @@
 
     for (e = 0; e < ch_data->bs_num_env; e++) {
         for (i = 2 * ch_data->t_env[e]; i < 2 * ch_data->t_env[e + 1]; i++) {
-            int phi_sign = (1 - 2*(kx & 1));
+            aac_float_t g_filt_tab[48];
+            aac_float_t q_filt_tab[48];
+            aac_float_t *g_filt, *q_filt;
 
             if (h_SL && e != e_a[0] && e != e_a[1]) {
+                g_filt = g_filt_tab;
+                q_filt = q_filt_tab;
                 for (m = 0; m < m_max; m++) {
                     const int idx1 = i + h_SL;
-                    float g_filt = 0.0f;
-                    for (j = 0; j <= h_SL; j++)
-                        g_filt += g_temp[idx1 - j][m] * h_smooth[j];
-                    Y[1][i][m + kx][0] =
-                        X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][0] * g_filt;
-                    Y[1][i][m + kx][1] =
-                        X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][1] * g_filt;
+                    g_filt[m].mant = g_filt[m].expo = 0;
+                    q_filt[m].mant = q_filt[m].expo = 0;
+                    for (j = 0; j <= h_SL; j++) {
+                        g_filt[m] = float_add(g_filt[m], float_mul(g_temp[idx1 - j][m], h_smooth[j]));
+                        q_filt[m] = float_add(q_filt[m], float_mul(q_temp[idx1 - j][m], h_smooth[j]));
+                    }
                 }
             } else {
-                for (m = 0; m < m_max; m++) {
-                    const float g_filt = g_temp[i + h_SL][m];
-                    Y[1][i][m + kx][0] =
-                        X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][0] * g_filt;
-                    Y[1][i][m + kx][1] =
-                        X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][1] * g_filt;
-                }
+                g_filt = g_temp[i + h_SL];
+                q_filt = q_temp[i];
             }
 
+            sbr->dsp.hf_g_filt_int(Y1[i] + kx, X_high + kx, g_filt, m_max,
+                               i + ENVELOPE_ADJUSTMENT_OFFSET);
+
             if (e != e_a[0] && e != e_a[1]) {
-                for (m = 0; m < m_max; m++) {
-                    indexnoise = (indexnoise + 1) & 0x1ff;
-                    if (sbr->s_m[e][m]) {
-                        Y[1][i][m + kx][0] +=
-                            sbr->s_m[e][m] * phi[0][indexsine];
-                        Y[1][i][m + kx][1] +=
-                            sbr->s_m[e][m] * (phi[1][indexsine] * phi_sign);
-                    } else {
-                        float q_filt;
-                        if (h_SL) {
-                            const int idx1 = i + h_SL;
-                            q_filt = 0.0f;
-                            for (j = 0; j <= h_SL; j++)
-                                q_filt += q_temp[idx1 - j][m] * h_smooth[j];
-                        } else {
-                            q_filt = q_temp[i][m];
-                        }
-                        Y[1][i][m + kx][0] +=
-                            q_filt * sbr_noise_table[indexnoise][0];
-                        Y[1][i][m + kx][1] +=
-                            q_filt * sbr_noise_table[indexnoise][1];
-                    }
-                    phi_sign = -phi_sign;
-                }
+                sbr->dsp.hf_apply_noise_int[indexsine](Y1[i] + kx, sbr->s_m[e],
+                                                   q_filt, indexnoise,
+                                                   kx, m_max);
             } else {
-                indexnoise = (indexnoise + m_max) & 0x1ff;
-                for (m = 0; m < m_max; m++) {
-                    Y[1][i][m + kx][0] +=
-                        sbr->s_m[e][m] * phi[0][indexsine];
-                    Y[1][i][m + kx][1] +=
-                        sbr->s_m[e][m] * (phi[1][indexsine] * phi_sign);
-                    phi_sign = -phi_sign;
+                int idx = indexsine&1;
+                int A = (1-((indexsine+(kx & 1))&2));
+                int B = (A^(-idx)) + idx;
+                int *out = &Y1[i][kx][idx];
+                int shift, round;
+
+                aac_float_t *in  = sbr->s_m[e];
+                for (m = 0; m+1 < m_max; m+=2) {
+                  shift = 22 - in[m  ].expo;
+                  round = 1 << (shift-1);
+                  out[2*m  ] += (in[m  ].mant * A + round) >> shift;
+
+                  shift = 22 - in[m+1].expo;
+                  round = 1 << (shift-1);
+                  out[2*m+2] += (in[m+1].mant * B + round) >> shift;
+                }
+                if(m_max&1)
+                {
+                  shift = 22 - in[m  ].expo;
+                  round = 1 << (shift-1);
+
+                  out[2*m  ] += (in[m  ].mant * A + round) >> shift;
                 }
             }
+            indexnoise = (indexnoise + m_max) & 0x1ff;
             indexsine = (indexsine + 1) & 3;
         }
     }
@@ -1713,57 +498,1508 @@
     ch_data->f_indexsine  = indexsine;
 }
 
-void ff_sbr_apply(AACContext *ac, SpectralBandReplication *sbr, int id_aac,
-                  float* L, float* R)
-{
-    int downsampled = ac->m4ac.ext_sample_rate < sbr->sample_rate;
-    int ch;
-    int nch = (id_aac == TYPE_CPE) ? 2 : 1;
-
-    if (sbr->start) {
-        sbr_dequant(sbr, id_aac);
-    }
-    for (ch = 0; ch < nch; ch++) {
-        /* decode channel */
-        sbr_qmf_analysis(&ac->dsp, &sbr->mdct_ana, ch ? R : L, sbr->data[ch].analysis_filterbank_samples,
-                         (float*)sbr->qmf_filter_scratch,
-                         sbr->data[ch].W);
-        sbr_lf_gen(ac, sbr, sbr->X_low, sbr->data[ch].W);
-        if (sbr->start) {
-            sbr_hf_inverse_filter(sbr->alpha0, sbr->alpha1, sbr->X_low, sbr->k[0]);
-            sbr_chirp(sbr, &sbr->data[ch]);
-            sbr_hf_gen(ac, sbr, sbr->X_high, sbr->X_low, sbr->alpha0, sbr->alpha1,
-                       sbr->data[ch].bw_array, sbr->data[ch].t_env,
-                       sbr->data[ch].bs_num_env);
-
-            // hf_adj
-            sbr_mapping(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);
-            sbr_env_estimate(sbr->e_curr, sbr->X_high, sbr, &sbr->data[ch]);
-            sbr_gain_calc(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);
-            sbr_hf_assemble(sbr->data[ch].Y, sbr->X_high, sbr, &sbr->data[ch],
-                            sbr->data[ch].e_a);
-        }
-
-        /* synthesis */
-        sbr_x_gen(sbr, sbr->X[ch], sbr->X_low, sbr->data[ch].Y, ch);
-    }
 
-    if (ac->m4ac.ps == 1) {
-        if (sbr->ps.start) {
-            ff_ps_apply(ac->avctx, &sbr->ps, sbr->X[0], sbr->X[1], sbr->kx[1] + sbr->m[1]);
-        } else {
-            memcpy(sbr->X[1], sbr->X[0], sizeof(sbr->X[0]));
+static void aacsbr_func_ptr_init(AACSBRContext *c);                                                                                                                  
+// Places SBR in pure upsampling mode.                                                                                                                      
+static void sbr_turnoff(SpectralBandReplication *sbr)                                                                                                       
+{                                                                                                                                                           
+    sbr->start = 0;                                                                                                                                         
+    // Init defults used in pure upsampling mode                                                                                                            
+    sbr->kx[1] = 32; //Typo in spec, kx' inits to 32                                                                                                        
+    sbr->m[1] = 0;                                                                                                                                          
+    // Reset values for first SBR header                                                                                                                    
+    sbr->data[0].e_a[1] = sbr->data[1].e_a[1] = -1;                                                                                                         
+    memset(&sbr->spectrum_params, -1, sizeof(SpectrumParameters));                                                                                          
+}                                                                                                                                                           
+                                                                                                                                                            
+static int qsort_comparison_function_int16(const void *a, const void *b)                                                                                    
+{                                                                                                                                                           
+    return *(const int16_t *)a - *(const int16_t *)b;                                                                                                       
+}                                                                                                                                                           
+                                                                                                                                                            
+static inline int in_table_int16(const int16_t *table, int last_el, int16_t needle)                                                                         
+{                                                                                                                                                           
+    int i;                                                                                                                                                  
+    for (i = 0; i <= last_el; i++)                                                                                                                          
+        if (table[i] == needle)                                                                                                                             
+            return 1;                                                                                                                                       
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Limiter Frequency Band Table (14496-3 sp04 p198)                                                                                                        
+static void sbr_make_f_tablelim(SpectralBandReplication *sbr)                                                                                               
+{                                                                                                                                                           
+    int k;                                                                                                                                                  
+    if (sbr->bs_limiter_bands > 0) {                                                                                                                        
+        static const INTFLOAT bands_warped[3] = { Q23(1.32715174233856803909f),   //2^(0.49/1.2)                                                            
+                                               Q23(1.18509277094158210129f),   //2^(0.49/2)                                                                 
+                                               Q23(1.11987160404675912501f) }; //2^(0.49/3)                                                                 
+        const INTFLOAT lim_bands_per_octave_warped = bands_warped[sbr->bs_limiter_bands - 1];                                                               
+        int16_t patch_borders[7];                                                                                                                           
+        uint16_t *in = sbr->f_tablelim + 1, *out = sbr->f_tablelim;                                                                                         
+                                                                                                                                                            
+        patch_borders[0] = sbr->kx[1];                                                                                                                      
+        for (k = 1; k <= sbr->num_patches; k++)                                                                                                             
+            patch_borders[k] = patch_borders[k-1] + sbr->patch_num_subbands[k-1];                                                                           
+                                                                                                                                                            
+        memcpy(sbr->f_tablelim, sbr->f_tablelow,                                                                                                            
+               (sbr->n[0] + 1) * sizeof(sbr->f_tablelow[0]));                                                                                               
+        if (sbr->num_patches > 1)                                                                                                                           
+            memcpy(sbr->f_tablelim + sbr->n[0] + 1, patch_borders + 1,                                                                                      
+                   (sbr->num_patches - 1) * sizeof(patch_borders[0]));                                                                                      
+                                                                                                                                                            
+        qsort(sbr->f_tablelim, sbr->num_patches + sbr->n[0],                                                                                                
+              sizeof(sbr->f_tablelim[0]),                                                                                                                   
+              qsort_comparison_function_int16);                                                                                                             
+                                                                                                                                                            
+        sbr->n_lim = sbr->n[0] + sbr->num_patches - 1;                                                                                                      
+        while (out < sbr->f_tablelim + sbr->n_lim) {                                                                                                        
+#if CONFIG_AAC_FIXED                                                                                                                                        
+            if ((*in << 23) >= *out * lim_bands_per_octave_warped) {                                                                                        
+#else                                                                                                                                                       
+            if (*in >= *out * lim_bands_per_octave_warped) {                                                                                                
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                *++out = *in++;                                                                                                                             
+            } else if (*in == *out ||                                                                                                                       
+                !in_table_int16(patch_borders, sbr->num_patches, *in)) {                                                                                    
+                in++;                                                                                                                                       
+                sbr->n_lim--;                                                                                                                               
+            } else if (!in_table_int16(patch_borders, sbr->num_patches, *out)) {                                                                            
+                *out = *in++;                                                                                                                               
+                sbr->n_lim--;                                                                                                                               
+            } else {                                                                                                                                        
+                *++out = *in++;                                                                                                                             
+            }                                                                                                                                               
+        }                                                                                                                                                   
+    } else {                                                                                                                                                
+        sbr->f_tablelim[0] = sbr->f_tablelow[0];                                                                                                            
+        sbr->f_tablelim[1] = sbr->f_tablelow[sbr->n[0]];                                                                                                    
+        sbr->n_lim = 1;                                                                                                                                     
+    }                                                                                                                                                       
+}                                                                                                                                                           
+                                                                                                                                                            
+static unsigned int read_sbr_header(SpectralBandReplication *sbr, GetBitContext *gb)                                                                        
+{                                                                                                                                                           
+    unsigned int cnt = get_bits_count(gb);                                                                                                                  
+    uint8_t bs_header_extra_1;                                                                                                                              
+    uint8_t bs_header_extra_2;                                                                                                                              
+    int old_bs_limiter_bands = sbr->bs_limiter_bands;                                                                                                       
+    SpectrumParameters old_spectrum_params;                                                                                                                 
+                                                                                                                                                            
+    sbr->start = 1;                                                                                                                                         
+                                                                                                                                                            
+    // Save last spectrum parameters variables to compare to new ones                                                                                       
+    memcpy(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters));                                                                        
+                                                                                                                                                            
+    sbr->bs_amp_res_header              = get_bits1(gb);                                                                                                    
+    sbr->spectrum_params.bs_start_freq  = get_bits(gb, 4);                                                                                                  
+    sbr->spectrum_params.bs_stop_freq   = get_bits(gb, 4);                                                                                                  
+    sbr->spectrum_params.bs_xover_band  = get_bits(gb, 3);                                                                                                  
+                                          skip_bits(gb, 2); // bs_reserved                                                                                  
+                                                                                                                                                            
+    bs_header_extra_1 = get_bits1(gb);                                                                                                                      
+    bs_header_extra_2 = get_bits1(gb);                                                                                                                      
+                                                                                                                                                            
+    if (bs_header_extra_1) {                                                                                                                                
+        sbr->spectrum_params.bs_freq_scale  = get_bits(gb, 2);                                                                                              
+        sbr->spectrum_params.bs_alter_scale = get_bits1(gb);                                                                                                
+        sbr->spectrum_params.bs_noise_bands = get_bits(gb, 2);                                                                                              
+    } else {                                                                                                                                                
+        sbr->spectrum_params.bs_freq_scale  = 2;                                                                                                            
+        sbr->spectrum_params.bs_alter_scale = 1;                                                                                                            
+        sbr->spectrum_params.bs_noise_bands = 2;                                                                                                            
+    }                                                                                                                                                       
+                                                                                                                                                            
+    // Check if spectrum parameters changed                                                                                                                 
+    if (memcmp(&old_spectrum_params, &sbr->spectrum_params, sizeof(SpectrumParameters)))                                                                    
+        sbr->reset = 1;                                                                                                                                     
+                                                                                                                                                            
+    if (bs_header_extra_2) {                                                                                                                                
+        sbr->bs_limiter_bands  = get_bits(gb, 2);                                                                                                           
+        sbr->bs_limiter_gains  = get_bits(gb, 2);                                                                                                           
+        sbr->bs_interpol_freq  = get_bits1(gb);                                                                                                             
+        sbr->bs_smoothing_mode = get_bits1(gb);                                                                                                             
+    } else {                                                                                                                                                
+        sbr->bs_limiter_bands  = 2;                                                                                                                         
+        sbr->bs_limiter_gains  = 2;                                                                                                                         
+        sbr->bs_interpol_freq  = 1;                                                                                                                         
+        sbr->bs_smoothing_mode = 1;                                                                                                                         
+    }                                                                                                                                                       
+                                                                                                                                                            
+    if (sbr->bs_limiter_bands != old_bs_limiter_bands && !sbr->reset)                                                                                       
+        sbr_make_f_tablelim(sbr);                                                                                                                           
+                                                                                                                                                            
+    return get_bits_count(gb) - cnt;                                                                                                                        
+}                                                                                                                                                           
+                                                                                                                                                            
+static int array_min_int16(const int16_t *array, int nel)                                                                                                   
+{                                                                                                                                                           
+    int i, min = array[0];                                                                                                                                  
+    for (i = 1; i < nel; i++)                                                                                                                               
+        min = FFMIN(array[i], min);                                                                                                                         
+    return min;                                                                                                                                             
+}                                                                                                                                                           
+                                                                                                                                                            
+static int check_n_master(AVCodecContext *avctx, int n_master, int bs_xover_band)                                                                           
+{                                                                                                                                                           
+    // Requirements (14496-3 sp04 p205)                                                                                                                     
+    if (n_master <= 0) {                                                                                                                                    
+        av_log(avctx, AV_LOG_ERROR, "Invalid n_master: %d\n", n_master);                                                                                    
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+    if (bs_xover_band >= n_master) {                                                                                                                        
+        av_log(avctx, AV_LOG_ERROR,                                                                                                                         
+               "Invalid bitstream, crossover band index beyond array bounds: %d\n",                                                                         
+               bs_xover_band);                                                                                                                              
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Master Frequency Band Table (14496-3 sp04 p194)                                                                                                         
+static int sbr_make_f_master(AACContext *ac, SpectralBandReplication *sbr,                                                                                  
+                             SpectrumParameters *spectrum)                                                                                                  
+{                                                                                                                                                           
+    unsigned int temp, max_qmf_subbands;                                                                                                                    
+    unsigned int start_min, stop_min;                                                                                                                       
+    int k;                                                                                                                                                  
+    const int8_t *sbr_offset_ptr;                                                                                                                           
+    int16_t stop_dk[13];                                                                                                                                    
+                                                                                                                                                            
+    if (sbr->sample_rate < 32000) {                                                                                                                         
+        temp = 3000;                                                                                                                                        
+    } else if (sbr->sample_rate < 64000) {                                                                                                                  
+        temp = 4000;                                                                                                                                        
+    } else                                                                                                                                                  
+        temp = 5000;                                                                                                                                        
+                                                                                                                                                            
+    switch (sbr->sample_rate) {                                                                                                                             
+    case 16000:                                                                                                                                             
+        sbr_offset_ptr = sbr_offset[0];                                                                                                                     
+        break;                                                                                                                                              
+    case 22050:                                                                                                                                             
+        sbr_offset_ptr = sbr_offset[1];                                                                                                                     
+        break;                                                                                                                                              
+    case 24000:                                                                                                                                             
+        sbr_offset_ptr = sbr_offset[2];                                                                                                                     
+        break;                                                                                                                                              
+    case 32000:                                                                                                                                             
+        sbr_offset_ptr = sbr_offset[3];                                                                                                                     
+        break;                                                                                                                                              
+    case 44100: case 48000: case 64000:                                                                                                                     
+        sbr_offset_ptr = sbr_offset[4];                                                                                                                     
+        break;                                                                                                                                              
+    case 88200: case 96000: case 128000: case 176400: case 192000:                                                                                          
+        sbr_offset_ptr = sbr_offset[5];                                                                                                                     
+        break;                                                                                                                                              
+    default:                                                                                                                                                
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+               "Unsupported sample rate for SBR: %d\n", sbr->sample_rate);                                                                                  
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+    start_min = ((temp << 7) + (sbr->sample_rate >> 1)) / sbr->sample_rate;                                                                                 
+    stop_min  = ((temp << 8) + (sbr->sample_rate >> 1)) / sbr->sample_rate;                                                                                 
+                                                                                                                                                            
+    sbr->k[0] = start_min + sbr_offset_ptr[spectrum->bs_start_freq];                                                                                        
+                                                                                                                                                            
+    if (spectrum->bs_stop_freq < 14) {                                                                                                                      
+        sbr->k[2] = stop_min;                                                                                                                               
+        make_bands(stop_dk, stop_min, 64, 13);                                                                                                              
+        qsort(stop_dk, 13, sizeof(stop_dk[0]), qsort_comparison_function_int16);                                                                            
+        for (k = 0; k < spectrum->bs_stop_freq; k++)                                                                                                        
+            sbr->k[2] += stop_dk[k];                                                                                                                        
+    } else if (spectrum->bs_stop_freq == 14) {                                                                                                              
+        sbr->k[2] = 2*sbr->k[0];                                                                                                                            
+    } else if (spectrum->bs_stop_freq == 15) {                                                                                                              
+        sbr->k[2] = 3*sbr->k[0];                                                                                                                            
+    } else {                                                                                                                                                
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+               "Invalid bs_stop_freq: %d\n", spectrum->bs_stop_freq);                                                                                       
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+    sbr->k[2] = FFMIN(64, sbr->k[2]);                                                                                                                       
+                                                                                                                                                            
+    // Requirements (14496-3 sp04 p205)                                                                                                                     
+    if (sbr->sample_rate <= 32000) {                                                                                                                        
+        max_qmf_subbands = 48;                                                                                                                              
+    } else if (sbr->sample_rate == 44100) {                                                                                                                 
+        max_qmf_subbands = 35;                                                                                                                              
+    } else if (sbr->sample_rate >= 48000)                                                                                                                   
+        max_qmf_subbands = 32;                                                                                                                              
+    else                                                                                                                                                    
+        av_assert0(0);                                                                                                                                      
+                                                                                                                                                            
+    if (sbr->k[2] - sbr->k[0] > max_qmf_subbands) {                                                                                                         
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+               "Invalid bitstream, too many QMF subbands: %d\n", sbr->k[2] - sbr->k[0]);                                                                    
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+    if (!spectrum->bs_freq_scale) {                                                                                                                         
+        int dk, k2diff;                                                                                                                                     
+                                                                                                                                                            
+        dk = spectrum->bs_alter_scale + 1;                                                                                                                  
+        sbr->n_master = ((sbr->k[2] - sbr->k[0] + (dk&2)) >> dk) << 1;                                                                                      
+        if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))                                                                   
+            return -1;                                                                                                                                      
+                                                                                                                                                            
+        for (k = 1; k <= sbr->n_master; k++)                                                                                                                
+            sbr->f_master[k] = dk;                                                                                                                          
+                                                                                                                                                            
+        k2diff = sbr->k[2] - sbr->k[0] - sbr->n_master * dk;                                                                                                
+        if (k2diff < 0) {                                                                                                                                   
+            sbr->f_master[1]--;                                                                                                                             
+            sbr->f_master[2]-= (k2diff < -1);                                                                                                               
+        } else if (k2diff) {                                                                                                                                
+            sbr->f_master[sbr->n_master]++;                                                                                                                 
+        }                                                                                                                                                   
+                                                                                                                                                            
+        sbr->f_master[0] = sbr->k[0];                                                                                                                       
+        for (k = 1; k <= sbr->n_master; k++)                                                                                                                
+            sbr->f_master[k] += sbr->f_master[k - 1];                                                                                                       
+                                                                                                                                                            
+    } else {                                                                                                                                                
+        int half_bands = 7 - spectrum->bs_freq_scale;      // bs_freq_scale  = {1,2,3}                                                                      
+        int two_regions, num_bands_0;                                                                                                                       
+        int vdk0_max, vdk1_min;                                                                                                                             
+        int16_t vk0[49];                                                                                                                                    
+#if CONFIG_AAC_FIXED                                                                                                                                        
+        int tmp, nz = 0;                                                                                                                                    
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                                                                                                                                                            
+        if (49 * sbr->k[2] > 110 * sbr->k[0]) {                                                                                                             
+            two_regions = 1;                                                                                                                                
+            sbr->k[1] = 2 * sbr->k[0];                                                                                                                      
+        } else {                                                                                                                                            
+            two_regions = 0;                                                                                                                                
+            sbr->k[1] = sbr->k[2];                                                                                                                          
+        }                                                                                                                                                   
+                                                                                                                                                            
+#if CONFIG_AAC_FIXED                                                                                                                                        
+        tmp = (sbr->k[1] << 23) / sbr->k[0];                                                                                                                
+        while (tmp < 0x40000000) {                                                                                                                          
+          tmp <<= 1;                                                                                                                                        
+          nz++;                                                                                                                                             
+        }                                                                                                                                                   
+        tmp = fixed_log(tmp - 0x80000000);                                                                                                                  
+        tmp = (int)(((int64_t)tmp * CONST_RECIP_LN2 + 0x20000000) >> 30);                                                                                   
+        tmp = (((tmp + 128) >> 8) + ((8 - nz) << 23)) * half_bands;                                                                                         
+        num_bands_0 = ((tmp + 0x400000) >> 23) * 2;                                                                                                         
+#else                                                                                                                                                       
+        num_bands_0 = lrintf(half_bands * log2f(sbr->k[1] / (float)sbr->k[0])) * 2;                                                                         
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                                                                                                                                                            
+        if (num_bands_0 <= 0) { // Requirements (14496-3 sp04 p205)                                                                                         
+            av_log(ac->avctx, AV_LOG_ERROR, "Invalid num_bands_0: %d\n", num_bands_0);                                                                      
+            return -1;                                                                                                                                      
+        }                                                                                                                                                   
+                                                                                                                                                            
+        vk0[0] = 0;                                                                                                                                         
+                                                                                                                                                            
+        make_bands(vk0+1, sbr->k[0], sbr->k[1], num_bands_0);                                                                                               
+                                                                                                                                                            
+        qsort(vk0 + 1, num_bands_0, sizeof(vk0[1]), qsort_comparison_function_int16);                                                                       
+        vdk0_max = vk0[num_bands_0];                                                                                                                        
+                                                                                                                                                            
+        vk0[0] = sbr->k[0];                                                                                                                                 
+        for (k = 1; k <= num_bands_0; k++) {                                                                                                                
+            if (vk0[k] <= 0) { // Requirements (14496-3 sp04 p205)                                                                                          
+                av_log(ac->avctx, AV_LOG_ERROR, "Invalid vDk0[%d]: %d\n", k, vk0[k]);                                                                       
+                return -1;                                                                                                                                  
+            }                                                                                                                                               
+            vk0[k] += vk0[k-1];                                                                                                                             
+        }                                                                                                                                                   
+                                                                                                                                                            
+        if (two_regions) {                                                                                                                                  
+            int16_t vk1[49];                                                                                                                                
+#if CONFIG_AAC_FIXED                                                                                                                                        
+            int num_bands_1;                                                                                                                                
+                                                                                                                                                            
+            tmp = (sbr->k[2] << 23) / sbr->k[1];                                                                                                            
+            nz = 0;                                                                                                                                         
+            while (tmp < 0x40000000) {                                                                                                                      
+              tmp <<= 1;                                                                                                                                    
+              nz++;                                                                                                                                         
+            }                                                                                                                                               
+            tmp = fixed_log(tmp - 0x80000000);                                                                                                              
+            tmp = (int)(((int64_t)tmp * CONST_RECIP_LN2 + 0x20000000) >> 30);                                                                               
+            tmp = (((tmp + 128) >> 8) + ((8 - nz) << 23)) * half_bands;                                                                                     
+            if (spectrum->bs_alter_scale)                                                                                                                   
+                tmp = (int)(((int64_t)tmp * CONST_076923 + 0x40000000) >> 31);                                                                              
+            num_bands_1 = ((tmp + 0x400000) >> 23) * 2;                                                                                                     
+#else                                                                                                                                                       
+            float invwarp = spectrum->bs_alter_scale ? 0.76923076923076923077f                                                                              
+                                                     : 1.0f; // bs_alter_scale = {0,1}                                                                      
+            int num_bands_1 = lrintf(half_bands * invwarp *                                                                                                 
+                                     log2f(sbr->k[2] / (float)sbr->k[1])) * 2;                                                                              
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+            make_bands(vk1+1, sbr->k[1], sbr->k[2], num_bands_1);                                                                                           
+                                                                                                                                                            
+            vdk1_min = array_min_int16(vk1 + 1, num_bands_1);                                                                                               
+                                                                                                                                                            
+            if (vdk1_min < vdk0_max) {                                                                                                                      
+                int change;                                                                                                                                 
+                qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);                                                               
+                change = FFMIN(vdk0_max - vk1[1], (vk1[num_bands_1] - vk1[1]) >> 1);                                                                        
+                vk1[1]           += change;                                                                                                                 
+                vk1[num_bands_1] -= change;                                                                                                                 
+            }                                                                                                                                               
+                                                                                                                                                            
+            qsort(vk1 + 1, num_bands_1, sizeof(vk1[1]), qsort_comparison_function_int16);                                                                   
+                                                                                                                                                            
+            vk1[0] = sbr->k[1];                                                                                                                             
+            for (k = 1; k <= num_bands_1; k++) {                                                                                                            
+                if (vk1[k] <= 0) { // Requirements (14496-3 sp04 p205)                                                                                      
+                    av_log(ac->avctx, AV_LOG_ERROR, "Invalid vDk1[%d]: %d\n", k, vk1[k]);                                                                   
+                    return -1;                                                                                                                              
+                }                                                                                                                                           
+                vk1[k] += vk1[k-1];                                                                                                                         
+            }                                                                                                                                               
+                                                                                                                                                            
+            sbr->n_master = num_bands_0 + num_bands_1;                                                                                                      
+            if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))                                                               
+                return -1;                                                                                                                                  
+            memcpy(&sbr->f_master[0],               vk0,                                                                                                    
+                   (num_bands_0 + 1) * sizeof(sbr->f_master[0]));                                                                                           
+            memcpy(&sbr->f_master[num_bands_0 + 1], vk1 + 1,                                                                                                
+                    num_bands_1      * sizeof(sbr->f_master[0]));                                                                                           
+                                                                                                                                                            
+        } else {                                                                                                                                            
+            sbr->n_master = num_bands_0;                                                                                                                    
+            if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))                                                               
+                return -1;                                                                                                                                  
+            memcpy(sbr->f_master, vk0, (num_bands_0 + 1) * sizeof(sbr->f_master[0]));                                                                       
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+                                                                                                                                                            
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+/// High Frequency Generation - Patch Construction (14496-3 sp04 p216 fig. 4.46)                                                                            
+static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)                                                                               
+{                                                                                                                                                           
+    int i, k, sb = 0;                                                                                                                                       
+    int msb = sbr->k[0];                                                                                                                                    
+    int usb = sbr->kx[1];                                                                                                                                   
+    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;                                                                              
+                                                                                                                                                            
+    sbr->num_patches = 0;                                                                                                                                   
+                                                                                                                                                            
+    if (goal_sb < sbr->kx[1] + sbr->m[1]) {                                                                                                                 
+        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;                                                                                                      
+    } else                                                                                                                                                  
+        k = sbr->n_master;                                                                                                                                  
+                                                                                                                                                            
+    do {                                                                                                                                                    
+        int odd = 0;                                                                                                                                        
+        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {                                                                                      
+            sb = sbr->f_master[i];                                                                                                                          
+            odd = (sb + sbr->k[0]) & 1;                                                                                                                     
+        }                                                                                                                                                   
+                                                                                                                                                            
+        // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5.                                                                        
+        // After this check the final number of patches can still be six which is                                                                           
+        // illegal however the Coding Technologies decoder check stream has a final                                                                         
+        // count of 6 patches                                                                                                                               
+        if (sbr->num_patches > 5) {                                                                                                                         
+            av_log(ac->avctx, AV_LOG_ERROR, "Too many patches: %d\n", sbr->num_patches);                                                                    
+            return -1;                                                                                                                                      
+        }                                                                                                                                                   
+                                                                                                                                                            
+        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);                                                                                    
+        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];                                           
+                                                                                                                                                            
+        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {                                                                                                
+            usb = sb;                                                                                                                                       
+            msb = sb;                                                                                                                                       
+            sbr->num_patches++;                                                                                                                             
+        } else                                                                                                                                              
+            msb = sbr->kx[1];                                                                                                                               
+                                                                                                                                                            
+        if (sbr->f_master[k] - sb < 3)                                                                                                                      
+            k = sbr->n_master;                                                                                                                              
+    } while (sb != sbr->kx[1] + sbr->m[1]);                                                                                                                 
+                                                                                                                                                            
+    if (sbr->num_patches > 1 && sbr->patch_num_subbands[sbr->num_patches-1] < 3)                                                                            
+        sbr->num_patches--;                                                                                                                                 
+                                                                                                                                                            
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Derived Frequency Band Tables (14496-3 sp04 p197)                                                                                                       
+static int sbr_make_f_derived(AACContext *ac, SpectralBandReplication *sbr)                                                                                 
+{                                                                                                                                                           
+    int k, temp;                                                                                                                                            
+#if CONFIG_AAC_FIXED                                                                                                                                        
+    int nz = 0;                                                                                                                                             
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                                                                                                                                                            
+    sbr->n[1] = sbr->n_master - sbr->spectrum_params.bs_xover_band;                                                                                         
+    sbr->n[0] = (sbr->n[1] + 1) >> 1;                                                                                                                       
+                                                                                                                                                            
+    memcpy(sbr->f_tablehigh, &sbr->f_master[sbr->spectrum_params.bs_xover_band],                                                                            
+           (sbr->n[1] + 1) * sizeof(sbr->f_master[0]));                                                                                                     
+    sbr->m[1] = sbr->f_tablehigh[sbr->n[1]] - sbr->f_tablehigh[0];                                                                                          
+    sbr->kx[1] = sbr->f_tablehigh[0];                                                                                                                       
+                                                                                                                                                            
+    // Requirements (14496-3 sp04 p205)                                                                                                                     
+    if (sbr->kx[1] + sbr->m[1] > 64) {                                                                                                                      
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+               "Stop frequency border too high: %d\n", sbr->kx[1] + sbr->m[1]);                                                                             
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+    if (sbr->kx[1] > 32) {                                                                                                                                  
+        av_log(ac->avctx, AV_LOG_ERROR, "Start frequency border too high: %d\n", sbr->kx[1]);                                                               
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+    sbr->f_tablelow[0] = sbr->f_tablehigh[0];                                                                                                               
+    temp = sbr->n[1] & 1;                                                                                                                                   
+    for (k = 1; k <= sbr->n[0]; k++)                                                                                                                        
+        sbr->f_tablelow[k] = sbr->f_tablehigh[2 * k - temp];                                                                                                
+#if CONFIG_AAC_FIXED                                                                                                                                        
+    temp = (sbr->k[2] << 23) / sbr->kx[1];                                                                                                                  
+    while (temp < 0x40000000) {                                                                                                                             
+        temp <<= 1;                                                                                                                                         
+        nz++;                                                                                                                                               
+    }                                                                                                                                                       
+    temp = fixed_log(temp - 0x80000000);                                                                                                                    
+    temp = (int)(((int64_t)temp * CONST_RECIP_LN2 + 0x20000000) >> 30);                                                                                     
+    temp = (((temp + 128) >> 8) + ((8 - nz) << 23)) * sbr->spectrum_params.bs_noise_bands;                                                                  
+                                                                                                                                                            
+    sbr->n_q = (temp + 0x400000) >> 23;                                                                                                                     
+    if (sbr->n_q < 1)                                                                                                                                       
+        sbr->n_q = 1;                                                                                                                                       
+#else                                                                                                                                                       
+    sbr->n_q = FFMAX(1, lrintf(sbr->spectrum_params.bs_noise_bands *                                                                                        
+                               log2f(sbr->k[2] / (float)sbr->kx[1]))); // 0 <= bs_noise_bands <= 3                                                          
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                                                                                                                                                            
+    if (sbr->n_q > 5) {                                                                                                                                     
+        av_log(ac->avctx, AV_LOG_ERROR, "Too many noise floor scale factors: %d\n", sbr->n_q);                                                              
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+    sbr->f_tablenoise[0] = sbr->f_tablelow[0];                                                                                                              
+    temp = 0;                                                                                                                                               
+    for (k = 1; k <= sbr->n_q; k++) {                                                                                                                       
+        temp += (sbr->n[0] - temp) / (sbr->n_q + 1 - k);                                                                                                    
+        sbr->f_tablenoise[k] = sbr->f_tablelow[temp];                                                                                                       
+    }                                                                                                                                                       
+                                                                                                                                                            
+    if (sbr_hf_calc_npatches(ac, sbr) < 0)                                                                                                                  
+        return -1;                                                                                                                                          
+                                                                                                                                                            
+    sbr_make_f_tablelim(sbr);                                                                                                                               
+                                                                                                                                                            
+    sbr->data[0].f_indexnoise = 0;                                                                                                                          
+    sbr->data[1].f_indexnoise = 0;                                                                                                                          
+                                                                                                                                                            
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+static av_always_inline void get_bits1_vector(GetBitContext *gb, uint8_t *vec,                                                                              
+                                              int elements)                                                                                                 
+{                                                                                                                                                           
+    int i;                                                                                                                                                  
+    for (i = 0; i < elements; i++) {                                                                                                                        
+        vec[i] = get_bits1(gb);                                                                                                                             
+    }                                                                                                                                                       
+}                                                                                                                                                           
+                                                                                                                                                            
+//** ceil(log2(index+1))                                                                                                                                    
+static const int8_t ceil_log2[] = {                                                                                                                         
+    0, 1, 2, 2, 3, 3,                                                                                                                                       
+};                                                                                                                                                          
+                                                                                                                                                            
+static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,                                                                                      
+                         GetBitContext *gb, SBRData *ch_data)                                                                                               
+{                                                                                                                                                           
+    int i;                                                                                                                                                  
+    unsigned bs_pointer = 0;                                                                                                                                
+    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots                                                          
+    int abs_bord_trail = 16;                                                                                                                                
+    int num_rel_lead, num_rel_trail;                                                                                                                        
+    unsigned bs_num_env_old = ch_data->bs_num_env;                                                                                                          
+                                                                                                                                                            
+    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];                                                                                    
+    ch_data->bs_amp_res = sbr->bs_amp_res_header;                                                                                                           
+    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];                                                                                            
+                                                                                                                                                            
+    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {                                                                                                    
+    case FIXFIX:                                                                                                                                            
+        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);                                                                                         
+        num_rel_lead                        = ch_data->bs_num_env - 1;                                                                                      
+        if (ch_data->bs_num_env == 1)                                                                                                                       
+            ch_data->bs_amp_res = 0;                                                                                                                        
+                                                                                                                                                            
+        if (ch_data->bs_num_env > 4) {                                                                                                                      
+            av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                 
+                   "Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\n",                                                              
+                   ch_data->bs_num_env);                                                                                                                    
+            return -1;                                                                                                                                      
+        }                                                                                                                                                   
+                                                                                                                                                            
+        ch_data->t_env[0]                   = 0;                                                                                                            
+        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;                                                                                               
+                                                                                                                                                            
+        abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /                                                                                    
+                   ch_data->bs_num_env;                                                                                                                     
+        for (i = 0; i < num_rel_lead; i++)                                                                                                                  
+            ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;                                                                                     
+                                                                                                                                                            
+        ch_data->bs_freq_res[1] = get_bits1(gb);                                                                                                            
+        for (i = 1; i < ch_data->bs_num_env; i++)                                                                                                           
+            ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];                                                                                          
+        break;                                                                                                                                              
+    case FIXVAR:                                                                                                                                            
+        abs_bord_trail                     += get_bits(gb, 2);                                                                                              
+        num_rel_trail                       = get_bits(gb, 2);                                                                                              
+        ch_data->bs_num_env                 = num_rel_trail + 1;                                                                                            
+        ch_data->t_env[0]                   = 0;                                                                                                            
+        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;                                                                                               
+                                                                                                                                                            
+        for (i = 0; i < num_rel_trail; i++)                                                                                                                 
+            ch_data->t_env[ch_data->bs_num_env - 1 - i] =                                                                                                   
+                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;                                                                          
+                                                                                                                                                            
+        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);                                                                                          
+                                                                                                                                                            
+        for (i = 0; i < ch_data->bs_num_env; i++)                                                                                                           
+            ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);                                                                                  
+        break;                                                                                                                                              
+    case VARFIX:                                                                                                                                            
+        ch_data->t_env[0]                   = get_bits(gb, 2);                                                                                              
+        num_rel_lead                        = get_bits(gb, 2);                                                                                              
+        ch_data->bs_num_env                 = num_rel_lead + 1;                                                                                             
+        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;                                                                                               
+                                                                                                                                                            
+        for (i = 0; i < num_rel_lead; i++)                                                                                                                  
+            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;                                                                            
+                                                                                                                                                            
+        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);                                                                                          
+                                                                                                                                                            
+        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);                                                                                
+        break;                                                                                                                                              
+    case VARVAR:                                                                                                                                            
+        ch_data->t_env[0]                   = get_bits(gb, 2);                                                                                              
+        abs_bord_trail                     += get_bits(gb, 2);                                                                                              
+        num_rel_lead                        = get_bits(gb, 2);                                                                                              
+        num_rel_trail                       = get_bits(gb, 2);                                                                                              
+        ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;                                                                             
+                                                                                                                                                            
+        if (ch_data->bs_num_env > 5) {                                                                                                                      
+            av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                 
+                   "Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\n",                                                              
+                   ch_data->bs_num_env);                                                                                                                    
+            return -1;                                                                                                                                      
+        }                                                                                                                                                   
+                                                                                                                                                            
+        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;                                                                                               
+                                                                                                                                                            
+        for (i = 0; i < num_rel_lead; i++)                                                                                                                  
+            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;                                                                            
+        for (i = 0; i < num_rel_trail; i++)                                                                                                                 
+            ch_data->t_env[ch_data->bs_num_env - 1 - i] =                                                                                                   
+                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;                                                                          
+                                                                                                                                                            
+        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);                                                                                          
+                                                                                                                                                            
+        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);                                                                                
+        break;                                                                                                                                              
+    }                                                                                                                                                       
+                                                                                                                                                            
+    if (bs_pointer > ch_data->bs_num_env + 1) {                                                                                                             
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+               "Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n",                                        
+               bs_pointer);                                                                                                                                 
+        return -1;                                                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+    for (i = 1; i <= ch_data->bs_num_env; i++) {                                                                                                            
+        if (ch_data->t_env[i-1] > ch_data->t_env[i]) {                                                                                                      
+            av_log(ac->avctx, AV_LOG_ERROR, "Non monotone time borders\n");                                                                                 
+            return -1;                                                                                                                                      
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+                                                                                                                                                            
+    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;                                                                                                  
+                                                                                                                                                            
+    ch_data->t_q[0]                     = ch_data->t_env[0];                                                                                                
+    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];                                                                              
+    if (ch_data->bs_num_noise > 1) {                                                                                                                        
+        unsigned int idx;                                                                                                                                   
+        if (ch_data->bs_frame_class == FIXFIX) {                                                                                                            
+            idx = ch_data->bs_num_env >> 1;                                                                                                                 
+        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR                                                                                       
+            idx = ch_data->bs_num_env - FFMAX((int)bs_pointer - 1, 1);                                                                                      
+        } else { // VARFIX                                                                                                                                  
+            if (!bs_pointer)                                                                                                                                
+                idx = 1;                                                                                                                                    
+            else if (bs_pointer == 1)                                                                                                                       
+                idx = ch_data->bs_num_env - 1;                                                                                                              
+            else // bs_pointer > 1                                                                                                                          
+                idx = bs_pointer - 1;                                                                                                                       
+        }                                                                                                                                                   
+        ch_data->t_q[1] = ch_data->t_env[idx];                                                                                                              
+    }                                                                                                                                                       
+                                                                                                                                                            
+    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev                                                                                      
+    ch_data->e_a[1] = -1;                                                                                                                                   
+    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0                                                              
+        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;                                                                                             
+    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1                                                             
+        ch_data->e_a[1] = bs_pointer - 1;                                                                                                                   
+                                                                                                                                                            
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+static void copy_sbr_grid(SBRData *dst, const SBRData *src)                                                                                                 
+{                                                                                                                                                           
+    //These variables are saved from the previous frame rather than copied                                                                                  
+    dst->bs_freq_res[0]    = dst->bs_freq_res[dst->bs_num_env];                                                                                             
+    dst->t_env_num_env_old = dst->t_env[dst->bs_num_env];                                                                                                   
+    dst->e_a[0]            = -(dst->e_a[1] != dst->bs_num_env);                                                                                             
+                                                                                                                                                            
+    //These variables are read from the bitstream and therefore copied                                                                                      
+    memcpy(dst->bs_freq_res+1, src->bs_freq_res+1, sizeof(dst->bs_freq_res)-sizeof(*dst->bs_freq_res));                                                     
+    memcpy(dst->t_env,         src->t_env,         sizeof(dst->t_env));                                                                                     
+    memcpy(dst->t_q,           src->t_q,           sizeof(dst->t_q));                                                                                       
+    dst->bs_num_env        = src->bs_num_env;                                                                                                               
+    dst->bs_amp_res        = src->bs_amp_res;                                                                                                               
+    dst->bs_num_noise      = src->bs_num_noise;                                                                                                             
+    dst->bs_frame_class    = src->bs_frame_class;                                                                                                           
+    dst->e_a[1]            = src->e_a[1];                                                                                                                   
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Read how the envelope and noise floor data is delta coded                                                                                               
+static void read_sbr_dtdf(SpectralBandReplication *sbr, GetBitContext *gb,                                                                                  
+                          SBRData *ch_data)                                                                                                                 
+{                                                                                                                                                           
+    get_bits1_vector(gb, ch_data->bs_df_env,   ch_data->bs_num_env);                                                                                        
+    get_bits1_vector(gb, ch_data->bs_df_noise, ch_data->bs_num_noise);                                                                                      
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Read inverse filtering data                                                                                                                             
+static void read_sbr_invf(SpectralBandReplication *sbr, GetBitContext *gb,                                                                                  
+                          SBRData *ch_data)                                                                                                                 
+{                                                                                                                                                           
+    int i;                                                                                                                                                  
+                                                                                                                                                            
+    memcpy(ch_data->bs_invf_mode[1], ch_data->bs_invf_mode[0], 5 * sizeof(uint8_t));                                                                        
+    for (i = 0; i < sbr->n_q; i++)                                                                                                                          
+        ch_data->bs_invf_mode[0][i] = get_bits(gb, 2);                                                                                                      
+}                                                                                                                                                           
+                                                                                                                                                            
+static void read_sbr_envelope(SpectralBandReplication *sbr, GetBitContext *gb,                                                                              
+                              SBRData *ch_data, int ch)                                                                                                     
+{                                                                                                                                                           
+    int bits;                                                                                                                                               
+    int i, j, k;                                                                                                                                            
+    VLC_TYPE (*t_huff)[2], (*f_huff)[2];                                                                                                                    
+    int t_lav, f_lav;                                                                                                                                       
+    const int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;                                                                                               
+    const int odd = sbr->n[1] & 1;                                                                                                                          
+                                                                                                                                                            
+    if (sbr->bs_coupling && ch) {                                                                                                                           
+        if (ch_data->bs_amp_res) {                                                                                                                          
+            bits   = 5;                                                                                                                                     
+            t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_3_0DB].table;                                                                                                
+            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_3_0DB];                                                                                                  
+            f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;                                                                                                
+            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];                                                                                                  
+        } else {                                                                                                                                            
+            bits   = 6;                                                                                                                                     
+            t_huff = vlc_sbr[T_HUFFMAN_ENV_BAL_1_5DB].table;                                                                                                
+            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_BAL_1_5DB];                                                                                                  
+            f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_1_5DB].table;                                                                                                
+            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_1_5DB];                                                                                                  
+        }                                                                                                                                                   
+    } else {                                                                                                                                                
+        if (ch_data->bs_amp_res) {                                                                                                                          
+            bits   = 6;                                                                                                                                     
+            t_huff = vlc_sbr[T_HUFFMAN_ENV_3_0DB].table;                                                                                                    
+            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_3_0DB];                                                                                                      
+            f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;                                                                                                    
+            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];                                                                                                      
+        } else {                                                                                                                                            
+            bits   = 7;                                                                                                                                     
+            t_huff = vlc_sbr[T_HUFFMAN_ENV_1_5DB].table;                                                                                                    
+            t_lav  = vlc_sbr_lav[T_HUFFMAN_ENV_1_5DB];                                                                                                      
+            f_huff = vlc_sbr[F_HUFFMAN_ENV_1_5DB].table;                                                                                                    
+            f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_1_5DB];                                                                                                      
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+                                                                                                                                                            
+#if CONFIG_AAC_FIXED                                                                                                                                        
+    for (i = 0; i < ch_data->bs_num_env; i++) {                                                                                                             
+        if (ch_data->bs_df_env[i]) {                                                                                                                        
+            // bs_freq_res[0] == bs_freq_res[bs_num_env] from prev frame                                                                                    
+            if (ch_data->bs_freq_res[i + 1] == ch_data->bs_freq_res[i]) {                                                                                   
+                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)                                                                                   
+                    ch_data->env_facs[i + 1][j].mant = ch_data->env_facs[i][j].mant + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);                         
+            } else if (ch_data->bs_freq_res[i + 1]) {                                                                                                       
+                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {                                                                                 
+                    k = (j + odd) >> 1; // find k such that f_tablelow[k] <= f_tablehigh[j] < f_tablelow[k + 1]                                             
+                    ch_data->env_facs[i + 1][j].mant = ch_data->env_facs[i][k].mant + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);                         
+                }                                                                                                                                           
+            } else {                                                                                                                                        
+                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {                                                                                 
+                    k = j ? 2*j - odd : 0; // find k such that f_tablehigh[k] == f_tablelow[j]                                                              
+                    ch_data->env_facs[i + 1][j].mant = ch_data->env_facs[i][k].mant + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);                         
+                }                                                                                                                                           
+            }                                                                                                                                               
+        } else {                                                                                                                                            
+            ch_data->env_facs[i + 1][0].mant = delta * get_bits(gb, bits); // bs_env_start_value_balance                                                    
+            for (j = 1; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)                                                                                       
+                ch_data->env_facs[i + 1][j].mant = ch_data->env_facs[i + 1][j - 1].mant + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);                     
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+#else                                                                                                                                                       
+    for (i = 0; i < ch_data->bs_num_env; i++) {                                                                                                             
+        if (ch_data->bs_df_env[i]) {                                                                                                                        
+            // bs_freq_res[0] == bs_freq_res[bs_num_env] from prev frame                                                                                    
+            if (ch_data->bs_freq_res[i + 1] == ch_data->bs_freq_res[i]) {                                                                                   
+                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)                                                                                   
+                    ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);                                   
+            } else if (ch_data->bs_freq_res[i + 1]) {                                                                                                       
+                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {                                                                                 
+                    k = (j + odd) >> 1; // find k such that f_tablelow[k] <= f_tablehigh[j] < f_tablelow[k + 1]                                             
+                    ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);                                   
+                }                                                                                                                                           
+            } else {                                                                                                                                        
+                for (j = 0; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++) {                                                                                 
+                    k = j ? 2*j - odd : 0; // find k such that f_tablehigh[k] == f_tablelow[j]                                                              
+                    ch_data->env_facs[i + 1][j] = ch_data->env_facs[i][k] + delta * (get_vlc2(gb, t_huff, 9, 3) - t_lav);                                   
+                }                                                                                                                                           
+            }                                                                                                                                               
+        } else {                                                                                                                                            
+            ch_data->env_facs[i + 1][0] = delta * get_bits(gb, bits); // bs_env_start_value_balance                                                         
+            for (j = 1; j < sbr->n[ch_data->bs_freq_res[i + 1]]; j++)                                                                                       
+                ch_data->env_facs[i + 1][j] = ch_data->env_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);                               
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                                                                                                                                                            
+    //assign 0th elements of env_facs from last elements                                                                                                    
+    memcpy(ch_data->env_facs[0], ch_data->env_facs[ch_data->bs_num_env],                                                                                    
+           sizeof(ch_data->env_facs[0]));                                                                                                                   
+}                                                                                                                                                           
+                                                                                                                                                            
+static void read_sbr_noise(SpectralBandReplication *sbr, GetBitContext *gb,                                                                                 
+                           SBRData *ch_data, int ch)                                                                                                        
+{                                                                                                                                                           
+    int i, j;                                                                                                                                               
+    VLC_TYPE (*t_huff)[2], (*f_huff)[2];                                                                                                                    
+    int t_lav, f_lav;                                                                                                                                       
+    int delta = (ch == 1 && sbr->bs_coupling == 1) + 1;                                                                                                     
+                                                                                                                                                            
+    if (sbr->bs_coupling && ch) {                                                                                                                           
+        t_huff = vlc_sbr[T_HUFFMAN_NOISE_BAL_3_0DB].table;                                                                                                  
+        t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_BAL_3_0DB];                                                                                                    
+        f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table;                                                                                                    
+        f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB];                                                                                                      
+    } else {                                                                                                                                                
+        t_huff = vlc_sbr[T_HUFFMAN_NOISE_3_0DB].table;                                                                                                      
+        t_lav  = vlc_sbr_lav[T_HUFFMAN_NOISE_3_0DB];                                                                                                        
+        f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table;                                                                                                        
+        f_lav  = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB];                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+#if CONFIG_AAC_FIXED                                                                                                                                        
+    for (i = 0; i < ch_data->bs_num_noise; i++) {                                                                                                           
+        if (ch_data->bs_df_noise[i]) {                                                                                                                      
+            for (j = 0; j < sbr->n_q; j++)                                                                                                                  
+                ch_data->noise_facs[i + 1][j].mant = ch_data->noise_facs[i][j].mant + delta * (get_vlc2(gb, t_huff, 9, 2) - t_lav);                         
+        } else {                                                                                                                                            
+            ch_data->noise_facs[i + 1][0].mant = delta * get_bits(gb, 5); // bs_noise_start_value_balance or bs_noise_start_value_level                     
+            for (j = 1; j < sbr->n_q; j++)                                                                                                                  
+                ch_data->noise_facs[i + 1][j].mant = ch_data->noise_facs[i + 1][j - 1].mant + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);                 
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+#else                                                                                                                                                       
+    for (i = 0; i < ch_data->bs_num_noise; i++) {                                                                                                           
+        if (ch_data->bs_df_noise[i]) {                                                                                                                      
+            for (j = 0; j < sbr->n_q; j++)                                                                                                                  
+                ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 2) - t_lav);                                   
+        } else {                                                                                                                                            
+            ch_data->noise_facs[i + 1][0] = delta * get_bits(gb, 5); // bs_noise_start_value_balance or bs_noise_start_value_level                          
+            for (j = 1; j < sbr->n_q; j++)                                                                                                                  
+                ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav);                           
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                                                                                                                                                            
+    //assign 0th elements of noise_facs from last elements                                                                                                  
+    memcpy(ch_data->noise_facs[0], ch_data->noise_facs[ch_data->bs_num_noise],                                                                              
+           sizeof(ch_data->noise_facs[0]));                                                                                                                 
+}                                                                                                                                                           
+                                                                                                                                                            
+static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,                                                                                
+                               GetBitContext *gb,                                                                                                           
+                               int bs_extension_id, int *num_bits_left)                                                                                     
+{                                                                                                                                                           
+    switch (bs_extension_id) {                                                                                                                              
+    case EXTENSION_ID_PS:                                                                                                                                   
+        if (!ac->oc[1].m4ac.ps) {                                                                                                                           
+            av_log(ac->avctx, AV_LOG_ERROR, "Parametric Stereo signaled to be not-present but was found in the bitstream.\n");                              
+            skip_bits_long(gb, *num_bits_left); // bs_fill_bits                                                                                             
+            *num_bits_left = 0;                                                                                                                             
+        } else {                                                                                                                                            
+#if 1                                                                                                                                                       
+            *num_bits_left -= AAC_RENAME(ff_ps_read_data)(ac->avctx, gb, &sbr->ps, *num_bits_left);                                                         
+#else                                                                                                                                                       
+            avpriv_report_missing_feature(ac->avctx, "Parametric Stereo");                                                                                  
+            skip_bits_long(gb, *num_bits_left); // bs_fill_bits                                                                                             
+            *num_bits_left = 0;                                                                                                                             
+#endif                                                                                                                                                      
+        }                                                                                                                                                   
+        break;                                                                                                                                              
+    default:                                                                                                                                                
+        // some files contain 0-padding                                                                                                                     
+        if (bs_extension_id || *num_bits_left > 16 || show_bits(gb, *num_bits_left))                                                                        
+            av_log_missing_feature(ac->avctx, "Reserved SBR extensions", 1);
+        skip_bits_long(gb, *num_bits_left); // bs_fill_bits                                                                                                 
+        *num_bits_left = 0;                                                                                                                                 
+        break;                                                                                                                                              
+    }                                                                                                                                                       
+}                                                                                                                                                           
+                                                                                                                                                            
+static int read_sbr_single_channel_element(AACContext *ac,                                                                                                  
+                                            SpectralBandReplication *sbr,                                                                                   
+                                            GetBitContext *gb)                                                                                              
+{                                                                                                                                                           
+    if (get_bits1(gb)) // bs_data_extra                                                                                                                     
+        skip_bits(gb, 4); // bs_reserved                                                                                                                    
+                                                                                                                                                            
+    if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))                                                                                                          
+        return -1;                                                                                                                                          
+    read_sbr_dtdf(sbr, gb, &sbr->data[0]);                                                                                                                  
+    read_sbr_invf(sbr, gb, &sbr->data[0]);                                                                                                                  
+    read_sbr_envelope(sbr, gb, &sbr->data[0], 0);                                                                                                           
+    read_sbr_noise(sbr, gb, &sbr->data[0], 0);                                                                                                              
+                                                                                                                                                            
+    if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))                                                                                                
+        get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);                                                                                      
+                                                                                                                                                            
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+static int read_sbr_channel_pair_element(AACContext *ac,                                                                                                    
+                                          SpectralBandReplication *sbr,                                                                                     
+                                          GetBitContext *gb)                                                                                                
+{                                                                                                                                                           
+    if (get_bits1(gb))    // bs_data_extra                                                                                                                  
+        skip_bits(gb, 8); // bs_reserved                                                                                                                    
+                                                                                                                                                            
+    if ((sbr->bs_coupling = get_bits1(gb))) {                                                                                                               
+        if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))                                                                                                      
+            return -1;                                                                                                                                      
+        copy_sbr_grid(&sbr->data[1], &sbr->data[0]);                                                                                                        
+        read_sbr_dtdf(sbr, gb, &sbr->data[0]);                                                                                                              
+        read_sbr_dtdf(sbr, gb, &sbr->data[1]);                                                                                                              
+        read_sbr_invf(sbr, gb, &sbr->data[0]);                                                                                                              
+        memcpy(sbr->data[1].bs_invf_mode[1], sbr->data[1].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));                                           
+        memcpy(sbr->data[1].bs_invf_mode[0], sbr->data[0].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));                                           
+        read_sbr_envelope(sbr, gb, &sbr->data[0], 0);                                                                                                       
+        read_sbr_noise(sbr, gb, &sbr->data[0], 0);                                                                                                          
+        read_sbr_envelope(sbr, gb, &sbr->data[1], 1);                                                                                                       
+        read_sbr_noise(sbr, gb, &sbr->data[1], 1);                                                                                                          
+    } else {                                                                                                                                                
+        if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]) ||                                                                                                    
+            read_sbr_grid(ac, sbr, gb, &sbr->data[1]))                                                                                                      
+            return -1;                                                                                                                                      
+        read_sbr_dtdf(sbr, gb, &sbr->data[0]);                                                                                                              
+        read_sbr_dtdf(sbr, gb, &sbr->data[1]);                                                                                                              
+        read_sbr_invf(sbr, gb, &sbr->data[0]);                                                                                                              
+        read_sbr_invf(sbr, gb, &sbr->data[1]);                                                                                                              
+        read_sbr_envelope(sbr, gb, &sbr->data[0], 0);                                                                                                       
+        read_sbr_envelope(sbr, gb, &sbr->data[1], 1);                                                                                                       
+        read_sbr_noise(sbr, gb, &sbr->data[0], 0);                                                                                                          
+        read_sbr_noise(sbr, gb, &sbr->data[1], 1);                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+    if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))                                                                                                
+        get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);                                                                                      
+    if ((sbr->data[1].bs_add_harmonic_flag = get_bits1(gb)))                                                                                                
+        get_bits1_vector(gb, sbr->data[1].bs_add_harmonic, sbr->n[1]);                                                                                      
+                                                                                                                                                            
+        return 0;                                                                                                                                           
+}                                                                                                                                                           
+                                                                                                                                                            
+static unsigned int read_sbr_data(AACContext *ac, SpectralBandReplication *sbr,                                                                             
+                                  GetBitContext *gb, int id_aac)                                                                                            
+{                                                                                                                                                           
+    unsigned int cnt = get_bits_count(gb);                                                                                                                  
+                                                                                                                                                            
+    if (id_aac == TYPE_SCE || id_aac == TYPE_CCE) {                                                                                                         
+        if (read_sbr_single_channel_element(ac, sbr, gb)) {                                                                                                 
+            sbr_turnoff(sbr);                                                                                                                               
+            return get_bits_count(gb) - cnt;                                                                                                                
+        }                                                                                                                                                   
+    } else if (id_aac == TYPE_CPE) {                                                                                                                        
+        if (read_sbr_channel_pair_element(ac, sbr, gb)) {                                                                                                   
+            sbr_turnoff(sbr);                                                                                                                               
+            return get_bits_count(gb) - cnt;                                                                                                                
+        }                                                                                                                                                   
+    } else {                                                                                                                                                
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+            "Invalid bitstream - cannot apply SBR to element type %d\n", id_aac);                                                                           
+        sbr_turnoff(sbr);                                                                                                                                   
+        return get_bits_count(gb) - cnt;                                                                                                                    
+    }                                                                                                                                                       
+    if (get_bits1(gb)) { // bs_extended_data                                                                                                                
+        int num_bits_left = get_bits(gb, 4); // bs_extension_size                                                                                           
+        if (num_bits_left == 15)                                                                                                                            
+            num_bits_left += get_bits(gb, 8); // bs_esc_count                                                                                               
+                                                                                                                                                            
+        num_bits_left <<= 3;                                                                                                                                
+        while (num_bits_left > 7) {                                                                                                                         
+            num_bits_left -= 2;                                                                                                                             
+            read_sbr_extension(ac, sbr, gb, get_bits(gb, 2), &num_bits_left); // bs_extension_id                                                            
+        }                                                                                                                                                   
+        if (num_bits_left < 0) {                                                                                                                            
+            av_log(ac->avctx, AV_LOG_ERROR, "SBR Extension over read.\n");                                                                                  
+        }                                                                                                                                                   
+        if (num_bits_left > 0)                                                                                                                              
+            skip_bits(gb, num_bits_left);                                                                                                                   
+    }                                                                                                                                                       
+                                                                                                                                                            
+    return get_bits_count(gb) - cnt;                                                                                                                        
+}                                                                                                                                                           
+                                                                                                                                                            
+static void sbr_reset(AACContext *ac, SpectralBandReplication *sbr)                                                                                         
+{                                                                                                                                                           
+    int err;                                                                                                                                                
+    err = sbr_make_f_master(ac, sbr, &sbr->spectrum_params);                                                                                                
+    if (err >= 0)                                                                                                                                           
+        err = sbr_make_f_derived(ac, sbr);                                                                                                                  
+    if (err < 0) {                                                                                                                                          
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+               "SBR reset failed. Switching SBR to pure upsampling mode.\n");                                                                               
+        sbr_turnoff(sbr);                                                                                                                                   
+    }                                                                                                                                                       
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Generate the subband filtered lowband                                                                                                                   
+static int sbr_lf_gen(AACContext *ac, SpectralBandReplication *sbr,                                                                                         
+                      INTFLOAT X_low[32][40][2], const INTFLOAT W[2][32][32][2],                                                                            
+                      int buf_idx)                                                                                                                          
+{                                                                                                                                                           
+    int i, k;                                                                                                                                               
+    const int t_HFGen = 8;                                                                                                                                  
+    const int i_f = 32;                                                                                                                                     
+    memset(X_low, 0, 32*sizeof(*X_low));                                                                                                                    
+    for (k = 0; k < sbr->kx[1]; k++) {                                                                                                                      
+        for (i = t_HFGen; i < i_f + t_HFGen; i++) {                                                                                                         
+            X_low[k][i][0] = W[buf_idx][i - t_HFGen][k][0];                                                                                                 
+            X_low[k][i][1] = W[buf_idx][i - t_HFGen][k][1];                                                                                                 
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+    buf_idx = 1-buf_idx;                                                                                                                                    
+    for (k = 0; k < sbr->kx[0]; k++) {                                                                                                                      
+        for (i = 0; i < t_HFGen; i++) {                                                                                                                     
+            X_low[k][i][0] = W[buf_idx][i + i_f - t_HFGen][k][0];                                                                                           
+            X_low[k][i][1] = W[buf_idx][i + i_f - t_HFGen][k][1];                                                                                           
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+/// High Frequency Generator (14496-3 sp04 p215)                                                                                                            
+static int sbr_hf_gen(AACContext *ac, SpectralBandReplication *sbr,                                                                                         
+                      INTFLOAT X_high[64][40][2], const INTFLOAT X_low[32][40][2],                                                                          
+                      const INTFLOAT (*alpha0)[2], const INTFLOAT (*alpha1)[2],                                                                             
+                      const INTFLOAT bw_array[5], const uint8_t *t_env,                                                                                     
+                      int bs_num_env)                                                                                                                       
+{                                                                                                                                                           
+    int j, x;                                                                                                                                               
+    int g = 0;                                                                                                                                              
+    int k = sbr->kx[1];                                                                                                                                     
+    for (j = 0; j < sbr->num_patches; j++) {                                                                                                                
+        for (x = 0; x < sbr->patch_num_subbands[j]; x++, k++) {                                                                                             
+            const int p = sbr->patch_start_subband[j] + x;                                                                                                  
+            while (g <= sbr->n_q && k >= sbr->f_tablenoise[g])                                                                                              
+                g++;                                                                                                                                        
+            g--;                                                                                                                                            
+                                                                                                                                                            
+            if (g < 0) {                                                                                                                                    
+                av_log(ac->avctx, AV_LOG_ERROR,                                                                                                             
+                       "ERROR : no subband found for frequency %d\n", k);                                                                                   
+                return -1;                                                                                                                                  
+            }                                                                                                                                               
+                                                                                                                                                            
+            sbr->dsp.AAC_RENAME(hf_gen)(X_high[k] + ENVELOPE_ADJUSTMENT_OFFSET,                                                                             
+                                        X_low[p]  + ENVELOPE_ADJUSTMENT_OFFSET,                                                                             
+                                        alpha0[p], alpha1[p], bw_array[g],                                                                                  
+                                        2 * t_env[0], 2 * t_env[bs_num_env]);                                                                               
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+    if (k < sbr->m[1] + sbr->kx[1])                                                                                                                         
+        memset(X_high + k, 0, (sbr->m[1] + sbr->kx[1] - k) * sizeof(*X_high));                                                                              
+                                                                                                                                                            
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Generate the subband filtered lowband                                                                                                                   
+static int sbr_x_gen(SpectralBandReplication *sbr, INTFLOAT X[2][38][64],                                                                                   
+                     const INTFLOAT Y0[38][64][2], const INTFLOAT Y1[38][64][2],                                                                            
+                     const INTFLOAT X_low[32][40][2], int ch)                                                                                               
+{                                                                                                                                                           
+    int k, i;                                                                                                                                               
+    const int i_f = 32;                                                                                                                                     
+    const int i_Temp = FFMAX(2*sbr->data[ch].t_env_num_env_old - i_f, 0);                                                                                   
+    memset(X, 0, 2*sizeof(*X));                                                                                                                             
+    for (k = 0; k < sbr->kx[0]; k++) {                                                                                                                      
+        for (i = 0; i < i_Temp; i++) {                                                                                                                      
+            X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];                                                                                       
+            X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];                                                                                       
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+    for (; k < sbr->kx[0] + sbr->m[0]; k++) {                                                                                                               
+        for (i = 0; i < i_Temp; i++) {                                                                                                                      
+            X[0][i][k] = Y0[i + i_f][k][0];                                                                                                                 
+            X[1][i][k] = Y0[i + i_f][k][1];                                                                                                                 
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+                                                                                                                                                            
+    for (k = 0; k < sbr->kx[1]; k++) {                                                                                                                      
+        for (i = i_Temp; i < 38; i++) {                                                                                                                     
+            X[0][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][0];                                                                                       
+            X[1][i][k] = X_low[k][i + ENVELOPE_ADJUSTMENT_OFFSET][1];                                                                                       
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+    for (; k < sbr->kx[1] + sbr->m[1]; k++) {                                                                                                               
+        for (i = i_Temp; i < i_f; i++) {                                                                                                                    
+            X[0][i][k] = Y1[i][k][0];                                                                                                                       
+            X[1][i][k] = Y1[i][k][1];                                                                                                                       
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+static int sbr_mapping(AACContext *ac, SpectralBandReplication *sbr,                                                                                        
+                        SBRData *ch_data, int e_a[2])                                                                                                       
+{                                                                                                                                                           
+    int e, i, m;                                                                                                                                            
+                                                                                                                                                            
+    memset(ch_data->s_indexmapped[1], 0, 7*sizeof(ch_data->s_indexmapped[1]));                                                                              
+    for (e = 0; e < ch_data->bs_num_env; e++) {                                                                                                             
+        const unsigned int ilim = sbr->n[ch_data->bs_freq_res[e + 1]];                                                                                      
+        uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;                                                                 
+        int k;                                                                                                                                              
+                                                                                                                                                            
+        if (sbr->kx[1] != table[0]) {                                                                                                                       
+            av_log(ac->avctx, AV_LOG_ERROR, "kx != f_table{high,low}[0]. "                                                                                  
+                   "Derived frequency tables were not regenerated.\n");                                                                                     
+            sbr_turnoff(sbr);                                                                                                                               
+            return -1;                                                                                                                             
+        }                                                                                                                                                   
+        for (i = 0; i < ilim; i++)                                                                                                                          
+            for (m = table[i]; m < table[i + 1]; m++)                                                                                                       
+                sbr->e_origmapped[e][m - sbr->kx[1]] = ch_data->env_facs[e+1][i];                                                                           
+                                                                                                                                                            
+        // ch_data->bs_num_noise > 1 => 2 noise floors                                                                                                      
+        k = (ch_data->bs_num_noise > 1) && (ch_data->t_env[e] >= ch_data->t_q[1]);                                                                          
+        for (i = 0; i < sbr->n_q; i++)                                                                                                                      
+            for (m = sbr->f_tablenoise[i]; m < sbr->f_tablenoise[i + 1]; m++)                                                                               
+                sbr->q_mapped[e][m - sbr->kx[1]] = ch_data->noise_facs[k+1][i];                                                                             
+                                                                                                                                                            
+        for (i = 0; i < sbr->n[1]; i++) {                                                                                                                   
+            if (ch_data->bs_add_harmonic_flag) {                                                                                                            
+                const unsigned int m_midpoint =                                                                                                             
+                    (sbr->f_tablehigh[i] + sbr->f_tablehigh[i + 1]) >> 1;                                                                                   
+                                                                                                                                                            
+                ch_data->s_indexmapped[e + 1][m_midpoint - sbr->kx[1]] = ch_data->bs_add_harmonic[i] *                                                      
+                    (e >= e_a[1] || (ch_data->s_indexmapped[0][m_midpoint - sbr->kx[1]] == 1));                                                             
+            }                                                                                                                                               
+        }                                                                                                                                                   
+                                                                                                                                                            
+        for (i = 0; i < ilim; i++) {                                                                                                                        
+            int additional_sinusoid_present = 0;                                                                                                            
+            for (m = table[i]; m < table[i + 1]; m++) {                                                                                                     
+                if (ch_data->s_indexmapped[e + 1][m - sbr->kx[1]]) {                                                                                        
+                    additional_sinusoid_present = 1;                                                                                                        
+                    break;                                                                                                                                  
+                }                                                                                                                                           
+            }                                                                                                                                               
+            memset(&sbr->s_mapped[e][table[i] - sbr->kx[1]], additional_sinusoid_present,                                                                   
+                   (table[i + 1] - table[i]) * sizeof(sbr->s_mapped[e][0]));                                                                                
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+                                                                                                                                                            
+    memcpy(ch_data->s_indexmapped[0], ch_data->s_indexmapped[ch_data->bs_num_env], sizeof(ch_data->s_indexmapped[0]));                                      
+    return 0;                                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+/// Estimation of current envelope (14496-3 sp04 p218)                                                                                                      
+static void sbr_env_estimate(AAC_FLOAT (*e_curr)[48], INTFLOAT X_high[64][40][2],                                                                           
+                             SpectralBandReplication *sbr, SBRData *ch_data)                                                                                
+{                                                                                                                                                           
+    int e, m;                                                                                                                                               
+    int kx1 = sbr->kx[1];                                                                                                                                   
+                                                                                                                                                            
+    if (sbr->bs_interpol_freq) {                                                                                                                            
+        for (e = 0; e < ch_data->bs_num_env; e++) {                                                                                                         
+#if CONFIG_AAC_FIXED                                                                                                                                        
+            const AAC_FLOAT recip_env_size = int2float(0x20000000 / (ch_data->t_env[e + 1] - ch_data->t_env[e]), 0);                                        
+#else                                                                                                                                                       
+            const AAC_FLOAT recip_env_size = 0.5f / (ch_data->t_env[e + 1] - ch_data->t_env[e]);                                                            
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+            int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;                                                                               
+            int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;                                                                               
+                                                                                                                                                            
+            for (m = 0; m < sbr->m[1]; m++) {                                                                                                               
+                AAC_FLOAT sum = sbr->dsp.AAC_RENAME(sum_square)(X_high[m+kx1] + ilb, iub - ilb);                                                            
+#if CONFIG_AAC_FIXED                                                                                                                                        
+                e_curr[e][m] = float_mul(sum, recip_env_size);                                                                                              
+#else                                                                                                                                                       
+                e_curr[e][m] = sum * recip_env_size;                                                                                                        
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+            }                                                                                                                                               
+        }                                                                                                                                                   
+    } else {                                                                                                                                                
+        int k, p;                                                                                                                                           
+                                                                                                                                                            
+        for (e = 0; e < ch_data->bs_num_env; e++) {                                                                                                         
+            const int env_size = 2 * (ch_data->t_env[e + 1] - ch_data->t_env[e]);                                                                           
+            int ilb = ch_data->t_env[e]     * 2 + ENVELOPE_ADJUSTMENT_OFFSET;                                                                               
+            int iub = ch_data->t_env[e + 1] * 2 + ENVELOPE_ADJUSTMENT_OFFSET;                                                                               
+            const uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;                                                       
+                                                                                                                                                            
+            for (p = 0; p < sbr->n[ch_data->bs_freq_res[e + 1]]; p++) {                                                                                     
+#if CONFIG_AAC_FIXED                                                                                                                                        
+                aac_float_t sum = { 0, 0 };                                                                                                                 
+                const aac_float_t den = int2float(0x20000000 / (env_size * (table[p + 1] - table[p])), 1);                                                  
+                for (k = table[p]; k < table[p + 1]; k++) {                                                                                                 
+                    sum = float_add(sum, sbr->dsp.sum_square_fixed(X_high[k] + ilb, iub - ilb));                                                            
+                }                                                                                                                                           
+                sum = float_mul(sum, den);                                                                                                                  
+#else                                                                                                                                                       
+                AAC_FLOAT sum = 0.0f;                                                                                                                       
+                const int den = env_size * (table[p + 1] - table[p]);                                                                                       
+                                                                                                                                                            
+                for (k = table[p]; k < table[p + 1]; k++) {                                                                                                 
+                    sum += sbr->dsp.sum_square(X_high[k] + ilb, iub - ilb);                                                                                 
+                }                                                                                                                                           
+                sum /= den;                                                                                                                                 
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                for (k = table[p]; k < table[p + 1]; k++) {                                                                                                 
+                    e_curr[e][k - kx1] = sum;                                                                                                               
+                }                                                                                                                                           
+            }                                                                                                                                               
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+}                                                                                                                                                           
+                                                                                                                                                            
+av_cold void AAC_RENAME(ff_aac_sbr_init)(void)                                                                                                              
+{                                                                                                                                                           
+    int n;                                                                                                                                                  
+    static const struct {                                                                                                                                   
+        const void *sbr_codes, *sbr_bits;                                                                                                                   
+        const unsigned int table_size, elem_size;                                                                                                           
+    } sbr_tmp[] = {                                                                                                                                         
+        SBR_VLC_ROW(t_huffman_env_1_5dB),                                                                                                                   
+        SBR_VLC_ROW(f_huffman_env_1_5dB),                                                                                                                   
+        SBR_VLC_ROW(t_huffman_env_bal_1_5dB),                                                                                                               
+        SBR_VLC_ROW(f_huffman_env_bal_1_5dB),                                                                                                               
+        SBR_VLC_ROW(t_huffman_env_3_0dB),                                                                                                                   
+        SBR_VLC_ROW(f_huffman_env_3_0dB),                                                                                                                   
+        SBR_VLC_ROW(t_huffman_env_bal_3_0dB),                                                                                                               
+        SBR_VLC_ROW(f_huffman_env_bal_3_0dB),                                                                                                               
+        SBR_VLC_ROW(t_huffman_noise_3_0dB),                                                                                                                 
+        SBR_VLC_ROW(t_huffman_noise_bal_3_0dB),                                                                                                             
+    };                                                                                                                                                      
+                                                                                                                                                            
+    // SBR VLC table initialization                                                                                                                         
+    SBR_INIT_VLC_STATIC(0, 1098);                                                                                                                           
+    SBR_INIT_VLC_STATIC(1, 1092);                                                                                                                           
+    SBR_INIT_VLC_STATIC(2, 768);                                                                                                                            
+    SBR_INIT_VLC_STATIC(3, 1026);                                                                                                                           
+    SBR_INIT_VLC_STATIC(4, 1058);                                                                                                                           
+    SBR_INIT_VLC_STATIC(5, 1052);                                                                                                                           
+    SBR_INIT_VLC_STATIC(6, 544);                                                                                                                            
+    SBR_INIT_VLC_STATIC(7, 544);                                                                                                                            
+    SBR_INIT_VLC_STATIC(8, 592);                                                                                                                            
+    SBR_INIT_VLC_STATIC(9, 512);                                                                                                                            
+                                                                                                                                                            
+    for (n = 1; n < 320; n++)                                                                                                                               
+        sbr_qmf_window_us[320 + n] = sbr_qmf_window_us[320 - n];                                                                                            
+    sbr_qmf_window_us[384] = -sbr_qmf_window_us[384];                                                                                                       
+    sbr_qmf_window_us[512] = -sbr_qmf_window_us[512];                                                                                                       
+                                                                                                                                                            
+    for (n = 0; n < 320; n++)                                                                                                                               
+        sbr_qmf_window_ds[n] = sbr_qmf_window_us[2*n];                                                                                                      
+                                                                                                                                                            
+    AAC_RENAME(ff_ps_init)();                                                                                                                               
+}                                                                                                                                                           
+                                                                                                                                                            
+av_cold void AAC_RENAME(ff_aac_sbr_ctx_init)(AACContext *ac, SpectralBandReplication *sbr)                                                                  
+{                                                                                                                                                           
+    if(sbr->mdct.mdct_bits)                                                                                                                                 
+        return;                                                                                                                                             
+    sbr->kx[0] = sbr->kx[1];                                                                                                                                
+    sbr_turnoff(sbr);                                                                                                                                       
+    sbr->data[0].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);                                                               
+    sbr->data[1].synthesis_filterbank_samples_offset = SBR_SYNTHESIS_BUF_SIZE - (1280 - 128);                                                               
+    /* SBR requires samples to be scaled to +/-32768.0 to work correctly.                                                                                   
+     * mdct scale factors are adjusted to scale up from +/-1.0 at analysis                                                                                  
+     * and scale back down at synthesis. */                                                                                                                 
+    AAC_RENAME_32(ff_mdct_init)(&sbr->mdct,     7, 1, 1.0 / (64 * 32768.0));                                                                                
+    AAC_RENAME_32(ff_mdct_init)(&sbr->mdct_ana, 7, 1, -2.0 * 32768.0);                                                                                      
+    AAC_RENAME(ff_ps_ctx_init)(&sbr->ps);                                                                                                                   
+    ff_sbrdsp_init(&sbr->dsp);                                                                                                                              
+    //aacsbr_func_ptr_init(&sbr->c);                                                                                                                          
+}                                                                                                                                                           
+                                                                                                                                                            
+av_cold void AAC_RENAME(ff_aac_sbr_ctx_close)(SpectralBandReplication *sbr)                                                                                 
+{                                                                                                                                                           
+    AAC_RENAME_32(ff_mdct_end)(&sbr->mdct);                                                                                                                 
+    AAC_RENAME_32(ff_mdct_end)(&sbr->mdct_ana);                                                                                                             
+}                                                                                                                                                           
+                                                                                                                                                            
+/**                                                                                                                                                         
+ * Decode Spectral Band Replication extension data; reference: table 4.55.                                                                                  
+ *                                                                                                                                                          
+ *  <at> param   crc flag indicating the presence of CRC checksum                                                                                           
+ *  <at> param   cnt length of TYPE_FIL syntactic element in bytes                                                                                          
+ *                                                                                                                                                          
+ *  <at> return  Returns number of bytes consumed from the TYPE_FIL element.                                                                                
+ */                                                                                                                                                         
+int AAC_RENAME(ff_decode_sbr_extension)(AACContext *ac, SpectralBandReplication *sbr,                                                                       
+                            GetBitContext *gb_host, int crc, int cnt, int id_aac)                                                                           
+{                                                                                                                                                           
+    unsigned int num_sbr_bits = 0, num_align_bits;                                                                                                          
+    unsigned bytes_read;                                                                                                                                    
+    GetBitContext gbc = *gb_host, *gb = &gbc;                                                                                                               
+    skip_bits_long(gb_host, cnt*8 - 4);                                                                                                                     
+                                                                                                                                                            
+    sbr->reset = 0;                                                                                                                                         
+                                                                                                                                                            
+    if (!sbr->sample_rate)                                                                                                                                  
+        sbr->sample_rate = 2 * ac->oc[1].m4ac.sample_rate; //TODO use the nominal sample rate for arbitrary sample rate support                             
+    if (!ac->oc[1].m4ac.ext_sample_rate)                                                                                                                    
+        ac->oc[1].m4ac.ext_sample_rate = 2 * ac->oc[1].m4ac.sample_rate;                                                                                    
+                                                                                                                                                            
+    if (crc) {                                                                                                                                              
+        skip_bits(gb, 10); // bs_sbr_crc_bits; TODO - implement CRC check                                                                                   
+        num_sbr_bits += 10;                                                                                                                                 
+    }                                                                                                                                                       
+                                                                                                                                                            
+    //Save some state from the previous frame.                                                                                                              
+    sbr->kx[0] = sbr->kx[1];                                                                                                                                
+    sbr->m[0] = sbr->m[1];                                                                                                                                  
+    sbr->kx_and_m_pushed = 1;                                                                                                                               
+                                                                                                                                                            
+    num_sbr_bits++;                                                                                                                                         
+    if (get_bits1(gb)) // bs_header_flag                                                                                                                    
+        num_sbr_bits += read_sbr_header(sbr, gb);                                                                                                           
+                                                                                                                                                            
+    if (sbr->reset)                                                                                                                                         
+        sbr_reset(ac, sbr);                                                                                                                                 
+                                                                                                                                                            
+    if (sbr->start)                                                                                                                                         
+        num_sbr_bits  += read_sbr_data(ac, sbr, gb, id_aac);                                                                                                
+                                                                                                                                                            
+    num_align_bits = ((cnt << 3) - 4 - num_sbr_bits) & 7;                                                                                                   
+    bytes_read = ((num_sbr_bits + num_align_bits + 4) >> 3);                                                                                                
+                                                                                                                                                            
+    if (bytes_read > cnt) {                                                                                                                                 
+        av_log(ac->avctx, AV_LOG_ERROR,                                                                                                                     
+               "Expected to read %d SBR bytes actually read %d.\n", cnt, bytes_read);                                                                       
+    }                                                                                                                                                       
+    return cnt;                                                                                                                                             
+}                                                                                                                                                           
+                                                                                                                                                            
+/**                                                                                                                                                         
+ * Analysis QMF Bank (14496-3 sp04 p206)                                                                                                                    
+ *                                                                                                                                                          
+ *  <at> param   x       pointer to the beginning of the first sample window                                                                                
+ *  <at> param   W       array of complex-valued samples split into subbands                                                                                
+ */                                                                                                                                                         
+#ifndef sbr_qmf_analysis                                                                                                                                    
+#if CONFIG_AAC_FIXED                                                                                                                                        
+static void sbr_qmf_analysis(AVFixedDSPContext *dsp, FFTContext *mdct,                                                                                      
+#else                                                                                                                                                       
+static void sbr_qmf_analysis(DSPContext *dsp, FFTContext *mdct,                                                                                      
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                             SBRDSPContext *sbrdsp, const INTFLOAT *in, INTFLOAT *x,                                                                        
+                             INTFLOAT z[320], INTFLOAT W[2][32][32][2], int buf_idx)                                                                        
+{                                                                                                                                                           
+    int i;                                                                                                                                                  
+    memcpy(x    , x+1024, (320-32)*sizeof(x[0]));                                                                                                           
+    memcpy(x+288, in,         1024*sizeof(x[0])); 
+/*av_log(NULL,AV_LOG_INFO,"----------%d----------\n",buf_idx);
+ for(i = 0 ; i < 1024; i++)
+av_log(NULL,AV_LOG_INFO,"[%d]%d ",i,x[i]);*/
+    for (i = 0; i < 32; i++) { // numTimeSlots*RATE = 16*2 as 960 sample frames                                                                             
+                               // are not supported                                                                                                         
+        dsp->AAC_RENAME(vector_fmul_reverse)(z, sbr_qmf_window_ds, x, 320);                                                                                 
+        sbrdsp->AAC_RENAME(sum64x5)(z);                                                                                                                     
+        sbrdsp->AAC_RENAME(qmf_pre_shuffle)(z);                                                                                                             
+        mdct->imdct_half(mdct, z, z+64);                                                                                                                    
+        sbrdsp->AAC_RENAME(qmf_post_shuffle)(W[buf_idx][i], z);                                                                                             
+        x += 32;
+    } 
+}                                                                                                                                                           
+#endif                                                                                                                                                      
+/**                                                                                                                                                         
+ * Synthesis QMF Bank (14496-3 sp04 p206) and Downsampled Synthesis QMF Bank                                                                                
+ * (14496-3 sp04 p206)                                                                                                                                      
+ */                                                                                                                                                         
+#ifndef sbr_qmf_synthesis                                                                                                                                   
+static void sbr_qmf_synthesis(FFTContext *mdct,                                                                                                             
+#if CONFIG_AAC_FIXED                                                                                                                                        
+                              SBRDSPContext *sbrdsp, AVFixedDSPContext *dsp,                                                                                
+#else                                                                                                                                                       
+                              SBRDSPContext *sbrdsp, DSPContext *dsp,AVFloatDSPContext *fdsp,                                                  
+#endif /* CONFIG_AAC_FIXED */                                                                                                                               
+                              INTFLOAT *out, INTFLOAT X[2][38][64],                                                                                         
+                              INTFLOAT mdct_buf[2][64],                                                                                                     
+                              INTFLOAT *v0, int *v_off, const unsigned int div)                                                                             
+{                                                                                                                                                           
+    int i, n;                                                                                                                                               
+    const INTFLOAT *sbr_qmf_window = div ? sbr_qmf_window_ds : sbr_qmf_window_us;                                                                           
+    const int step = 128 >> div;                                                                                                                            
+    INTFLOAT *v;                                                                                                                                            
+
+/*av_log(NULL,AV_LOG_INFO,"----------%d----------\n",buf_idx);
+ for(i = 0 ; i < 1024; i++)
+av_log(NULL,AV_LOG_INFO,"[%d]%d ",i,x[i]);*/
+    for (i = 0; i < 32; i++) {                                                                                                                              
+        if (*v_off < step) {                                                                                                                                
+            int saved_samples = (1280 - 128) >> div;                                                                                                        
+            memcpy(&v0[SBR_SYNTHESIS_BUF_SIZE - saved_samples], v0, saved_samples * sizeof(INTFLOAT));                                                      
+            *v_off = SBR_SYNTHESIS_BUF_SIZE - saved_samples - step;                                                                                         
+        } else {                                                                                                                                            
+            *v_off -= step;                                                                                                                                 
+        }                                                                                                                                                   
+        v = v0 + *v_off;                                                                                                                                    
+        if (div) {                                                                                                                                          
+            for (n = 0; n < 32; n++) {                                                                                                                      
+                X[0][i][   n] = -X[0][i][n];                                                                                                                
+                X[0][i][32+n] =  X[1][i][31-n];                                                                                                             
+            }                                                                                                                                               
+            mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);                                                                                                   
+            sbrdsp->AAC_RENAME(qmf_deint_neg)(v, mdct_buf[0]);                                                                                              
+        } else {                                                                                                                                            
+            sbrdsp->AAC_RENAME(neg_odd_64)(X[1][i]);                                                                                                        
+            mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);                                                                                                   
+            mdct->imdct_half(mdct, mdct_buf[1], X[1][i]);                                                                                                   
+            sbrdsp->AAC_RENAME(qmf_deint_bfly)(v, mdct_buf[1], mdct_buf[0]);                                                                                
         }
-        nch = 2;
-    }
-
-    sbr_qmf_synthesis(&ac->dsp, &sbr->mdct, L, sbr->X[0], sbr->qmf_filter_scratch,
-                      sbr->data[0].synthesis_filterbank_samples,
-                      &sbr->data[0].synthesis_filterbank_samples_offset,
-                      downsampled);
-    if (nch == 2)
-        sbr_qmf_synthesis(&ac->dsp, &sbr->mdct, R, sbr->X[1], sbr->qmf_filter_scratch,
-                          sbr->data[1].synthesis_filterbank_samples,
-                          &sbr->data[1].synthesis_filterbank_samples_offset,
-                          downsampled);
-}
+#if CONFIG_AAC_FIXED    
+        dsp->AAC_RENAME(vector_fmul)    (out, v                , sbr_qmf_window                       , 64 >> div);                                         
+#else
+        fdsp->AAC_RENAME(vector_fmul)    (out, v                , sbr_qmf_window                       , 64 >> div);
+#endif
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + ( 192 >> div), sbr_qmf_window + ( 64 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + ( 256 >> div), sbr_qmf_window + (128 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + ( 448 >> div), sbr_qmf_window + (192 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + ( 512 >> div), sbr_qmf_window + (256 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + ( 704 >> div), sbr_qmf_window + (320 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + ( 768 >> div), sbr_qmf_window + (384 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + ( 960 >> div), sbr_qmf_window + (448 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + (1024 >> div), sbr_qmf_window + (512 >> div), out   , 64 >> div);                                         
+        dsp->AAC_RENAME(vector_fmul_add)(out, v + (1216 >> div), sbr_qmf_window + (576 >> div), out   , 64 >> div);                                         
+        out += 64 >> div;                                                                                                                                   
+    }                                                                                                                                                       
+}                                                                                                                                                           
+#endif                                                                                                                                                      
+                                                                                                                                                            
+void AAC_RENAME(ff_sbr_apply)(AACContext *ac, SpectralBandReplication *sbr, int id_aac,                                                                     
+                  INTFLOAT* L, INTFLOAT* R)                                                                                                                 
+{                                                                                                                                                           
+    int downsampled = ac->oc[1].m4ac.ext_sample_rate < sbr->sample_rate;                                                                                    
+    int ch;                                                                                                                                                 
+    int nch = (id_aac == TYPE_CPE) ? 2 : 1;                                                                                                                 
+    int err;                                                                                                                                                
+                                                                                                                                                            
+    if (!sbr->kx_and_m_pushed) {                                                                                                                            
+        sbr->kx[0] = sbr->kx[1];                                                                                                                            
+        sbr->m[0] = sbr->m[1];                                                                                                                              
+    } else {                                                                                                                                                
+        sbr->kx_and_m_pushed = 0;                                                                                                                           
+    }                                                                                                                                                       
+                                                                                                                                                            
+    if (sbr->start) {                                                                                                                                       
+        sbr_dequant(sbr, id_aac);                                                                                                                           
+    }                                                                                                                                                       
+    for (ch = 0; ch < nch; ch++) {                                                                                                                          
+        /* decode channel */    
+#if CONFIG_AAC_FIXED                                                                                                                            
+        sbr_qmf_analysis(&ac->fdsp, &sbr->mdct_ana, &sbr->dsp, ch ? R : L, sbr->data[ch].analysis_filterbank_samples, 
+#else
+        sbr_qmf_analysis(&ac->dsp, &sbr->mdct_ana, &sbr->dsp, ch ? R : L, sbr->data[ch].analysis_filterbank_samples,
+#endif
+                         (INTFLOAT*)sbr->qmf_filter_scratch,                                                                                                
+                         sbr->data[ch].W, sbr->data[ch].Ypos);                                                                                              
+        sbr_lf_gen(ac, sbr, sbr->X_low, sbr->data[ch].W, sbr->data[ch].Ypos);                                                                        
+        sbr->data[ch].Ypos ^= 1;                                                                                                                            
+        if (sbr->start) {                                                                                                                                   
+            sbr_hf_inverse_filter(&sbr->dsp, sbr->alpha0, sbr->alpha1, sbr->X_low, sbr->k[0]);                                                       
+            sbr_chirp(sbr, &sbr->data[ch]);                                                                                                                 
+            sbr_hf_gen(ac, sbr, sbr->X_high, sbr->X_low, sbr->alpha0, sbr->alpha1,                                                                          
+                       sbr->data[ch].bw_array, sbr->data[ch].t_env,                                                                                         
+                       sbr->data[ch].bs_num_env);                                                                                                           
+                                                                                                                                                            
+            // hf_adj                                                                                                                                       
+            err = sbr_mapping(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);                                                                                  
+            if (!err) {                                                                                                                                     
+                sbr_env_estimate(sbr->e_curr, sbr->X_high, sbr, &sbr->data[ch]);                                                                            
+                sbr_gain_calc(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);                                                                                  
+                sbr_hf_assemble(sbr->data[ch].Y[sbr->data[ch].Ypos],                                                                                 
+                                sbr->X_high, sbr, &sbr->data[ch],                                                                                           
+                                sbr->data[ch].e_a); 
+            }                                                                                                                                               
+        }                                                                                                                                                   
+                                                                                                                                                            
+        /* synthesis */                                                                                                                                     
+        sbr_x_gen(sbr, sbr->X[ch],                                                                                                                   
+                  sbr->data[ch].Y[1-sbr->data[ch].Ypos],                                                                                                    
+                  sbr->data[ch].Y[  sbr->data[ch].Ypos],                                                                                                    
+                  sbr->X_low, ch);                                                                                                                          
+    }                                                                                                                                                       
+                                                                                                                                                            
+    if (ac->oc[1].m4ac.ps == 1) {                                                                                                                           
+        if (sbr->ps.start) {                                                                                                                                
+            AAC_RENAME(ff_ps_apply)(ac->avctx, &sbr->ps, sbr->X[0], sbr->X[1], sbr->kx[1] + sbr->m[1]);                                                     
+        } else {                                                                                                                                            
+            memcpy(sbr->X[1], sbr->X[0], sizeof(sbr->X[0]));                                                                                                
+        }                                                                                                                                                   
+        nch = 2;                                                                                                                                            
+    }                                                                                                                                                       
+#if CONFIG_AAC_FIXED
+    sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp, &ac->fdsp, 
+#else
+    sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp,&sbr->dsp,&ac->fdsp, 
+#endif                                                                                                    
+                      L, sbr->X[0], sbr->qmf_filter_scratch,                                                                                                
+                      sbr->data[0].synthesis_filterbank_samples,                                                                                            
+                      &sbr->data[0].synthesis_filterbank_samples_offset,                                                                                    
+                      downsampled);                                                                                                                         
+    if (nch == 2)                                                                                                                                           
+#if CONFIG_AAC_FIXED
+    sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp, &ac->fdsp, 
+#else
+    sbr_qmf_synthesis(&sbr->mdct, &sbr->dsp,&sbr->dsp,&ac->fdsp, 
+#endif                                                                                                  
+                          R, sbr->X[1], sbr->qmf_filter_scratch,                                                                                            
+                          sbr->data[1].synthesis_filterbank_samples,                                                                                        
+                          &sbr->data[1].synthesis_filterbank_samples_offset,                                                                                
+                          downsampled);                                                                                                                     
+}                                                                                                                                                           
+                                                                                                                                                            
+static void aacsbr_func_ptr_init(AACSBRContext *c)                                                                                                          
+{                                                                                                                                                           
+  /*  c->sbr_lf_gen            = sbr_lf_gen;                                                                                                                  
+    c->sbr_hf_assemble       = sbr_hf_assemble;                                                                                                             
+    c->sbr_x_gen             = sbr_x_gen;                                                                                                                   
+    c->sbr_hf_inverse_filter = sbr_hf_inverse_filter;       */                                                                                                
+                                                                                                                                                            
+/*#if !CONFIG_AAC_FIXED                                                                                                                                       
+    if(ARCH_MIPS)                                                                                                                                           
+        ff_aacsbr_func_ptr_init_mips(c);                                                                                                                    
+#endif      */                                                                                                                                                
+}          
diff -uNr ffmpeg-0.7.12/libavcodec/aacsbrdata.h ffmpeg-0.7.12-140902/libavcodec/aacsbrdata.h
--- ffmpeg-0.7.12/libavcodec/aacsbrdata.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacsbrdata.h	2014-09-02 15:35:08.000000000 +0800
@@ -30,9 +30,15 @@
 
 #include <stdint.h>
 #include "libavutil/mem.h"
-
+#include "aac.h"
 ///< Huffman tables for SBR
 
+#if CONFIG_AAC_FIXED
+
+#else
+
+#endif
+
 static const uint8_t t_huffman_env_1_5dB_bits[121] = {
     18, 18, 18, 18, 18, 18, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19,
@@ -267,348 +273,352 @@
 };
 
 ///< window coefficients for analysis/synthesis QMF banks
-static DECLARE_ALIGNED(16, float, sbr_qmf_window_ds)[320];
-static DECLARE_ALIGNED(16, float, sbr_qmf_window_us)[640] = {
-     0.0000000000, -0.0005525286, -0.0005617692, -0.0004947518,
-    -0.0004875227, -0.0004893791, -0.0005040714, -0.0005226564,
-    -0.0005466565, -0.0005677802, -0.0005870930, -0.0006132747,
-    -0.0006312493, -0.0006540333, -0.0006777690, -0.0006941614,
-    -0.0007157736, -0.0007255043, -0.0007440941, -0.0007490598,
-    -0.0007681371, -0.0007724848, -0.0007834332, -0.0007779869,
-    -0.0007803664, -0.0007801449, -0.0007757977, -0.0007630793,
-    -0.0007530001, -0.0007319357, -0.0007215391, -0.0006917937,
-    -0.0006650415, -0.0006341594, -0.0005946118, -0.0005564576,
-    -0.0005145572, -0.0004606325, -0.0004095121, -0.0003501175,
-    -0.0002896981, -0.0002098337, -0.0001446380, -0.0000617334,
-     0.0000134949,  0.0001094383,  0.0002043017,  0.0002949531,
-     0.0004026540,  0.0005107388,  0.0006239376,  0.0007458025,
-     0.0008608443,  0.0009885988,  0.0011250155,  0.0012577884,
-     0.0013902494,  0.0015443219,  0.0016868083,  0.0018348265,
-     0.0019841140,  0.0021461583,  0.0023017254,  0.0024625616,
-     0.0026201758,  0.0027870464,  0.0029469447,  0.0031125420,
-     0.0032739613,  0.0034418874,  0.0036008268,  0.0037603922,
-     0.0039207432,  0.0040819753,  0.0042264269,  0.0043730719,
-     0.0045209852,  0.0046606460,  0.0047932560,  0.0049137603,
-     0.0050393022,  0.0051407353,  0.0052461166,  0.0053471681,
-     0.0054196775,  0.0054876040,  0.0055475714,  0.0055938023,
-     0.0056220643,  0.0056455196,  0.0056389199,  0.0056266114,
-     0.0055917128,  0.0055404363,  0.0054753783,  0.0053838975,
-     0.0052715758,  0.0051382275,  0.0049839687,  0.0048109469,
-     0.0046039530,  0.0043801861,  0.0041251642,  0.0038456408,
-     0.0035401246,  0.0032091885,  0.0028446757,  0.0024508540,
-     0.0020274176,  0.0015784682,  0.0010902329,  0.0005832264,
-     0.0000276045, -0.0005464280, -0.0011568135, -0.0018039472,
-    -0.0024826723, -0.0031933778, -0.0039401124, -0.0047222596,
-    -0.0055337211, -0.0063792293, -0.0072615816, -0.0081798233,
-    -0.0091325329, -0.0101150215, -0.0111315548, -0.0121849995,
-     0.0132718220,  0.0143904666,  0.0155405553,  0.0167324712,
-     0.0179433381,  0.0191872431,  0.0204531793,  0.0217467550,
-     0.0230680169,  0.0244160992,  0.0257875847,  0.0271859429,
-     0.0286072173,  0.0300502657,  0.0315017608,  0.0329754081,
-     0.0344620948,  0.0359697560,  0.0374812850,  0.0390053679,
-     0.0405349170,  0.0420649094,  0.0436097542,  0.0451488405,
-     0.0466843027,  0.0482165720,  0.0497385755,  0.0512556155,
-     0.0527630746,  0.0542452768,  0.0557173648,  0.0571616450,
-     0.0585915683,  0.0599837480,  0.0613455171,  0.0626857808,
-     0.0639715898,  0.0652247106,  0.0664367512,  0.0676075985,
-     0.0687043828,  0.0697630244,  0.0707628710,  0.0717002673,
-     0.0725682583,  0.0733620255,  0.0741003642,  0.0747452558,
-     0.0753137336,  0.0758008358,  0.0761992479,  0.0764992170,
-     0.0767093490,  0.0768173975,  0.0768230011,  0.0767204924,
-     0.0765050718,  0.0761748321,  0.0757305756,  0.0751576255,
-     0.0744664394,  0.0736406005,  0.0726774642,  0.0715826364,
-     0.0703533073,  0.0689664013,  0.0674525021,  0.0657690668,
-     0.0639444805,  0.0619602779,  0.0598166570,  0.0575152691,
-     0.0550460034,  0.0524093821,  0.0495978676,  0.0466303305,
-     0.0434768782,  0.0401458278,  0.0366418116,  0.0329583930,
-     0.0290824006,  0.0250307561,  0.0207997072,  0.0163701258,
-     0.0117623832,  0.0069636862,  0.0019765601, -0.0032086896,
-    -0.0085711749, -0.0141288827, -0.0198834129, -0.0258227288,
-    -0.0319531274, -0.0382776572, -0.0447806821, -0.0514804176,
-    -0.0583705326, -0.0654409853, -0.0726943300, -0.0801372934,
-    -0.0877547536, -0.0955533352, -0.1035329531, -0.1116826931,
-    -0.1200077984, -0.1285002850, -0.1371551761, -0.1459766491,
-    -0.1549607071, -0.1640958855, -0.1733808172, -0.1828172548,
-    -0.1923966745, -0.2021250176, -0.2119735853, -0.2219652696,
-    -0.2320690870, -0.2423016884, -0.2526480309, -0.2631053299,
-    -0.2736634040, -0.2843214189, -0.2950716717, -0.3059098575,
-    -0.3168278913, -0.3278113727, -0.3388722693, -0.3499914122,
-     0.3611589903,  0.3723795546,  0.3836350013,  0.3949211761,
-     0.4062317676,  0.4175696896,  0.4289119920,  0.4402553754,
-     0.4515996535,  0.4629308085,  0.4742453214,  0.4855253091,
-     0.4967708254,  0.5079817500,  0.5191234970,  0.5302240895,
-     0.5412553448,  0.5522051258,  0.5630789140,  0.5738524131,
-     0.5845403235,  0.5951123086,  0.6055783538,  0.6159109932,
-     0.6261242695,  0.6361980107,  0.6461269695,  0.6559016302,
-     0.6655139880,  0.6749663190,  0.6842353293,  0.6933282376,
-     0.7022388719,  0.7109410426,  0.7194462634,  0.7277448900,
-     0.7358211758,  0.7436827863,  0.7513137456,  0.7587080760,
-     0.7658674865,  0.7727780881,  0.7794287519,  0.7858353120,
-     0.7919735841,  0.7978466413,  0.8034485751,  0.8087695004,
-     0.8138191270,  0.8185776004,  0.8230419890,  0.8272275347,
-     0.8311038457,  0.8346937361,  0.8379717337,  0.8409541392,
-     0.8436238281,  0.8459818469,  0.8480315777,  0.8497805198,
-     0.8511971524,  0.8523047035,  0.8531020949,  0.8535720573,
-     0.8537385600,
-};
-
-static const float sbr_noise_table[512][2] = {
-{-0.99948153278296, -0.59483417516607}, { 0.97113454393991, -0.67528515225647},
-{ 0.14130051758487, -0.95090983575689}, {-0.47005496701697, -0.37340549728647},
-{ 0.80705063769351,  0.29653668284408}, {-0.38981478896926,  0.89572605717087},
-{-0.01053049862020, -0.66959058036166}, {-0.91266367957293, -0.11522938140034},
-{ 0.54840422910309,  0.75221367176302}, { 0.40009252867955, -0.98929400334421},
-{-0.99867974711855, -0.88147068645358}, {-0.95531076805040,  0.90908757154593},
-{-0.45725933317144, -0.56716323646760}, {-0.72929675029275, -0.98008272727324},
-{ 0.75622801399036,  0.20950329995549}, { 0.07069442601050, -0.78247898470706},
-{ 0.74496252926055, -0.91169004445807}, {-0.96440182703856, -0.94739918296622},
-{ 0.30424629369539, -0.49438267012479}, { 0.66565033746925,  0.64652935542491},
-{ 0.91697008020594,  0.17514097332009}, {-0.70774918760427,  0.52548653416543},
-{-0.70051415345560, -0.45340028808763}, {-0.99496513054797, -0.90071908066973},
-{ 0.98164490790123, -0.77463155528697}, {-0.54671580548181, -0.02570928536004},
-{-0.01689629065389,  0.00287506445732}, {-0.86110349531986,  0.42548583726477},
-{-0.98892980586032, -0.87881132267556}, { 0.51756627678691,  0.66926784710139},
-{-0.99635026409640, -0.58107730574765}, {-0.99969370862163,  0.98369989360250},
-{ 0.55266258627194,  0.59449057465591}, { 0.34581177741673,  0.94879421061866},
-{ 0.62664209577999, -0.74402970906471}, {-0.77149701404973, -0.33883658042801},
-{-0.91592244254432,  0.03687901376713}, {-0.76285492357887, -0.91371867919124},
-{ 0.79788337195331, -0.93180971199849}, { 0.54473080610200, -0.11919206037186},
-{-0.85639281671058,  0.42429854760451}, {-0.92882402971423,  0.27871809078609},
-{-0.11708371046774, -0.99800843444966}, { 0.21356749817493, -0.90716295627033},
-{-0.76191692573909,  0.99768118356265}, { 0.98111043100884, -0.95854459734407},
-{-0.85913269895572,  0.95766566168880}, {-0.93307242253692,  0.49431757696466},
-{ 0.30485754879632, -0.70540034357529}, { 0.85289650925190,  0.46766131791044},
-{ 0.91328082618125, -0.99839597361769}, {-0.05890199924154,  0.70741827819497},
-{ 0.28398686150148,  0.34633555702188}, { 0.95258164539612, -0.54893416026939},
-{-0.78566324168507, -0.75568541079691}, {-0.95789495447877, -0.20423194696966},
-{ 0.82411158711197,  0.96654618432562}, {-0.65185446735885, -0.88734990773289},
-{-0.93643603134666,  0.99870790442385}, { 0.91427159529618, -0.98290505544444},
-{-0.70395684036886,  0.58796798221039}, { 0.00563771969365,  0.61768196727244},
-{ 0.89065051931895,  0.52783352697585}, {-0.68683707712762,  0.80806944710339},
-{ 0.72165342518718, -0.69259857349564}, {-0.62928247730667,  0.13627037407335},
-{ 0.29938434065514, -0.46051329682246}, {-0.91781958879280, -0.74012716684186},
-{ 0.99298717043688,  0.40816610075661}, { 0.82368298622748, -0.74036047190173},
-{-0.98512833386833, -0.99972330709594}, {-0.95915368242257, -0.99237800466040},
-{-0.21411126572790, -0.93424819052545}, {-0.68821476106884, -0.26892306315457},
-{ 0.91851997982317,  0.09358228901785}, {-0.96062769559127,  0.36099095133739},
-{ 0.51646184922287, -0.71373332873917}, { 0.61130721139669,  0.46950141175917},
-{ 0.47336129371299, -0.27333178296162}, { 0.90998308703519,  0.96715662938132},
-{ 0.44844799194357,  0.99211574628306}, { 0.66614891079092,  0.96590176169121},
-{ 0.74922239129237, -0.89879858826087}, {-0.99571588506485,  0.52785521494349},
-{ 0.97401082477563, -0.16855870075190}, { 0.72683747733879, -0.48060774432251},
-{ 0.95432193457128,  0.68849603408441}, {-0.72962208425191, -0.76608443420917},
-{-0.85359479233537,  0.88738125901579}, {-0.81412430338535, -0.97480768049637},
-{-0.87930772356786,  0.74748307690436}, {-0.71573331064977, -0.98570608178923},
-{ 0.83524300028228,  0.83702537075163}, {-0.48086065601423, -0.98848504923531},
-{ 0.97139128574778,  0.80093621198236}, { 0.51992825347895,  0.80247631400510},
-{-0.00848591195325, -0.76670128000486}, {-0.70294374303036,  0.55359910445577},
-{-0.95894428168140, -0.43265504344783}, { 0.97079252950321,  0.09325857238682},
-{-0.92404293670797,  0.85507704027855}, {-0.69506469500450,  0.98633412625459},
-{ 0.26559203620024,  0.73314307966524}, { 0.28038443336943,  0.14537913654427},
-{-0.74138124825523,  0.99310339807762}, {-0.01752795995444, -0.82616635284178},
-{-0.55126773094930, -0.98898543862153}, { 0.97960898850996, -0.94021446752851},
-{-0.99196309146936,  0.67019017358456}, {-0.67684928085260,  0.12631491649378},
-{ 0.09140039465500, -0.20537731453108}, {-0.71658965751996, -0.97788200391224},
-{ 0.81014640078925,  0.53722648362443}, { 0.40616991671205, -0.26469008598449},
-{-0.67680188682972,  0.94502052337695}, { 0.86849774348749, -0.18333598647899},
-{-0.99500381284851, -0.02634122068550}, { 0.84329189340667,  0.10406957462213},
-{-0.09215968531446,  0.69540012101253}, { 0.99956173327206, -0.12358542001404},
-{-0.79732779473535, -0.91582524736159}, { 0.96349973642406,  0.96640458041000},
-{-0.79942778496547,  0.64323902822857}, {-0.11566039853896,  0.28587846253726},
-{-0.39922954514662,  0.94129601616966}, { 0.99089197565987, -0.92062625581587},
-{ 0.28631285179909, -0.91035047143603}, {-0.83302725605608, -0.67330410892084},
-{ 0.95404443402072,  0.49162765398743}, {-0.06449863579434,  0.03250560813135},
-{-0.99575054486311,  0.42389784469507}, {-0.65501142790847,  0.82546114655624},
-{-0.81254441908887, -0.51627234660629}, {-0.99646369485481,  0.84490533520752},
-{ 0.00287840603348,  0.64768261158166}, { 0.70176989408455, -0.20453028573322},
-{ 0.96361882270190,  0.40706967140989}, {-0.68883758192426,  0.91338958840772},
-{-0.34875585502238,  0.71472290693300}, { 0.91980081243087,  0.66507455644919},
-{-0.99009048343881,  0.85868021604848}, { 0.68865791458395,  0.55660316809678},
-{-0.99484402129368, -0.20052559254934}, { 0.94214511408023, -0.99696425367461},
-{-0.67414626793544,  0.49548221180078}, {-0.47339353684664, -0.85904328834047},
-{ 0.14323651387360, -0.94145598222488}, {-0.29268293575672,  0.05759224927952},
-{ 0.43793861458754, -0.78904969892724}, {-0.36345126374441,  0.64874435357162},
-{-0.08750604656825,  0.97686944362527}, {-0.96495267812511, -0.53960305946511},
-{ 0.55526940659947,  0.78891523734774}, { 0.73538215752630,  0.96452072373404},
-{-0.30889773919437, -0.80664389776860}, { 0.03574995626194, -0.97325616900959},
-{ 0.98720684660488,  0.48409133691962}, {-0.81689296271203, -0.90827703628298},
-{ 0.67866860118215,  0.81284503870856}, {-0.15808569732583,  0.85279555024382},
-{ 0.80723395114371, -0.24717418514605}, { 0.47788757329038, -0.46333147839295},
-{ 0.96367554763201,  0.38486749303242}, {-0.99143875716818, -0.24945277239809},
-{ 0.83081876925833, -0.94780851414763}, {-0.58753191905341,  0.01290772389163},
-{ 0.95538108220960, -0.85557052096538}, {-0.96490920476211, -0.64020970923102},
-{-0.97327101028521,  0.12378128133110}, { 0.91400366022124,  0.57972471346930},
-{-0.99925837363824,  0.71084847864067}, {-0.86875903507313, -0.20291699203564},
-{-0.26240034795124, -0.68264554369108}, {-0.24664412953388, -0.87642273115183},
-{ 0.02416275806869,  0.27192914288905}, { 0.82068619590515, -0.85087787994476},
-{ 0.88547373760759, -0.89636802901469}, {-0.18173078152226, -0.26152145156800},
-{ 0.09355476558534,  0.54845123045604}, {-0.54668414224090,  0.95980774020221},
-{ 0.37050990604091, -0.59910140383171}, {-0.70373594262891,  0.91227665827081},
-{-0.34600785879594, -0.99441426144200}, {-0.68774481731008, -0.30238837956299},
-{-0.26843291251234,  0.83115668004362}, { 0.49072334613242, -0.45359708737775},
-{ 0.38975993093975,  0.95515358099121}, {-0.97757125224150,  0.05305894580606},
-{-0.17325552859616, -0.92770672250494}, { 0.99948035025744,  0.58285545563426},
-{-0.64946246527458,  0.68645507104960}, {-0.12016920576437, -0.57147322153312},
-{-0.58947456517751, -0.34847132454388}, {-0.41815140454465,  0.16276422358861},
-{ 0.99885650204884,  0.11136095490444}, {-0.56649614128386, -0.90494866361587},
-{ 0.94138021032330,  0.35281916733018}, {-0.75725076534641,  0.53650549640587},
-{ 0.20541973692630, -0.94435144369918}, { 0.99980371023351,  0.79835913565599},
-{ 0.29078277605775,  0.35393777921520}, {-0.62858772103030,  0.38765693387102},
-{ 0.43440904467688, -0.98546330463232}, {-0.98298583762390,  0.21021524625209},
-{ 0.19513029146934, -0.94239832251867}, {-0.95476662400101,  0.98364554179143},
-{ 0.93379635304810, -0.70881994583682}, {-0.85235410573336, -0.08342347966410},
-{-0.86425093011245, -0.45795025029466}, { 0.38879779059045,  0.97274429344593},
-{ 0.92045124735495, -0.62433652524220}, { 0.89162532251878,  0.54950955570563},
-{-0.36834336949252,  0.96458298020975}, { 0.93891760988045, -0.89968353740388},
-{ 0.99267657565094, -0.03757034316958}, {-0.94063471614176,  0.41332338538963},
-{ 0.99740224117019, -0.16830494996370}, {-0.35899413170555, -0.46633226649613},
-{ 0.05237237274947, -0.25640361602661}, { 0.36703583957424, -0.38653265641875},
-{ 0.91653180367913, -0.30587628726597}, { 0.69000803499316,  0.90952171386132},
-{-0.38658751133527,  0.99501571208985}, {-0.29250814029851,  0.37444994344615},
-{-0.60182204677608,  0.86779651036123}, {-0.97418588163217,  0.96468523666475},
-{ 0.88461574003963,  0.57508405276414}, { 0.05198933055162,  0.21269661669964},
-{-0.53499621979720,  0.97241553731237}, {-0.49429560226497,  0.98183865291903},
-{-0.98935142339139, -0.40249159006933}, {-0.98081380091130, -0.72856895534041},
-{-0.27338148835532,  0.99950922447209}, { 0.06310802338302, -0.54539587529618},
-{-0.20461677199539, -0.14209977628489}, { 0.66223843141647,  0.72528579940326},
-{-0.84764345483665,  0.02372316801261}, {-0.89039863483811,  0.88866581484602},
-{ 0.95903308477986,  0.76744927173873}, { 0.73504123909879, -0.03747203173192},
-{-0.31744434966056, -0.36834111883652}, {-0.34110827591623,  0.40211222807691},
-{ 0.47803883714199, -0.39423219786288}, { 0.98299195879514,  0.01989791390047},
-{-0.30963073129751, -0.18076720599336}, { 0.99992588229018, -0.26281872094289},
-{-0.93149731080767, -0.98313162570490}, { 0.99923472302773, -0.80142993767554},
-{-0.26024169633417, -0.75999759855752}, {-0.35712514743563,  0.19298963768574},
-{-0.99899084509530,  0.74645156992493}, { 0.86557171579452,  0.55593866696299},
-{ 0.33408042438752,  0.86185953874709}, { 0.99010736374716,  0.04602397576623},
-{-0.66694269691195, -0.91643611810148}, { 0.64016792079480,  0.15649530836856},
-{ 0.99570534804836,  0.45844586038111}, {-0.63431466947340,  0.21079116459234},
-{-0.07706847005931, -0.89581437101329}, { 0.98590090577724,  0.88241721133981},
-{ 0.80099335254678, -0.36851896710853}, { 0.78368131392666,  0.45506999802597},
-{ 0.08707806671691,  0.80938994918745}, {-0.86811883080712,  0.39347308654705},
-{-0.39466529740375, -0.66809432114456}, { 0.97875325649683, -0.72467840967746},
-{-0.95038560288864,  0.89563219587625}, { 0.17005239424212,  0.54683053962658},
-{-0.76910792026848, -0.96226617549298}, { 0.99743281016846,  0.42697157037567},
-{ 0.95437383549973,  0.97002324109952}, { 0.99578905365569, -0.54106826257356},
-{ 0.28058259829990, -0.85361420634036}, { 0.85256524470573, -0.64567607735589},
-{-0.50608540105128, -0.65846015480300}, {-0.97210735183243, -0.23095213067791},
-{ 0.95424048234441, -0.99240147091219}, {-0.96926570524023,  0.73775654896574},
-{ 0.30872163214726,  0.41514960556126}, {-0.24523839572639,  0.63206633394807},
-{-0.33813265086024, -0.38661779441897}, {-0.05826828420146, -0.06940774188029},
-{-0.22898461455054,  0.97054853316316}, {-0.18509915019881,  0.47565762892084},
-{-0.10488238045009, -0.87769947402394}, {-0.71886586182037,  0.78030982480538},
-{ 0.99793873738654,  0.90041310491497}, { 0.57563307626120, -0.91034337352097},
-{ 0.28909646383717,  0.96307783970534}, { 0.42188998312520,  0.48148651230437},
-{ 0.93335049681047, -0.43537023883588}, {-0.97087374418267,  0.86636445711364},
-{ 0.36722871286923,  0.65291654172961}, {-0.81093025665696,  0.08778370229363},
-{-0.26240603062237, -0.92774095379098}, { 0.83996497984604,  0.55839849139647},
-{-0.99909615720225, -0.96024605713970}, { 0.74649464155061,  0.12144893606462},
-{-0.74774595569805, -0.26898062008959}, { 0.95781667469567, -0.79047927052628},
-{ 0.95472308713099, -0.08588776019550}, { 0.48708332746299,  0.99999041579432},
-{ 0.46332038247497,  0.10964126185063}, {-0.76497004940162,  0.89210929242238},
-{ 0.57397389364339,  0.35289703373760}, { 0.75374316974495,  0.96705214651335},
-{-0.59174397685714, -0.89405370422752}, { 0.75087906691890, -0.29612672982396},
-{-0.98607857336230,  0.25034911730023}, {-0.40761056640505, -0.90045573444695},
-{ 0.66929266740477,  0.98629493401748}, {-0.97463695257310, -0.00190223301301},
-{ 0.90145509409859,  0.99781390365446}, {-0.87259289048043,  0.99233587353666},
-{-0.91529461447692, -0.15698707534206}, {-0.03305738840705, -0.37205262859764},
-{ 0.07223051368337, -0.88805001733626}, { 0.99498012188353,  0.97094358113387},
-{-0.74904939500519,  0.99985483641521}, { 0.04585228574211,  0.99812337444082},
-{-0.89054954257993, -0.31791913188064}, {-0.83782144651251,  0.97637632547466},
-{ 0.33454804933804, -0.86231516800408}, {-0.99707579362824,  0.93237990079441},
-{-0.22827527843994,  0.18874759397997}, { 0.67248046289143, -0.03646211390569},
-{-0.05146538187944, -0.92599700120679}, { 0.99947295749905,  0.93625229707912},
-{ 0.66951124390363,  0.98905825623893}, {-0.99602956559179, -0.44654715757688},
-{ 0.82104905483590,  0.99540741724928}, { 0.99186510988782,  0.72023001312947},
-{-0.65284592392918,  0.52186723253637}, { 0.93885443798188, -0.74895312615259},
-{ 0.96735248738388,  0.90891816978629}, {-0.22225968841114,  0.57124029781228},
-{-0.44132783753414, -0.92688840659280}, {-0.85694974219574,  0.88844532719844},
-{ 0.91783042091762, -0.46356892383970}, { 0.72556974415690, -0.99899555770747},
-{-0.99711581834508,  0.58211560180426}, { 0.77638976371966,  0.94321834873819},
-{ 0.07717324253925,  0.58638399856595}, {-0.56049829194163,  0.82522301569036},
-{ 0.98398893639988,  0.39467440420569}, { 0.47546946844938,  0.68613044836811},
-{ 0.65675089314631,  0.18331637134880}, { 0.03273375457980, -0.74933109564108},
-{-0.38684144784738,  0.51337349030406}, {-0.97346267944545, -0.96549364384098},
-{-0.53282156061942, -0.91423265091354}, { 0.99817310731176,  0.61133572482148},
-{-0.50254500772635, -0.88829338134294}, { 0.01995873238855,  0.85223515096765},
-{ 0.99930381973804,  0.94578896296649}, { 0.82907767600783, -0.06323442598128},
-{-0.58660709669728,  0.96840773806582}, {-0.17573736667267, -0.48166920859485},
-{ 0.83434292401346, -0.13023450646997}, { 0.05946491307025,  0.20511047074866},
-{ 0.81505484574602, -0.94685947861369}, {-0.44976380954860,  0.40894572671545},
-{-0.89746474625671,  0.99846578838537}, { 0.39677256130792, -0.74854668609359},
-{-0.07588948563079,  0.74096214084170}, { 0.76343198951445,  0.41746629422634},
-{-0.74490104699626,  0.94725911744610}, { 0.64880119792759,  0.41336660830571},
-{ 0.62319537462542, -0.93098313552599}, { 0.42215817594807, -0.07712787385208},
-{ 0.02704554141885, -0.05417518053666}, { 0.80001773566818,  0.91542195141039},
-{-0.79351832348816, -0.36208897989136}, { 0.63872359151636,  0.08128252493444},
-{ 0.52890520960295,  0.60048872455592}, { 0.74238552914587,  0.04491915291044},
-{ 0.99096131449250, -0.19451182854402}, {-0.80412329643109, -0.88513818199457},
-{-0.64612616129736,  0.72198674804544}, { 0.11657770663191, -0.83662833815041},
-{-0.95053182488101, -0.96939905138082}, {-0.62228872928622,  0.82767262846661},
-{ 0.03004475787316, -0.99738896333384}, {-0.97987214341034,  0.36526129686425},
-{-0.99986980746200, -0.36021610299715}, { 0.89110648599879, -0.97894250343044},
-{ 0.10407960510582,  0.77357793811619}, { 0.95964737821728, -0.35435818285502},
-{ 0.50843233159162,  0.96107691266205}, { 0.17006334670615, -0.76854025314829},
-{ 0.25872675063360,  0.99893303933816}, {-0.01115998681937,  0.98496019742444},
-{-0.79598702973261,  0.97138411318894}, {-0.99264708948101, -0.99542822402536},
-{-0.99829663752818,  0.01877138824311}, {-0.70801016548184,  0.33680685948117},
-{-0.70467057786826,  0.93272777501857}, { 0.99846021905254, -0.98725746254433},
-{-0.63364968534650, -0.16473594423746}, {-0.16258217500792, -0.95939125400802},
-{-0.43645594360633, -0.94805030113284}, {-0.99848471702976,  0.96245166923809},
-{-0.16796458968998, -0.98987511890470}, {-0.87979225745213, -0.71725725041680},
-{ 0.44183099021786, -0.93568974498761}, { 0.93310180125532, -0.99913308068246},
-{-0.93941931782002, -0.56409379640356}, {-0.88590003188677,  0.47624600491382},
-{ 0.99971463703691, -0.83889954253462}, {-0.75376385639978,  0.00814643438625},
-{ 0.93887685615875, -0.11284528204636}, { 0.85126435782309,  0.52349251543547},
-{ 0.39701421446381,  0.81779634174316}, {-0.37024464187437, -0.87071656222959},
-{-0.36024828242896,  0.34655735648287}, {-0.93388812549209, -0.84476541096429},
-{-0.65298804552119, -0.18439575450921}, { 0.11960319006843,  0.99899346780168},
-{ 0.94292565553160,  0.83163906518293}, { 0.75081145286948, -0.35533223142265},
-{ 0.56721979748394, -0.24076836414499}, { 0.46857766746029, -0.30140233457198},
-{ 0.97312313923635, -0.99548191630031}, {-0.38299976567017,  0.98516909715427},
-{ 0.41025800019463,  0.02116736935734}, { 0.09638062008048,  0.04411984381457},
-{-0.85283249275397,  0.91475563922421}, { 0.88866808958124, -0.99735267083226},
-{-0.48202429536989, -0.96805608884164}, { 0.27572582416567,  0.58634753335832},
-{-0.65889129659168,  0.58835634138583}, { 0.98838086953732,  0.99994349600236},
-{-0.20651349620689,  0.54593044066355}, {-0.62126416356920, -0.59893681700392},
-{ 0.20320105410437, -0.86879180355289}, {-0.97790548600584,  0.96290806999242},
-{ 0.11112534735126,  0.21484763313301}, {-0.41368337314182,  0.28216837680365},
-{ 0.24133038992960,  0.51294362630238}, {-0.66393410674885, -0.08249679629081},
-{-0.53697829178752, -0.97649903936228}, {-0.97224737889348,  0.22081333579837},
-{ 0.87392477144549, -0.12796173740361}, { 0.19050361015753,  0.01602615387195},
-{-0.46353441212724, -0.95249041539006}, {-0.07064096339021, -0.94479803205886},
-{-0.92444085484466, -0.10457590187436}, {-0.83822593578728, -0.01695043208885},
-{ 0.75214681811150, -0.99955681042665}, {-0.42102998829339,  0.99720941999394},
-{-0.72094786237696, -0.35008961934255}, { 0.78843311019251,  0.52851398958271},
-{ 0.97394027897442, -0.26695944086561}, { 0.99206463477946, -0.57010120849429},
-{ 0.76789609461795, -0.76519356730966}, {-0.82002421836409, -0.73530179553767},
-{ 0.81924990025724,  0.99698425250579}, {-0.26719850873357,  0.68903369776193},
-{-0.43311260380975,  0.85321815947490}, { 0.99194979673836,  0.91876249766422},
-{-0.80692001248487, -0.32627540663214}, { 0.43080003649976, -0.21919095636638},
-{ 0.67709491937357, -0.95478075822906}, { 0.56151770568316, -0.70693811747778},
-{ 0.10831862810749, -0.08628837174592}, { 0.91229417540436, -0.65987351408410},
-{-0.48972893932274,  0.56289246362686}, {-0.89033658689697, -0.71656563987082},
-{ 0.65269447475094,  0.65916004833932}, { 0.67439478141121, -0.81684380846796},
-{-0.47770832416973, -0.16789556203025}, {-0.99715979260878, -0.93565784007648},
-{-0.90889593602546,  0.62034397054380}, {-0.06618622548177, -0.23812217221359},
-{ 0.99430266919728,  0.18812555317553}, { 0.97686402381843, -0.28664534366620},
-{ 0.94813650221268, -0.97506640027128}, {-0.95434497492853, -0.79607978501983},
-{-0.49104783137150,  0.32895214359663}, { 0.99881175120751,  0.88993983831354},
-{ 0.50449166760303, -0.85995072408434}, { 0.47162891065108, -0.18680204049569},
-{-0.62081581361840,  0.75000676218956}, {-0.43867015250812,  0.99998069244322},
-{ 0.98630563232075, -0.53578899600662}, {-0.61510362277374, -0.89515019899997},
-{-0.03841517601843, -0.69888815681179}, {-0.30102157304644, -0.07667808922205},
-{ 0.41881284182683,  0.02188098922282}, {-0.86135454941237,  0.98947480909359},
-{ 0.67226861393788, -0.13494389011014}, {-0.70737398842068, -0.76547349325992},
-{ 0.94044946687963,  0.09026201157416}, {-0.82386352534327,  0.08924768823676},
-{-0.32070666698656,  0.50143421908753}, { 0.57593163224487, -0.98966422921509},
-{-0.36326018419965,  0.07440243123228}, { 0.99979044674350, -0.14130287347405},
-{-0.92366023326932, -0.97979298068180}, {-0.44607178518598, -0.54233252016394},
-{ 0.44226800932956,  0.71326756742752}, { 0.03671907158312,  0.63606389366675},
-{ 0.52175424682195, -0.85396826735705}, {-0.94701139690956, -0.01826348194255},
-{-0.98759606946049,  0.82288714303073}, { 0.87434794743625,  0.89399495655433},
-{-0.93412041758744,  0.41374052024363}, { 0.96063943315511,  0.93116709541280},
-{ 0.97534253457837,  0.86150930812689}, { 0.99642466504163,  0.70190043427512},
-{-0.94705089665984, -0.29580042814306}, { 0.91599807087376, -0.98147830385781},
+static DECLARE_ALIGNED(32, INTFLOAT, sbr_qmf_window_ds)[320];
+static DECLARE_ALIGNED(32, INTFLOAT, sbr_qmf_window_us)[640] = {
+    Q31( 0.0000000000f), Q31(-0.0005525286f), Q31(-0.0005617692f), Q31(-0.0004947518f),
+    Q31(-0.0004875227f), Q31(-0.0004893791f), Q31(-0.0005040714f), Q31(-0.0005226564f),
+    Q31(-0.0005466565f), Q31(-0.0005677802f), Q31(-0.0005870930f), Q31(-0.0006132747f),
+    Q31(-0.0006312493f), Q31(-0.0006540333f), Q31(-0.0006777690f), Q31(-0.0006941614f),
+    Q31(-0.0007157736f), Q31(-0.0007255043f), Q31(-0.0007440941f), Q31(-0.0007490598f),
+    Q31(-0.0007681371f), Q31(-0.0007724848f), Q31(-0.0007834332f), Q31(-0.0007779869f),
+    Q31(-0.0007803664f), Q31(-0.0007801449f), Q31(-0.0007757977f), Q31(-0.0007630793f),
+    Q31(-0.0007530001f), Q31(-0.0007319357f), Q31(-0.0007215391f), Q31(-0.0006917937f),
+    Q31(-0.0006650415f), Q31(-0.0006341594f), Q31(-0.0005946118f), Q31(-0.0005564576f),
+    Q31(-0.0005145572f), Q31(-0.0004606325f), Q31(-0.0004095121f), Q31(-0.0003501175f),
+    Q31(-0.0002896981f), Q31(-0.0002098337f), Q31(-0.0001446380f), Q31(-0.0000617334f),
+    Q31( 0.0000134949f), Q31( 0.0001094383f), Q31( 0.0002043017f), Q31( 0.0002949531f),
+    Q31( 0.0004026540f), Q31( 0.0005107388f), Q31( 0.0006239376f), Q31( 0.0007458025f),
+    Q31( 0.0008608443f), Q31( 0.0009885988f), Q31( 0.0011250155f), Q31( 0.0012577884f),
+    Q31( 0.0013902494f), Q31( 0.0015443219f), Q31( 0.0016868083f), Q31( 0.0018348265f),
+    Q31( 0.0019841140f), Q31( 0.0021461583f), Q31( 0.0023017254f), Q31( 0.0024625616f),
+    Q31( 0.0026201758f), Q31( 0.0027870464f), Q31( 0.0029469447f), Q31( 0.0031125420f),
+    Q31( 0.0032739613f), Q31( 0.0034418874f), Q31( 0.0036008268f), Q31( 0.0037603922f),
+    Q31( 0.0039207432f), Q31( 0.0040819753f), Q31( 0.0042264269f), Q31( 0.0043730719f),
+    Q31( 0.0045209852f), Q31( 0.0046606460f), Q31( 0.0047932560f), Q31( 0.0049137603f),
+    Q31( 0.0050393022f), Q31( 0.0051407353f), Q31( 0.0052461166f), Q31( 0.0053471681f),
+    Q31( 0.0054196775f), Q31( 0.0054876040f), Q31( 0.0055475714f), Q31( 0.0055938023f),
+    Q31( 0.0056220643f), Q31( 0.0056455196f), Q31( 0.0056389199f), Q31( 0.0056266114f),
+    Q31( 0.0055917128f), Q31( 0.0055404363f), Q31( 0.0054753783f), Q31( 0.0053838975f),
+    Q31( 0.0052715758f), Q31( 0.0051382275f), Q31( 0.0049839687f), Q31( 0.0048109469f),
+    Q31( 0.0046039530f), Q31( 0.0043801861f), Q31( 0.0041251642f), Q31( 0.0038456408f),
+    Q31( 0.0035401246f), Q31( 0.0032091885f), Q31( 0.0028446757f), Q31( 0.0024508540f),
+    Q31( 0.0020274176f), Q31( 0.0015784682f), Q31( 0.0010902329f), Q31( 0.0005832264f),
+    Q31( 0.0000276045f), Q31(-0.0005464280f), Q31(-0.0011568135f), Q31(-0.0018039472f),
+    Q31(-0.0024826723f), Q31(-0.0031933778f), Q31(-0.0039401124f), Q31(-0.0047222596f),
+    Q31(-0.0055337211f), Q31(-0.0063792293f), Q31(-0.0072615816f), Q31(-0.0081798233f),
+    Q31(-0.0091325329f), Q31(-0.0101150215f), Q31(-0.0111315548f), Q31(-0.0121849995f),
+    Q31( 0.0132718220f), Q31( 0.0143904666f), Q31( 0.0155405553f), Q31( 0.0167324712f),
+    Q31( 0.0179433381f), Q31( 0.0191872431f), Q31( 0.0204531793f), Q31( 0.0217467550f),
+    Q31( 0.0230680169f), Q31( 0.0244160992f), Q31( 0.0257875847f), Q31( 0.0271859429f),
+    Q31( 0.0286072173f), Q31( 0.0300502657f), Q31( 0.0315017608f), Q31( 0.0329754081f),
+    Q31( 0.0344620948f), Q31( 0.0359697560f), Q31( 0.0374812850f), Q31( 0.0390053679f),
+    Q31( 0.0405349170f), Q31( 0.0420649094f), Q31( 0.0436097542f), Q31( 0.0451488405f),
+    Q31( 0.0466843027f), Q31( 0.0482165720f), Q31( 0.0497385755f), Q31( 0.0512556155f),
+    Q31( 0.0527630746f), Q31( 0.0542452768f), Q31( 0.0557173648f), Q31( 0.0571616450f),
+    Q31( 0.0585915683f), Q31( 0.0599837480f), Q31( 0.0613455171f), Q31( 0.0626857808f),
+    Q31( 0.0639715898f), Q31( 0.0652247106f), Q31( 0.0664367512f), Q31( 0.0676075985f),
+    Q31( 0.0687043828f), Q31( 0.0697630244f), Q31( 0.0707628710f), Q31( 0.0717002673f),
+    Q31( 0.0725682583f), Q31( 0.0733620255f), Q31( 0.0741003642f), Q31( 0.0747452558f),
+    Q31( 0.0753137336f), Q31( 0.0758008358f), Q31( 0.0761992479f), Q31( 0.0764992170f),
+    Q31( 0.0767093490f), Q31( 0.0768173975f), Q31( 0.0768230011f), Q31( 0.0767204924f),
+    Q31( 0.0765050718f), Q31( 0.0761748321f), Q31( 0.0757305756f), Q31( 0.0751576255f),
+    Q31( 0.0744664394f), Q31( 0.0736406005f), Q31( 0.0726774642f), Q31( 0.0715826364f),
+    Q31( 0.0703533073f), Q31( 0.0689664013f), Q31( 0.0674525021f), Q31( 0.0657690668f),
+    Q31( 0.0639444805f), Q31( 0.0619602779f), Q31( 0.0598166570f), Q31( 0.0575152691f),
+    Q31( 0.0550460034f), Q31( 0.0524093821f), Q31( 0.0495978676f), Q31( 0.0466303305f),
+    Q31( 0.0434768782f), Q31( 0.0401458278f), Q31( 0.0366418116f), Q31( 0.0329583930f),
+    Q31( 0.0290824006f), Q31( 0.0250307561f), Q31( 0.0207997072f), Q31( 0.0163701258f),
+    Q31( 0.0117623832f), Q31( 0.0069636862f), Q31( 0.0019765601f), Q31(-0.0032086896f),
+    Q31(-0.0085711749f), Q31(-0.0141288827f), Q31(-0.0198834129f), Q31(-0.0258227288f),
+    Q31(-0.0319531274f), Q31(-0.0382776572f), Q31(-0.0447806821f), Q31(-0.0514804176f),
+    Q31(-0.0583705326f), Q31(-0.0654409853f), Q31(-0.0726943300f), Q31(-0.0801372934f),
+    Q31(-0.0877547536f), Q31(-0.0955533352f), Q31(-0.1035329531f), Q31(-0.1116826931f),
+    Q31(-0.1200077984f), Q31(-0.1285002850f), Q31(-0.1371551761f), Q31(-0.1459766491f),
+    Q31(-0.1549607071f), Q31(-0.1640958855f), Q31(-0.1733808172f), Q31(-0.1828172548f),
+    Q31(-0.1923966745f), Q31(-0.2021250176f), Q31(-0.2119735853f), Q31(-0.2219652696f),
+    Q31(-0.2320690870f), Q31(-0.2423016884f), Q31(-0.2526480309f), Q31(-0.2631053299f),
+    Q31(-0.2736634040f), Q31(-0.2843214189f), Q31(-0.2950716717f), Q31(-0.3059098575f),
+    Q31(-0.3168278913f), Q31(-0.3278113727f), Q31(-0.3388722693f), Q31(-0.3499914122f),
+    Q31( 0.3611589903f), Q31( 0.3723795546f), Q31( 0.3836350013f), Q31( 0.3949211761f),
+    Q31( 0.4062317676f), Q31( 0.4175696896f), Q31( 0.4289119920f), Q31( 0.4402553754f),
+    Q31( 0.4515996535f), Q31( 0.4629308085f), Q31( 0.4742453214f), Q31( 0.4855253091f),
+    Q31( 0.4967708254f), Q31( 0.5079817500f), Q31( 0.5191234970f), Q31( 0.5302240895f),
+    Q31( 0.5412553448f), Q31( 0.5522051258f), Q31( 0.5630789140f), Q31( 0.5738524131f),
+    Q31( 0.5845403235f), Q31( 0.5951123086f), Q31( 0.6055783538f), Q31( 0.6159109932f),
+    Q31( 0.6261242695f), Q31( 0.6361980107f), Q31( 0.6461269695f), Q31( 0.6559016302f),
+    Q31( 0.6655139880f), Q31( 0.6749663190f), Q31( 0.6842353293f), Q31( 0.6933282376f),
+    Q31( 0.7022388719f), Q31( 0.7109410426f), Q31( 0.7194462634f), Q31( 0.7277448900f),
+    Q31( 0.7358211758f), Q31( 0.7436827863f), Q31( 0.7513137456f), Q31( 0.7587080760f),
+    Q31( 0.7658674865f), Q31( 0.7727780881f), Q31( 0.7794287519f), Q31( 0.7858353120f),
+    Q31( 0.7919735841f), Q31( 0.7978466413f), Q31( 0.8034485751f), Q31( 0.8087695004f),
+    Q31( 0.8138191270f), Q31( 0.8185776004f), Q31( 0.8230419890f), Q31( 0.8272275347f),
+    Q31( 0.8311038457f), Q31( 0.8346937361f), Q31( 0.8379717337f), Q31( 0.8409541392f),
+    Q31( 0.8436238281f), Q31( 0.8459818469f), Q31( 0.8480315777f), Q31( 0.8497805198f),
+    Q31( 0.8511971524f), Q31( 0.8523047035f), Q31( 0.8531020949f), Q31( 0.8535720573f),
+    Q31( 0.8537385600f),
+};
+
+const DECLARE_ALIGNED(32, INTFLOAT, AAC_RENAME(ff_sbr_noise_table))[][2] = {
+{Q31(-0.99948153278296f), Q31(-0.59483417516607f)}, {Q31( 0.97113454393991f), Q31(-0.67528515225647f)},
+{Q31( 0.14130051758487f), Q31(-0.95090983575689f)}, {Q31(-0.47005496701697f), Q31(-0.37340549728647f)},
+{Q31( 0.80705063769351f), Q31( 0.29653668284408f)}, {Q31(-0.38981478896926f), Q31( 0.89572605717087f)},
+{Q31(-0.01053049862020f), Q31(-0.66959058036166f)}, {Q31(-0.91266367957293f), Q31(-0.11522938140034f)},
+{Q31( 0.54840422910309f), Q31( 0.75221367176302f)}, {Q31( 0.40009252867955f), Q31(-0.98929400334421f)},
+{Q31(-0.99867974711855f), Q31(-0.88147068645358f)}, {Q31(-0.95531076805040f), Q31( 0.90908757154593f)},
+{Q31(-0.45725933317144f), Q31(-0.56716323646760f)}, {Q31(-0.72929675029275f), Q31(-0.98008272727324f)},
+{Q31( 0.75622801399036f), Q31( 0.20950329995549f)}, {Q31( 0.07069442601050f), Q31(-0.78247898470706f)},
+{Q31( 0.74496252926055f), Q31(-0.91169004445807f)}, {Q31(-0.96440182703856f), Q31(-0.94739918296622f)},
+{Q31( 0.30424629369539f), Q31(-0.49438267012479f)}, {Q31( 0.66565033746925f), Q31( 0.64652935542491f)},
+{Q31( 0.91697008020594f), Q31( 0.17514097332009f)}, {Q31(-0.70774918760427f), Q31( 0.52548653416543f)},
+{Q31(-0.70051415345560f), Q31(-0.45340028808763f)}, {Q31(-0.99496513054797f), Q31(-0.90071908066973f)},
+{Q31( 0.98164490790123f), Q31(-0.77463155528697f)}, {Q31(-0.54671580548181f), Q31(-0.02570928536004f)},
+{Q31(-0.01689629065389f), Q31( 0.00287506445732f)}, {Q31(-0.86110349531986f), Q31( 0.42548583726477f)},
+{Q31(-0.98892980586032f), Q31(-0.87881132267556f)}, {Q31( 0.51756627678691f), Q31( 0.66926784710139f)},
+{Q31(-0.99635026409640f), Q31(-0.58107730574765f)}, {Q31(-0.99969370862163f), Q31( 0.98369989360250f)},
+{Q31( 0.55266258627194f), Q31( 0.59449057465591f)}, {Q31( 0.34581177741673f), Q31( 0.94879421061866f)},
+{Q31( 0.62664209577999f), Q31(-0.74402970906471f)}, {Q31(-0.77149701404973f), Q31(-0.33883658042801f)},
+{Q31(-0.91592244254432f), Q31( 0.03687901376713f)}, {Q31(-0.76285492357887f), Q31(-0.91371867919124f)},
+{Q31( 0.79788337195331f), Q31(-0.93180971199849f)}, {Q31( 0.54473080610200f), Q31(-0.11919206037186f)},
+{Q31(-0.85639281671058f), Q31( 0.42429854760451f)}, {Q31(-0.92882402971423f), Q31( 0.27871809078609f)},
+{Q31(-0.11708371046774f), Q31(-0.99800843444966f)}, {Q31( 0.21356749817493f), Q31(-0.90716295627033f)},
+{Q31(-0.76191692573909f), Q31( 0.99768118356265f)}, {Q31( 0.98111043100884f), Q31(-0.95854459734407f)},
+{Q31(-0.85913269895572f), Q31( 0.95766566168880f)}, {Q31(-0.93307242253692f), Q31( 0.49431757696466f)},
+{Q31( 0.30485754879632f), Q31(-0.70540034357529f)}, {Q31( 0.85289650925190f), Q31( 0.46766131791044f)},
+{Q31( 0.91328082618125f), Q31(-0.99839597361769f)}, {Q31(-0.05890199924154f), Q31( 0.70741827819497f)},
+{Q31( 0.28398686150148f), Q31( 0.34633555702188f)}, {Q31( 0.95258164539612f), Q31(-0.54893416026939f)},
+{Q31(-0.78566324168507f), Q31(-0.75568541079691f)}, {Q31(-0.95789495447877f), Q31(-0.20423194696966f)},
+{Q31( 0.82411158711197f), Q31( 0.96654618432562f)}, {Q31(-0.65185446735885f), Q31(-0.88734990773289f)},
+{Q31(-0.93643603134666f), Q31( 0.99870790442385f)}, {Q31( 0.91427159529618f), Q31(-0.98290505544444f)},
+{Q31(-0.70395684036886f), Q31( 0.58796798221039f)}, {Q31( 0.00563771969365f), Q31( 0.61768196727244f)},
+{Q31( 0.89065051931895f), Q31( 0.52783352697585f)}, {Q31(-0.68683707712762f), Q31( 0.80806944710339f)},
+{Q31( 0.72165342518718f), Q31(-0.69259857349564f)}, {Q31(-0.62928247730667f), Q31( 0.13627037407335f)},
+{Q31( 0.29938434065514f), Q31(-0.46051329682246f)}, {Q31(-0.91781958879280f), Q31(-0.74012716684186f)},
+{Q31( 0.99298717043688f), Q31( 0.40816610075661f)}, {Q31( 0.82368298622748f), Q31(-0.74036047190173f)},
+{Q31(-0.98512833386833f), Q31(-0.99972330709594f)}, {Q31(-0.95915368242257f), Q31(-0.99237800466040f)},
+{Q31(-0.21411126572790f), Q31(-0.93424819052545f)}, {Q31(-0.68821476106884f), Q31(-0.26892306315457f)},
+{Q31( 0.91851997982317f), Q31( 0.09358228901785f)}, {Q31(-0.96062769559127f), Q31( 0.36099095133739f)},
+{Q31( 0.51646184922287f), Q31(-0.71373332873917f)}, {Q31( 0.61130721139669f), Q31( 0.46950141175917f)},
+{Q31( 0.47336129371299f), Q31(-0.27333178296162f)}, {Q31( 0.90998308703519f), Q31( 0.96715662938132f)},
+{Q31( 0.44844799194357f), Q31( 0.99211574628306f)}, {Q31( 0.66614891079092f), Q31( 0.96590176169121f)},
+{Q31( 0.74922239129237f), Q31(-0.89879858826087f)}, {Q31(-0.99571588506485f), Q31( 0.52785521494349f)},
+{Q31( 0.97401082477563f), Q31(-0.16855870075190f)}, {Q31( 0.72683747733879f), Q31(-0.48060774432251f)},
+{Q31( 0.95432193457128f), Q31( 0.68849603408441f)}, {Q31(-0.72962208425191f), Q31(-0.76608443420917f)},
+{Q31(-0.85359479233537f), Q31( 0.88738125901579f)}, {Q31(-0.81412430338535f), Q31(-0.97480768049637f)},
+{Q31(-0.87930772356786f), Q31( 0.74748307690436f)}, {Q31(-0.71573331064977f), Q31(-0.98570608178923f)},
+{Q31( 0.83524300028228f), Q31( 0.83702537075163f)}, {Q31(-0.48086065601423f), Q31(-0.98848504923531f)},
+{Q31( 0.97139128574778f), Q31( 0.80093621198236f)}, {Q31( 0.51992825347895f), Q31( 0.80247631400510f)},
+{Q31(-0.00848591195325f), Q31(-0.76670128000486f)}, {Q31(-0.70294374303036f), Q31( 0.55359910445577f)},
+{Q31(-0.95894428168140f), Q31(-0.43265504344783f)}, {Q31( 0.97079252950321f), Q31( 0.09325857238682f)},
+{Q31(-0.92404293670797f), Q31( 0.85507704027855f)}, {Q31(-0.69506469500450f), Q31( 0.98633412625459f)},
+{Q31( 0.26559203620024f), Q31( 0.73314307966524f)}, {Q31( 0.28038443336943f), Q31( 0.14537913654427f)},
+{Q31(-0.74138124825523f), Q31( 0.99310339807762f)}, {Q31(-0.01752795995444f), Q31(-0.82616635284178f)},
+{Q31(-0.55126773094930f), Q31(-0.98898543862153f)}, {Q31( 0.97960898850996f), Q31(-0.94021446752851f)},
+{Q31(-0.99196309146936f), Q31( 0.67019017358456f)}, {Q31(-0.67684928085260f), Q31( 0.12631491649378f)},
+{Q31( 0.09140039465500f), Q31(-0.20537731453108f)}, {Q31(-0.71658965751996f), Q31(-0.97788200391224f)},
+{Q31( 0.81014640078925f), Q31( 0.53722648362443f)}, {Q31( 0.40616991671205f), Q31(-0.26469008598449f)},
+{Q31(-0.67680188682972f), Q31( 0.94502052337695f)}, {Q31( 0.86849774348749f), Q31(-0.18333598647899f)},
+{Q31(-0.99500381284851f), Q31(-0.02634122068550f)}, {Q31( 0.84329189340667f), Q31( 0.10406957462213f)},
+{Q31(-0.09215968531446f), Q31( 0.69540012101253f)}, {Q31( 0.99956173327206f), Q31(-0.12358542001404f)},
+{Q31(-0.79732779473535f), Q31(-0.91582524736159f)}, {Q31( 0.96349973642406f), Q31( 0.96640458041000f)},
+{Q31(-0.79942778496547f), Q31( 0.64323902822857f)}, {Q31(-0.11566039853896f), Q31( 0.28587846253726f)},
+{Q31(-0.39922954514662f), Q31( 0.94129601616966f)}, {Q31( 0.99089197565987f), Q31(-0.92062625581587f)},
+{Q31( 0.28631285179909f), Q31(-0.91035047143603f)}, {Q31(-0.83302725605608f), Q31(-0.67330410892084f)},
+{Q31( 0.95404443402072f), Q31( 0.49162765398743f)}, {Q31(-0.06449863579434f), Q31( 0.03250560813135f)},
+{Q31(-0.99575054486311f), Q31( 0.42389784469507f)}, {Q31(-0.65501142790847f), Q31( 0.82546114655624f)},
+{Q31(-0.81254441908887f), Q31(-0.51627234660629f)}, {Q31(-0.99646369485481f), Q31( 0.84490533520752f)},
+{Q31( 0.00287840603348f), Q31( 0.64768261158166f)}, {Q31( 0.70176989408455f), Q31(-0.20453028573322f)},
+{Q31( 0.96361882270190f), Q31( 0.40706967140989f)}, {Q31(-0.68883758192426f), Q31( 0.91338958840772f)},
+{Q31(-0.34875585502238f), Q31( 0.71472290693300f)}, {Q31( 0.91980081243087f), Q31( 0.66507455644919f)},
+{Q31(-0.99009048343881f), Q31( 0.85868021604848f)}, {Q31( 0.68865791458395f), Q31( 0.55660316809678f)},
+{Q31(-0.99484402129368f), Q31(-0.20052559254934f)}, {Q31( 0.94214511408023f), Q31(-0.99696425367461f)},
+{Q31(-0.67414626793544f), Q31( 0.49548221180078f)}, {Q31(-0.47339353684664f), Q31(-0.85904328834047f)},
+{Q31( 0.14323651387360f), Q31(-0.94145598222488f)}, {Q31(-0.29268293575672f), Q31( 0.05759224927952f)},
+{Q31( 0.43793861458754f), Q31(-0.78904969892724f)}, {Q31(-0.36345126374441f), Q31( 0.64874435357162f)},
+{Q31(-0.08750604656825f), Q31( 0.97686944362527f)}, {Q31(-0.96495267812511f), Q31(-0.53960305946511f)},
+{Q31( 0.55526940659947f), Q31( 0.78891523734774f)}, {Q31( 0.73538215752630f), Q31( 0.96452072373404f)},
+{Q31(-0.30889773919437f), Q31(-0.80664389776860f)}, {Q31( 0.03574995626194f), Q31(-0.97325616900959f)},
+{Q31( 0.98720684660488f), Q31( 0.48409133691962f)}, {Q31(-0.81689296271203f), Q31(-0.90827703628298f)},
+{Q31( 0.67866860118215f), Q31( 0.81284503870856f)}, {Q31(-0.15808569732583f), Q31( 0.85279555024382f)},
+{Q31( 0.80723395114371f), Q31(-0.24717418514605f)}, {Q31( 0.47788757329038f), Q31(-0.46333147839295f)},
+{Q31( 0.96367554763201f), Q31( 0.38486749303242f)}, {Q31(-0.99143875716818f), Q31(-0.24945277239809f)},
+{Q31( 0.83081876925833f), Q31(-0.94780851414763f)}, {Q31(-0.58753191905341f), Q31( 0.01290772389163f)},
+{Q31( 0.95538108220960f), Q31(-0.85557052096538f)}, {Q31(-0.96490920476211f), Q31(-0.64020970923102f)},
+{Q31(-0.97327101028521f), Q31( 0.12378128133110f)}, {Q31( 0.91400366022124f), Q31( 0.57972471346930f)},
+{Q31(-0.99925837363824f), Q31( 0.71084847864067f)}, {Q31(-0.86875903507313f), Q31(-0.20291699203564f)},
+{Q31(-0.26240034795124f), Q31(-0.68264554369108f)}, {Q31(-0.24664412953388f), Q31(-0.87642273115183f)},
+{Q31( 0.02416275806869f), Q31( 0.27192914288905f)}, {Q31( 0.82068619590515f), Q31(-0.85087787994476f)},
+{Q31( 0.88547373760759f), Q31(-0.89636802901469f)}, {Q31(-0.18173078152226f), Q31(-0.26152145156800f)},
+{Q31( 0.09355476558534f), Q31( 0.54845123045604f)}, {Q31(-0.54668414224090f), Q31( 0.95980774020221f)},
+{Q31( 0.37050990604091f), Q31(-0.59910140383171f)}, {Q31(-0.70373594262891f), Q31( 0.91227665827081f)},
+{Q31(-0.34600785879594f), Q31(-0.99441426144200f)}, {Q31(-0.68774481731008f), Q31(-0.30238837956299f)},
+{Q31(-0.26843291251234f), Q31( 0.83115668004362f)}, {Q31( 0.49072334613242f), Q31(-0.45359708737775f)},
+{Q31( 0.38975993093975f), Q31( 0.95515358099121f)}, {Q31(-0.97757125224150f), Q31( 0.05305894580606f)},
+{Q31(-0.17325552859616f), Q31(-0.92770672250494f)}, {Q31( 0.99948035025744f), Q31( 0.58285545563426f)},
+{Q31(-0.64946246527458f), Q31( 0.68645507104960f)}, {Q31(-0.12016920576437f), Q31(-0.57147322153312f)},
+{Q31(-0.58947456517751f), Q31(-0.34847132454388f)}, {Q31(-0.41815140454465f), Q31( 0.16276422358861f)},
+{Q31( 0.99885650204884f), Q31( 0.11136095490444f)}, {Q31(-0.56649614128386f), Q31(-0.90494866361587f)},
+{Q31( 0.94138021032330f), Q31( 0.35281916733018f)}, {Q31(-0.75725076534641f), Q31( 0.53650549640587f)},
+{Q31( 0.20541973692630f), Q31(-0.94435144369918f)}, {Q31( 0.99980371023351f), Q31( 0.79835913565599f)},
+{Q31( 0.29078277605775f), Q31( 0.35393777921520f)}, {Q31(-0.62858772103030f), Q31( 0.38765693387102f)},
+{Q31( 0.43440904467688f), Q31(-0.98546330463232f)}, {Q31(-0.98298583762390f), Q31( 0.21021524625209f)},
+{Q31( 0.19513029146934f), Q31(-0.94239832251867f)}, {Q31(-0.95476662400101f), Q31( 0.98364554179143f)},
+{Q31( 0.93379635304810f), Q31(-0.70881994583682f)}, {Q31(-0.85235410573336f), Q31(-0.08342347966410f)},
+{Q31(-0.86425093011245f), Q31(-0.45795025029466f)}, {Q31( 0.38879779059045f), Q31( 0.97274429344593f)},
+{Q31( 0.92045124735495f), Q31(-0.62433652524220f)}, {Q31( 0.89162532251878f), Q31( 0.54950955570563f)},
+{Q31(-0.36834336949252f), Q31( 0.96458298020975f)}, {Q31( 0.93891760988045f), Q31(-0.89968353740388f)},
+{Q31( 0.99267657565094f), Q31(-0.03757034316958f)}, {Q31(-0.94063471614176f), Q31( 0.41332338538963f)},
+{Q31( 0.99740224117019f), Q31(-0.16830494996370f)}, {Q31(-0.35899413170555f), Q31(-0.46633226649613f)},
+{Q31( 0.05237237274947f), Q31(-0.25640361602661f)}, {Q31( 0.36703583957424f), Q31(-0.38653265641875f)},
+{Q31( 0.91653180367913f), Q31(-0.30587628726597f)}, {Q31( 0.69000803499316f), Q31( 0.90952171386132f)},
+{Q31(-0.38658751133527f), Q31( 0.99501571208985f)}, {Q31(-0.29250814029851f), Q31( 0.37444994344615f)},
+{Q31(-0.60182204677608f), Q31( 0.86779651036123f)}, {Q31(-0.97418588163217f), Q31( 0.96468523666475f)},
+{Q31( 0.88461574003963f), Q31( 0.57508405276414f)}, {Q31( 0.05198933055162f), Q31( 0.21269661669964f)},
+{Q31(-0.53499621979720f), Q31( 0.97241553731237f)}, {Q31(-0.49429560226497f), Q31( 0.98183865291903f)},
+{Q31(-0.98935142339139f), Q31(-0.40249159006933f)}, {Q31(-0.98081380091130f), Q31(-0.72856895534041f)},
+{Q31(-0.27338148835532f), Q31( 0.99950922447209f)}, {Q31( 0.06310802338302f), Q31(-0.54539587529618f)},
+{Q31(-0.20461677199539f), Q31(-0.14209977628489f)}, {Q31( 0.66223843141647f), Q31( 0.72528579940326f)},
+{Q31(-0.84764345483665f), Q31( 0.02372316801261f)}, {Q31(-0.89039863483811f), Q31( 0.88866581484602f)},
+{Q31( 0.95903308477986f), Q31( 0.76744927173873f)}, {Q31( 0.73504123909879f), Q31(-0.03747203173192f)},
+{Q31(-0.31744434966056f), Q31(-0.36834111883652f)}, {Q31(-0.34110827591623f), Q31( 0.40211222807691f)},
+{Q31( 0.47803883714199f), Q31(-0.39423219786288f)}, {Q31( 0.98299195879514f), Q31( 0.01989791390047f)},
+{Q31(-0.30963073129751f), Q31(-0.18076720599336f)}, {Q31( 0.99992588229018f), Q31(-0.26281872094289f)},
+{Q31(-0.93149731080767f), Q31(-0.98313162570490f)}, {Q31( 0.99923472302773f), Q31(-0.80142993767554f)},
+{Q31(-0.26024169633417f), Q31(-0.75999759855752f)}, {Q31(-0.35712514743563f), Q31( 0.19298963768574f)},
+{Q31(-0.99899084509530f), Q31( 0.74645156992493f)}, {Q31( 0.86557171579452f), Q31( 0.55593866696299f)},
+{Q31( 0.33408042438752f), Q31( 0.86185953874709f)}, {Q31( 0.99010736374716f), Q31( 0.04602397576623f)},
+{Q31(-0.66694269691195f), Q31(-0.91643611810148f)}, {Q31( 0.64016792079480f), Q31( 0.15649530836856f)},
+{Q31( 0.99570534804836f), Q31( 0.45844586038111f)}, {Q31(-0.63431466947340f), Q31( 0.21079116459234f)},
+{Q31(-0.07706847005931f), Q31(-0.89581437101329f)}, {Q31( 0.98590090577724f), Q31( 0.88241721133981f)},
+{Q31( 0.80099335254678f), Q31(-0.36851896710853f)}, {Q31( 0.78368131392666f), Q31( 0.45506999802597f)},
+{Q31( 0.08707806671691f), Q31( 0.80938994918745f)}, {Q31(-0.86811883080712f), Q31( 0.39347308654705f)},
+{Q31(-0.39466529740375f), Q31(-0.66809432114456f)}, {Q31( 0.97875325649683f), Q31(-0.72467840967746f)},
+{Q31(-0.95038560288864f), Q31( 0.89563219587625f)}, {Q31( 0.17005239424212f), Q31( 0.54683053962658f)},
+{Q31(-0.76910792026848f), Q31(-0.96226617549298f)}, {Q31( 0.99743281016846f), Q31( 0.42697157037567f)},
+{Q31( 0.95437383549973f), Q31( 0.97002324109952f)}, {Q31( 0.99578905365569f), Q31(-0.54106826257356f)},
+{Q31( 0.28058259829990f), Q31(-0.85361420634036f)}, {Q31( 0.85256524470573f), Q31(-0.64567607735589f)},
+{Q31(-0.50608540105128f), Q31(-0.65846015480300f)}, {Q31(-0.97210735183243f), Q31(-0.23095213067791f)},
+{Q31( 0.95424048234441f), Q31(-0.99240147091219f)}, {Q31(-0.96926570524023f), Q31( 0.73775654896574f)},
+{Q31( 0.30872163214726f), Q31( 0.41514960556126f)}, {Q31(-0.24523839572639f), Q31( 0.63206633394807f)},
+{Q31(-0.33813265086024f), Q31(-0.38661779441897f)}, {Q31(-0.05826828420146f), Q31(-0.06940774188029f)},
+{Q31(-0.22898461455054f), Q31( 0.97054853316316f)}, {Q31(-0.18509915019881f), Q31( 0.47565762892084f)},
+{Q31(-0.10488238045009f), Q31(-0.87769947402394f)}, {Q31(-0.71886586182037f), Q31( 0.78030982480538f)},
+{Q31( 0.99793873738654f), Q31( 0.90041310491497f)}, {Q31( 0.57563307626120f), Q31(-0.91034337352097f)},
+{Q31( 0.28909646383717f), Q31( 0.96307783970534f)}, {Q31( 0.42188998312520f), Q31( 0.48148651230437f)},
+{Q31( 0.93335049681047f), Q31(-0.43537023883588f)}, {Q31(-0.97087374418267f), Q31( 0.86636445711364f)},
+{Q31( 0.36722871286923f), Q31( 0.65291654172961f)}, {Q31(-0.81093025665696f), Q31( 0.08778370229363f)},
+{Q31(-0.26240603062237f), Q31(-0.92774095379098f)}, {Q31( 0.83996497984604f), Q31( 0.55839849139647f)},
+{Q31(-0.99909615720225f), Q31(-0.96024605713970f)}, {Q31( 0.74649464155061f), Q31( 0.12144893606462f)},
+{Q31(-0.74774595569805f), Q31(-0.26898062008959f)}, {Q31( 0.95781667469567f), Q31(-0.79047927052628f)},
+{Q31( 0.95472308713099f), Q31(-0.08588776019550f)}, {Q31( 0.48708332746299f), Q31( 0.99999041579432f)},
+{Q31( 0.46332038247497f), Q31( 0.10964126185063f)}, {Q31(-0.76497004940162f), Q31( 0.89210929242238f)},
+{Q31( 0.57397389364339f), Q31( 0.35289703373760f)}, {Q31( 0.75374316974495f), Q31( 0.96705214651335f)},
+{Q31(-0.59174397685714f), Q31(-0.89405370422752f)}, {Q31( 0.75087906691890f), Q31(-0.29612672982396f)},
+{Q31(-0.98607857336230f), Q31( 0.25034911730023f)}, {Q31(-0.40761056640505f), Q31(-0.90045573444695f)},
+{Q31( 0.66929266740477f), Q31( 0.98629493401748f)}, {Q31(-0.97463695257310f), Q31(-0.00190223301301f)},
+{Q31( 0.90145509409859f), Q31( 0.99781390365446f)}, {Q31(-0.87259289048043f), Q31( 0.99233587353666f)},
+{Q31(-0.91529461447692f), Q31(-0.15698707534206f)}, {Q31(-0.03305738840705f), Q31(-0.37205262859764f)},
+{Q31( 0.07223051368337f), Q31(-0.88805001733626f)}, {Q31( 0.99498012188353f), Q31( 0.97094358113387f)},
+{Q31(-0.74904939500519f), Q31( 0.99985483641521f)}, {Q31( 0.04585228574211f), Q31( 0.99812337444082f)},
+{Q31(-0.89054954257993f), Q31(-0.31791913188064f)}, {Q31(-0.83782144651251f), Q31( 0.97637632547466f)},
+{Q31( 0.33454804933804f), Q31(-0.86231516800408f)}, {Q31(-0.99707579362824f), Q31( 0.93237990079441f)},
+{Q31(-0.22827527843994f), Q31( 0.18874759397997f)}, {Q31( 0.67248046289143f), Q31(-0.03646211390569f)},
+{Q31(-0.05146538187944f), Q31(-0.92599700120679f)}, {Q31( 0.99947295749905f), Q31( 0.93625229707912f)},
+{Q31( 0.66951124390363f), Q31( 0.98905825623893f)}, {Q31(-0.99602956559179f), Q31(-0.44654715757688f)},
+{Q31( 0.82104905483590f), Q31( 0.99540741724928f)}, {Q31( 0.99186510988782f), Q31( 0.72023001312947f)},
+{Q31(-0.65284592392918f), Q31( 0.52186723253637f)}, {Q31( 0.93885443798188f), Q31(-0.74895312615259f)},
+{Q31( 0.96735248738388f), Q31( 0.90891816978629f)}, {Q31(-0.22225968841114f), Q31( 0.57124029781228f)},
+{Q31(-0.44132783753414f), Q31(-0.92688840659280f)}, {Q31(-0.85694974219574f), Q31( 0.88844532719844f)},
+{Q31( 0.91783042091762f), Q31(-0.46356892383970f)}, {Q31( 0.72556974415690f), Q31(-0.99899555770747f)},
+{Q31(-0.99711581834508f), Q31( 0.58211560180426f)}, {Q31( 0.77638976371966f), Q31( 0.94321834873819f)},
+{Q31( 0.07717324253925f), Q31( 0.58638399856595f)}, {Q31(-0.56049829194163f), Q31( 0.82522301569036f)},
+{Q31( 0.98398893639988f), Q31( 0.39467440420569f)}, {Q31( 0.47546946844938f), Q31( 0.68613044836811f)},
+{Q31( 0.65675089314631f), Q31( 0.18331637134880f)}, {Q31( 0.03273375457980f), Q31(-0.74933109564108f)},
+{Q31(-0.38684144784738f), Q31( 0.51337349030406f)}, {Q31(-0.97346267944545f), Q31(-0.96549364384098f)},
+{Q31(-0.53282156061942f), Q31(-0.91423265091354f)}, {Q31( 0.99817310731176f), Q31( 0.61133572482148f)},
+{Q31(-0.50254500772635f), Q31(-0.88829338134294f)}, {Q31( 0.01995873238855f), Q31( 0.85223515096765f)},
+{Q31( 0.99930381973804f), Q31( 0.94578896296649f)}, {Q31( 0.82907767600783f), Q31(-0.06323442598128f)},
+{Q31(-0.58660709669728f), Q31( 0.96840773806582f)}, {Q31(-0.17573736667267f), Q31(-0.48166920859485f)},
+{Q31( 0.83434292401346f), Q31(-0.13023450646997f)}, {Q31( 0.05946491307025f), Q31( 0.20511047074866f)},
+{Q31( 0.81505484574602f), Q31(-0.94685947861369f)}, {Q31(-0.44976380954860f), Q31( 0.40894572671545f)},
+{Q31(-0.89746474625671f), Q31( 0.99846578838537f)}, {Q31( 0.39677256130792f), Q31(-0.74854668609359f)},
+{Q31(-0.07588948563079f), Q31( 0.74096214084170f)}, {Q31( 0.76343198951445f), Q31( 0.41746629422634f)},
+{Q31(-0.74490104699626f), Q31( 0.94725911744610f)}, {Q31( 0.64880119792759f), Q31( 0.41336660830571f)},
+{Q31( 0.62319537462542f), Q31(-0.93098313552599f)}, {Q31( 0.42215817594807f), Q31(-0.07712787385208f)},
+{Q31( 0.02704554141885f), Q31(-0.05417518053666f)}, {Q31( 0.80001773566818f), Q31( 0.91542195141039f)},
+{Q31(-0.79351832348816f), Q31(-0.36208897989136f)}, {Q31( 0.63872359151636f), Q31( 0.08128252493444f)},
+{Q31( 0.52890520960295f), Q31( 0.60048872455592f)}, {Q31( 0.74238552914587f), Q31( 0.04491915291044f)},
+{Q31( 0.99096131449250f), Q31(-0.19451182854402f)}, {Q31(-0.80412329643109f), Q31(-0.88513818199457f)},
+{Q31(-0.64612616129736f), Q31( 0.72198674804544f)}, {Q31( 0.11657770663191f), Q31(-0.83662833815041f)},
+{Q31(-0.95053182488101f), Q31(-0.96939905138082f)}, {Q31(-0.62228872928622f), Q31( 0.82767262846661f)},
+{Q31( 0.03004475787316f), Q31(-0.99738896333384f)}, {Q31(-0.97987214341034f), Q31( 0.36526129686425f)},
+{Q31(-0.99986980746200f), Q31(-0.36021610299715f)}, {Q31( 0.89110648599879f), Q31(-0.97894250343044f)},
+{Q31( 0.10407960510582f), Q31( 0.77357793811619f)}, {Q31( 0.95964737821728f), Q31(-0.35435818285502f)},
+{Q31( 0.50843233159162f), Q31( 0.96107691266205f)}, {Q31( 0.17006334670615f), Q31(-0.76854025314829f)},
+{Q31( 0.25872675063360f), Q31( 0.99893303933816f)}, {Q31(-0.01115998681937f), Q31( 0.98496019742444f)},
+{Q31(-0.79598702973261f), Q31( 0.97138411318894f)}, {Q31(-0.99264708948101f), Q31(-0.99542822402536f)},
+{Q31(-0.99829663752818f), Q31( 0.01877138824311f)}, {Q31(-0.70801016548184f), Q31( 0.33680685948117f)},
+{Q31(-0.70467057786826f), Q31( 0.93272777501857f)}, {Q31( 0.99846021905254f), Q31(-0.98725746254433f)},
+{Q31(-0.63364968534650f), Q31(-0.16473594423746f)}, {Q31(-0.16258217500792f), Q31(-0.95939125400802f)},
+{Q31(-0.43645594360633f), Q31(-0.94805030113284f)}, {Q31(-0.99848471702976f), Q31( 0.96245166923809f)},
+{Q31(-0.16796458968998f), Q31(-0.98987511890470f)}, {Q31(-0.87979225745213f), Q31(-0.71725725041680f)},
+{Q31( 0.44183099021786f), Q31(-0.93568974498761f)}, {Q31( 0.93310180125532f), Q31(-0.99913308068246f)},
+{Q31(-0.93941931782002f), Q31(-0.56409379640356f)}, {Q31(-0.88590003188677f), Q31( 0.47624600491382f)},
+{Q31( 0.99971463703691f), Q31(-0.83889954253462f)}, {Q31(-0.75376385639978f), Q31( 0.00814643438625f)},
+{Q31( 0.93887685615875f), Q31(-0.11284528204636f)}, {Q31( 0.85126435782309f), Q31( 0.52349251543547f)},
+{Q31( 0.39701421446381f), Q31( 0.81779634174316f)}, {Q31(-0.37024464187437f), Q31(-0.87071656222959f)},
+{Q31(-0.36024828242896f), Q31( 0.34655735648287f)}, {Q31(-0.93388812549209f), Q31(-0.84476541096429f)},
+{Q31(-0.65298804552119f), Q31(-0.18439575450921f)}, {Q31( 0.11960319006843f), Q31( 0.99899346780168f)},
+{Q31( 0.94292565553160f), Q31( 0.83163906518293f)}, {Q31( 0.75081145286948f), Q31(-0.35533223142265f)},
+{Q31( 0.56721979748394f), Q31(-0.24076836414499f)}, {Q31( 0.46857766746029f), Q31(-0.30140233457198f)},
+{Q31( 0.97312313923635f), Q31(-0.99548191630031f)}, {Q31(-0.38299976567017f), Q31( 0.98516909715427f)},
+{Q31( 0.41025800019463f), Q31( 0.02116736935734f)}, {Q31( 0.09638062008048f), Q31( 0.04411984381457f)},
+{Q31(-0.85283249275397f), Q31( 0.91475563922421f)}, {Q31( 0.88866808958124f), Q31(-0.99735267083226f)},
+{Q31(-0.48202429536989f), Q31(-0.96805608884164f)}, {Q31( 0.27572582416567f), Q31( 0.58634753335832f)},
+{Q31(-0.65889129659168f), Q31( 0.58835634138583f)}, {Q31( 0.98838086953732f), Q31( 0.99994349600236f)},
+{Q31(-0.20651349620689f), Q31( 0.54593044066355f)}, {Q31(-0.62126416356920f), Q31(-0.59893681700392f)},
+{Q31( 0.20320105410437f), Q31(-0.86879180355289f)}, {Q31(-0.97790548600584f), Q31( 0.96290806999242f)},
+{Q31( 0.11112534735126f), Q31( 0.21484763313301f)}, {Q31(-0.41368337314182f), Q31( 0.28216837680365f)},
+{Q31( 0.24133038992960f), Q31( 0.51294362630238f)}, {Q31(-0.66393410674885f), Q31(-0.08249679629081f)},
+{Q31(-0.53697829178752f), Q31(-0.97649903936228f)}, {Q31(-0.97224737889348f), Q31( 0.22081333579837f)},
+{Q31( 0.87392477144549f), Q31(-0.12796173740361f)}, {Q31( 0.19050361015753f), Q31( 0.01602615387195f)},
+{Q31(-0.46353441212724f), Q31(-0.95249041539006f)}, {Q31(-0.07064096339021f), Q31(-0.94479803205886f)},
+{Q31(-0.92444085484466f), Q31(-0.10457590187436f)}, {Q31(-0.83822593578728f), Q31(-0.01695043208885f)},
+{Q31( 0.75214681811150f), Q31(-0.99955681042665f)}, {Q31(-0.42102998829339f), Q31( 0.99720941999394f)},
+{Q31(-0.72094786237696f), Q31(-0.35008961934255f)}, {Q31( 0.78843311019251f), Q31( 0.52851398958271f)},
+{Q31( 0.97394027897442f), Q31(-0.26695944086561f)}, {Q31( 0.99206463477946f), Q31(-0.57010120849429f)},
+{Q31( 0.76789609461795f), Q31(-0.76519356730966f)}, {Q31(-0.82002421836409f), Q31(-0.73530179553767f)},
+{Q31( 0.81924990025724f), Q31( 0.99698425250579f)}, {Q31(-0.26719850873357f), Q31( 0.68903369776193f)},
+{Q31(-0.43311260380975f), Q31( 0.85321815947490f)}, {Q31( 0.99194979673836f), Q31( 0.91876249766422f)},
+{Q31(-0.80692001248487f), Q31(-0.32627540663214f)}, {Q31( 0.43080003649976f), Q31(-0.21919095636638f)},
+{Q31( 0.67709491937357f), Q31(-0.95478075822906f)}, {Q31( 0.56151770568316f), Q31(-0.70693811747778f)},
+{Q31( 0.10831862810749f), Q31(-0.08628837174592f)}, {Q31( 0.91229417540436f), Q31(-0.65987351408410f)},
+{Q31(-0.48972893932274f), Q31( 0.56289246362686f)}, {Q31(-0.89033658689697f), Q31(-0.71656563987082f)},
+{Q31( 0.65269447475094f), Q31( 0.65916004833932f)}, {Q31( 0.67439478141121f), Q31(-0.81684380846796f)},
+{Q31(-0.47770832416973f), Q31(-0.16789556203025f)}, {Q31(-0.99715979260878f), Q31(-0.93565784007648f)},
+{Q31(-0.90889593602546f), Q31( 0.62034397054380f)}, {Q31(-0.06618622548177f), Q31(-0.23812217221359f)},
+{Q31( 0.99430266919728f), Q31( 0.18812555317553f)}, {Q31( 0.97686402381843f), Q31(-0.28664534366620f)},
+{Q31( 0.94813650221268f), Q31(-0.97506640027128f)}, {Q31(-0.95434497492853f), Q31(-0.79607978501983f)},
+{Q31(-0.49104783137150f), Q31( 0.32895214359663f)}, {Q31( 0.99881175120751f), Q31( 0.88993983831354f)},
+{Q31( 0.50449166760303f), Q31(-0.85995072408434f)}, {Q31( 0.47162891065108f), Q31(-0.18680204049569f)},
+{Q31(-0.62081581361840f), Q31( 0.75000676218956f)}, {Q31(-0.43867015250812f), Q31( 0.99998069244322f)},
+{Q31( 0.98630563232075f), Q31(-0.53578899600662f)}, {Q31(-0.61510362277374f), Q31(-0.89515019899997f)},
+{Q31(-0.03841517601843f), Q31(-0.69888815681179f)}, {Q31(-0.30102157304644f), Q31(-0.07667808922205f)},
+{Q31( 0.41881284182683f), Q31( 0.02188098922282f)}, {Q31(-0.86135454941237f), Q31( 0.98947480909359f)},
+{Q31( 0.67226861393788f), Q31(-0.13494389011014f)}, {Q31(-0.70737398842068f), Q31(-0.76547349325992f)},
+{Q31( 0.94044946687963f), Q31( 0.09026201157416f)}, {Q31(-0.82386352534327f), Q31( 0.08924768823676f)},
+{Q31(-0.32070666698656f), Q31( 0.50143421908753f)}, {Q31( 0.57593163224487f), Q31(-0.98966422921509f)},
+{Q31(-0.36326018419965f), Q31( 0.07440243123228f)}, {Q31( 0.99979044674350f), Q31(-0.14130287347405f)},
+{Q31(-0.92366023326932f), Q31(-0.97979298068180f)}, {Q31(-0.44607178518598f), Q31(-0.54233252016394f)},
+{Q31( 0.44226800932956f), Q31( 0.71326756742752f)}, {Q31( 0.03671907158312f), Q31( 0.63606389366675f)},
+{Q31( 0.52175424682195f), Q31(-0.85396826735705f)}, {Q31(-0.94701139690956f), Q31(-0.01826348194255f)},
+{Q31(-0.98759606946049f), Q31( 0.82288714303073f)}, {Q31( 0.87434794743625f), Q31( 0.89399495655433f)},
+{Q31(-0.93412041758744f), Q31( 0.41374052024363f)}, {Q31( 0.96063943315511f), Q31( 0.93116709541280f)},
+{Q31( 0.97534253457837f), Q31( 0.86150930812689f)}, {Q31( 0.99642466504163f), Q31( 0.70190043427512f)},
+{Q31(-0.94705089665984f), Q31(-0.29580042814306f)}, {Q31( 0.91599807087376f), Q31(-0.98147830385781f)},
+{Q31(-0.99948153278296f), Q31(-0.59483417516607f)}, {Q31( 0.97113454393991f), Q31(-0.67528515225647f)},
+{Q31( 0.14130051758487f), Q31(-0.95090983575689f)}, {Q31(-0.47005496701697f), Q31(-0.37340549728647f)},
+{Q31( 0.80705063769351f), Q31( 0.29653668284408f)}, {Q31(-0.38981478896926f), Q31( 0.89572605717087f)},
+{Q31(-0.01053049862020f), Q31(-0.66959058036166f)}, {Q31(-0.91266367957293f), Q31(-0.11522938140034f)},
 };
 
 #endif /* AVCODEC_AACSBRDATA_H */
diff -uNr ffmpeg-0.7.12/libavcodec/aacsbr.h ffmpeg-0.7.12-140902/libavcodec/aacsbr.h
--- ffmpeg-0.7.12/libavcodec/aacsbr.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aacsbr.h	2014-09-02 15:23:08.000000000 +0800
@@ -30,20 +30,60 @@
 #define AVCODEC_AACSBR_H
 
 #include "get_bits.h"
-#include "aac.h"
-#include "sbr.h"
-
+                                                                                                                                                            
+#define ENVELOPE_ADJUSTMENT_OFFSET 2                                                                                                                        
+                                                                                                                                                            
+enum {                                                                                                                                                      
+    T_HUFFMAN_ENV_1_5DB,                                                                                                                                    
+    F_HUFFMAN_ENV_1_5DB,                                                                                                                                    
+    T_HUFFMAN_ENV_BAL_1_5DB,                                                                                                                                
+    F_HUFFMAN_ENV_BAL_1_5DB,                                                                                                                                
+    T_HUFFMAN_ENV_3_0DB,                                                                                                                                    
+    F_HUFFMAN_ENV_3_0DB,                                                                                                                                    
+    T_HUFFMAN_ENV_BAL_3_0DB,                                                                                                                                
+    F_HUFFMAN_ENV_BAL_3_0DB,                                                                                                                                
+    T_HUFFMAN_NOISE_3_0DB,                                                                                                                                  
+    T_HUFFMAN_NOISE_BAL_3_0DB,                                                                                                                              
+};                                                                                                                                                          
+                                                                                                                                                            
+/**                                                                                                                                                         
+ * bs_frame_class - frame class of current SBR frame (14496-3 sp04 p98)                                                                                     
+ */                                                                                                                                                         
+enum {                                                                                                                                                      
+    FIXFIX,                                                                                                                                                 
+    FIXVAR,                                                                                                                                                 
+    VARFIX,                                                                                                                                                 
+    VARVAR,                                                                                                                                                 
+};                                                                                                                                                          
+                                                                                                                                                            
+enum {                                                                                                                                                      
+    EXTENSION_ID_PS = 2,                                                                                                                                    
+};                                                                                                                                                          
+                                                                                                                                                            
+static const int8_t vlc_sbr_lav[10] =                                                                                                                       
+    { 60, 60, 24, 24, 31, 31, 12, 12, 31, 12 };                                                                                                             
+                                                                                                                                                            
+#define SBR_INIT_VLC_STATIC(num, size) \                                                                                                                    
+    INIT_VLC_STATIC(&vlc_sbr[num], 9, sbr_tmp[num].table_size / sbr_tmp[num].elem_size,     \                                                               
+                    sbr_tmp[num].sbr_bits ,                      1,                      1, \                                                               
+                    sbr_tmp[num].sbr_codes, sbr_tmp[num].elem_size, sbr_tmp[num].elem_size, \                                                               
+                    size)                                                                                                                                   
+                                                                                                                                                            
+#define SBR_VLC_ROW(name) \                                                                                                                                 
+    { name##_codes, name##_bits, sizeof(name##_codes), sizeof(name##_codes[0]) }                                                                    
+                                                                                                                                                            
+#define NOISE_FLOOR_OFFSET FIXR(6.0f)   
 /** Initialize SBR. */
-av_cold void ff_aac_sbr_init(void);
+av_cold void AAC_RENAME(ff_aac_sbr_init)(void);  
 /** Initialize one SBR context. */
-av_cold void ff_aac_sbr_ctx_init(AACContext *ac, SpectralBandReplication *sbr);
+av_cold void AAC_RENAME(ff_aac_sbr_ctx_init)(AACContext *ac, SpectralBandReplication *sbr); 
 /** Close one SBR context. */
-av_cold void ff_aac_sbr_ctx_close(SpectralBandReplication *sbr);
+av_cold void AAC_RENAME(ff_aac_sbr_ctx_close)(SpectralBandReplication *sbr); 
 /** Decode one SBR element. */
-int ff_decode_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,
+int AAC_RENAME(ff_decode_sbr_extension)(AACContext *ac, SpectralBandReplication *sbr,
                             GetBitContext *gb, int crc, int cnt, int id_aac);
 /** Apply one SBR element to one AAC element. */
-void ff_sbr_apply(AACContext *ac, SpectralBandReplication *sbr, int id_aac,
-                  float* L, float *R);
+void AAC_RENAME(ff_sbr_apply)(AACContext *ac, SpectralBandReplication *sbr, int id_aac,                                                                     
+                  INTFLOAT* L, INTFLOAT *R);     
 
 #endif /* AVCODEC_AACSBR_H */
diff -uNr ffmpeg-0.7.12/libavcodec/aactab.c ffmpeg-0.7.12-140902/libavcodec/aactab.c
--- ffmpeg-0.7.12/libavcodec/aactab.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aactab.c	2013-10-31 11:10:02.000000000 +0800
@@ -33,8 +33,10 @@
 
 #include <stdint.h>
 
-DECLARE_ALIGNED(16, float,  ff_aac_kbd_long_1024)[1024];
-DECLARE_ALIGNED(16, float,  ff_aac_kbd_short_128)[128];
+//DECLARE_ALIGNED(16, float,  ff_aac_kbd_long_1024)[1024];
+//DECLARE_ALIGNED(16, float,  ff_aac_kbd_short_128)[128];
+DECLARE_ALIGNED(32, int,    ff_aac_kbd_long_1024_fixed)[1024];
+DECLARE_ALIGNED(32, int,    ff_aac_kbd_short_128_fixed)[128];
 
 const uint8_t ff_aac_num_swb_1024[] = {
     41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40, 40
diff -uNr ffmpeg-0.7.12/libavcodec/aactab.h ffmpeg-0.7.12-140902/libavcodec/aactab.h
--- ffmpeg-0.7.12/libavcodec/aactab.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aactab.h	2013-10-31 11:10:02.000000000 +0800
@@ -44,8 +44,10 @@
 /* @name window coefficients
  * @{
  */
-DECLARE_ALIGNED(16, extern float,  ff_aac_kbd_long_1024)[1024];
-DECLARE_ALIGNED(16, extern float,  ff_aac_kbd_short_128)[128];
+//DECLARE_ALIGNED(16, extern float,  ff_aac_kbd_long_1024)[1024];
+//jh DECLARE_ALIGNED(16, extern float,  ff_aac_kbd_short_128)[128];
+DECLARE_ALIGNED(32, extern int,  ff_aac_kbd_long_1024_fixed)[1024];
+DECLARE_ALIGNED(32, extern int,  ff_aac_kbd_short_128_fixed)[128];
 // @}
 
 /* @name number of scalefactor window bands for long and short transform windows respectively
diff -uNr ffmpeg-0.7.12/libavcodec/aac_tablegen.h ffmpeg-0.7.12-140902/libavcodec/aac_tablegen.h
--- ffmpeg-0.7.12/libavcodec/aac_tablegen.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/aac_tablegen.h	2014-09-02 16:58:02.000000000 +0800
@@ -36,7 +36,7 @@
 {
     int i;
     for (i = 0; i < 428; i++)
-        ff_aac_pow2sf_tab[i] = pow(2, (i - POW_SF2_ZERO) / 4.);
+        ff_aac_pow2sf_tab[i] = pow(2, (i - POW_SF2_ZERO) / 4.0);
 }
 #endif /* CONFIG_HARDCODED_TABLES */

diff -uNr ffmpeg-0.7.12/libavcodec/avcodec.h ffmpeg-0.7.12-140902/libavcodec/avcodec.h
--- ffmpeg-0.7.12/libavcodec/avcodec.h	2012-04-10 01:05:33.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/avcodec.h	2014-09-04 14:54:00.904421668 +0800
@@ -775,7 +775,7 @@
      * - encoding: \
      * - decoding: \
      */\
-    uint8_t *data[4];\
+    uint8_t *data[8];\
     int linesize[4];\
     /**\
      * pointer to the first allocated byte of the picture. Can be used in get_buffer/release_buffer.\
@@ -1092,6 +1092,108 @@
 #define FF_BUFFER_HINTS_PRESERVE 0x04 // User must not alter buffer content.
 #define FF_BUFFER_HINTS_REUSABLE 0x08 // Codec will reuse the buffer (update).
 
+
+enum AVPacketSideDataType {
+    AV_PKT_DATA_PALETTE,
+    AV_PKT_DATA_NEW_EXTRADATA,
+
+    /**
+     * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
+     * @code
+     * u32le param_flags
+     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
+     *     s32le channel_count
+     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
+     *     u64le channel_layout
+     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
+     *     s32le sample_rate
+     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
+     *     s32le width
+     *     s32le height
+     * @endcode
+     */
+    AV_PKT_DATA_PARAM_CHANGE,
+
+    /**
+     * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
+     * structures with info about macroblocks relevant to splitting the
+     * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
+     * That is, it does not necessarily contain info about all macroblocks,
+     * as long as the distance between macroblocks in the info is smaller
+     * than the target payload size.
+     * Each MB info structure is 12 bytes, and is laid out as follows:
+     * @code
+     * u32le bit offset from the start of the packet
+     * u8    current quantizer at the start of the macroblock
+     * u8    GOB number
+     * u16le macroblock address within the GOB
+     * u8    horizontal MV predictor
+     * u8    vertical MV predictor
+     * u8    horizontal MV predictor for block number 3
+     * u8    vertical MV predictor for block number 3
+     * @endcode
+     */
+    AV_PKT_DATA_H263_MB_INFO,
+
+    /**
+     * Recommmends skipping the specified number of samples
+     * @code
+     * u32le number of samples to skip from start of this packet
+     * u32le number of samples to skip from end of this packet
+     * u8    reason for start skip
+     * u8    reason for end   skip (0=padding silence, 1=convergence)
+     * @endcode
+     */
+    AV_PKT_DATA_SKIP_SAMPLES=70,
+
+    /**
+     * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
+     * the packet may contain "dual mono" audio specific to Japanese DTV
+     * and if it is true, recommends only the selected channel to be used.
+     * @code
+     * u8    selected channels (0=mail/left, 1=sub/right, 2=both)
+     * @endcode
+     */
+    AV_PKT_DATA_JP_DUALMONO,
+
+    /**
+     * A list of zero terminated key/value strings. There is no end marker for
+     * the list, so it is required to rely on the side data size to stop.
+     */
+    AV_PKT_DATA_STRINGS_METADATA,
+
+    /**
+     * Subtitle event position
+     * @code
+     * u32le x1
+     * u32le y1
+     * u32le x2
+     * u32le y2
+     * @endcode
+     */
+    AV_PKT_DATA_SUBTITLE_POSITION,
+
+    /**
+     * Data found in BlockAdditional element of matroska container. There is
+     * no end marker for the data, so it is required to rely on the side data
+     * size to recognize the end. 8 byte id (as found in BlockAddId) followed
+     * by data.
+     */
+    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
+
+    /**
+     * The optional first identifier line of a WebVTT cue.
+     */
+    AV_PKT_DATA_WEBVTT_IDENTIFIER,
+
+    /**
+     * The optional settings (rendering instructions) that immediately
+     * follow the timestamp specifier of a WebVTT cue.
+     */
+    AV_PKT_DATA_WEBVTT_SETTINGS,
+};
+
+
 typedef struct AVPacket {
     /**
      * Presentation timestamp in AVStream->time_base units; the time at which
@@ -1157,6 +1259,76 @@
  */
 typedef struct AVFrame {
     FF_COMMON_FRAME
+    /**
+     * number of audio samples (per channel) described by this frame
+     * - encoding: Set by user
+     * - decoding: Set by libavcodec
+     */
+    int nb_samples;
+    /**
+     * duration of the corresponding packet, expressed in
+     * AVStream->time_base units, 0 if unknown.
+     * Code outside libavcodec should access this field using:
+     * av_frame_get_pkt_duration(frame)
+     * - encoding: unused
+     * - decoding: Read by user.
+     */
+    int64_t pkt_duration;
+    /**
+     * Sample rate of the audio data.
+     *
+     * - encoding: unused
+     * - decoding: read by user
+     */
+    int sample_rate;
+
+    /**
+     * Channel layout of the audio data.
+     *
+     * - encoding: unused
+     * - decoding: read by user.
+     */
+    uint64_t channel_layout;
+     /**
+     * number of audio channels, only used for audio.
+     * Code outside libavcodec should access this field using:
+     * av_frame_get_channels(frame)
+     * - encoding: unused
+     * - decoding: Read by user.
+     */
+    int64_t channels;
+
+    /**
+     * size of the corresponding packet containing the compressed
+     * frame. It must be accessed using av_frame_get_pkt_size() and
+     * av_frame_set_pkt_size().
+     * It is set to a negative value if unknown.
+     * - encoding: unused
+     * - decoding: set by libavcodec, read by user.
+     */
+    int pkt_size;
+
+    /**
+     * pointers to the data planes/channels.
+     *
+     * For video, this should simply point to data[].
+     *
+     * For planar audio, each channel has a separate data pointer, and
+     * linesize[0] contains the size of each channel buffer.
+     * For packed audio, there is just one data pointer, and linesize[0]
+     * contains the total size of the buffer for all channels.
+     *
+     * Note: Both data and extended_data will always be set by get_buffer(),
+     * but for planar audio with more channels that can fit in data,
+     * extended_data must be used by the decoder in order to access all
+     * channels.
+     *
+     * encoding: set by user
+     * decoding: set by AVCodecContext.get_buffer()
+     */
+    uint8_t **extended_data;
+
+
 } AVFrame;
 
 /**
@@ -2675,7 +2847,16 @@
      * - decoding: Set by user.
      */
     float drc_scale;
-
+    /**
+     * Error recognition; may misdetect some more or less valid parts as errors.
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    int err_recognition;
+#define AV_EF_CRCCHECK  (1<<0)
+#define AV_EF_BITSTREAM (1<<1)
+#define AV_EF_BUFFER    (1<<2)
+#define AV_EF_EXPLODE   (1<<3)
     /**
      * opaque 64bit number (generally a PTS) that will be reordered and
      * output in AVFrame.reordered_opaque
@@ -3642,6 +3823,9 @@
  */
 AVCodec *avcodec_find_encoder_by_name(const char *name);
 
+/*uint8_t* av_packet_get_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
+                                 int *size);//jh*/
+
 /**
  * Find a registered decoder with a matching codec ID.
  *

diff -uNr ffmpeg-0.7.12/libavcodec/cbrt_fixed_tablegen.c ffmpeg-0.7.12-140902/libavcodec/cbrt_fixed_tablegen.c
--- ffmpeg-0.7.12/libavcodec/cbrt_fixed_tablegen.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/cbrt_fixed_tablegen.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,2 @@
+#define CONFIG_FIXED 1
+#include "cbrt_tablegen_template.c"
diff -uNr ffmpeg-0.7.12/libavcodec/cbrt_tablegen.c ffmpeg-0.7.12-140902/libavcodec/cbrt_tablegen.c
--- ffmpeg-0.7.12/libavcodec/cbrt_tablegen.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/cbrt_tablegen.c	2014-09-02 15:26:16.000000000 +0800
@@ -1,37 +1,4 @@
-/*
- * Generate a header file for hardcoded AAC cube-root table
- *
- * Copyright (c) 2010 Reimar Döffinger <Reimar.Doeffinger@gmx.de>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
 #include <stdlib.h>
 #define CONFIG_HARDCODED_TABLES 0
-#include "cbrt_tablegen.h"
-#include "tableprint.h"
-
-int main(void)
-{
-    cbrt_tableinit();
-
-    write_fileheader();
-
-    WRITE_ARRAY("static const", uint32_t, cbrt_tab);
-
-    return 0;
-}
+#define CONFIG_FIXED 0
+#include "cbrt_tablegen_template.c"
diff -uNr ffmpeg-0.7.12/libavcodec/cbrt_tablegen.h ffmpeg-0.7.12-140902/libavcodec/cbrt_tablegen.h
--- ffmpeg-0.7.12/libavcodec/cbrt_tablegen.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/cbrt_tablegen.h	2013-10-31 11:10:02.000000000 +0800
@@ -26,13 +26,30 @@
 #include <stdint.h>
 #include <math.h>
 
+
+#if CONFIG_FIXED
+#define CBRT_RENAME(a) a ## _fixed
+#define CBRT(x) (int)floor((x).f * 8192 + 0.5)
+#else
+#define CBRT_RENAME(a) a
+#define CBRT(x) x.i
+#endif
+
+
 #if CONFIG_HARDCODED_TABLES
+
+#if CONFIG_FIXED
+#define cbrt_tableinit_fixed()
+#include "libavcodec/cbrt_fixed_tables.h"
+#else
+
 #define cbrt_tableinit()
 #include "libavcodec/cbrt_tables.h"
+#endif
 #else
 static uint32_t cbrt_tab[1 << 13];
 
-static void cbrt_tableinit(void)
+static void CBRT_RENAME(cbrt_tableinit)(void)
 {
     if (!cbrt_tab[(1<<13) - 1]) {
         int i;
@@ -42,7 +59,7 @@
                 uint32_t i;
             } f;
             f.f = cbrtf(i) * i;
-            cbrt_tab[i] = f.i;
+            cbrt_tab[i] = CBRT(f);
         }
     }
 }
diff -uNr ffmpeg-0.7.12/libavcodec/cbrt_tablegen_template.c ffmpeg-0.7.12-140902/libavcodec/cbrt_tablegen_template.c
--- ffmpeg-0.7.12/libavcodec/cbrt_tablegen_template.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/cbrt_tablegen_template.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,15 @@
+#include <stdlib.h>
+#define CONFIG_HARDCODED_TABLES 0
+#include "cbrt_tablegen.h"
+#include "tableprint.h"
+
+int main(void)
+{
+    CBRT_RENAME(cbrt_tableinit)();
+
+    write_fileheader();
+
+    WRITE_ARRAY("static const", uint32_t, cbrt_tab);
+
+    return 0;
+}
diff -uNr ffmpeg-0.7.12/libavcodec/dsputil.c ffmpeg-0.7.12NF/libavcodec/dsputil.c
--- ffmpeg-0.7.12/libavcodec/dsputil.c	2013-08-26 15:52:03.076038042 +0800
+++ ffmpeg-0.7.12NF/libavcodec/dsputil.c	2013-08-19 14:35:26.000000000 +0800
@@ -2476,6 +2476,76 @@
 WRAPPER8_16_SQ(rd8x8_c, rd16_c)
 WRAPPER8_16_SQ(bit8x8_c, bit16_c)
 
+
+static void vector_q31mul_reverse_c(int *dst, const int *src0, const int *src1, int len)
+{
+    int i;
+    long long accu;
+
+    src1 += len-1;
+    for (i=0; i<len; i++) {
+        accu = (long long)src0[i] * src1[-i];
+        dst[i] = (int)((accu+0x40000000) >> 31);
+    }
+}
+
+static void vector_imul_add_c(int *dst, const int *src0, const int *src1, const int *src2, int len){
+    int i;
+    int64_t accu;
+
+    for(i=0; i<len; i++) {
+        accu = (int64_t)src0[i] * src1[i];
+        dst[i] = src2[i] + (int)((accu + 0x40000000) >> 31);
+    }
+}
+
+static void vector_q31mul_window_c(int *dst, const int *src0, const int *src1, const int *win, int len)
+{
+    int i,j;
+    int64_t accu;
+
+    dst += len;
+    win += len;
+    src0+= len;
+
+    for (i=-len, j=len-1; i<0; i++, j--) {
+        int s0 = src0[i];
+        int s1 = src1[j];
+        int wi = win[i];
+        int wj = win[j];
+
+        accu  = (int64_t)s0*wj;
+        accu -= (int64_t)s1*wi;
+        dst[i] = (int)((accu + 0x40000000) >> 31);
+        accu  = (int64_t)s0*wi;
+        accu += (int64_t)s1*wj;
+        dst[j] = (int)((accu + 0x40000000) >> 31);
+    }
+}
+
+static void vector_q31mul_c(int *dst, const int *src0, const int *src1, int len)
+{
+    int i;
+    int64_t accu;
+
+    for (i = 0; i < len; i++) {
+        accu = (int64_t)src0[i] * src1[i];
+        dst[i] = (int)((accu+0x40000000) >> 31);
+    }
+}
+
+int ff_scalarproduct_q31_c(const int *v1, const int *v2, int len)
+{
+    long long p = 0;
+    int i;
+
+    for (i = 0; i < len; i++)
+        p += (long long)v1[i] * v2[i];
+
+    return (int)((p + 0x40000000) >> 31);
+}
+
+
 static void vector_fmul_c(float *dst, const float *src0, const float *src1, int len){
     int i;
     for(i=0; i<len; i++)
@@ -3122,6 +3192,13 @@
     c->vector_fmul_add = vector_fmul_add_c;
     c->vector_fmul_window = vector_fmul_window_c;
     c->vector_fmul_window_fixed = vector_fmul_window_fixed_c;
+
+//jh
+    c->vector_q31mul_reverse = vector_q31mul_reverse_c;
+    c->vector_imul_add = vector_imul_add_c;
+    c->vector_q31mul = vector_q31mul_c;
+    c->vector_q31mul_window = vector_q31mul_window_c;
+
     c->vector_clipf = vector_clipf_c;
     c->scalarproduct_int16 = scalarproduct_int16_c;
     c->scalarproduct_and_madd_int16 = scalarproduct_and_madd_int16_c;
@@ -3135,7 +3212,8 @@
 
     c->sv_fmul_scalar[0] = sv_fmul_scalar_2_c;
     c->sv_fmul_scalar[1] = sv_fmul_scalar_4_c;
-
+//jh
+    c->scalarproduct_q31 = ff_scalarproduct_q31_c;
     c->shrink[0]= av_image_copy_plane;
     c->shrink[1]= ff_shrink22;
     c->shrink[2]= ff_shrink44;
diff -uNr ffmpeg-0.7.12/libavcodec/dsputil.h ffmpeg-0.7.12NF/libavcodec/dsputil.h
--- ffmpeg-0.7.12/libavcodec/dsputil.h	2013-08-26 15:52:03.086038210 +0800
+++ ffmpeg-0.7.12NF/libavcodec/dsputil.h	2013-08-19 14:39:16.000000000 +0800
@@ -397,6 +397,16 @@
 
     void (*h261_loop_filter)(uint8_t *src, int stride);
 
+
+
+    void (*vector_q31mul_reverse)(int *dst, const int *src0, const int *src1, int len);
+
+    void (*vector_imul_add)(int *dst, const int *src0, const int *src1, const int *src2, int len);
+    void (*vector_q31mul_window)(int *dst, const int *src0, const int *src1, const int *win, int len);
+    void (*vector_q31mul)(int *dst, const int *src0, const int *src1, int len);
+    int (*scalarproduct_q31)(const int *v1, const int *v2, int len);
+
+
     void (*x8_v_loop_filter)(uint8_t *src, int stride, int qscale);
     void (*x8_h_loop_filter)(uint8_t *src, int stride, int qscale);
 
@@ -583,6 +593,8 @@
 
 int ff_check_alignment(void);
 
+int ff_scalarproduct_q31_c(const int *v1, const int *v2, int len);
+
 /**
  * permute block according to permuatation.
  * @param last last non zero element in scantable order
diff -uNr ffmpeg-0.7.12/libavcodec/fft.c ffmpeg-0.7.12-140902/libavcodec/fft.c
--- ffmpeg-0.7.12/libavcodec/fft.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft.c	2013-10-31 11:10:02.000000000 +0800
@@ -32,6 +32,10 @@
 #include "fft.h"
 #include "fft-internal.h"
 
+#if CONFIG_FFT_FIXED_32                                                                 
+#include "fft_table.h"                                                                  
+#else /* CONFIG_FFT_FIXED_32 */  
+
 /* cos(2*pi*x/n) for 0<=x<=n/4, followed by its reverse */
 #if !CONFIG_HARDCODED_TABLES
 COSTABLE(16);
@@ -64,6 +68,7 @@
     FFT_NAME(ff_cos_32768),
     FFT_NAME(ff_cos_65536),
 };
+#endif /* CONFIG_FFT_FIXED_32 */
 
 static void ff_fft_permute_c(FFTContext *s, FFTComplex *z);
 static void ff_fft_calc_c(FFTContext *s, FFTComplex *z);
@@ -81,7 +86,7 @@
 
 av_cold void ff_init_ff_cos_tabs(int index)
 {
-#if !CONFIG_HARDCODED_TABLES
+#if (!CONFIG_HARDCODED_TABLES) && (!CONFIG_FFT_FIXED_32)
     int i;
     int m = 1<<index;
     double freq = 2*M_PI/m;
@@ -157,6 +162,13 @@
     s->mdct_calc   = ff_mdct_calc_c;
 #endif
 
+#if CONFIG_FFT_FIXED_32                                                                 
+    {                                                                                   
+        int n=0;                                                                        
+        ff_fft_lut_init(fft_offsets_lut, 0, 1 << 16, &n);                               
+    }                                                                                   
+#else /* CONFIG_FFT_FIXED_32 */    
+
 #if CONFIG_FFT_FLOAT
     if (ARCH_ARM)     ff_fft_init_arm(s);
     if (HAVE_ALTIVEC) ff_fft_init_altivec(s);
@@ -170,7 +182,7 @@
     for(j=4; j<=nbits; j++) {
         ff_init_ff_cos_tabs(j);
     }
-
+#endif /* CONFIG_FFT_FIXED_32 */ 
     if (s->fft_permutation == FF_FFT_PERM_AVX) {
         fft_perm_avx(s);
     } else {
@@ -205,6 +217,169 @@
     av_freep(&s->tmp_buf);
 }
 
+#if CONFIG_FFT_FIXED_32                                                                 
+                                                                                        
+static void ff_fft_calc_c(FFTContext *s, FFTComplex *z) {                                  
+                                                                                        
+    int nbits, i, n, num_transforms, offset, step;                                      
+    int n4, n2, n34;                                                                    
+    FFTSample tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;                           
+    FFTComplex *tmpz;                                                                   
+    FFTSample w_re, w_im;                                                               
+    FFTSample *w_re_ptr, *w_im_ptr;                                                     
+    const int fft_size = (1 << s->nbits);                                               
+    int64_t accu;                                                                       
+                                                                                        
+    num_transforms = (0x2aab >> (16 - s->nbits)) | 1;                                   
+                                                                                        
+    for (n=0; n<num_transforms; n++){                                                   
+        offset = fft_offsets_lut[n] << 2;                                               
+        tmpz = z + offset;                                                              
+                                                                                        
+        tmp1 = tmpz[0].re + tmpz[1].re;                                                 
+        tmp5 = tmpz[2].re + tmpz[3].re;                                                 
+        tmp2 = tmpz[0].im + tmpz[1].im;                                                 
+        tmp6 = tmpz[2].im + tmpz[3].im;                                                 
+        tmp3 = tmpz[0].re - tmpz[1].re;                                                 
+        tmp8 = tmpz[2].im - tmpz[3].im;                                                 
+        tmp4 = tmpz[0].im - tmpz[1].im;                                                 
+        tmp7 = tmpz[2].re - tmpz[3].re;                                                 
+                                                                                        
+        tmpz[0].re = tmp1 + tmp5;                                                       
+        tmpz[2].re = tmp1 - tmp5;                                                       
+        tmpz[0].im = tmp2 + tmp6;                                                       
+        tmpz[2].im = tmp2 - tmp6;                                                       
+        tmpz[1].re = tmp3 + tmp8;                                                       
+        tmpz[3].re = tmp3 - tmp8;                                                       
+        tmpz[1].im = tmp4 - tmp7;                                                       
+        tmpz[3].im = tmp4 + tmp7;                                                       
+    }                                                                                   
+                                                                                        
+    if (fft_size < 8)                                                                   
+        return;                                                                         
+                                                                                        
+    num_transforms = (num_transforms >> 1) | 1;                                         
+                                                                                        
+    for (n=0; n<num_transforms; n++){                                                   
+        offset = fft_offsets_lut[n] << 3;                                               
+        tmpz = z + offset;                                                              
+                                                                                        
+        tmp1 = tmpz[4].re + tmpz[5].re;                                                 
+        tmp3 = tmpz[6].re + tmpz[7].re;                                                 
+        tmp2 = tmpz[4].im + tmpz[5].im;                                                 
+        tmp4 = tmpz[6].im + tmpz[7].im;                                                 
+        tmp5 = tmp1 + tmp3;                                                             
+        tmp7 = tmp1 - tmp3;                                                             
+        tmp6 = tmp2 + tmp4;                                                             
+        tmp8 = tmp2 - tmp4;                                                             
+                                                                                        
+        tmp1 = tmpz[4].re - tmpz[5].re;                                                 
+        tmp2 = tmpz[4].im - tmpz[5].im;                                                 
+        tmp3 = tmpz[6].re - tmpz[7].re;                                                 
+        tmp4 = tmpz[6].im - tmpz[7].im;                                                 
+                                                                                        
+        tmpz[4].re = tmpz[0].re - tmp5;                                                 
+        tmpz[0].re = tmpz[0].re + tmp5;                                                 
+        tmpz[4].im = tmpz[0].im - tmp6;                                                 
+        tmpz[0].im = tmpz[0].im + tmp6;                                                 
+        tmpz[6].re = tmpz[2].re - tmp8;                                                 
+        tmpz[2].re = tmpz[2].re + tmp8;                                                 
+        tmpz[6].im = tmpz[2].im + tmp7;                                                 
+        tmpz[2].im = tmpz[2].im - tmp7;                                                 
+                                                                                        
+        accu = (int64_t)Q31(M_SQRT1_2)*(tmp1 + tmp2);                                   
+        tmp5 = (int32_t)((accu + 0x40000000) >> 31);                                    
+        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 - tmp4);                                   
+        tmp7 = (int32_t)((accu + 0x40000000) >> 31);                                    
+        accu = (int64_t)Q31(M_SQRT1_2)*(tmp2 - tmp1);                                   
+        tmp6 = (int32_t)((accu + 0x40000000) >> 31);                                    
+        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 + tmp4);                                   
+        tmp8 = (int32_t)((accu + 0x40000000) >> 31);                                    
+        tmp1 = tmp5 + tmp7;                                                             
+        tmp3 = tmp5 - tmp7;                                                             
+        tmp2 = tmp6 + tmp8;                                                             
+        tmp4 = tmp6 - tmp8;                                                             
+                                                                                        
+        tmpz[5].re = tmpz[1].re - tmp1;                                                 
+        tmpz[1].re = tmpz[1].re + tmp1;                                                 
+        tmpz[5].im = tmpz[1].im - tmp2;                                                 
+        tmpz[1].im = tmpz[1].im + tmp2;                                                 
+        tmpz[7].re = tmpz[3].re - tmp4;                                                 
+        tmpz[3].re = tmpz[3].re + tmp4;                                                 
+        tmpz[7].im = tmpz[3].im + tmp3;                                                 
+        tmpz[3].im = tmpz[3].im - tmp3;                                                 
+    }                                                                                   
+                                                                                        
+    step = 1 << ((MAX_LOG2_NFFT-4) - 4);                                                
+    n4 = 4;                                                                             
+                                                                                        
+    for (nbits=4; nbits<=s->nbits; nbits++){                                            
+        n2  = 2*n4;                                                                     
+        n34 = 3*n4;                                                                     
+        num_transforms = (num_transforms >> 1) | 1;                                     
+                                                                                        
+        for (n=0; n<num_transforms; n++){                                               
+            offset = fft_offsets_lut[n] << nbits;                                       
+            tmpz = z + offset;                                                          
+                                                                                        
+            tmp5 = tmpz[ n2].re + tmpz[n34].re;                                         
+            tmp1 = tmpz[ n2].re - tmpz[n34].re;                                         
+            tmp6 = tmpz[ n2].im + tmpz[n34].im;                                         
+            tmp2 = tmpz[ n2].im - tmpz[n34].im;                                         
+                                                                                        
+            tmpz[ n2].re = tmpz[ 0].re - tmp5;                                          
+            tmpz[  0].re = tmpz[ 0].re + tmp5;                                          
+            tmpz[ n2].im = tmpz[ 0].im - tmp6;                                          
+            tmpz[  0].im = tmpz[ 0].im + tmp6;                                          
+            tmpz[n34].re = tmpz[n4].re - tmp2;                                          
+            tmpz[ n4].re = tmpz[n4].re + tmp2;                                          
+            tmpz[n34].im = tmpz[n4].im + tmp1;                                          
+            tmpz[ n4].im = tmpz[n4].im - tmp1;                                          
+                                                                                        
+            w_re_ptr = w_tab_sr + step;                                                 
+            w_im_ptr = w_tab_sr + MAX_FFT_SIZE/(4*16) - step;                           
+                                                                                        
+            for (i=1; i<n4; i++){                                                       
+                w_re = w_re_ptr[0];                                                     
+                w_im = w_im_ptr[0];                                                     
+                accu  = (int64_t)w_re*tmpz[ n2+i].re;                                   
+                accu += (int64_t)w_im*tmpz[ n2+i].im;                                   
+                tmp1 = (int32_t)((accu + 0x40000000) >> 31);                            
+                accu  = (int64_t)w_re*tmpz[ n2+i].im;                                   
+                accu -= (int64_t)w_im*tmpz[ n2+i].re;                                   
+                tmp2 = (int32_t)((accu + 0x40000000) >> 31);                            
+                accu  = (int64_t)w_re*tmpz[n34+i].re;                                   
+                accu -= (int64_t)w_im*tmpz[n34+i].im;                                   
+                tmp3 = (int32_t)((accu + 0x40000000) >> 31);                            
+                accu  = (int64_t)w_re*tmpz[n34+i].im;                                   
+                accu += (int64_t)w_im*tmpz[n34+i].re;                                   
+                tmp4 = (int32_t)((accu + 0x40000000) >> 31);                            
+                                                                                        
+                tmp5 = tmp1 + tmp3;                                                     
+                tmp1 = tmp1 - tmp3;                                                     
+                tmp6 = tmp2 + tmp4;                                                     
+                tmp2 = tmp2 - tmp4;                                                     
+                                                                                        
+                tmpz[ n2+i].re = tmpz[   i].re - tmp5;                                  
+                tmpz[    i].re = tmpz[   i].re + tmp5;                                  
+                tmpz[ n2+i].im = tmpz[   i].im - tmp6;                                  
+                tmpz[    i].im = tmpz[   i].im + tmp6;                                  
+                tmpz[n34+i].re = tmpz[n4+i].re - tmp2;                                  
+                tmpz[ n4+i].re = tmpz[n4+i].re + tmp2;                                  
+                tmpz[n34+i].im = tmpz[n4+i].im + tmp1;                                  
+                tmpz[ n4+i].im = tmpz[n4+i].im - tmp1;                                  
+                                                                                        
+                w_re_ptr += step;                                                       
+                w_im_ptr -= step;                                                       
+            }                                                                           
+        }                                                                               
+        step >>= 1;                                                                     
+        n4   <<= 1;                                                                     
+    }                                                                                   
+}                                                                                       
+                                                                                        
+#else /* CONFIG_FFT_FIXED_32 */
+
 #define BUTTERFLIES(a0,a1,a2,a3) {\
     BF(t3, t5, t5, t1);\
     BF(a2.re, a0.re, a0.re, t5);\
@@ -350,4 +525,4 @@
 {
     fft_dispatch[s->nbits-2](z);
 }
-
+#endif /* CONFIG_FFT_FIXED_32 */
diff -uNr ffmpeg-0.7.12/libavcodec/fft_fixed_32.c ffmpeg-0.7.12-140902/libavcodec/fft_fixed_32.c
--- ffmpeg-0.7.12/libavcodec/fft_fixed_32.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft_fixed_32.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,52 @@
+/*                                                                                  
+ * Copyright (c) 2012                                                          
+ *      MIPS Technologies, Inc., California.                                   
+ *                                                                             
+ * Redistribution and use in source and binary forms, with or without          
+ * modification, are permitted provided that the following conditions          
+ * are met:                                                                    
+ * 1. Redistributions of source code must retain the above copyright           
+ *    notice, this list of conditions and the following disclaimer.            
+ * 2. Redistributions in binary form must reproduce the above copyright        
+ *    notice, this list of conditions and the following disclaimer in the      
+ *    documentation and/or other materials provided with the distribution.     
+ * 3. Neither the name of the MIPS Technologies, Inc., nor the names of its    
+ *    contributors may be used to endorse or promote products derived from     
+ *    this software without specific prior written permission.                 
+ *                                                                             
+ * THIS SOFTWARE IS PROVIDED BY THE MIPS TECHNOLOGIES, INC. ``AS IS'' AND      
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE MIPS TECHNOLOGIES, INC. BE LIABLE    
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      
+ * SUCH DAMAGE.                                                                
+ *                                                                             
+ * Authors:  Stanislav Ocovaj (socovaj@mips.com)                               
+ *           Goran Cordasic   (goran@mips.com)                                 
+ *           Djordje Pesut    (djordje@mips.com)                               
+ *                                                                             
+ * This file is part of FFmpeg.                                                
+ *                                                                             
+ * FFmpeg is free software; you can redistribute it and/or                     
+ * modify it under the terms of the GNU Lesser General Public                  
+ * License as published by the Free Software Foundation; either                
+ * version 2.1 of the License, or (at your option) any later version.          
+ *                                                                             
+ * FFmpeg is distributed in the hope that it will be useful,                   
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of              
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           
+ * Lesser General Public License for more details.                             
+ *                                                                             
+ * You should have received a copy of the GNU Lesser General Public            
+ * License along with FFmpeg; if not, write to the Free Software               
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */                                                                            
+                                                                               
+#define CONFIG_FFT_FLOAT 0                                                     
+#define CONFIG_FFT_FIXED_32 1                                                  
+#include "fft.c"
diff -uNr ffmpeg-0.7.12/libavcodec/fixed_bitstream.h ffmpeg-0.7.12NF/libavcodec/fixed_bitstream.h
--- ffmpeg-0.7.12/libavcodec/fixed_bitstream.h	2013-08-26 15:52:03.076038042 +0800
+++ ffmpeg-0.7.12NF/libavcodec/fixed_bitstream.h	2013-08-20 16:53:24.000000000 +0800
@@ -188,6 +188,7 @@
     int size_in_bits;
 } GetBitContext_fixed;
 
+
 #define VLC_TYPE int16_t
 
 typedef struct VLC_FIX {
@@ -480,16 +481,16 @@
 # endif
 
 // FIXME name?
-#   define SKIP_COUNTER(name, gb, num)\
+#   define SKIP_COUNTER_FIX(name, gb, num)\
         name##_index += (num);\
 
 #   define SKIP_BITS_FIX(name, gb, num)\
         {\
             SKIP_CACHE_FIX(name, gb, num)\
-            SKIP_COUNTER(name, gb, num)\
+            SKIP_COUNTER_FIX(name, gb, num)\
         }\
 
-#   define LAST_SKIP_BITS_FIX(name, gb, num) SKIP_COUNTER(name, gb, num)
+#   define LAST_SKIP_BITS_FIX(name, gb, num) SKIP_COUNTER_FIX(name, gb, num)
 #   define LAST_SKIP_CACHE_FIX(name, gb, num) ;
 
 # ifdef ALT_BITSTREAM_READER_LE
@@ -517,6 +518,12 @@
     s->index += n;
 }
 
+static inline int get_bits_left_fixed(GetBitContext_fixed *gb)
+{
+    return gb->size_in_bits - get_bits_count_fixed(gb);
+}
+
+
 #elif defined LIBMPEG2_BITSTREAM_READER
 //libmpeg2 like reader
 
@@ -555,13 +562,13 @@
 #   define SKIP_CACHE_FIX(name, gb, num)\
         name##_cache <<= (num);\
 
-#   define SKIP_COUNTER(name, gb, num)\
+#   define SKIP_COUNTER_FIX(name, gb, num)\
         name##_bit_count += (num);\
 
 #   define SKIP_BITS_FIX(name, gb, num)\
         {\
             SKIP_CACHE_FIX(name, gb, num)\
-            SKIP_COUNTER(name, gb, num)\
+            SKIP_COUNTER_FIX(name, gb, num)\
         }\
 
 #   define LAST_SKIP_BITS_FIX(name, gb, num) SKIP_BITS_FIX(name, gb, num)
@@ -630,13 +637,13 @@
         name##_cache1 <<= (num);
 //#endif
 
-#   define SKIP_COUNTER(name, gb, num)\
+#   define SKIP_COUNTER_FIX(name, gb, num)\
         name##_bit_count += (num);\
 
 #   define SKIP_BITS_FIX(name, gb, num)\
         {\
             SKIP_CACHE_FIX(name, gb, num)\
-            SKIP_COUNTER(name, gb, num)\
+            SKIP_COUNTER_FIX(name, gb, num)\
         }\
 
 #   define LAST_SKIP_BITS_FIX(name, gb, num) SKIP_BITS_FIX(name, gb, num)
diff -uNr ffmpeg-0.7.12/libavcodec/fft-fixed32-test.c ffmpeg-0.7.12-140902/libavcodec/fft-fixed32-test.c
--- ffmpeg-0.7.12/libavcodec/fft-fixed32-test.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft-fixed32-test.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,21 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 1
+#include "fft-test.c"
diff -uNr ffmpeg-0.7.12/libavcodec/fft_fixed.c ffmpeg-0.7.12-140902/libavcodec/fft_fixed.c
--- ffmpeg-0.7.12/libavcodec/fft_fixed.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft_fixed.c	2013-10-31 11:10:02.000000000 +0800
@@ -17,4 +17,5 @@
  */
 
 #define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 0
 #include "fft.c"
diff -uNr ffmpeg-0.7.12/libavcodec/fft_float.c ffmpeg-0.7.12-140902/libavcodec/fft_float.c
--- ffmpeg-0.7.12/libavcodec/fft_float.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft_float.c	2013-10-31 11:10:02.000000000 +0800
@@ -17,4 +17,5 @@
  */
 
 #define CONFIG_FFT_FLOAT 1
+#define CONFIG_FFT_FIXED_32 0
 #include "fft.c"
diff -uNr ffmpeg-0.7.12/libavcodec/fft.h ffmpeg-0.7.12-140902/libavcodec/fft.h
--- ffmpeg-0.7.12/libavcodec/fft.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft.h	2014-09-02 15:37:36.000000000 +0800
@@ -33,22 +33,33 @@
 #if CONFIG_FFT_FLOAT
 
 #include "avfft.h"
-
+#define CONFIG_FFT_FIXED_32 0
 #define FFT_NAME(x) x
 
 typedef float FFTDouble;
 
 #else
+#ifndef CONFIG_FFT_FIXED_32
+#define CONFIG_FFT_FIXED_32 1
+#endif
+
+#if CONFIG_FFT_FIXED_32                                                                 
+                                                                                        
+#define Q31(x) (int)((x)*2147483648.0 + 0.5)                                            
+#define FFT_NAME(x) x ## _fixed_32                                                      
+                                                                                        
+typedef int32_t FFTSample;                                                              
+                                                                                        
+#else /* CONFIG_FFT_FIXED_32 */ 
 
 #define FFT_NAME(x) x ## _fixed
 
 typedef int16_t FFTSample;
-typedef int     FFTDouble;
-
+#endif /* CONFIG_FFT_FIXED_32 */   
 typedef struct FFTComplex {
-    int16_t re, im;
+    FFTSample re, im;
 } FFTComplex;
-
+typedef int    FFTDouble; 
 typedef struct FFTContext FFTContext;
 
 #endif /* CONFIG_FFT_FLOAT */
@@ -131,12 +142,17 @@
  * @param nbits           log2 of the length of the input array
  * @param inverse         if 0 perform the forward transform, if 1 perform the inverse
  */
+
 int ff_fft_init(FFTContext *s, int nbits, int inverse);
 
 #if CONFIG_FFT_FLOAT
 void ff_fft_init_altivec(FFTContext *s);
 void ff_fft_init_mmx(FFTContext *s);
 void ff_fft_init_arm(FFTContext *s);
+
+void ff_fft_init_x86(FFTContext *s);                                                    
+void ff_fft_init_mips(FFTContext *s);                                                   
+void ff_fft_init_ppc(FFTContext *s);   
 #else
 void ff_fft_fixed_init_arm(FFTContext *s);
 #endif
diff -uNr ffmpeg-0.7.12/libavcodec/fft_init_table.c ffmpeg-0.7.12-140902/libavcodec/fft_init_table.c
--- ffmpeg-0.7.12/libavcodec/fft_init_table.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft_init_table.c	2014-09-02 15:38:16.000000000 +0800
@@ -0,0 +1,148 @@
+                                                                                                          
+#include "libavcodec/fft_table.h"                                                                                   
+                                                                                                                    
+int32_t w_tab_sr[MAX_FFT_SIZE/(4*16)] = {                                                                           
+    2147483647, 2147481121, 2147473542, 2147460908, 2147443222, 2147420483, 2147392690, 2147359845,                 
+    2147321946, 2147278995, 2147230991, 2147177934, 2147119825, 2147056664, 2146988450, 2146915184,                 
+    2146836866, 2146753497, 2146665076, 2146571603, 2146473080, 2146369505, 2146260881, 2146147205,                 
+    2146028480, 2145904705, 2145775880, 2145642006, 2145503083, 2145359112, 2145210092, 2145056025,                 
+    2144896910, 2144732748, 2144563539, 2144389283, 2144209982, 2144025635, 2143836244, 2143641807,                 
+    2143442326, 2143237802, 2143028234, 2142813624, 2142593971, 2142369276, 2142139541, 2141904764,                 
+    2141664948, 2141420092, 2141170197, 2140915264, 2140655293, 2140390284, 2140120240, 2139845159,                 
+    2139565043, 2139279892, 2138989708, 2138694490, 2138394240, 2138088958, 2137778644, 2137463301,                 
+    2137142927, 2136817525, 2136487095, 2136151637, 2135811153, 2135465642, 2135115107, 2134759548,                 
+    2134398966, 2134033361, 2133662734, 2133287087, 2132906420, 2132520734, 2132130030, 2131734309,                 
+    2131333572, 2130927819, 2130517052, 2130101272, 2129680480, 2129254676, 2128823862, 2128388038,                 
+    2127947206, 2127501367, 2127050522, 2126594672, 2126133817, 2125667960, 2125197100, 2124721240,                 
+    2124240380, 2123754522, 2123263666, 2122767814, 2122266967, 2121761126, 2121250292, 2120734467,                 
+    2120213651, 2119687847, 2119157054, 2118621275, 2118080511, 2117534762, 2116984031, 2116428319,                 
+    2115867626, 2115301954, 2114731305, 2114155680, 2113575080, 2112989506, 2112398960, 2111803444,                 
+    2111202959, 2110597505, 2109987085, 2109371700, 2108751352, 2108126041, 2107495770, 2106860540,                 
+    2106220352, 2105575208, 2104925109, 2104270057, 2103610054, 2102945101, 2102275199, 2101600350,                 
+    2100920556, 2100235819, 2099546139, 2098851519, 2098151960, 2097447464, 2096738032, 2096023667,                 
+    2095304370, 2094580142, 2093850985, 2093116901, 2092377892, 2091633960, 2090885105, 2090131331,                 
+    2089372638, 2088609029, 2087840505, 2087067068, 2086288720, 2085505463, 2084717298, 2083924228,                 
+    2083126254, 2082323379, 2081515603, 2080702930, 2079885360, 2079062896, 2078235540, 2077403294,                 
+    2076566160, 2075724139, 2074877233, 2074025446, 2073168777, 2072307231, 2071440808, 2070569511,                 
+    2069693342, 2068812302, 2067926394, 2067035621, 2066139983, 2065239484, 2064334124, 2063423908,                 
+    2062508835, 2061588910, 2060664133, 2059734508, 2058800036, 2057860719, 2056916560, 2055967560,                 
+    2055013723, 2054055050, 2053091544, 2052123207, 2051150040, 2050172048, 2049189231, 2048201592,                 
+    2047209133, 2046211857, 2045209767, 2044202863, 2043191150, 2042174628, 2041153301, 2040127172,                 
+    2039096241, 2038060512, 2037019988, 2035974670, 2034924562, 2033869665, 2032809982, 2031745516,                 
+    2030676269, 2029602243, 2028523442, 2027439867, 2026351522, 2025258408, 2024160529, 2023057887,                 
+    2021950484, 2020838323, 2019721407, 2018599739, 2017473321, 2016342155, 2015206245, 2014065592,                 
+    2012920201, 2011770073, 2010615210, 2009455617, 2008291295, 2007122248, 2005948478, 2004769987,                 
+    2003586779, 2002398857, 2001206222, 2000008879, 1998806829, 1997600076, 1996388622, 1995172471,                 
+    1993951625, 1992726087, 1991495860, 1990260946, 1989021350, 1987777073, 1986528118, 1985274489,                 
+    1984016189, 1982753220, 1981485585, 1980213288, 1978936331, 1977654717, 1976368450, 1975077532,                 
+    1973781967, 1972481757, 1971176906, 1969867417, 1968553292, 1967234535, 1965911148, 1964583136,                 
+    1963250501, 1961913246, 1960571375, 1959224890, 1957873796, 1956518093, 1955157788, 1953792881,                 
+    1952423377, 1951049279, 1949670589, 1948287312, 1946899451, 1945507008, 1944109987, 1942708392,                 
+    1941302225, 1939891490, 1938476190, 1937056329, 1935631910, 1934202936, 1932769411, 1931331338,                 
+    1929888720, 1928441561, 1926989864, 1925533633, 1924072871, 1922607581, 1921137767, 1919663432,                 
+    1918184581, 1916701216, 1915213340, 1913720958, 1912224073, 1910722688, 1909216806, 1907706433,                 
+    1906191570, 1904672222, 1903148392, 1901620084, 1900087301, 1898550047, 1897008325, 1895462140,                 
+    1893911494, 1892356392, 1890796837, 1889232832, 1887664383, 1886091491, 1884514161, 1882932397,                 
+    1881346202, 1879755580, 1878160535, 1876561070, 1874957189, 1873348897, 1871736196, 1870119091,                 
+    1868497586, 1866871683, 1865241388, 1863606704, 1861967634, 1860324183, 1858676355, 1857024153,                 
+    1855367581, 1853706643, 1852041343, 1850371686, 1848697674, 1847019312, 1845336604, 1843649553,                 
+    1841958164, 1840262441, 1838562388, 1836858008, 1835149306, 1833436286, 1831718951, 1829997307,                 
+    1828271356, 1826541103, 1824806552, 1823067707, 1821324572, 1819577151, 1817825449, 1816069469,                 
+    1814309216, 1812544694, 1810775906, 1809002858, 1807225553, 1805443995, 1803658189, 1801868139,                 
+    1800073849, 1798275323, 1796472565, 1794665580, 1792854372, 1791038946, 1789219305, 1787395453,                 
+    1785567396, 1783735137, 1781898681, 1780058032, 1778213194, 1776364172, 1774510970, 1772653593,                 
+    1770792044, 1768926328, 1767056450, 1765182414, 1763304224, 1761421885, 1759535401, 1757644777,                 
+    1755750017, 1753851126, 1751948107, 1750040966, 1748129707, 1746214334, 1744294853, 1742371267,                 
+    1740443581, 1738511799, 1736575927, 1734635968, 1732691928, 1730743810, 1728791620, 1726835361,                 
+    1724875040, 1722910659, 1720942225, 1718969740, 1716993211, 1715012642, 1713028037, 1711039401,                 
+    1709046739, 1707050055, 1705049355, 1703044642, 1701035922, 1699023199, 1697006479, 1694985765,                 
+    1692961062, 1690932376, 1688899711, 1686863072, 1684822463, 1682777890, 1680729357, 1678676870,                 
+    1676620432, 1674560049, 1672495725, 1670427466, 1668355276, 1666279161, 1664199124, 1662115172,                 
+    1660027308, 1657935539, 1655839867, 1653740300, 1651636841, 1649529496, 1647418269, 1645303166,                 
+    1643184191, 1641061349, 1638934646, 1636804087, 1634669676, 1632531418, 1630389319, 1628243383,                 
+    1626093616, 1623940023, 1621782608, 1619621377, 1617456335, 1615287487, 1613114838, 1610938393,                 
+    1608758157, 1606574136, 1604386335, 1602194758, 1599999411, 1597800299, 1595597428, 1593390801,                 
+    1591180426, 1588966306, 1586748447, 1584526854, 1582301533, 1580072489, 1577839726, 1575603251,                 
+    1573363068, 1571119183, 1568871601, 1566620327, 1564365367, 1562106725, 1559844408, 1557578421,                 
+    1555308768, 1553035455, 1550758488, 1548477872, 1546193612, 1543905714, 1541614183, 1539319024,                 
+    1537020244, 1534717846, 1532411837, 1530102222, 1527789007, 1525472197, 1523151797, 1520827813,                 
+    1518500250, 1516169114, 1513834411, 1511496145, 1509154322, 1506808949, 1504460029, 1502107570,                 
+    1499751576, 1497392053, 1495029006, 1492662441, 1490292364, 1487918781, 1485541696, 1483161115,                 
+    1480777044, 1478389489, 1475998456, 1473603949, 1471205974, 1468804538, 1466399645, 1463991302,                 
+    1461579514, 1459164286, 1456745625, 1454323536, 1451898025, 1449469098, 1447036760, 1444601017,                 
+    1442161874, 1439719338, 1437273414, 1434824109, 1432371426, 1429915374, 1427455956, 1424993180,                 
+    1422527051, 1420057574, 1417584755, 1415108601, 1412629117, 1410146309, 1407660183, 1405170745,                 
+    1402678000, 1400181954, 1397682613, 1395179984, 1392674072, 1390164882, 1387652422, 1385136696,                 
+    1382617710, 1380095472, 1377569986, 1375041258, 1372509294, 1369974101, 1367435685, 1364894050,                 
+    1362349204, 1359801152, 1357249901, 1354695455, 1352137822, 1349577007, 1347013017, 1344445857,                 
+    1341875533, 1339302052, 1336725419, 1334145641, 1331562723, 1328976672, 1326387494, 1323795195,                 
+    1321199781, 1318601257, 1315999631, 1313394909, 1310787095, 1308176198, 1305562222, 1302945174,                 
+    1300325060, 1297701886, 1295075659, 1292446384, 1289814068, 1287178717, 1284540337, 1281898935,                 
+    1279254516, 1276607086, 1273956653, 1271303222, 1268646800, 1265987392, 1263325005, 1260659646,                 
+    1257991320, 1255320034, 1252645794, 1249968606, 1247288478, 1244605414, 1241919421, 1239230506,                 
+    1236538675, 1233843935, 1231146291, 1228445750, 1225742318, 1223036002, 1220326809, 1217614743,                 
+    1214899813, 1212182024, 1209461382, 1206737894, 1204011567, 1201282407, 1198550419, 1195815612,                 
+    1193077991, 1190337562, 1187594332, 1184848308, 1182099496, 1179347902, 1176593533, 1173836395,                 
+    1171076495, 1168313840, 1165548435, 1162780288, 1160009405, 1157235792, 1154459456, 1151680403,                 
+    1148898640, 1146114174, 1143327011, 1140537158, 1137744621, 1134949406, 1132151521, 1129350972,                 
+    1126547765, 1123741908, 1120933406, 1118122267, 1115308496, 1112492101, 1109673089, 1106851465,                 
+    1104027237, 1101200410, 1098370993, 1095538991, 1092704411, 1089867259, 1087027544, 1084185270,                 
+    1081340445, 1078493076, 1075643169, 1072790730, 1069935768, 1067078288, 1064218296, 1061355801,                 
+    1058490808, 1055623324, 1052753357, 1049880912, 1047005996, 1044128617, 1041248781, 1038366495,                 
+    1035481766, 1032594600, 1029705004, 1026812985, 1023918550, 1021021705, 1018122458, 1015220816,                 
+    1012316784, 1009410370, 1006501581, 1003590424, 1000676905,  997761031,  994842810,  991922248,                 
+     988999351,  986074127,  983146583,  980216726,  977284562,  974350098,  971413342,  968474300,                 
+     965532978,  962589385,  959643527,  956695411,  953745043,  950792431,  947837582,  944880503,                 
+     941921200,  938959681,  935995952,  933030021,  930061894,  927091579,  924119082,  921144411,                 
+     918167572,  915188572,  912207419,  909224120,  906238681,  903251110,  900261413,  897269597,                 
+     894275671,  891279640,  888281512,  885281293,  882278992,  879274614,  876268167,  873259659,                 
+     870249095,  867236484,  864221832,  861205147,  858186435,  855165703,  852142959,  849118210,                 
+     846091463,  843062726,  840032004,  836999305,  833964638,  830928007,  827889422,  824848888,                 
+     821806413,  818762005,  815715670,  812667415,  809617249,  806565177,  803511207,  800455346,                 
+     797397602,  794337982,  791276492,  788213141,  785147934,  782080880,  779011986,  775941259,                 
+     772868706,  769794334,  766718151,  763640164,  760560380,  757478806,  754395449,  751310318,                 
+     748223418,  745134758,  742044345,  738952186,  735858287,  732762657,  729665303,  726566232,                 
+     723465451,  720362968,  717258790,  714152924,  711045377,  707936158,  704825272,  701712728,                 
+     698598533,  695482694,  692365218,  689246113,  686125387,  683003045,  679879097,  676753549,                 
+     673626408,  670497682,  667367379,  664235505,  661102068,  657967075,  654830535,  651692453,                 
+     648552838,  645411696,  642269036,  639124865,  635979190,  632832018,  629683357,  626533215,                 
+     623381598,  620228514,  617073971,  613917975,  610760536,  607601658,  604441352,  601279623,                 
+     598116479,  594951927,  591785976,  588618632,  585449903,  582279796,  579108320,  575935480,                 
+     572761285,  569585743,  566408860,  563230645,  560051104,  556870245,  553688076,  550504604,                 
+     547319836,  544133781,  540946445,  537757837,  534567963,  531376831,  528184449,  524990824,                 
+     521795963,  518599875,  515402566,  512204045,  509004318,  505803394,  502601279,  499397982,                 
+    496193509,  492987869,  489781069,  486573117,  483364019,  480153784,  476942419,  473729932,                 
+     470516330,  467301622,  464085813,  460868912,  457650927,  454431865,  451211734,  447990541,                 
+     444768294,  441545000,  438320667,  435095303,  431868915,  428641511,  425413098,  422183684,                 
+     418953276,  415721883,  412489512,  409256170,  406021865,  402786604,  399550396,  396313247,                 
+     393075166,  389836160,  386596237,  383355404,  380113669,  376871039,  373627523,  370383128,                 
+     367137861,  363891730,  360644742,  357396906,  354148230,  350898719,  347648383,  344397230,                 
+     341145265,  337892498,  334638936,  331384586,  328129457,  324873555,  321616889,  318359466,                 
+     315101295,  311842381,  308582734,  305322361,  302061269,  298799466,  295536961,  292273760,                 
+     289009871,  285745302,  282480061,  279214155,  275947592,  272680379,  269412525,  266144038,                 
+     262874923,  259605191,  256334847,  253063900,  249792358,  246520228,  243247518,  239974235,                 
+     236700388,  233425984,  230151030,  226875535,  223599506,  220322951,  217045878,  213768293,                 
+     210490206,  207211624,  203932553,  200653003,  197372981,  194092495,  190811551,  187530159,                 
+     184248325,  180966058,  177683365,  174400254,  171116733,  167832808,  164548489,  161263783,                 
+     157978697,  154693240,  151407418,  148121241,  144834714,  141547847,  138260647,  134973122,                 
+     131685278,  128397125,  125108670,  121819921,  118530885,  115241570,  111951983,  108662134,                 
+     105372028,  102081675,   98791081,   95500255,   92209205,   88917937,   85626460,   82334782,                 
+      79042909,   75750851,   72458615,   69166208,   65873638,   62580914,   59288042,   55995030,                 
+      52701887,   49408620,   46115236,   42821744,   39528151,   36234466,   32940695,   29646846,                 
+      26352928,   23058947,   19764913,   16470832,   13176712,    9882561,    6588387,    3294197                  
+};                                                                                                                  
+                                                                                                                    
+uint16_t fft_offsets_lut[0x2aab];                                                                                   
+                                                                                                                    
+void ff_fft_lut_init(uint16_t *table, int off, int size, int *index)                                                
+{                                                                                                                   
+    if (size < 16) {                                                                                                
+        table[*index] = off >> 2;                                                                                   
+        (*index)++;                                                                                                 
+    }                                                                                                               
+    else {                                                                                                          
+        ff_fft_lut_init(table, off, size>>1, index);                                                                
+        ff_fft_lut_init(table, off+(size>>1), size>>2, index);                                                      
+        ff_fft_lut_init(table, off+3*(size>>2), size>>2, index);                                                    
+    }                                                                                                               
+}                                                       
diff -uNr ffmpeg-0.7.12/libavcodec/fft-internal.h ffmpeg-0.7.12-140902/libavcodec/fft-internal.h
--- ffmpeg-0.7.12/libavcodec/fft-internal.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft-internal.h	2014-09-02 15:38:34.000000000 +0800
@@ -35,13 +35,28 @@
     } while (0)
 
 #else
-
+#define SCALE_FLOAT(a, bits) lrint((a) * (double)(1 << (bits)))
+#if CONFIG_FFT_FIXED_32                                                        
+                                                                               
+#define CMUL(dre, dim, are, aim, bre, bim) do {             \
+        int64_t accu;                                     \
+        (accu)  = (int64_t)(bre) * (are);                 \
+        (accu) -= (int64_t)(bim) * (aim);                 \
+        (dre)   = (int)(((accu) + 0x40000000) >> 31);       \
+        (accu)  = (int64_t)(bre) * (aim);                 \
+        (accu) += (int64_t)(bim) * (are);                 \
+        (dim)   = (int)(((accu) + 0x40000000) >> 31);       \                  
+    } while (0)                                                                
+                                                                               
+#define FIX15(a) av_clip(SCALE_FLOAT(a, 31), -2147483647, 2147483647)
+//#define FIX15(a) av_clip(SCALE_FLOAT(a, 15), -32767, 32767)                                                                            
+#else /* CONFIG_FFT_FIXED_32 */                                                
 #include "libavutil/intmath.h"
 #include "mathops.h"
 
 void ff_mdct_calcw_c(FFTContext *s, FFTDouble *output, const FFTSample *input);
 
-#define SCALE_FLOAT(a, bits) lrint((a) * (double)(1 << (bits)))
+
 #define FIX15(a) av_clip(SCALE_FLOAT(a, 15), -32767, 32767)
 
 #define sqrthalf ((int16_t)((1<<15)*M_SQRT1_2))
@@ -61,7 +76,7 @@
 
 #define CMULL(dre, dim, are, aim, bre, bim)     \
     CMULS(dre, dim, are, aim, bre, bim, 0)
-
+#endif /* CONFIG_FFT_FIXED_32 */  
 #endif /* CONFIG_FFT_FLOAT */
 
 #define ff_imdct_calc_c FFT_NAME(ff_imdct_calc_c)
diff -uNr ffmpeg-0.7.12/libavcodec/fft_table.h ffmpeg-0.7.12-140902/libavcodec/fft_table.h
--- ffmpeg-0.7.12/libavcodec/fft_table.h	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft_table.h	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,66 @@
+/*                                                                                  
+ * Copyright (c) 2012                                                          
+ *      MIPS Technologies, Inc., California.                                   
+ *                                                                             
+ * Redistribution and use in source and binary forms, with or without          
+ * modification, are permitted provided that the following conditions          
+ * are met:                                                                    
+ * 1. Redistributions of source code must retain the above copyright           
+ *    notice, this list of conditions and the following disclaimer.            
+ * 2. Redistributions in binary form must reproduce the above copyright        
+ *    notice, this list of conditions and the following disclaimer in the      
+ *    documentation and/or other materials provided with the distribution.     
+ * 3. Neither the name of the MIPS Technologies, Inc., nor the names of its    
+ *    contributors may be used to endorse or promote products derived from     
+ *    this software without specific prior written permission.                 
+ *                                                                             
+ * THIS SOFTWARE IS PROVIDED BY THE MIPS TECHNOLOGIES, INC. ``AS IS'' AND      
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE MIPS TECHNOLOGIES, INC. BE LIABLE    
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      
+ * SUCH DAMAGE.                                                                
+ *                                                                             
+ * Authors:  Stanislav Ocovaj (socovaj@mips.com)                               
+ *           Goran Cordasic   (goran@mips.com)                                 
+ *           Djordje Pesut    (djordje@mips.com)                               
+ *                                                                             
+ * This file is part of FFmpeg.                                                
+ *                                                                             
+ * FFmpeg is free software; you can redistribute it and/or                     
+ * modify it under the terms of the GNU Lesser General Public                  
+ * License as published by the Free Software Foundation; either                
+ * version 2.1 of the License, or (at your option) any later version.          
+ *                                                                             
+ * FFmpeg is distributed in the hope that it will be useful,                   
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of              
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           
+ * Lesser General Public License for more details.                             
+ *                                                                             
+ * You should have received a copy of the GNU Lesser General Public            
+ * License along with FFmpeg; if not, write to the Free Software               
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */                                                                            
+                                                                               
+/**                                                                            
+ * @file                                                                       
+ * definitions and tables for FFT                                              
+ */                                                                            
+#ifndef AVCODEC_FFT_TABLE_H                                                    
+#define AVCODEC_FFT_TABLE_H                                                    
+                                                                               
+#include "libavcodec/fft.h"
+                                                                               
+#define MAX_LOG2_NFFT 16 //!< Specifies maxiumum allowed fft size              
+#define MAX_FFT_SIZE (1 << MAX_LOG2_NFFT)                                      
+                                                                               
+extern int32_t w_tab_sr[];                                                     
+extern uint16_t fft_offsets_lut[];                                             
+void ff_fft_lut_init(uint16_t *table, int off, int size, int *index);          
+                                                                               
+#endif /* AVCODEC_FFT_TABLE_H */                                               
diff -uNr ffmpeg-0.7.12/libavcodec/fft-test.c ffmpeg-0.7.12-140902/libavcodec/fft-test.c
--- ffmpeg-0.7.12/libavcodec/fft-test.c	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fft-test.c	2013-10-31 11:10:02.000000000 +0800
@@ -53,6 +53,10 @@
 #   define RANGE 1.0
 #   define REF_SCALE(x, bits)  (x)
 #   define FMT "%10.6f"
+#elif CONFIG_FFT_FIXED_32
+#   define RANGE 8388608 
+#   define REF_SCALE(x, bits) (x)
+#   define FMT "%6d"
 #else
 #   define RANGE 16384
 #   define REF_SCALE(x, bits) ((x) / (1<<(bits)))

diff -uNr ffmpeg-0.7.12/libavcodec/fixed_dsp.c ffmpeg-0.7.12-140902/libavcodec/fixed_dsp.c
--- ffmpeg-0.7.12/libavcodec/fixed_dsp.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fixed_dsp.c	2014-09-04 17:13:57.048252934 +0800
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) 2012
+ *      MIPS Technologies, Inc., California.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the MIPS Technologies, Inc., nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE MIPS TECHNOLOGIES, INC. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE MIPS TECHNOLOGIES, INC. BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Author:  Nedeljko Babic (nbabic <at> mips.com)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "fixed_dsp.h"
+
+static void vector_fmul_add_fixed_c(int *dst, const int *src0, const int *src1, const int *src2, int len){
+    int i;
+    int64_t accu;
+
+    for (i=0; i<len; i++) {
+        accu = (int64_t)src0[i] * src1[i];
+        dst[i] = src2[i] + (int)((accu + 0x40000000) >> 31);                                                                                             
+    }
+}
+
+static void vector_fmul_reverse_fixed_c(int *dst, const int *src0, const int *src1, int len)
+{
+    int i;
+    int64_t accu;                                                                                                                                        
+                                                                                                                                                         
+    src1 += len-1;                                                                                                                                       
+    for (i=0; i<len; i++) {                                                                                                                              
+        accu = (int64_t)src0[i] * src1[-i];                                                                                                              
+        dst[i] = (int)((accu+0x40000000) >> 31);                                                                                                         
+    }                                                                                                                                                    
+}                                                                                                                                                        
+        
+static void vector_fmul_window_fixed_scaled_c(int16_t *dst, const int32_t *src0,                                                               
+                                       const int32_t *src1, const int32_t *win,                                                                
+                                       int len, uint8_t bits)                                                                                  
+{                                                                                                                                              
+    int32_t s0, s1, wi, wj, i,j, round;                                                                                                        
+                                                                                                                                               
+    dst += len;                                                                                                                                
+    win += len;                                                                                                                                
+    src0+= len;                                                                                                                                
+    round = bits? 1 << (bits-1) : 0;                                                                                                           
+                                                                                                                                               
+    for (i=-len, j=len-1; i<0; i++, j--) {                                                                                                     
+        s0 = src0[i];                                                                                                                          
+        s1 = src1[j];                                                                                                                          
+        wi = win[i];                                                                                                                           
+        wj = win[j];                                                                                                                           
+        dst[i] = av_clip_int16_c(((((int64_t)s0*wj - (int64_t)s1*wi + 0x40000000) >> 31) + round) >> bits);                                    
+        dst[j] = av_clip_int16_c(((((int64_t)s0*wi + (int64_t)s1*wj + 0x40000000) >> 31) + round) >> bits);                                    
+    }                                                                                                                                          
+}                                                                                                                                              
+
+void vector_fmul_fixed_ogg(int *dst, const int *src0, const int *src1, int len)
+{
+    int i;
+    int64_t accu;
+ //av_log(NULL,AV_LOG_INFO,"%s:ENTER\n", __FUNCTION__);
+    for (i = 0; i < len; i++) {
+        accu = (int64_t)src0[i] * src1[i];
+        dst[i] = (int)(((accu+0x4000000) >> 31)) >>8;
+    }
+}
+
+void vector_fmul_window_fixed_ogg(int32_t *dst, const int32_t *src0,
+                                       const int32_t *src1, const int32_t *win,
+                                       int len)
+{
+    int32_t s0, s1, wi, wj, i, j;
+
+    dst += len;
+    win += len;
+    src0+= len;
+
+    for (i=-len, j=len-1; i<0; i++, j--) {
+        s0 = src0[i];
+        s1 = src1[j];
+        wi = win[i];
+        wj = win[j];
+        dst[i] = ((int64_t)s0*wj - (int64_t)s1*wi + 0x4000000) >> 31;
+        dst[j] = ((int64_t)s0*wi + (int64_t)s1*wj + 0x4000000) >> 31;
+    }
+}
+
+void vector_fmul_window_fixed_aac(int32_t *dst, const int32_t *src0,                                                                      
+                                       const int32_t *src1, const int32_t *win,                                                                
+                                       int len)                                                                                                
+{                                                                                                                                              
+    int32_t s0, s1, wi, wj, i, j;                                                                                                              
+                                                                                                                                               
+    dst += len;                                                                                                                                
+    win += len;                                                                                                                                
+    src0+= len;                                                                                                                                
+                                                                                                                                               
+    for (i=-len, j=len-1; i<0; i++, j--) {                                   
+        s0 = src0[i];                                                                                                                          
+        s1 = src1[j];                                                                                                                          
+        wi = win[i];                                                                                                                           
+        wj = win[j];                                                                                                                           
+        dst[i] = ((int64_t)s0*wj - (int64_t)s1*wi + 0x40000000) >> 31;                                                                         
+        dst[j] = ((int64_t)s0*wi + (int64_t)s1*wj + 0x40000000) >> 31;                                                                         
+    }                                                                                                                                          
+}         
+static void vector_fmul_window_fixed_c(int32_t *dst, const int32_t *src0,                                                                      
+                                       const int32_t *src1, const int32_t *win,                                                                
+                                       int len)                                                                                                
+{                                                                                                                                              
+    int32_t s0, s1, wi, wj, i,j;
+
+    dst += len;
+    win += len;
+    src0+= len;  //   av_log(NULL,AV_LOG_INFO,"%s:ENTER\n", __FUNCTION__);
+
+    for (i=-len, j=len-1; i<0; i++, j--) {
+        s0 = src0[i];
+        s1 = src1[j];
+        wi = win[i];
+        wj = win[j];
+        dst[i] = av_clip_int16_c(((((int64_t)s0*wj - (int64_t)s1*wi + 0x40000000) >> 31) + 0x80) >> 8);
+        dst[j] = av_clip_int16_c(((((int64_t)s0*wi + (int64_t)s1*wj + 0x40000000) >> 31) + 0x80) >> 8);
+    }                                                                                                                                
+}                                                                                                                                              
+static void vector_fmul_fixed_c(int *dst, const int *src0, const int *src1, int len)                                                                     
+{                                                                                                                                                        
+    int i;                                                                                                                                               
+    int64_t accu;                                                                                                                                        
+                                                                                                                                                         
+    for (i = 0; i < len; i++) {                                                                                                                          
+        accu = (int64_t)src0[i] * src1[i];                                                                                                               
+        dst[i] = (int)((accu+0x40000000) >> 31);                                                                                                         
+    }                                                                                                                                                    
+}                                                                                                                                                        
+                                                                                                                                                         
+static int ff_scalarproduct_fixed_c(const int *v1, const int *v2, int len)                                                                               
+{                                                                                                                                                        
+    int64_t p = 0;                                                                                                                                       
+    int i;                                                                                                                                               
+                                                                                                                                                         
+    for (i = 0; i < len; i++)                                                                                                                            
+        p += (int64_t)v1[i] * v2[i];                                                                                                                     
+                                                                                                                                                         
+    return (int)((p + 0x40000000) >> 31);                                                                                                                
+}                                                                                                                                                        
+                                                                                                                                                         
+static void butterflies_fixed_c(int *v1, int *v2, int len)                                                                                               
+{                                                                                                                                                        
+  int i;                                                                                                                                                 
+                                                                                                                                                         
+  for (i = 0; i < len; i++) {                                                                                                                            
+    int t = v1[i] - v2[i];                                                                                                                               
+    v1[i] += v2[i];                                                                                                                                      
+    v2[i] = t;                                                                                                                                           
+  }                                                                                                                                                      
+}                                                                                                                                                        
+                                                                                                                                            
+void avpriv_fixed_dsp_init(AVFixedDSPContext *fdsp, int bit_exact)                                                                             
+{                                   
+    fdsp->vector_fmul_fixed = vector_fmul_fixed_c;                                                                                                       
+    fdsp->vector_fmul_add_fixed = vector_fmul_add_fixed_c;                                                                                               
+    fdsp->vector_fmul_reverse_fixed =vector_fmul_reverse_fixed_c;  
+    fdsp->vector_fmul_window_fixed_scaled = vector_fmul_window_fixed_scaled_c;                                                                 
+    fdsp->vector_fmul_window_fixed = vector_fmul_window_fixed_c;    
+    fdsp->vector_fmul_fixed = vector_fmul_fixed_c;                                                                                                       
+    fdsp->butterflies_fixed = butterflies_fixed_c;                                                                                                       
+    fdsp->scalarproduct_fixed = ff_scalarproduct_fixed_c;                                                                               
+} 
+
+
diff -uNr ffmpeg-0.7.12/libavcodec/fixed_dsp.h ffmpeg-0.7.12-140902/libavcodec/fixed_dsp.h
--- ffmpeg-0.7.12/libavcodec/fixed_dsp.h	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fixed_dsp.h	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2012
+ *      MIPS Technologies, Inc., California.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the MIPS Technologies, Inc., nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE MIPS TECHNOLOGIES, INC. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE MIPS TECHNOLOGIES, INC. BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Author:  Nedeljko Babic (nbabic <at> mips.com)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_FIXED_DSP_H
+#define AVUTIL_FIXED_DSP_H
+
+#include <stdint.h>
+#include "libavutil/attributes.h"
+#include "libavutil/common.h"
+
+typedef struct AVFixedDSPContext {
+
+    void (*vector_fmul_fixed)(int *dst, const int *src0, const int *src1,int len);
+
+    void (*vector_fmul_reverse_fixed)(int *dst, const int *src0, const int *src1, int len);
+    /**
+     * Overlap/add with window function.
+     * Used primarily by MDCT-based audio codecs.
+     * Source and destination vectors must overlap exactly or not at all.
+     *
+     *  <at> param dst  result vector
+     *             constraints: 16-byte aligned
+     *  <at> param src0 first source vector
+     *             constraints: 16-byte aligned
+     *  <at> param src1 second source vector
+     *             constraints: 16-byte aligned
+     *  <at> param win  half-window vector
+     *             constraints: 16-byte aligned
+     *  <at> param len  length of vector
+     *             constraints: multiple of 4
+     *  <at> param bits scaling parameter
+     *
+     */
+    void (*vector_fmul_window_fixed_scaled)(int32_t *dst, const int32_t *src0, const int32_t *src1, const int32_t *win, int len, uint8_t bits);
+
+    /**
+     * Overlap/add with window function.
+     * Used primarily by MDCT-based audio codecs.
+     * Source and destination vectors must overlap exactly or not at all.
+     *
+     *  <at> param dst  result vector
+     *             constraints: 32-byte aligned
+     *  <at> param src0 first source vector
+     *             constraints: 16-byte aligned
+     *  <at> param src1 second source vector
+     *             constraints: 16-byte aligned
+     *  <at> param win  half-window vector
+     *             constraints: 16-byte aligned
+     *  <at> param len  length of vector
+     *             constraints: multiple of 4
+     */
+    void (*vector_fmul_window_fixed)(int32_t *dst, const int32_t *src0, const int32_t *src1, const int32_t *win, int len);
+
+    /**
+     * Calculate the product of two vectors of integers, add a third vector of
+     * integers and store the result in a vector of integers.
+     *
+     *  <at> param dst  output vector
+     *             constraints: 32-byte aligned
+     *  <at> param src0 first input vector
+     *             constraints: 32-byte aligned
+     *  <at> param src1 second input vector
+     *             constraints: 32-byte aligned
+     *  <at> param src1 third input vector
+     *             constraints: 32-byte aligned
+     *  <at> param len  number of elements in the input
+     *             constraints: multiple of 16
+     */
+    void (*vector_fmul_add_fixed)(int *dst, const int *src0, const int *src1,
+                            const int *src2, int len);
+
+    /**
+     * Calculate the scalar product of two vectors of floats.
+     *  <at> param v1  first vector, 16-byte aligned
+     *  <at> param v2  second vector, 16-byte aligned
+     *  <at> param len length of vectors, multiple of 4
+     */
+    int (*scalarproduct_fixed)(const int *v1, const int *v2, int len);
+
+    /**
+     * Calculate the sum and difference of two vectors of integers.
+     *
+     *  <at> param v1  first input vector, sum output, 16-byte aligned
+     *  <at> param v2  second input vector, difference output, 16-byte aligned
+     *  <at> param len length of vectors, multiple of 4
+     */
+    void (*butterflies_fixed)(int *restrict v1, int *restrict v2, int len);
+
+} AVFixedDSPContext;
+
+/**
+ * Initialize a fixed DSP context.
+ *
+ *  <at> param fdsp    fixed DSP context
+ *  <at> param strict  setting to non-zero avoids using functions which may not be IEEE-754 compliant
+ */
+void avpriv_fixed_dsp_init(AVFixedDSPContext *fdsp, int strict);
+
+static av_always_inline int fixed_sqrt(int x, int bits)
+{
+    int retval, bit_mask, guess, square, i;
+    int64_t accu;
+
+        retval = 0;
+        bit_mask = bits ? 1 << (bits - 1) : 0;
+
+        for (i=0; i<bits; i++){
+            guess = retval + bit_mask;
+            accu = (int64_t)guess * guess;
+            square = (int)((accu + bit_mask) >> bits);
+            if (x >= square)
+                retval += bit_mask;
+            bit_mask >>= 1;
+        }
+    return retval;
+}
+void vector_fmul_window_fixed_aac(int32_t *dst, const int32_t *src0,
+                                       const int32_t *src1, const int32_t *win,
+                                       int len);
+void vector_fmul_window_fixed_ogg(int32_t *dst, const int32_t *src0,
+                                       const int32_t *src1, const int32_t *win,
+                                       int len);
+void vector_fmul_fixed_ogg(int *dst, const int *src0, const int *src1, int len);
+
+#endif /* AVUTIL_FIXED_DSP_H */
diff -uNr ffmpeg-0.7.12/libavcodec/fixed_mdct.h ffmpeg-0.7.12NF/libavcodec/fixed_mdct.h
--- ffmpeg-0.7.12/libavcodec/fixed_mdct.h	2013-08-26 15:52:03.076038042 +0800
+++ ffmpeg-0.7.12NF/libavcodec/fixed_mdct.h	2013-08-07 10:12:52.000000000 +0800
@@ -33,6 +33,17 @@
 }
 MDCTContext_fixed;
 
+/*typedef struct FFTContext_fixed
+{
+    int nbits;
+    int inverse;
+    uint16_t *revtab;
+    FFTComplex_fixed *exptab;
+    FFTComplex_fixed *exptab1; 
+    int (*fft_calc)(struct FFTContext_fixed *s, FFTComplex_fixed *z);
+}
+FFTContext_fixed;*/
+
 int ff_mdct_init_fixed1(MDCTContext_fixed *s, int nbits, int inverse);
 void ff_imdct_calc_fixed(MDCTContext_fixed *s, int32_t *output, int32_t *input);
 int mdct_init_global_fixed(void);

diff -uNr ffmpeg-0.7.12/libavcodec/float_emu.h ffmpeg-0.7.12-140902/libavcodec/float_emu.h
--- ffmpeg-0.7.12/libavcodec/float_emu.h	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/float_emu.h	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,357 @@
+#ifndef AVUTIL_FLOAT_EMU_H
+#define AVUTIL_FLOAT_EMU_H
+#include <stdint.h>
+
+#include "libavutil/common.h"
+#include "libavutil/intmath.h"
+
+#   define ff_log2(x) (31 - __builtin_clz((x)|1))
+
+extern const int divTable[128];
+extern const int sqrtTab[513];
+extern const int sqrExpMultTab[2];
+extern const int aac_costbl_1[16];
+extern const int aac_costbl_2[32];
+extern const int aac_sintbl_2[32];
+extern const int aac_costbl_3[32];
+extern const int aac_sintbl_3[32];
+extern const int aac_costbl_4[33];
+extern const int aac_sintbl_4[33];
+
+typedef struct aac_float_t {
+    int mant;
+    int expo;
+} aac_float_t;
+
+static const aac_float_t FLOAT_0          = {         0,   0};
+static const aac_float_t FLOAT_05         = { 536870912,   0};
+static const aac_float_t FLOAT_1          = { 536870912,   1};
+static const aac_float_t FLOAT_EPSILON    = { 703687442, -16};
+static const aac_float_t FLOAT_1584893192 = { 850883053,   1};
+static const aac_float_t FLOAT_100000     = { 819200000,  17};
+static const aac_float_t FLOAT_0999999    = {1073740750,   0};
+
+static __inline aac_float_t int2float(const int x, const int exp)
+{
+    aac_float_t ret;
+    int nz;
+
+    if (x == 0)
+    {
+        ret.mant = 0;
+        ret.expo = 0;
+    }
+    else
+    {
+        ret.expo = exp;
+        ret.mant = x;
+        nz = 29 - ff_log2(FFABS(ret.mant));
+        ret.mant <<= nz;
+        ret.expo -= nz;
+    }
+
+    return ret;
+}
+
+static __inline aac_float_t float_add(aac_float_t a, aac_float_t b)
+{
+    int diff, nz;
+    int expa = a.expo;
+    int expb = b.expo;
+    int manta = a.mant;
+    int mantb = b.mant;
+    aac_float_t res;
+
+    if (manta == 0)
+        return b;
+
+    if (mantb == 0)
+        return a;
+
+    diff = expa - expb;
+    if (diff < 0)  // expa < expb
+    {
+        diff = -diff;
+        if (diff >= 31)
+        manta = 0;
+        else if (diff != 0)
+        manta >>= diff;
+        expa = expb;
+    }
+    else  // expa >= expb
+    {
+        if (diff >= 31)
+        mantb = 0;
+        else if (diff != 0)
+        mantb >>= diff;
+    }
+
+    manta = manta + mantb;
+    if (manta == 0)
+        expa = 0;
+    else
+    {
+        nz = 30 - ff_log2(FFABS(manta));
+        manta <<= nz;
+        manta >>= 1;
+        expa -= (nz-1);
+    }
+
+    res.mant = manta;
+    res.expo = expa;
+
+    return res;
+}
+
+static __inline aac_float_t float_sub(aac_float_t a, aac_float_t b)
+{
+    int diff, nz;
+    int expa = a.expo;
+    int expb = b.expo;
+    int manta = a.mant;
+    int mantb = b.mant;
+    aac_float_t res;
+
+    if (manta == 0)
+    {
+        res.mant = -mantb;
+        res.expo = expb;
+        return res;
+    }
+
+    if (mantb == 0)
+        return a;
+
+    diff = expa - expb;
+    if (diff < 0)  // expa < expb
+    {
+        diff = -diff;
+        if (diff >= 31)
+        manta = 0;
+        else if (diff != 0)
+        manta >>= diff;
+        expa = expb;
+    }
+    else  // expa >= expb
+    {
+        if (diff >= 31)
+        mantb = 0;
+        else if (diff != 0)
+        mantb >>= diff;
+    }
+
+    manta = manta - mantb;
+    if (manta == 0)
+        expa = 0;
+    else
+    {
+        nz = 30 - ff_log2(FFABS(manta));
+        manta <<= nz;
+        manta >>= 1;
+        expa -= (nz-1);
+    }
+
+    res.mant = manta;
+    res.expo = expa;
+
+    return res;
+}
+
+static __inline aac_float_t float_mul(aac_float_t a, aac_float_t b)
+{
+    aac_float_t res;
+    int mant;
+    int expa = a.expo;
+    int expb = b.expo;
+    long long accu;
+
+    expa = expa + expb;
+    accu = (long long)a.mant * b.mant;
+    mant = (int)((accu + 0x20000000) >> 30);
+    if (mant == 0)
+        expa = 0;
+    else if (mant < 536870912 && mant > -536870912)
+    {
+        mant <<= 1;
+        expa = expa - 1;
+    }
+    res.mant = mant;
+    res.expo = expa;
+
+    return res;
+}
+
+static __inline aac_float_t float_recip(const aac_float_t a)
+{
+    aac_float_t r;
+    int s;
+    int manta, expa;
+
+    manta = a.mant;
+    expa = a.expo;
+
+    expa = 1 - expa;
+    r.expo = expa;
+
+    s = manta >> 31;
+    manta = (manta ^ s) - s;
+
+    manta = divTable[(manta - 0x20000000) >> 22];
+
+    r.mant = (manta ^ s) - s;
+
+    return r;
+}
+
+static __inline aac_float_t float_div(aac_float_t a, aac_float_t b)
+{
+    aac_float_t res;
+    aac_float_t iB, tmp;
+    int mantb;
+
+    mantb = b.mant;
+    if (mantb != 0)
+    {
+        iB = float_recip(b);
+        // newton iteration to double precision
+        tmp = float_sub(FLOAT_1, float_mul(b, iB));
+        iB = float_add(iB, float_mul(iB, tmp));
+        res = float_mul(a, iB);
+    }
+    else
+    {
+        res.mant = 1;
+        res.expo = 2147483647;
+    }
+
+    return res;
+}
+
+static __inline int float_gt(aac_float_t a, aac_float_t b)
+{
+    int expa = a.expo;
+    int expb = b.expo;
+    int manta = a.mant;
+    int mantb = b.mant;
+
+    if (manta == 0)
+        expa = 0x80000000;
+
+    if (mantb == 0)
+        expb = 0x80000000;
+
+    if (expa > expb)
+        return 1;
+    else if (expa < expb)
+        return 0;
+    else // expa == expb
+    {
+        if (manta > mantb)
+        return 1;
+        else
+        return 0;
+    }
+}
+
+static __inline aac_float_t float_sqrt(aac_float_t val)
+{
+    int exp;
+    int tabIndex, rem;
+    int mant;
+    long long accu;
+    aac_float_t res;
+
+    exp = val.expo;
+    mant = val.mant;
+
+    if (mant == 0)
+    {
+        res.mant = 0;
+        res.expo = 0;
+    }
+    else
+    {
+        tabIndex = (mant - 536870912);
+        tabIndex = tabIndex >> 20;
+
+        rem = mant & 0xfffff;
+        accu  = (long long)sqrtTab[tabIndex] * (0x100000-rem);
+        accu += (long long)sqrtTab[tabIndex+1] * rem;
+        mant = (int)((accu + 0x80000) >> 20);
+
+        accu = (long long)sqrExpMultTab[exp&1] * mant;
+        mant = (int)((accu + 0x10000000) >> 29);
+        if (mant < 1073741824)
+            exp -= 2;
+        else
+            mant >>= 1;
+
+        res.mant = mant;
+        res.expo = (exp>>1)+1;
+    }
+
+    return res;
+}
+
+static __inline void aac_fixed_sincos(int a, int *s, int *c)
+{
+    int idx, sign;
+    int sv, cv;
+    int st, ct;
+    long long accu;
+
+    idx = a >> 26;
+    sign = (idx << 27) >> 31;
+    cv = aac_costbl_1[idx & 0xf];
+    cv = (cv ^ sign) - sign;
+
+    idx -= 8;
+    sign = (idx << 27) >> 31;
+    sv = aac_costbl_1[idx & 0xf];
+    sv = (sv ^ sign) - sign;
+
+    idx = a >> 21;
+    ct = aac_costbl_2[idx & 0x1f];
+    st = aac_sintbl_2[idx & 0x1f];
+
+    accu  = (long long)cv*ct;
+    accu -= (long long)sv*st;
+    idx = (int)((accu + 0x20000000) >> 30);
+
+    accu  = (long long)cv*st;
+    accu += (long long)sv*ct;
+    sv = (int)((accu + 0x20000000) >> 30);
+    cv = idx;
+
+    idx = a >> 16;
+    ct = aac_costbl_3[idx & 0x1f];
+    st = aac_sintbl_3[idx & 0x1f];
+
+    accu  = (long long)cv*ct;
+    accu -= (long long)sv*st;
+    idx = (int)((accu + 0x20000000) >> 30);
+
+    accu  = (long long)cv*st;
+    accu += (long long)sv*ct;
+    sv = (int)((accu + 0x20000000) >> 30);
+    cv = idx;
+
+    idx = a >> 11;
+    accu  = (long long)aac_costbl_4[idx & 0x1f]*(0x800 - (a&0x7ff));
+    accu += (long long)aac_costbl_4[(idx & 0x1f)+1]*(a&0x7ff);
+    ct = (int)((accu + 0x400) >> 11);
+    accu  = (long long)aac_sintbl_4[idx & 0x1f]*(0x800 - (a&0x7ff));
+    accu += (long long)aac_sintbl_4[(idx & 0x1f)+1]*(a&0x7ff);
+    st = (int)((accu + 0x400) >> 11);
+
+    accu  = (long long)cv*ct;
+    accu -= (long long)sv*st;
+    *c = (int)((accu + 0x20000000) >> 30);
+
+    accu  = (long long)cv*st;
+    accu += (long long)sv*ct;
+    *s = (int)((accu + 0x20000000) >> 30);
+}
+
+#endif /* AVUTIL_FLOAT_EMU_H */
+
diff -uNr ffmpeg-0.7.12/libavcodec/float_emu_tab.c ffmpeg-0.7.12-140902/libavcodec/float_emu_tab.c
--- ffmpeg-0.7.12/libavcodec/float_emu_tab.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/float_emu_tab.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,249 @@
+#include <stdint.h>
+
+#define Q30(x) (int)((x)*1073741824.0 + 0.5)
+
+const int divTable[128] = {
+    Q30(0.9999999995), Q30(0.9922480620), Q30(0.9846153846), Q30(0.9770992366),
+    Q30(0.9696969697), Q30(0.9624060150), Q30(0.9552238807), Q30(0.9481481481),
+    Q30(0.9411764704), Q30(0.9343065694), Q30(0.9275362319), Q30(0.9208633094),
+    Q30(0.9142857143), Q30(0.9078014186), Q30(0.9014084507), Q30(0.8951048949),
+    Q30(0.8888888890), Q30(0.8827586207), Q30(0.8767123288), Q30(0.8707482992),
+    Q30(0.8648648649), Q30(0.8590604025), Q30(0.8533333335), Q30(0.8476821193),
+    Q30(0.8421052634), Q30(0.8366013071), Q30(0.8311688313), Q30(0.8258064515),
+    Q30(0.8205128205), Q30(0.8152866242), Q30(0.8101265822), Q30(0.8050314467),
+    Q30(0.7999999998), Q30(0.7950310558), Q30(0.7901234566), Q30(0.7852760735),
+    Q30(0.7804878047), Q30(0.7757575759), Q30(0.7710843375), Q30(0.7664670660),
+    Q30(0.7619047621), Q30(0.7573964498), Q30(0.7529411763), Q30(0.7485380117),
+    Q30(0.7441860465), Q30(0.7398843933), Q30(0.7356321840), Q30(0.7314285715),
+    Q30(0.7272727271), Q30(0.7231638418), Q30(0.7191011235), Q30(0.7150837989),
+    Q30(0.7111111111), Q30(0.7071823203), Q30(0.7032967033), Q30(0.6994535518),
+    Q30(0.6956521738), Q30(0.6918918919), Q30(0.6881720428), Q30(0.6844919785),
+    Q30(0.6808510637), Q30(0.6772486772), Q30(0.6736842105), Q30(0.6701570679),
+    Q30(0.6666666665), Q30(0.6632124353), Q30(0.6597938146), Q30(0.6564102564),
+    Q30(0.6530612246), Q30(0.6497461931), Q30(0.6464646463), Q30(0.6432160805),
+    Q30(0.6400000001), Q30(0.6368159205), Q30(0.6336633665), Q30(0.6305418718),
+    Q30(0.6274509802), Q30(0.6243902440), Q30(0.6213592235), Q30(0.6183574880),
+    Q30(0.6153846155), Q30(0.6124401912), Q30(0.6095238095), Q30(0.6066350709),
+    Q30(0.6037735851), Q30(0.6009389670), Q30(0.5981308413), Q30(0.5953488373),
+    Q30(0.5925925928), Q30(0.5898617511), Q30(0.5871559633), Q30(0.5844748858),
+    Q30(0.5818181820), Q30(0.5791855203), Q30(0.5765765766), Q30(0.5739910314),
+    Q30(0.5714285714), Q30(0.5688888887), Q30(0.5663716816), Q30(0.5638766522),
+    Q30(0.5614035088), Q30(0.5589519651), Q30(0.5565217393), Q30(0.5541125541),
+    Q30(0.5517241377), Q30(0.5493562231), Q30(0.5470085470), Q30(0.5446808510),
+    Q30(0.5423728814), Q30(0.5400843881), Q30(0.5378151261), Q30(0.5355648533),
+    Q30(0.5333333332), Q30(0.5311203320), Q30(0.5289256200), Q30(0.5267489711),
+    Q30(0.5245901640), Q30(0.5224489798), Q30(0.5203252034), Q30(0.5182186235),
+    Q30(0.5161290322), Q30(0.5140562248), Q30(0.5120000001), Q30(0.5099601592),
+    Q30(0.5079365079), Q30(0.5059288535), Q30(0.5039370079), Q30(0.5019607842)
+};
+
+const int sqrtTab[512+1] = { /*  sqrt(x), 0.5<=x<1 */
+    Q30(0.7071067812), Q30(0.7077969783), Q30(0.7084865030), Q30(0.7091753576),
+    Q30(0.7098635430), Q30(0.7105510626), Q30(0.7112379172), Q30(0.7119241091),
+    Q30(0.7126096408), Q30(0.7132945131), Q30(0.7139787287), Q30(0.7146622892),
+    Q30(0.7153451964), Q30(0.7160274521), Q30(0.7167090587), Q30(0.7173900176),
+    Q30(0.7180703310), Q30(0.7187500000), Q30(0.7194290273), Q30(0.7201074138),
+    Q30(0.7207851619), Q30(0.7214622740), Q30(0.7221387504), Q30(0.7228145939),
+    Q30(0.7234898065), Q30(0.7241643891), Q30(0.7248383439), Q30(0.7255116729),
+    Q30(0.7261843774), Q30(0.7268564594), Q30(0.7275279206), Q30(0.7281987625),
+    Q30(0.7288689869), Q30(0.7295385958), Q30(0.7302075904), Q30(0.7308759727),
+    Q30(0.7315437444), Q30(0.7322109072), Q30(0.7328774626), Q30(0.7335434123),
+    Q30(0.7342087580), Q30(0.7348735011), Q30(0.7355376435), Q30(0.7362011867),
+    Q30(0.7368641328), Q30(0.7375264824), Q30(0.7381882383), Q30(0.7388494010),
+    Q30(0.7395099727), Q30(0.7401699550), Q30(0.7408293495), Q30(0.7414881573),
+    Q30(0.7421463802), Q30(0.7428040202), Q30(0.7434610785), Q30(0.7441175561),
+    Q30(0.7447734554), Q30(0.7454287778), Q30(0.7460835241), Q30(0.7467376967),
+    Q30(0.7473912966), Q30(0.7480443250), Q30(0.7486967845), Q30(0.7493486754),
+    Q30(0.7500000000), Q30(0.7506507593), Q30(0.7513009552), Q30(0.7519505885),
+    Q30(0.7525996612), Q30(0.7532481747), Q30(0.7538961302), Q30(0.7545435294),
+    Q30(0.7551903734), Q30(0.7558366638), Q30(0.7564824023), Q30(0.7571275900),
+    Q30(0.7577722282), Q30(0.7584163188), Q30(0.7590598627), Q30(0.7597028613),
+    Q30(0.7603453165), Q30(0.7609872287), Q30(0.7616286003), Q30(0.7622694322),
+    Q30(0.7629097258), Q30(0.7635494824), Q30(0.7641887036), Q30(0.7648273907),
+    Q30(0.7654655445), Q30(0.7661031671), Q30(0.7667402592), Q30(0.7673768224),
+    Q30(0.7680128580), Q30(0.7686483674), Q30(0.7692833515), Q30(0.7699178122),
+    Q30(0.7705517504), Q30(0.7711851676), Q30(0.7718180646), Q30(0.7724504434),
+    Q30(0.7730823047), Q30(0.7737136502), Q30(0.7743444811), Q30(0.7749747979),
+    Q30(0.7756046029), Q30(0.7762338966), Q30(0.7768626809), Q30(0.7774909567),
+    Q30(0.7781187249), Q30(0.7787459870), Q30(0.7793727447), Q30(0.7799989986),
+    Q30(0.7806247496), Q30(0.7812500000), Q30(0.7818747503), Q30(0.7824990018),
+    Q30(0.7831227556), Q30(0.7837460130), Q30(0.7843687749), Q30(0.7849910432),
+    Q30(0.7856128183), Q30(0.7862341017), Q30(0.7868548944), Q30(0.7874751980),
+    Q30(0.7880950132), Q30(0.7887143414), Q30(0.7893331838), Q30(0.7899515415),
+    Q30(0.7905694149), Q30(0.7911868063), Q30(0.7918037162), Q30(0.7924201456),
+    Q30(0.7930360963), Q30(0.7936515687), Q30(0.7942665643), Q30(0.7948810840),
+    Q30(0.7954951287), Q30(0.7961087003), Q30(0.7967217988), Q30(0.7973344265),
+    Q30(0.7979465835), Q30(0.7985582710), Q30(0.7991694906), Q30(0.7997802431),
+    Q30(0.8003905294), Q30(0.8010003511), Q30(0.8016097085), Q30(0.8022186034),
+    Q30(0.8028270360), Q30(0.8034350080), Q30(0.8040425205), Q30(0.8046495742),
+    Q30(0.8052561702), Q30(0.8058623099), Q30(0.8064679937), Q30(0.8070732229),
+    Q30(0.8076779991), Q30(0.8082823223), Q30(0.8088861941), Q30(0.8094896153),
+    Q30(0.8100925875), Q30(0.8106951108), Q30(0.8112971867), Q30(0.8118988159),
+    Q30(0.8125000000), Q30(0.8131007394), Q30(0.8137010355), Q30(0.8143008887),
+    Q30(0.8149003005), Q30(0.8154992717), Q30(0.8160978034), Q30(0.8166958964),
+    Q30(0.8172935518), Q30(0.8178907707), Q30(0.8184875534), Q30(0.8190839016),
+    Q30(0.8196798153), Q30(0.8202752969), Q30(0.8208703459), Q30(0.8214649642),
+    Q30(0.8220591522), Q30(0.8226529113), Q30(0.8232462420), Q30(0.8238391452),
+    Q30(0.8244316224), Q30(0.8250236739), Q30(0.8256153008), Q30(0.8262065044),
+    Q30(0.8267972847), Q30(0.8273876435), Q30(0.8279775814), Q30(0.8285670988),
+    Q30(0.8291561976), Q30(0.8297448778), Q30(0.8303331411), Q30(0.8309209873),
+    Q30(0.8315084185), Q30(0.8320954349), Q30(0.8326820373), Q30(0.8332682266),
+    Q30(0.8338540038), Q30(0.8344393703), Q30(0.8350243261), Q30(0.8356088721),
+    Q30(0.8361930102), Q30(0.8367767399), Q30(0.8373600631), Q30(0.8379429798),
+    Q30(0.8385254918), Q30(0.8391075991), Q30(0.8396893027), Q30(0.8402706035),
+    Q30(0.8408515030), Q30(0.8414320010), Q30(0.8420120990), Q30(0.8425917975),
+    Q30(0.8431710978), Q30(0.8437500000), Q30(0.8443285055), Q30(0.8449066146),
+    Q30(0.8454843285), Q30(0.8460616483), Q30(0.8466385738), Q30(0.8472151072),
+    Q30(0.8477912480), Q30(0.8483669977), Q30(0.8489423566), Q30(0.8495173263),
+    Q30(0.8500919067), Q30(0.8506660992), Q30(0.8512399043), Q30(0.8518133233),
+    Q30(0.8523863559), Q30(0.8529590038), Q30(0.8535312680), Q30(0.8541031480),
+    Q30(0.8546746457), Q30(0.8552457616), Q30(0.8558164961), Q30(0.8563868506),
+    Q30(0.8569568251), Q30(0.8575264211), Q30(0.8580956385), Q30(0.8586644791),
+    Q30(0.8592329426), Q30(0.8598010307), Q30(0.8603687435), Q30(0.8609360820),
+    Q30(0.8615030469), Q30(0.8620696389), Q30(0.8626358588), Q30(0.8632017071),
+    Q30(0.8637671852), Q30(0.8643322927), Q30(0.8648970313), Q30(0.8654614016),
+    Q30(0.8660254036), Q30(0.8665890391), Q30(0.8671523076), Q30(0.8677152111),
+    Q30(0.8682777495), Q30(0.8688399233), Q30(0.8694017339), Q30(0.8699631817),
+    Q30(0.8705242672), Q30(0.8710849914), Q30(0.8716453551), Q30(0.8722053585),
+    Q30(0.8727650028), Q30(0.8733242881), Q30(0.8738832157), Q30(0.8744417862),
+    Q30(0.8750000000), Q30(0.8755578580), Q30(0.8761153608), Q30(0.8766725087),
+    Q30(0.8772293031), Q30(0.8777857441), Q30(0.8783418327), Q30(0.8788975696),
+    Q30(0.8794529550), Q30(0.8800079902), Q30(0.8805626752), Q30(0.8811170114),
+    Q30(0.8816709989), Q30(0.8822246385), Q30(0.8827779307), Q30(0.8833308765),
+    Q30(0.8838834763), Q30(0.8844357310), Q30(0.8849876411), Q30(0.8855392071),
+    Q30(0.8860904300), Q30(0.8866413101), Q30(0.8871918479), Q30(0.8877420444),
+    Q30(0.8882919000), Q30(0.8888414158), Q30(0.8893905920), Q30(0.8899394292),
+    Q30(0.8904879279), Q30(0.8910360895), Q30(0.8915839135), Q30(0.8921314017),
+    Q30(0.8926785537), Q30(0.8932253704), Q30(0.8937718528), Q30(0.8943180013),
+    Q30(0.8948638164), Q30(0.8954092991), Q30(0.8959544492), Q30(0.8964992678),
+    Q30(0.8970437557), Q30(0.8975879136), Q30(0.8981317417), Q30(0.8986752401),
+    Q30(0.8992184107), Q30(0.8997612530), Q30(0.9003037680), Q30(0.9008459565),
+    Q30(0.9013878191), Q30(0.9019293557), Q30(0.9024705673), Q30(0.9030114547),
+    Q30(0.9035520186), Q30(0.9040922588), Q30(0.9046321767), Q30(0.9051717725),
+    Q30(0.9057110464), Q30(0.9062500000), Q30(0.9067886332), Q30(0.9073269465),
+    Q30(0.9078649404), Q30(0.9084026157), Q30(0.9089399735), Q30(0.9094770132),
+    Q30(0.9100137362), Q30(0.9105501426), Q30(0.9110862338), Q30(0.9116220092),
+    Q30(0.9121574699), Q30(0.9126926167), Q30(0.9132274496), Q30(0.9137619697),
+    Q30(0.9142961772), Q30(0.9148300732), Q30(0.9153636573), Q30(0.9158969307),
+    Q30(0.9164298936), Q30(0.9169625468), Q30(0.9174948912), Q30(0.9180269265),
+    Q30(0.9185586534), Q30(0.9190900731), Q30(0.9196211854), Q30(0.9201519913),
+    Q30(0.9206824913), Q30(0.9212126858), Q30(0.9217425752), Q30(0.9222721602),
+    Q30(0.9228014410), Q30(0.9233304188), Q30(0.9238590938), Q30(0.9243874662),
+    Q30(0.9249155368), Q30(0.9254433061), Q30(0.9259707746), Q30(0.9264979423),
+    Q30(0.9270248110), Q30(0.9275513799), Q30(0.9280776503), Q30(0.9286036226),
+    Q30(0.9291292969), Q30(0.9296546737), Q30(0.9301797543), Q30(0.9307045382),
+    Q30(0.9312290265), Q30(0.9317532196), Q30(0.9322771183), Q30(0.9328007223),
+    Q30(0.9333240325), Q30(0.9338470497), Q30(0.9343697741), Q30(0.9348922065),
+    Q30(0.9354143469), Q30(0.9359361958), Q30(0.9364577541), Q30(0.9369790219),
+    Q30(0.9375000000), Q30(0.9380206889), Q30(0.9385410887), Q30(0.9390612002),
+    Q30(0.9395810235), Q30(0.9401005600), Q30(0.9406198091), Q30(0.9411387718),
+    Q30(0.9416574482), Q30(0.9421758396), Q30(0.9426939455), Q30(0.9432117669),
+    Q30(0.9437293042), Q30(0.9442465580), Q30(0.9447635286), Q30(0.9452802162),
+    Q30(0.9457966220), Q30(0.9463127456), Q30(0.9468285879), Q30(0.9473441495),
+    Q30(0.9478594307), Q30(0.9483744316), Q30(0.9488891531), Q30(0.9494035956),
+    Q30(0.9499177597), Q30(0.9504316454), Q30(0.9509452535), Q30(0.9514585841),
+    Q30(0.9519716380), Q30(0.9524844158), Q30(0.9529969175), Q30(0.9535091440),
+    Q30(0.9540210953), Q30(0.9545327718), Q30(0.9550441746), Q30(0.9555553030),
+    Q30(0.9560661586), Q30(0.9565767418), Q30(0.9570870521), Q30(0.9575970904),
+    Q30(0.9581068573), Q30(0.9586163531), Q30(0.9591255784), Q30(0.9596345332),
+    Q30(0.9601432183), Q30(0.9606516343), Q30(0.9611597811), Q30(0.9616676597),
+    Q30(0.9621752701), Q30(0.9626826127), Q30(0.9631896880), Q30(0.9636964966),
+    Q30(0.9642030387), Q30(0.9647093150), Q30(0.9652153258), Q30(0.9657210712),
+    Q30(0.9662265521), Q30(0.9667317686), Q30(0.9672367214), Q30(0.9677414102),
+    Q30(0.9682458364), Q30(0.9687500000), Q30(0.9692539014), Q30(0.9697575406),
+    Q30(0.9702609186), Q30(0.9707640354), Q30(0.9712668918), Q30(0.9717694880),
+    Q30(0.9722718243), Q30(0.9727739012), Q30(0.9732757187), Q30(0.9737772783),
+    Q30(0.9742785795), Q30(0.9747796226), Q30(0.9752804083), Q30(0.9757809374),
+    Q30(0.9762812094), Q30(0.9767812253), Q30(0.9772809856), Q30(0.9777804906),
+    Q30(0.9782797401), Q30(0.9787787353), Q30(0.9792774762), Q30(0.9797759629),
+    Q30(0.9802741962), Q30(0.9807721768), Q30(0.9812699044), Q30(0.9817673797),
+    Q30(0.9822646030), Q30(0.9827615744), Q30(0.9832582953), Q30(0.9837547648),
+    Q30(0.9842509842), Q30(0.9847469535), Q30(0.9852426732), Q30(0.9857381433),
+    Q30(0.9862333648), Q30(0.9867283376), Q30(0.9872230627), Q30(0.9877175395),
+    Q30(0.9882117687), Q30(0.9887057510), Q30(0.9891994870), Q30(0.9896929762),
+    Q30(0.9901862200), Q30(0.9906792180), Q30(0.9911719705), Q30(0.9916644781),
+    Q30(0.9921567417), Q30(0.9926487608), Q30(0.9931405364), Q30(0.9936320684),
+    Q30(0.9941233573), Q30(0.9946144037), Q30(0.9951052079), Q30(0.9955957700),
+    Q30(0.9960860908), Q30(0.9965761700), Q30(0.9970660084), Q30(0.9975556061),
+    Q30(0.9980449639), Q30(0.9985340820), Q30(0.9990229602), Q30(0.9995115995),
+    0x3FFFFFFF
+};
+
+const int sqrExpMultTab[2] = {
+    Q30(0.5000000000), Q30(0.7071067812)
+};
+
+const int aac_costbl_1[16] = {
+    Q30( 1.000000000000000), Q30( 0.980785280403230), Q30( 0.923879532511287), Q30( 0.831469612302545),
+    Q30( 0.707106781186548), Q30( 0.555570233019602), Q30( 0.382683432365090), Q30( 0.195090322016128),
+    Q30( 0.000000000000000), Q30(-0.195090322016128), Q30(-0.382683432365090), Q30(-0.555570233019602),
+    Q30(-0.707106781186547), Q30(-0.831469612302545), Q30(-0.923879532511287), Q30(-0.980785280403230)
+};
+
+const int aac_costbl_2[32] = {
+    Q30(1.000000000000000), Q30(0.999981175282601), Q30(0.999924701839145), Q30(0.999830581795823),
+    Q30(0.999698818696204), Q30(0.999529417501093), Q30(0.999322384588350), Q30(0.999077727752645),
+    Q30(0.998795456205172), Q30(0.998475580573295), Q30(0.998118112900149), Q30(0.997723066644192),
+    Q30(0.997290456678690), Q30(0.996820299291166), Q30(0.996312612182778), Q30(0.995767414467660),
+    Q30(0.995184726672197), Q30(0.994564570734255), Q30(0.993906970002356), Q30(0.993211949234795),
+    Q30(0.992479534598710), Q30(0.991709753669100), Q30(0.990902635427780), Q30(0.990058210262297),
+    Q30(0.989176509964781), Q30(0.988257567730749), Q30(0.987301418157858), Q30(0.986308097244599),
+    Q30(0.985277642388941), Q30(0.984210092386929), Q30(0.983105487431216), Q30(0.981963869109555)
+};
+
+const int aac_sintbl_2[32] = {
+    Q30(0.000000000000000), Q30(0.006135884649154), Q30(0.012271538285720), Q30(0.018406729905805),
+    Q30(0.024541228522912), Q30(0.030674803176637), Q30(0.036807222941359), Q30(0.042938256934941),
+    Q30(0.049067674327418), Q30(0.055195244349690), Q30(0.061320736302209), Q30(0.067443919563664),
+    Q30(0.073564563599667), Q30(0.079682437971430), Q30(0.085797312344440), Q30(0.091908956497133),
+    Q30(0.098017140329561), Q30(0.104121633872055), Q30(0.110222207293883), Q30(0.116318630911905),
+    Q30(0.122410675199216), Q30(0.128498110793793), Q30(0.134580708507126), Q30(0.140658239332849),
+    Q30(0.146730474455362), Q30(0.152797185258443), Q30(0.158858143333861), Q30(0.164913120489970),
+    Q30(0.170961888760301), Q30(0.177004220412149), Q30(0.183039887955141), Q30(0.189068664149806)
+};
+
+const int aac_costbl_3[32] = {
+    Q30(1.000000000000000), Q30(0.999999981616429), Q30(0.999999926465718), Q30(0.999999834547868),
+    Q30(0.999999705862882), Q30(0.999999540410766), Q30(0.999999338191526), Q30(0.999999099205168),
+    Q30(0.999998823451702), Q30(0.999998510931138), Q30(0.999998161643487), Q30(0.999997775588762),
+    Q30(0.999997352766978), Q30(0.999996893178150), Q30(0.999996396822294), Q30(0.999995863699430),
+    Q30(0.999995293809576), Q30(0.999994687152754), Q30(0.999994043728986), Q30(0.999993363538295),
+    Q30(0.999992646580707), Q30(0.999991892856248), Q30(0.999991102364946), Q30(0.999990275106829),
+    Q30(0.999989411081928), Q30(0.999988510290276), Q30(0.999987572731904), Q30(0.999986598406848),
+    Q30(0.999985587315143), Q30(0.999984539456827), Q30(0.999983454831938), Q30(0.999982333440515)
+};
+
+const int aac_sintbl_3[32] = {
+    Q30(0.000000000000000), Q30(0.000191747597311), Q30(0.000383495187571), Q30(0.000575242763732),
+    Q30(0.000766990318743), Q30(0.000958737845553), Q30(0.001150485337114), Q30(0.001342232786374),
+    Q30(0.001533980186285), Q30(0.001725727529795), Q30(0.001917474809855), Q30(0.002109222019416),
+    Q30(0.002300969151426), Q30(0.002492716198836), Q30(0.002684463154596), Q30(0.002876210011656),
+    Q30(0.003067956762966), Q30(0.003259703401476), Q30(0.003451449920136), Q30(0.003643196311896),
+    Q30(0.003834942569706), Q30(0.004026688686517), Q30(0.004218434655277), Q30(0.004410180468938),
+    Q30(0.004601926120449), Q30(0.004793671602760), Q30(0.004985416908822), Q30(0.005177162031584),
+    Q30(0.005368906963996), Q30(0.005560651699010), Q30(0.005752396229574), Q30(0.005944140548639)
+};
+
+const int aac_costbl_4[33] = {
+    Q30(1.000000000000000), Q30(0.999999999982047), Q30(0.999999999928189), Q30(0.999999999838426),
+    Q30(0.999999999712757), Q30(0.999999999551182), Q30(0.999999999353703), Q30(0.999999999120317),
+    Q30(0.999999998851027), Q30(0.999999998545831), Q30(0.999999998204729), Q30(0.999999997827723),
+    Q30(0.999999997414810), Q30(0.999999996965993), Q30(0.999999996481270), Q30(0.999999995960641),
+    Q30(0.999999995404107), Q30(0.999999994811668), Q30(0.999999994183323), Q30(0.999999993519073),
+    Q30(0.999999992818918), Q30(0.999999992082857), Q30(0.999999991310890), Q30(0.999999990503019),
+    Q30(0.999999989659241), Q30(0.999999988779559), Q30(0.999999987863971), Q30(0.999999986912477),
+    Q30(0.999999985925079), Q30(0.999999984901774), Q30(0.999999983842565), Q30(0.999999982747450),
+    Q30(0.999999981616429)
+};
+
+const int aac_sintbl_4[33] = {
+    Q30(0.000000000000000), Q30(0.000005992112453), Q30(0.000011984224905), Q30(0.000017976337357),
+    Q30(0.000023968449808), Q30(0.000029960562259), Q30(0.000035952674708), Q30(0.000041944787156),
+    Q30(0.000047936899603), Q30(0.000053929012048), Q30(0.000059921124491), Q30(0.000065913236932),
+    Q30(0.000071905349370), Q30(0.000077897461806), Q30(0.000083889574239), Q30(0.000089881686669),
+    Q30(0.000095873799096), Q30(0.000101865911519), Q30(0.000107858023939), Q30(0.000113850136355),
+    Q30(0.000119842248767), Q30(0.000125834361174), Q30(0.000131826473577), Q30(0.000137818585975),
+    Q30(0.000143810698369), Q30(0.000149802810757), Q30(0.000155794923139), Q30(0.000161787035517),
+    Q30(0.000167779147888), Q30(0.000173771260253), Q30(0.000179763372612), Q30(0.000185755484965),
+    Q30(0.000191747597311)
+};
diff -uNr ffmpeg-0.7.12/libavcodec/fmtconvert.c ffmpeg-0.7.12-140902/libavcodec/fmtconvert.c
--- ffmpeg-0.7.12/libavcodec/fmtconvert.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fmtconvert.c	2014-09-05 14:57:52.751476645 +0800
@@ -29,10 +29,22 @@
         dst[i] = src[i] * mul;
 }
 
+static void int32_to_fixed_fmul_scalar_c(int16_t *dst, const int *src, int mul, int len) {
+    int i;
+    for(i=0; i<len; i++)
+    dst[i] = (src[i] * mul + 0x8000) >> 18;
+}
+
+
 static av_always_inline int float_to_int16_one(const float *src){
     return av_clip_int16(lrintf(*src));
 }
 
+static av_always_inline int fixed_to_int16_one(const int *src)
+{
+    return av_clip_int16_c_fixed(*src);
+}
+
 static void float_to_int16_c(int16_t *dst, const float *src, long len)
 {
     int i;
@@ -56,6 +68,104 @@
     }
 }
 
+static void fixed_to_int16_interleave_c(int16_t *dst, const int **src,
+                                        long len, int channels)
+{
+
+ /*int i, j, c;
+
+    if (channels==2){
+        for (i=0; i<len; i++){
+            dst[2*i]   = av_clip_int16((*(src[0]+i) + 256) >> 9);
+        dst[2*i+1] = av_clip_int16((*(src[1]+i) + 256) >> 9);
+        }
+    }else{
+    for (c=0; c<channels; c++)
+        for (i=0, j=c; i<len; i++, j+=channels)
+            dst[j] = av_clip_int16((*(src[c]+i) + 256) >> 9);
+    }
+
+*/
+    int i,j,c;
+/*
+for(i = 0; i < 128; i++)
+{
+av_log(NULL,AV_LOG_INFO,"%04x ",*(src[0]+i)); av_log(NULL,AV_LOG_INFO,"%04x ",*(src[1]+i)); 
+}*/
+
+    if(channels==2) {
+        for(i=0; i<len; i++) {
+            dst[2*i] = fixed_to_int16_one(src[0]+i);
+            dst[2*i+1] = fixed_to_int16_one(src[1]+i);
+        }
+    }
+    else {
+        if(channels==6) {
+            for(i=0; i<len; i++) {
+                dst[6*i] = fixed_to_int16_one(src[0]+i);
+                dst[6*i+1] = fixed_to_int16_one(src[1]+i);
+                dst[6*i+2] = fixed_to_int16_one(src[2]+i);
+                dst[6*i+3] = fixed_to_int16_one(src[3]+i);
+                dst[6*i+4] = fixed_to_int16_one(src[4]+i);
+                dst[6*i+5] = fixed_to_int16_one(src[5]+i);
+            }
+        }
+        else {
+            for(c=0; c<channels; c++)
+                for(i=0, j=c; i<len; i++, j+=channels)
+                    dst[j] = fixed_to_int16_one(src[c]+i);
+        }
+    }/*av_log(NULL,AV_LOG_INFO,"fffffffffffffffffffff\n "); 
+for(i = 0; i < 128; i++)
+{
+av_log(NULL,AV_LOG_INFO,"%04x ",dst[i]); 
+}av_log(NULL,AV_LOG_INFO,"ggggggggggggggggggg\n ");*/ 
+}
+
+void fixed_to_int16_interleave_aac(int16_t *dst, const int **src,
+                                        long len, int channels,int multiplier)
+{
+
+  int i,j,c;
+
+   if(channels==2)
+   { 
+       {
+           for(i=0; i<len; i++) 
+           {
+               dst[4*i] = (*(src[0]+i)&0xffff);  //ignoreoxff(&dst[4*i]);
+               dst[4*i+1] = ((*(src[0]+i)&0xffff0000)>>16); // ignoreoxff(&dst[4*i+1]);
+              dst[4*i+2] = (*(src[1]+i)&0xffff);  // ignoreoxff(&dst[4*i]+2);
+               dst[4*i+3] = ((*(src[1]+i)&0xffff0000)>>16); // ignoreoxff(&dst[4*i]+3);
+           }
+       }
+    }
+    else 
+    {
+        for(c=0; c<channels; c++)
+            for(i=0, j=c; i<len; i++, j+=channels)
+                dst[j] = fixed_to_int16_one(src[c]+i);
+    }
+
+}
+
+
+static void int_to_int16_interleave_c(int16_t *dst, const int **src, long len, int channels)
+{
+    int i, j, c;
+    if (channels==2){
+        for (i=0; i<len; i++){
+            dst[2*i]   = av_clip_int16((*(src[0]+i) + 256) >> 9);
+        dst[2*i+1] = av_clip_int16((*(src[1]+i) + 256) >> 9);
+        }
+    }else{
+    for (c=0; c<channels; c++)
+        for (i=0, j=c; i<len; i++, j+=channels)
+            dst[j] = av_clip_int16((*(src[c]+i) + 256) >> 9);
+    }
+}
+
+
 void ff_float_interleave_c(float *dst, const float **src, unsigned int len,
                            int channels)
 {
@@ -75,11 +185,45 @@
     }
 }
 
+void ff_fixed_interleave_c(int16_t *dst, const int **src, unsigned int len,
+                           int channels)
+{
+    int j, c;
+    unsigned int i;          
+    if (channels == 6) {
+        for (i = 0; i < len; i++) {
+            dst[6*i]   = src[0][i];
+            dst[6*i+1] = src[1][i];
+            dst[6*i+2] = src[2][i];
+            dst[6*i+3] = src[3][i];
+            dst[6*i+4] = src[4][i];
+            dst[6*i+5] = src[5][i];
+        }
+    }
+    else if (channels == 2) {
+        for (i = 0; i < len; i++) {
+            dst[2*i]   = src[0][i];
+            dst[2*i+1] = src[1][i];
+        }
+    } else if (channels == 1 && len < INT_MAX / sizeof(int)) {
+        memcpy(dst, src[0], len * sizeof(int));
+    } else {
+        for (c = 0; c < channels; c++)
+            for (i = 0, j = c; i < len; i++, j += channels)
+                dst[j] = src[c][i];
+    }
+}
+
+
 av_cold void ff_fmt_convert_init(FmtConvertContext *c, AVCodecContext *avctx)
 {
     c->int32_to_float_fmul_scalar = int32_to_float_fmul_scalar_c;
+    c->int32_to_fixed_fmul_scalar = int32_to_fixed_fmul_scalar_c;
+    c->fixed_to_int16_interleave  = fixed_to_int16_interleave_c;
+    c->fixed_interleave           = ff_fixed_interleave_c;
     c->float_to_int16             = float_to_int16_c;
     c->float_to_int16_interleave  = float_to_int16_interleave_c;
+    c->int_to_int16_interleave    = int_to_int16_interleave_c;
     c->float_interleave           = ff_float_interleave_c;
 
     if (ARCH_ARM) ff_fmt_convert_init_arm(c, avctx);
diff -uNr ffmpeg-0.7.12/libavcodec/fmtconvert.h ffmpeg-0.7.12-140902/libavcodec/fmtconvert.h
--- ffmpeg-0.7.12/libavcodec/fmtconvert.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/fmtconvert.h	2014-09-04 19:40:58.380263128 +0800
@@ -26,6 +26,12 @@
 #include "avcodec.h"
 
 typedef struct FmtConvertContext {
+
+   void (*int32_to_fixed_fmul_scalar)(int16_t *dst, const int *src, int mul, int len);
+   void (*fixed_to_int16)(int16_t *dst, const int *src, long len);
+   void (*fixed_to_int16_interleave)(int16_t *dst, const int **src,long len, int channels);
+   void (*fixed_interleave)(int16_t *dst, const int **src, unsigned int len,
+                             int channels);
     /**
      * Convert an array of int32_t to float and multiply by a float value.
      * @param dst destination array of float.
@@ -68,6 +74,8 @@
      */
     void (*float_to_int16_interleave)(int16_t *dst, const float **src,
                                       long len, int channels);
+    void (*int_to_int16_interleave)(int16_t *dst, const int **src,
+                                      long len, int channels);
 
     /**
      * Convert an array of interleaved float to multiple arrays of float.
@@ -79,6 +87,10 @@
 void ff_float_interleave_c(float *dst, const float **src, unsigned int len,
                            int channels);
 
+void ff_fixed_interleave_c(int16_t *dst, const int **src, unsigned int len,
+                           int channels);
+//void fixed_interleave(int *dst, const int **src, unsigned int len, int channels);
+
 void ff_fmt_convert_init(FmtConvertContext *c, AVCodecContext *avctx);
 
 void ff_fmt_convert_init_arm(FmtConvertContext *c, AVCodecContext *avctx);
@@ -88,5 +100,5 @@
 /* ffdshow custom code */
 void float_interleave(float *dst, const float **src, long len, int channels);
 void float_interleave_noscale(float *dst, const float **src, long len, int channels);
-
+void fixed_to_int16_interleave_aac(int16_t *dst, const int **src,long len, int channels,int multiplier);
 #endif /* AVCODEC_FMTCONVERT_H */
diff -uNr ffmpeg-0.7.12/libavcodec/kbdwin.c ffmpeg-0.7.12-140902/libavcodec/kbdwin.c
--- ffmpeg-0.7.12/libavcodec/kbdwin.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/kbdwin.c	2013-10-31 11:10:02.000000000 +0800
@@ -46,3 +46,25 @@
        window[i] = sqrt(local_window[i] / sum);
 }
 
+av_cold void ff_kbd_window_init_fixed(int32_t *window, float alpha, int n)
+{
+    int i, j;
+    double sum = 0.0, bessel, tmp;
+    double local_window[FF_KBD_WINDOW_MAX];
+    double alpha2 = (alpha * M_PI / n) * (alpha * M_PI / n);
+
+    assert(n <= FF_KBD_WINDOW_MAX);
+
+    for (i = 0; i < n; i++) {
+        tmp = i * (n - i) * alpha2;
+        bessel = 1.0;
+        for (j = BESSEL_I0_ITER; j > 0; j--)
+            bessel = bessel * tmp / (j * j) + 1;
+        sum += bessel;
+        local_window[i] = sum;
+    }
+
+    sum++;
+    for (i = 0; i < n; i++)
+       window[i] = (int)floor(2147483648.0 * sqrt(local_window[i] / sum) + 0.5);
+}
diff -uNr ffmpeg-0.7.12/libavcodec/kbdwin.h ffmpeg-0.7.12-140902/libavcodec/kbdwin.h
--- ffmpeg-0.7.12/libavcodec/kbdwin.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/kbdwin.h	2013-10-31 11:10:02.000000000 +0800
@@ -31,5 +31,5 @@
  * @param   n       size of half window, max FF_KBD_WINDOW_MAX
  */
 void ff_kbd_window_init(float *window, float alpha, int n);
-
+void ff_kbd_window_init_fixed(int32_t *window, float alpha, int n);
 #endif /* AVCODEC_KBDWIN_H */
diff -uNr ffmpeg-0.7.12/libavcodec/lpc.h ffmpeg-0.7.12-140902/libavcodec/lpc.h
--- ffmpeg-0.7.12/libavcodec/lpc.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/lpc.h	2014-09-02 15:46:12.000000000 +0800
@@ -25,6 +25,8 @@
 #include <stdint.h>
 #include "dsputil.h"
 
+#include "libavutil/avassert.h"
+
 #define ORDER_METHOD_EST     0
 #define ORDER_METHOD_2LEVEL  1
 #define ORDER_METHOD_4LEVEL  2
@@ -51,6 +53,7 @@
     int blocksize;
     int max_order;
     enum FFLPCType lpc_type;
+    double *windowed_buffer;
     double *windowed_samples;
 
     /**
@@ -91,6 +94,9 @@
                       enum FFLPCType lpc_type, int lpc_passes,
                       int omethod, int max_shift, int zero_shift);
 
+int ff_lpc_calc_ref_coefs(LPCContext *s,
+                          const int32_t *samples, int order, double *ref);
+
 /**
  * Initialize LPCContext.
  */
@@ -110,6 +116,37 @@
 #endif
 
 /**
+ * Schur recursion.
+ * Produces reflection coefficients from autocorrelation data.
+ */
+static inline void compute_ref_coefs(const LPC_TYPE *autoc, int max_order,
+                                     LPC_TYPE *ref, LPC_TYPE *error)
+{
+    int i, j;
+    LPC_TYPE err;
+    LPC_TYPE gen0[MAX_LPC_ORDER], gen1[MAX_LPC_ORDER];
+
+    for (i = 0; i < max_order; i++)
+        gen0[i] = gen1[i] = autoc[i + 1];
+
+    err    = autoc[0];
+    ref[0] = -gen1[0] / err;
+    err   +=  gen1[0] * ref[0];
+    if (error)
+        error[0] = err;
+    for (i = 1; i < max_order; i++) {
+        for (j = 0; j < max_order - i; j++) {
+            gen1[j] = gen1[j + 1] + ref[i - 1] * gen0[j];
+            gen0[j] = gen1[j + 1] * ref[i - 1] + gen0[j];
+        }
+        ref[i] = -gen1[0] / err;
+        err   +=  gen1[0] * ref[i];
+        if (error)
+            error[i] = err;
+    }
+}
+
+/**
  * Levinson-Durbin recursion.
  * Produce LPC coefficients from autocorrelation data.
  */
@@ -157,4 +194,51 @@
     return 0;
 }
 
+static inline int compute_lpc_coefs_fixed(const int *autoc, int max_order, int *lpc,
+                                           int lpc_stride, int fail, int normalize)
+{
+    int i, j;
+    int *lpc_last = lpc;
+    int err;
+    long long accu;
+
+    av_assert2(normalize || !fail);
+
+    if (normalize)
+        err = *autoc++;
+
+    if (fail && (autoc[max_order - 1] == 0 || err <= 0))
+        return -1;
+
+    for(i=0; i<max_order; i++) {
+        int r = (-autoc[i] + 16) >> 5;
+
+        if (normalize) {
+            for(j=0; j<i; j++)
+                r -= lpc_last[j] * autoc[i-j-1];
+
+           r /= err;
+            err *= 1 - (r * r);
+        }
+
+        lpc[i] = r;
+        for (j=0; j < (i+1)>>1; j++) {
+            int f = lpc_last[    j];
+            int b = lpc_last[i-1-j];
+
+            accu = (long long)r * b;
+            lpc[    j] = f + (int)((accu + 0x2000000) >> 26);
+            accu = (long long)r * f;
+            lpc[i-1-j] = b + (int)((accu + 0x2000000) >> 26);
+        }
+
+        if (fail && err < 0)
+            return -1;
+
+        lpc_last = lpc;
+        lpc += lpc_stride;
+    }
+    return 0;
+}
+
 #endif /* AVCODEC_LPC_H */
diff -uNr ffmpeg-0.7.12/libavcodec/Makefile ffmpeg-0.7.12NF/libavcodec/Makefile
--- ffmpeg-0.7.12/libavcodec/Makefile	2013-08-26 15:52:03.086038210 +0800
+++ ffmpeg-0.7.12NF/libavcodec/Makefile	2013-08-21 15:54:52.000000000 +0800
@@ -49,7 +49,7 @@
                                           mpegaudiodsp_float.o
 RDFT-OBJS-$(CONFIG_HARDCODED_TABLES)   += sin_tables.o
 OBJS-$(CONFIG_RDFT)                    += rdft.o $(RDFT-OBJS-yes)
-OBJS-$(CONFIG_SINEWIN)                 += sinewin.o
+OBJS-$(CONFIG_SINEWIN)                 += sinewin_fixed.o
 OBJS-$(CONFIG_VAAPI)                   += vaapi.o
 OBJS-$(CONFIG_VDPAU)                   += vdpau.o
 
@@ -57,7 +57,8 @@
 OBJS-$(CONFIG_A64MULTI_ENCODER)        += a64multienc.o elbg.o
 OBJS-$(CONFIG_A64MULTI5_ENCODER)       += a64multienc.o elbg.o
 OBJS-$(CONFIG_AAC_DECODER)             += aacdec.o aactab.o aacsbr.o aacps.o \
-                                          aacadtsdec.o mpeg4audio.o kbdwin.o
+                                          aacadtsdec.o mpeg4audio.o kbdwin.o \
+                                          sbrdsp.o aacpsdsp.o fixed_dsp.o
 OBJS-$(CONFIG_AAC_ENCODER)             += aacenc.o aaccoder.o    \
                                           aacpsy.o aactab.o      \
                                           psymodel.o iirfilter.o \
@@ -689,9 +690,9 @@
 TESTPROGS-$(HAVE_MMX) += motion
 TESTOBJS = dctref.o
 
-HOSTPROGS = aac_tablegen aacps_tablegen cbrt_tablegen cos_tablegen      \
+HOSTPROGS = aac_tablegen aacps_fixed_tablegen cbrt_tablegen cbrt_fixed_tablegen cos_tablegen      \
             dv_tablegen motionpixels_tablegen mpegaudio_tablegen        \
-            pcm_tablegen qdm2_tablegen sinewin_tablegen
+            pcm_tablegen qdm2_tablegen sinewin_tablegen sinewin_fixed_tablegen
 
 DIRS = alpha arm bfin mlib ppc ps2 sh4 sparc x86
 
@@ -713,8 +714,8 @@
 $(SUBDIR)%_tablegen$(HOSTEXESUF): HOSTCFLAGS += -DCONFIG_SMALL=0
 endif
 
-GEN_HEADERS = cbrt_tables.h aacps_tables.h aac_tables.h dv_tables.h     \
-              sinewin_tables.h mpegaudio_tables.h motionpixels_tables.h \
+GEN_HEADERS = cbrt_tables.h cbrt_fixed_tables.h aacps_tables.h aacps_fixed_tables.h aac_tables.h dv_tables.h     \
+              sinewin_tables.h sinewin_fixed_tables.h mpegaudio_tables.h motionpixels_tables.h \
               pcm_tables.h qdm2_tables.h
 GEN_HEADERS := $(addprefix $(SUBDIR), $(GEN_HEADERS))
 
@@ -722,11 +723,12 @@
 	$(M)./$< > $@
 
 ifdef CONFIG_HARDCODED_TABLES
-$(SUBDIR)aacdec.o: $(SUBDIR)cbrt_tables.h
-$(SUBDIR)aacps.o: $(SUBDIR)aacps_tables.h
-$(SUBDIR)aactab.o: $(SUBDIR)aac_tables.h
+$(SUBDIR)aacdec.o: $(SUBDIR)cbrt_tables.h cbrt_fixed_tables.h
+$(SUBDIR)aacps.o: $(SUBDIR)aacps_fixed_tables.h
+$(SUBDIR)aactab.o: $(SUBDIR)aac_tables.h 
+$(SUBDIR)aactab_fixed.o: $(SUBDIR)aac_fixed_tables.h
 $(SUBDIR)dv.o: $(SUBDIR)dv_tables.h
-$(SUBDIR)sinewin.o: $(SUBDIR)sinewin_tables.h
+$(SUBDIR)sinewin_fixed.o: $(SUBDIR)sinewin_fixed_tables.h
 $(SUBDIR)mpegaudiodec.o: $(SUBDIR)mpegaudio_tables.h
 $(SUBDIR)mpegaudiodec_float.o: $(SUBDIR)mpegaudio_tables.h
 $(SUBDIR)motionpixels.o: $(SUBDIR)motionpixels_tables.h


diff -uNr ffmpeg-0.7.12/libavcodec/mdct.c ffmpeg-0.7.12-140902/libavcodec/mdct.c
--- ffmpeg-0.7.12/libavcodec/mdct.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/mdct.c	2014-09-02 15:47:12.000000000 +0800
@@ -34,7 +34,11 @@
 #if CONFIG_FFT_FLOAT
 #   define RSCALE(x) (x)
 #else
-#   define RSCALE(x) ((x) >> 1)
+#if CONFIG_FFT_FIXED_32   
+#   define RSCALE(x) (((x) + 32) >> 6)
+#else /* CONFIG_FFT_FIXED_32 */                                                
+#   define RSCALE(x) ((x) >> 1)    
+#endif /* CONFIG_FFT_FIXED_32 */  
 #endif
 
 /**
@@ -50,7 +54,7 @@
     n = 1 << nbits;
     s->mdct_bits = nbits;
     s->mdct_size = n;
-    n4 = n >> 2;
+    n4 = n >> 2;//64
     s->mdct_permutation = FF_MDCT_PERM_NONE;
 
     if (ff_fft_init(s, s->mdct_bits - 2, inverse) < 0)
@@ -77,9 +81,16 @@
     scale = sqrt(fabs(scale));
     for(i=0;i<n4;i++) {
         alpha = 2 * M_PI * (i + theta) / n;
+#if CONFIG_FFT_FIXED_32                                                                                                                                  
+        s->tcos[i*tstep] = (FFTSample)floor(-cos(alpha) * 2147483648.0 + 0.5);                                                                           
+        s->tsin[i*tstep] = (FFTSample)floor(-sin(alpha) * 2147483648.0 + 0.5);                                                                           
+#else 
         s->tcos[i*tstep] = FIX15(-cos(alpha) * scale);
         s->tsin[i*tstep] = FIX15(-sin(alpha) * scale);
+#endif
     }
+ /*for(j = 0 ; j < 32; j++)
+av_log(NULL,AV_LOG_INFO,"[%d]%d ",j,s->tsin[j]);*/
     return 0;
  fail:
     ff_mdct_end(s);
diff -uNr ffmpeg-0.7.12/libavcodec/mdct_fixed_32.c ffmpeg-0.7.12-140902/libavcodec/mdct_fixed_32.c
--- ffmpeg-0.7.12/libavcodec/mdct_fixed_32.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/mdct_fixed_32.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,52 @@
+/*                                                                                  
+ * Copyright (c) 2012                                                          
+ *      MIPS Technologies, Inc., California.                                   
+ *                                                                             
+ * Redistribution and use in source and binary forms, with or without          
+ * modification, are permitted provided that the following conditions          
+ * are met:                                                                    
+ * 1. Redistributions of source code must retain the above copyright           
+ *    notice, this list of conditions and the following disclaimer.            
+ * 2. Redistributions in binary form must reproduce the above copyright        
+ *    notice, this list of conditions and the following disclaimer in the      
+ *    documentation and/or other materials provided with the distribution.     
+ * 3. Neither the name of the MIPS Technologies, Inc., nor the names of its    
+ *    contributors may be used to endorse or promote products derived from     
+ *    this software without specific prior written permission.                 
+ *                                                                             
+ * THIS SOFTWARE IS PROVIDED BY THE MIPS TECHNOLOGIES, INC. ``AS IS'' AND      
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE       
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE MIPS TECHNOLOGIES, INC. BE LIABLE    
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS     
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)       
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF      
+ * SUCH DAMAGE.                                                                
+ *                                                                             
+ * Authors:  Stanislav Ocovaj (socovaj@mips.com)                               
+ *           Goran Cordasic   (goran@mips.com)                                 
+ *           Djordje Pesut    (djordje@mips.com)                               
+ *                                                                             
+ * This file is part of FFmpeg.                                                
+ *                                                                             
+ * FFmpeg is free software; you can redistribute it and/or                     
+ * modify it under the terms of the GNU Lesser General Public                  
+ * License as published by the Free Software Foundation; either                
+ * version 2.1 of the License, or (at your option) any later version.          
+ *                                                                             
+ * FFmpeg is distributed in the hope that it will be useful,                   
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of              
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           
+ * Lesser General Public License for more details.                             
+ *                                                                             
+ * You should have received a copy of the GNU Lesser General Public            
+ * License along with FFmpeg; if not, write to the Free Software               
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */                                                                            
+                                                                               
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 1
+#include "mdct.c"
diff -uNr ffmpeg-0.7.12/libavcodec/mdct_fixed.c ffmpeg-0.7.12-140902/libavcodec/mdct_fixed.c
--- ffmpeg-0.7.12/libavcodec/mdct_fixed.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/mdct_fixed.c	2013-10-31 11:10:02.000000000 +0800
@@ -17,6 +17,7 @@
  */
 
 #define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 0 
 #include "mdct.c"
 
 /* same as ff_mdct_calcw_c with double-width unscaled output */
diff -uNr ffmpeg-0.7.12/libavcodec/mdct_float.c ffmpeg-0.7.12-140902/libavcodec/mdct_float.c
--- ffmpeg-0.7.12/libavcodec/mdct_float.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/mdct_float.c	2013-10-31 11:10:02.000000000 +0800
@@ -17,4 +17,5 @@
  */
 
 #define CONFIG_FFT_FLOAT 1
+#define CONFIG_FFT_FIXED_32 0
 #include "mdct.c"
diff -uNr ffmpeg-0.7.12/libavcodec/sbrdsp.c ffmpeg-0.7.12-140902/libavcodec/sbrdsp.c
--- ffmpeg-0.7.12/libavcodec/sbrdsp.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sbrdsp.c	2014-09-02 17:22:57.000000000 +0800
@@ -0,0 +1,629 @@
+/*
+ * AAC Spectral Band Replication decoding functions
+ * Copyright (c) 2008-2009 Robert Swain ( rob opendot cl )
+ * Copyright (c) 2009-2010 Alex Converse <alex.converse@gmail.com>
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "sbrdsp.h"
+
+static void sbr_sum64x5_c(float *z)
+{
+    int k;
+    for (k = 0; k < 64; k++) {
+        float f = z[k] + z[k + 64] + z[k + 128] + z[k + 192] + z[k + 256];
+        z[k] = f;
+    }
+}
+static void sbr_sum64x5_fixed_c(int *z)                                                                                                                     
+{                                                                                                                                                           
+    int k;                                                                                                                                                  
+    for (k = 0; k < 64; k++) {                                                                                                                              
+        int f = z[k] + z[k + 64] + z[k + 128] + z[k + 192] + z[k + 256];                                                                                    
+        z[k] = f;                                                                                                                                           
+    }                                                                                                                                                       
+}                                                                                                                                                           
+              
+static float sbr_sum_square_c(float (*x)[2], int n)
+{
+    float sum0 = 0.0f, sum1 = 0.0f;
+    int i;
+
+    for (i = 0; i < n; i += 2)
+    {
+        sum0 += x[i + 0][0] * x[i + 0][0];
+        sum1 += x[i + 0][1] * x[i + 0][1];
+        sum0 += x[i + 1][0] * x[i + 1][0];
+        sum1 += x[i + 1][1] * x[i + 1][1];
+    }
+
+    return sum0 + sum1;
+}
+static aac_float_t sbr_sum_square_fixed_c(int (*x)[2], int n)                                                                                               
+{                                                                                                                                                           
+    aac_float_t ret;                                                                                                                                        
+    long long accu = 0;                                                                                                                                     
+    int i, nz, round;                                                                                                                                       
+                                                                                                                                                            
+    for (i = 0; i < n; i += 2) {                                                                                                                            
+        accu += (long long)x[i + 0][0] * x[i + 0][0];                                                                                                       
+        accu += (long long)x[i + 0][1] * x[i + 0][1];                                                                                                       
+        accu += (long long)x[i + 1][0] * x[i + 1][0];                                                                                                       
+        accu += (long long)x[i + 1][1] * x[i + 1][1];                                                                                                       
+    }                                                                                                                                                       
+                                                                                                                                                            
+    i = (int)(accu >> 32);                                                                                                                                  
+    if (i == 0) {                                                                                                                                           
+        nz = 31;                                                                                                                                            
+    } else {                                                                                                                                                
+        nz = 0;                                                                                                                                             
+        while (FFABS(i) < 0x40000000) {                                                                                                                     
+            i <<= 1;                                                                                                                                        
+            nz++;                                                                                                                                           
+        }                                                                                                                                                   
+    }                                                                                                                                                       
+                                                                                                                                                            
+    nz = 32-nz;                                                                                                                                             
+    round = 1 << (nz-1);                                                                                                                                    
+    i = (int)((accu+round) >> nz);                                                                                                                          
+    i >>= 1;                                                                                                                                                
+    ret = int2float(i, nz + 15);                                                                                                                            
+                                                                                                                                                            
+    return ret;                                                                                                                                             
+}      
+static void sbr_neg_odd_64_c(float *x)
+{
+    int i;
+    for (i = 1; i < 64; i += 2)
+        x[i] = -x[i];
+}
+
+static void sbr_qmf_pre_shuffle_c(float *z)
+{
+    int k;
+    z[64] = z[0];
+    z[65] = z[1];
+    for (k = 1; k < 32; k++) {
+        z[64+2*k  ] = -z[64 - k];
+        z[64+2*k+1] =  z[ k + 1];
+    }
+}
+static void sbr_neg_odd_64_fixed_c(int *x)                                                                                                                  
+{                                                                                                                                                           
+    int i;                                                                                                                                                  
+    for (i = 1; i < 64; i += 2)                                                                                                                             
+        x[i] = -x[i];                                                                                                                                       
+}                                                                                                                                                           
+    
+static void sbr_qmf_post_shuffle_c(float W[32][2], const float *z)
+{
+    int k;
+    for (k = 0; k < 32; k++) {
+        W[k][0] = -z[63-k];
+        W[k][1] = z[k];
+    }
+}
+static void sbr_qmf_pre_shuffle_fixed_c(int *z)                                                                                                             
+{                                                                                                                                                           
+    int k;                                                                                                                                                  
+    z[64] = z[0];                                                                                                                                           
+    z[65] = z[1];                                                                                                                                           
+    for (k = 1; k < 32; k++) {                                                                                                                              
+        z[64+2*k  ] = -z[64 - k];                                                                                                                           
+        z[64+2*k+1] =  z[ k + 1];                                                                                                                           
+    }                                                                                                                                                       
+}                                                                                                                                                           
+         
+static void sbr_qmf_deint_neg_c(float *v, const float *src)
+{
+    int i;
+    for (i = 0; i < 32; i++) {
+        v[     i] =  src[63 - 2*i    ];
+        v[63 - i] = -src[63 - 2*i - 1];
+    }
+}
+
+static void sbr_qmf_deint_bfly_c(float *v, const float *src0, const float *src1)
+{
+    int i;
+    for (i = 0; i < 64; i++) {
+        v[      i] = src0[i] - src1[63 - i];
+        v[127 - i] = src0[i] + src1[63 - i];
+    }
+}
+static void sbr_qmf_post_shuffle_fixed_c(int W[32][2], const int *z)                                                                                        
+{                                                                                                                                                           
+    int k;                                                                                                                                                  
+    for (k = 0; k < 32; k++) {                                                                                                                              
+        W[k][0] = -z[63-k];                                                                                                                                 
+        W[k][1] = z[k];                                                                                                                                     
+    }                                                                                                                                                       
+}                                                                                                                                                           
+static void sbr_qmf_deint_neg_fixed_c(int *v, const int *src)                                                                                               
+{                                                                                                                                                           
+    int i;                                                                                                                                                  
+    for (i = 0; i < 32; i++) {                                                                                                                              
+        v[     i] = ( src[63 - 2*i    ] + 16) >> 5;                                                                                                         
+        v[63 - i] = (-src[63 - 2*i - 1] + 16) >> 5;                                                                                                         
+    }                                                                                                                                                       
+}      
+static av_always_inline void autocorrelate(const float x[40][2],
+                                           float phi[3][2][2], int lag)
+{
+    int i;
+    float real_sum = 0.0f;
+    float imag_sum = 0.0f;
+    if (lag) {
+        for (i = 1; i < 38; i++) {
+            real_sum += x[i][0] * x[i+lag][0] + x[i][1] * x[i+lag][1];
+            imag_sum += x[i][0] * x[i+lag][1] - x[i][1] * x[i+lag][0];
+        }
+        phi[2-lag][1][0] = real_sum + x[ 0][0] * x[lag][0] + x[ 0][1] * x[lag][1];
+        phi[2-lag][1][1] = imag_sum + x[ 0][0] * x[lag][1] - x[ 0][1] * x[lag][0];
+        if (lag == 1) {
+            phi[0][0][0] = real_sum + x[38][0] * x[39][0] + x[38][1] * x[39][1];
+            phi[0][0][1] = imag_sum + x[38][0] * x[39][1] - x[38][1] * x[39][0];
+        }
+    } else {
+        for (i = 1; i < 38; i++) {
+            real_sum += x[i][0] * x[i][0] + x[i][1] * x[i][1];
+        }
+        phi[2][1][0] = real_sum + x[ 0][0] * x[ 0][0] + x[ 0][1] * x[ 0][1];
+        phi[1][0][0] = real_sum + x[38][0] * x[38][0] + x[38][1] * x[38][1];
+    }
+}
+
+static void sbr_qmf_deint_bfly_fixed_c(int *v, const int *src0, const int *src1)
+{
+    int i;
+    for (i = 0; i < 64; i++) {
+        v[      i] = (src0[i] - src1[63 - i] + 16) >> 5;
+        v[127 - i] = (src0[i] + src1[63 - i] + 16) >> 5;
+    }
+}
+
+static av_always_inline void autocorrelate_q31(const int x[40][2], aac_float_t phi[3][2][2], int lag)
+{
+    int i, nz, round, mant, expo;
+    long long real_sum, imag_sum;
+    long long accu_re = 0, accu_im = 0;
+
+    if (lag) {
+        for (i = 1; i < 38; i++) {
+            accu_re += (long long)x[i][0] * x[i+lag][0];
+            accu_re += (long long)x[i][1] * x[i+lag][1];
+            accu_im += (long long)x[i][0] * x[i+lag][1];
+            accu_im -= (long long)x[i][1] * x[i+lag][0];
+        }
+
+        real_sum = accu_re;
+        imag_sum = accu_im;
+
+        accu_re += (long long)x[ 0][0] * x[lag][0];
+        accu_re += (long long)x[ 0][1] * x[lag][1];
+        accu_im += (long long)x[ 0][0] * x[lag][1];
+        accu_im -= (long long)x[ 0][1] * x[lag][0];
+
+        i = (int)(accu_re >> 32);
+        if (i == 0) {
+            nz = 31;
+        } else {
+            nz = 0;
+            while (FFABS(i) < 0x40000000) {
+                i <<= 1;
+                nz++;
+            }
+        }
+
+        nz = 32-nz;
+        round = 1 << (nz-1);
+        mant = (int)((accu_re+round) >> nz);
+        mant = (mant + 64)>>7;
+        mant <<= 6;
+        expo = nz + 15;
+        phi[2-lag][1][0] = int2float(mant, expo);
+
+        i = (int)(accu_im >> 32);
+        if (i == 0) {
+            nz = 31;
+        } else {
+            nz = 0;
+            while (FFABS(i) < 0x40000000) {
+                i <<= 1;
+                nz++;
+            }
+        }
+
+        nz = 32-nz;
+        round = 1 << (nz-1);
+        mant = (int)((accu_im+round) >> nz);
+        mant = (mant + 64)>>7;
+        mant <<= 6;
+        expo = nz + 15;
+        phi[2-lag][1][1] = int2float(mant, expo);
+
+        if (lag == 1) {
+            accu_re = real_sum;
+            accu_im = imag_sum;
+            accu_re += (long long)x[38][0] * x[39][0];
+            accu_re += (long long)x[38][1] * x[39][1];
+            accu_im += (long long)x[38][0] * x[39][1];
+            accu_im -= (long long)x[38][1] * x[39][0];
+
+            i = (int)(accu_re >> 32);
+            if (i == 0) {
+                nz = 31;
+            } else {
+                nz = 0;
+                while (FFABS(i) < 0x40000000) {
+                    i <<= 1;
+                    nz++;
+                }
+            }
+
+            nz = 32-nz;
+            round = 1 << (nz-1);
+            mant = (int)((accu_re+round) >> nz);
+            mant = (mant + 64)>>7;
+            mant <<= 6;
+            expo = nz + 15;
+            phi[0][0][0] = int2float(mant, expo);
+
+            i = (int)(accu_im >> 32);
+            if (i == 0) {
+                nz = 31;
+            } else {
+                nz = 0;
+                while (FFABS(i) < 0x40000000) {
+                    i <<= 1;
+                    nz++;
+                }
+            }
+
+            nz = 32-nz;
+            round = 1 << (nz-1);
+            mant = (int)((accu_im+round) >> nz);
+            mant = (mant + 64)>>7;
+            mant <<= 6;
+            expo = nz + 15;
+            phi[0][0][1] = int2float(mant, expo);
+        }
+    } else {
+        for (i = 1; i < 38; i++) {
+            accu_re += (long long)x[i][0] * x[i][0];
+            accu_re += (long long)x[i][1] * x[i][1];
+        }
+        real_sum = accu_re;
+        accu_re += (long long)x[ 0][0] * x[ 0][0];
+        accu_re += (long long)x[ 0][1] * x[ 0][1];
+
+        i = (int)(accu_re >> 32);
+        if (i == 0) {
+            nz = 31;
+        } else {
+            nz = 0;
+            while (FFABS(i) < 0x40000000) {
+                i <<= 1;
+                nz++;
+            }
+        }
+
+        nz = 32-nz;
+        round = 1 << (nz-1);
+        mant = (int)((accu_re+round) >> nz);
+        mant = (mant + 64)>>7;
+        mant <<= 6;
+        expo = nz + 15;
+        phi[2][1][0] = int2float(mant, expo);
+
+        accu_re = real_sum;
+        accu_re += (long long)x[38][0] * x[38][0];
+        accu_re += (long long)x[38][1] * x[38][1];
+
+        i = (int)(accu_re >> 32);
+        if (i == 0) {
+            nz = 31;
+        } else {
+            nz = 0;
+            while (FFABS(i) < 0x40000000) {
+                i <<= 1;
+                nz++;
+            }
+        }
+
+        nz = 32-nz;
+        round = 1 << (nz-1);
+        mant = (int)((accu_re+round) >> nz);
+        mant = (mant + 64)>>7;
+        mant <<= 6;
+        expo = nz + 15;
+        phi[1][0][0] = int2float(mant, expo);
+    }
+}
+static void sbr_autocorrelate_c(const float x[40][2], float phi[3][2][2])
+{
+    autocorrelate(x, phi, 0);
+    autocorrelate(x, phi, 1);
+    autocorrelate(x, phi, 2);
+}
+static void sbr_autocorrelate_q31_c(const int x[40][2], aac_float_t phi[3][2][2])                                                                           
+{                                                                                                                                                           
+    autocorrelate_q31(x, phi, 0);                                                                                                                           
+    autocorrelate_q31(x, phi, 1);                                                                                                                           
+    autocorrelate_q31(x, phi, 2);                                                                                                                           
+}                                                                                                                                                           
+       
+static void sbr_hf_gen_c(float (*X_high)[2], const float (*X_low)[2],
+                         const float alpha0[2], const float alpha1[2],
+                         float bw, int start, int end)
+{
+    float alpha[4];
+    int i;
+
+    alpha[0] = alpha1[0] * bw * bw;
+    alpha[1] = alpha1[1] * bw * bw;
+    alpha[2] = alpha0[0] * bw;
+    alpha[3] = alpha0[1] * bw;
+
+    for (i = start; i < end; i++) {
+        X_high[i][0] =
+            X_low[i - 2][0] * alpha[0] -
+            X_low[i - 2][1] * alpha[1] +
+            X_low[i - 1][0] * alpha[2] -
+            X_low[i - 1][1] * alpha[3] +
+            X_low[i][0];
+        X_high[i][1] =
+            X_low[i - 2][1] * alpha[0] +
+            X_low[i - 2][0] * alpha[1] +
+            X_low[i - 1][1] * alpha[2] +
+            X_low[i - 1][0] * alpha[3] +
+            X_low[i][1];
+    }
+}
+
+static void sbr_hf_gen_fixed_c(int (*X_high)[2], const int (*X_low)[2],
+                             const int alpha0[2], const int alpha1[2],
+                             int bw, int start, int end)
+{
+    int alpha[4];
+    int i;
+    long long accu;
+
+    accu = (long long)alpha0[0] * bw;
+    alpha[2] = (int)((accu + 0x40000000) >> 31);
+    accu = (long long)alpha0[1] * bw;
+    alpha[3] = (int)((accu + 0x40000000) >> 31);
+    accu = (long long)bw * bw;
+    bw = (int)((accu + 0x40000000) >> 31);
+    accu = (long long)alpha1[0] * bw;
+    alpha[0] = (int)((accu + 0x40000000) >> 31);
+    accu = (long long)alpha1[1] * bw;
+    alpha[1] = (int)((accu + 0x40000000) >> 31);
+
+    for (i = start; i < end; i++) {
+        accu  = (long long)X_low[i][0] * 0x20000000;
+        accu += (long long)X_low[i - 2][0] * alpha[0];
+        accu -= (long long)X_low[i - 2][1] * alpha[1];
+        accu += (long long)X_low[i - 1][0] * alpha[2];
+        accu -= (long long)X_low[i - 1][1] * alpha[3];
+        X_high[i][0] = (int)((accu + 0x10000000) >> 29);
+
+        accu  = (long long)X_low[i][1] * 0x20000000;
+        accu += (long long)X_low[i - 2][1] * alpha[0];
+        accu += (long long)X_low[i - 2][0] * alpha[1];
+        accu += (long long)X_low[i - 1][1] * alpha[2];
+        accu += (long long)X_low[i - 1][0] * alpha[3];
+        X_high[i][1] = (int)((accu + 0x10000000) >> 29);
+    }
+}
+static void sbr_hf_g_filt_c(float (*Y)[2], const float (*X_high)[40][2],
+                            const float *g_filt, int m_max, intptr_t ixh)
+{
+    int m;
+
+    for (m = 0; m < m_max; m++) {
+        Y[m][0] = X_high[m][ixh][0] * g_filt[m];
+        Y[m][1] = X_high[m][ixh][1] * g_filt[m];
+    }
+}
+
+static void sbr_hf_g_filt_int_c(int (*Y)[2], const int (*X_high)[40][2],                                                                                    
+                            const aac_float_t *g_filt, int m_max, intptr_t ixh)                                                                             
+{                                                                                                                                                           
+    int m, r;                                                                                                                                               
+    long long accu;                                                                                                                                         
+                                                                                                                                                            
+    for (m = 0; m < m_max; m++) {                                                                                                                           
+        r = 1 << (22-g_filt[m].expo);                                                                                                                       
+        accu = (long long)X_high[m][ixh][0] * ((g_filt[m].mant + 64)>>7);                                                                                   
+        Y[m][0] = (int)((accu + r) >> (23-g_filt[m].expo));                                                                                                 
+                                                                                                                                                            
+        accu = (long long)X_high[m][ixh][1] * ((g_filt[m].mant + 64)>>7);                                                                                   
+        Y[m][1] = (int)((accu + r) >> (23-g_filt[m].expo));                                                                                                 
+    }                                                                                                                                                       
+}                                                                                                                                                           
+       
+
+/*static av_always_inline void sbr_hf_apply_noise(float (*Y)[2],
+                                                const float *s_m,
+                                                const float *q_filt,
+                                                int noise,
+                                                float phi_sign0,
+                                                float phi_sign1,
+                                                int m_max)
+{
+    int m;
+
+    for (m = 0; m < m_max; m++) {
+        float y0 = Y[m][0];
+        float y1 = Y[m][1];
+        noise = (noise + 1) & 0x1ff;
+        if (s_m[m]) {
+            y0 += s_m[m] * phi_sign0;
+            y1 += s_m[m] * phi_sign1;
+        } else {
+            y0 += q_filt[m] * ff_sbr_noise_table[noise][0];
+            y1 += q_filt[m] * ff_sbr_noise_table[noise][1];
+        }
+        Y[m][0] = y0;
+        Y[m][1] = y1;
+        phi_sign1 = -phi_sign1;
+    }
+}*/
+
+static av_always_inline void sbr_hf_apply_noise_int(int (*Y)[2],
+                                                const aac_float_t *s_m,
+                                                const aac_float_t *q_filt,
+                                                int noise,
+                                                int phi_sign0,
+                                                int phi_sign1,
+                                                int m_max)
+{
+    int m;
+
+    for (m = 0; m < m_max; m++) {
+        int y0 = Y[m][0];
+        int y1 = Y[m][1];
+        noise = (noise + 1) & 0x1ff;
+        if (s_m[m].mant) {
+            int shift, round;
+
+            shift = 22 - s_m[m].expo;
+            if (shift < 30) {
+                round = 1 << (shift-1);
+                y0 += (s_m[m].mant * phi_sign0 + round) >> shift;
+                y1 += (s_m[m].mant * phi_sign1 + round) >> shift;
+            }
+        } else {
+            int shift, round, tmp;
+            long long accu;
+
+            shift = 22 - q_filt[m].expo;
+            if (shift < 30) {
+                round = 1 << (shift-1);
+
+                accu = (long long)q_filt[m].mant * ff_sbr_noise_table_fixed[noise][0];
+                tmp = (int)((accu + 0x40000000) >> 31);
+                y0 += (tmp + round) >> shift;
+
+                accu = (long long)q_filt[m].mant * ff_sbr_noise_table_fixed[noise][1];
+                tmp = (int)((accu + 0x40000000) >> 31);
+                y1 += (tmp + round) >> shift;
+            }
+        }
+        Y[m][0] = y0;
+        Y[m][1] = y1;
+        phi_sign1 = -phi_sign1;
+    }
+}
+/*static void sbr_hf_apply_noise_0(float (*Y)[2], const float *s_m,
+                                 const float *q_filt, int noise,
+                                 int kx, int m_max)
+{
+    sbr_hf_apply_noise(Y, s_m, q_filt, noise, 1.0, 0.0, m_max);
+}*/
+static void sbr_hf_apply_noise_0_int(int (*Y)[2], const aac_float_t *s_m,                                                                                   
+                                 const aac_float_t *q_filt, int noise,                                                                                      
+                                 int kx, int m_max)                                                                                                         
+{                                                                                                                                                           
+    sbr_hf_apply_noise_int(Y, s_m, q_filt, noise, 1, 0, m_max);                                                                                             
+}    
+/*static void sbr_hf_apply_noise_1(float (*Y)[2], const float *s_m,
+                                 const float *q_filt, int noise,
+                                 int kx, int m_max)
+{
+    float phi_sign = 1 - 2 * (kx & 1);
+    sbr_hf_apply_noise(Y, s_m, q_filt, noise, 0.0, phi_sign, m_max);
+}*/
+static void sbr_hf_apply_noise_1_int(int (*Y)[2], const aac_float_t *s_m,                                                                                   
+                                 const aac_float_t *q_filt, int noise,                                                                                      
+                                 int kx, int m_max)                                                                                                         
+{                                                                                                                                                           
+    int phi_sign = 1 - 2 * (kx & 1);                                                                                                                        
+    sbr_hf_apply_noise_int(Y, s_m, q_filt, noise, 0, phi_sign, m_max);                                                                                      
+}       
+/*static void sbr_hf_apply_noise_2(float (*Y)[2], const float *s_m,
+                                 const float *q_filt, int noise,
+                                 int kx, int m_max)
+{
+    sbr_hf_apply_noise(Y, s_m, q_filt, noise, -1.0, 0.0, m_max);
+}*/
+static void sbr_hf_apply_noise_2_int(int (*Y)[2], const aac_float_t *s_m,                                                                                   
+                                 const aac_float_t *q_filt, int noise,                                                                                      
+                                 int kx, int m_max)                                                                                                         
+{                                                                                                                                                           
+    sbr_hf_apply_noise_int(Y, s_m, q_filt, noise, -1, 0, m_max);                                                                                            
+}                   
+/*static void sbr_hf_apply_noise_3(float (*Y)[2], const float *s_m,
+                                 const float *q_filt, int noise,
+                                 int kx, int m_max)
+{
+    float phi_sign = 1 - 2 * (kx & 1);
+    sbr_hf_apply_noise(Y, s_m, q_filt, noise, 0.0, -phi_sign, m_max);
+}*/
+static void sbr_hf_apply_noise_3_int(int (*Y)[2], const aac_float_t *s_m,                                                                                   
+                                 const aac_float_t *q_filt, int noise,                                                                                      
+                                 int kx, int m_max)                                                                                                         
+{                                                                                                                                                           
+    int phi_sign = 1 - 2 * (kx & 1);                                                                                                                        
+    sbr_hf_apply_noise_int(Y, s_m, q_filt, noise, 0, -phi_sign, m_max);                                                                                     
+}                                                                                                                                                           
+          
+av_cold void ff_sbrdsp_init(SBRDSPContext *s)
+{
+    s->sum64x5 = sbr_sum64x5_c;
+    s->sum64x5_fixed = sbr_sum64x5_fixed_c;                                                                                                                 
+     s->sum_square = sbr_sum_square_c;                                                                                                                       
+    s->sum_square_fixed = sbr_sum_square_fixed_c;                                                                                                           
+     s->neg_odd_64 = sbr_neg_odd_64_c;                                                                                                                       
+    s->neg_odd_64_fixed = sbr_neg_odd_64_fixed_c;                                                                                                           
+     s->qmf_pre_shuffle = sbr_qmf_pre_shuffle_c;                                                                                                             
+    s->qmf_pre_shuffle_fixed = sbr_qmf_pre_shuffle_fixed_c;                                                                                                 
+     s->qmf_post_shuffle = sbr_qmf_post_shuffle_c;                                                                                                           
+    s->qmf_post_shuffle_fixed = sbr_qmf_post_shuffle_fixed_c;                                                                                               
+     s->qmf_deint_neg = sbr_qmf_deint_neg_c;                                                                                                                 
+    s->qmf_deint_neg_fixed = sbr_qmf_deint_neg_fixed_c;                                                                                                     
+     s->qmf_deint_bfly = sbr_qmf_deint_bfly_c;                                                                                                               
+    s->qmf_deint_bfly_fixed = sbr_qmf_deint_bfly_fixed_c;                                                                                                   
+     s->autocorrelate = sbr_autocorrelate_c;                                                                                                                 
+    s->autocorrelate_q31 = sbr_autocorrelate_q31_c;                                                                                                         
+     s->hf_gen = sbr_hf_gen_c;                                                                                                                               
+    s->hf_gen_fixed = sbr_hf_gen_fixed_c;                                                                                                                   
+     s->hf_g_filt = sbr_hf_g_filt_c;                                                                                                                         
+    s->hf_g_filt_int = sbr_hf_g_filt_int_c;  
+
+   /* s->hf_apply_noise[0] = sbr_hf_apply_noise_0;
+    s->hf_apply_noise[1] = sbr_hf_apply_noise_1;
+    s->hf_apply_noise[2] = sbr_hf_apply_noise_2;
+    s->hf_apply_noise[3] = sbr_hf_apply_noise_3;*/
+
+    s->hf_apply_noise_int[0] = sbr_hf_apply_noise_0_int;                                                                                                    
+    s->hf_apply_noise_int[1] = sbr_hf_apply_noise_1_int;                                                                                                    
+    s->hf_apply_noise_int[2] = sbr_hf_apply_noise_2_int;                                                                                                    
+    s->hf_apply_noise_int[3] = sbr_hf_apply_noise_3_int; 
+
+   /* if (ARCH_ARM)
+        ff_sbrdsp_init_arm(s);
+    if (ARCH_X86)
+        ff_sbrdsp_init_x86(s);*/
+}
+
+
+
diff -uNr ffmpeg-0.7.12/libavcodec/sbrdsp.h ffmpeg-0.7.12-140902/libavcodec/sbrdsp.h
--- ffmpeg-0.7.12/libavcodec/sbrdsp.h	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sbrdsp.h	2014-09-02 17:22:27.000000000 +0800
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2012 Mans Rullgard
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_SBRDSP_H
+#define AVCODEC_SBRDSP_H
+#include "float_emu.h"
+#include <stdint.h>
+
+typedef struct SBRDSPContext {
+     void (*sum64x5)(float *z);                                                                                                                              
+    void (*sum64x5_fixed)(int *z);                                                                                                                          
+     float (*sum_square)(float (*x)[2], int n);                                                                                                              
+    aac_float_t (*sum_square_fixed)(int (*x)[2], int n);                                                                                                    
+     void (*neg_odd_64)(float *x);                                                                                                                           
+    void (*neg_odd_64_fixed)(int *x);                                                                                                                       
+     void (*qmf_pre_shuffle)(float *z);                                                                                                                      
+    void (*qmf_pre_shuffle_fixed)(int *z);                                                                                                                  
+     void (*qmf_post_shuffle)(float W[32][2], const float *z);                                                                                               
+    void (*qmf_post_shuffle_fixed)(int W[32][2], const int *z);                                                                                             
+     void (*qmf_deint_neg)(float *v, const float *src);                                                                                                      
+    void (*qmf_deint_neg_fixed)(int *v, const int *src);                                                                                                    
+     void (*qmf_deint_bfly)(float *v, const float *src0, const float *src1);                                                                                 
+    void (*qmf_deint_bfly_fixed)(int *v, const int *src0, const int *src1);                                                                                 
+     void (*autocorrelate)(const float x[40][2], float phi[3][2][2]);                                                                                        
+    void (*autocorrelate_q31)(const int x[40][2], aac_float_t phi[3][2][2]);                                                                                
+     void (*hf_gen)(float (*X_high)[2], const float (*X_low)[2],                                                                                             
+                    const float alpha0[2], const float alpha1[2],                                                                                            
+                    float bw, int start, int end);                                                                                                           
+    void (*hf_gen_fixed)(int (*X_high)[2], const int (*X_low)[2],                                                                                           
+                   const int alpha0[2], const int alpha1[2],                                                                                                
+                   int bw, int start, int end);                                                                                                             
+     void (*hf_g_filt)(float (*Y)[2], const float (*X_high)[40][2],                                                                                          
+                       const float *g_filt, int m_max, intptr_t ixh);                                                                                        
+    void (*hf_g_filt_int)(int (*Y)[2], const int (*X_high)[40][2],                                                                                          
+                      const aac_float_t *g_filt, int m_max, intptr_t ixh);                                                                                  
+    void (*hf_gen_int)(int (*X_high)[2], const int (*X_low)[2],                                                                                             
+                             const int alpha0[2], const int alpha1[2],                                                                                      
+                             int bw, int start, int end);                                                                                                   
+    void (*qmf_deint_bfly_int)(int *v, const int *src0, const int *src1);                                                                                   
+    /* void (*hf_apply_noise[4])(float (*Y)[2], const float *s_m,                                                                                              
+                               const float *q_filt, int noise,                                                                                               
+                               int kx, int m_max);*/
+    void (*hf_apply_noise_int[4])(int (*Y)[2], const aac_float_t *s_m,                                                                                      
+                              const aac_float_t *q_filt, int noise,                                                                                         
+                              int kx, int m_max); 
+} SBRDSPContext;
+
+extern const float ff_sbr_noise_table[][2];
+extern const int   ff_sbr_noise_table_fixed[][2]; 
+void ff_sbrdsp_init(SBRDSPContext *s);
+void ff_sbrdsp_init_arm(SBRDSPContext *s);
+//void ff_sbrdsp_init_x86(SBRDSPContext *s);
+
+#endif /* AVCODEC_SBRDSP_H */
diff -uNr ffmpeg-0.7.12/libavcodec/sbr.h ffmpeg-0.7.12-140902/libavcodec/sbr.h
--- ffmpeg-0.7.12/libavcodec/sbr.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sbr.h	2014-09-02 15:48:48.000000000 +0800
@@ -30,13 +30,19 @@
 #define AVCODEC_SBR_H
 
 #include <stdint.h>
+
+//jh
+#include "float_emu.h"
+#include "aac.h"
+#include "sbrdsp.h"
+
 #include "fft.h"
 #include "aacps.h"
 
 /**
  * Spectral Band Replication header - spectrum parameters that invoke a reset if they differ from the previous header.
  */
-typedef struct {
+typedef struct SpectrumParameters {
     uint8_t bs_start_freq;
     uint8_t bs_stop_freq;
     uint8_t bs_xover_band;
@@ -56,16 +62,16 @@
 /**
  * Spectral Band Replication per channel data
  */
-typedef struct {
+typedef struct SBRData {
     /**
      * @name Main bitstream data variables
      * @{
      */
     unsigned           bs_frame_class;
     unsigned           bs_add_harmonic_flag;
-    unsigned           bs_num_env;
+    AAC_SIGNE          bs_num_env;
     uint8_t            bs_freq_res[7];
-    unsigned           bs_num_noise;
+    AAC_SIGNE          bs_num_noise;
     uint8_t            bs_df_env[5];
     uint8_t            bs_df_noise[2];
     uint8_t            bs_invf_mode[2][5];
@@ -77,24 +83,26 @@
      * @name State variables
      * @{
      */
-    DECLARE_ALIGNED(16, float, synthesis_filterbank_samples)[SBR_SYNTHESIS_BUF_SIZE];
-    DECLARE_ALIGNED(16, float, analysis_filterbank_samples) [1312];
+    DECLARE_ALIGNED(32, INTFLOAT, synthesis_filterbank_samples)[SBR_SYNTHESIS_BUF_SIZE];
+    DECLARE_ALIGNED(32, INTFLOAT, analysis_filterbank_samples) [1312];
     int                synthesis_filterbank_samples_offset;
     ///l_APrev and l_A
     int                e_a[2];
     ///Chirp factors
-    float              bw_array[5];
+    INTFLOAT              bw_array[5];
     ///QMF values of the original signal
-    float              W[2][32][32][2];
+    INTFLOAT              W[2][32][32][2];
+
+    int                Ypos;
     ///QMF output of the HF adjustor
-    float              Y[2][38][64][2];
-    float              g_temp[42][48];
-    float              q_temp[42][48];
+    DECLARE_ALIGNED(16, INTFLOAT, Y)[2][38][64][2];
+    DECLARE_ALIGNED(16, AAC_FLOAT, g_temp)[42][48];
+    AAC_FLOAT          q_temp[42][48];
     uint8_t            s_indexmapped[8][48];
     ///Envelope scalefactors
-    float              env_facs[6][48];
+    AAC_FLOAT              env_facs[6][48];
     ///Noise scalefactors
-    float              noise_facs[3][5];
+    AAC_FLOAT              noise_facs[3][5];
     ///Envelope time borders
     uint8_t            t_env[8];
     ///Envelope time border of the last envelope of the previous frame
@@ -106,10 +114,11 @@
     /** @} */
 } SBRData;
 
+
 /**
  * Spectral Band Replication
  */
-typedef struct {
+typedef struct SpectralBandReplication {
     int                sample_rate;
     int                start;
     int                reset;
@@ -125,22 +134,23 @@
     unsigned           bs_smoothing_mode;
     /** @} */
     unsigned           bs_coupling;
-    unsigned           k[5]; ///< k0, k1, k2
+    AAC_SIGNE           k[5]; ///< k0, k1, k2
     ///kx', and kx respectively, kx is the first QMF subband where SBR is used.
     ///kx' is its value from the previous frame
-    unsigned           kx[2];
+    AAC_SIGNE           kx[2];
     ///M' and M respectively, M is the number of QMF subbands that use SBR.
-    unsigned           m[2];
+    AAC_SIGNE           m[2];
+    unsigned           kx_and_m_pushed;
     ///The number of frequency bands in f_master
-    unsigned           n_master;
+    AAC_SIGNE           n_master;
     SBRData            data[2];
     PSContext          ps;
     ///N_Low and N_High respectively, the number of frequency bands for low and high resolution
-    unsigned           n[2];
+    AAC_SIGNE           n[2];
     ///Number of noise floor bands
-    unsigned           n_q;
+    AAC_SIGNE           n_q;
     ///Number of limiter bands
-    unsigned           n_lim;
+    AAC_SIGNE           n_lim;
     ///The master QMF frequency grouping
     uint16_t           f_master[49];
     ///Frequency borders for low resolution SBR
@@ -150,36 +160,42 @@
     ///Frequency borders for noise floors
     uint16_t           f_tablenoise[6];
     ///Frequency borders for the limiter
-    uint16_t           f_tablelim[29];
-    unsigned           num_patches;
+    uint16_t           f_tablelim[30];
+    AAC_SIGNE          num_patches;
     uint8_t            patch_num_subbands[6];
     uint8_t            patch_start_subband[6];
     ///QMF low frequency input to the HF generator
-    float              X_low[32][40][2];
+    DECLARE_ALIGNED(16, INTFLOAT, X_low)[32][40][2];
     ///QMF output of the HF generator
-    float              X_high[64][40][2];
+    DECLARE_ALIGNED(16, INTFLOAT, X_high)[64][40][2];
     ///QMF values of the reconstructed signal
-    DECLARE_ALIGNED(16, float, X)[2][2][38][64];
+    DECLARE_ALIGNED(16, INTFLOAT, X)[2][2][38][64];
     ///Zeroth coefficient used to filter the subband signals
-    float              alpha0[64][2];
+    DECLARE_ALIGNED(16, INTFLOAT, alpha0)[64][2];
     ///First coefficient used to filter the subband signals
-    float              alpha1[64][2];
+    DECLARE_ALIGNED(16, INTFLOAT, alpha1)[64][2]; 
     ///Dequantized envelope scalefactors, remapped
-    float              e_origmapped[7][48];
+    AAC_FLOAT              e_origmapped[7][48];
     ///Dequantized noise scalefactors, remapped
-    float              q_mapped[7][48];
+    AAC_FLOAT              q_mapped[7][48];
     ///Sinusoidal presence, remapped
     uint8_t            s_mapped[7][48];
     ///Estimated envelope
-    float              e_curr[7][48];
+    AAC_FLOAT              e_curr[7][48];
     ///Amplitude adjusted noise scalefactors
-    float              q_m[7][48];
+    AAC_FLOAT              q_m[7][48];
     ///Sinusoidal levels
-    float              s_m[7][48];
-    float              gain[7][48];
-    DECLARE_ALIGNED(16, float, qmf_filter_scratch)[5][64];
+    AAC_FLOAT              s_m[7][48];
+    AAC_FLOAT              gain[7][48];
+    DECLARE_ALIGNED(32, INTFLOAT, qmf_filter_scratch)[5][64];
     FFTContext         mdct_ana;
     FFTContext         mdct;
+
+    //jh
+    SBRDSPContext      dsp;
 } SpectralBandReplication;
 
+
+
+
 #endif /* AVCODEC_SBR_H */
diff -uNr ffmpeg-0.7.12/libavcodec/sinewin.c ffmpeg-0.7.12-140902/libavcodec/sinewin.c
--- ffmpeg-0.7.12/libavcodec/sinewin.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sinewin.c	2014-09-02 15:51:06.000000000 +0800
@@ -15,6 +15,6 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-
+#define CONFIG_FIXED 0
 #include "sinewin.h"
 #include "sinewin_tablegen.h"
diff -uNr ffmpeg-0.7.12/libavcodec/sinewin_fixed.c ffmpeg-0.7.12-140902/libavcodec/sinewin_fixed.c
--- ffmpeg-0.7.12/libavcodec/sinewin_fixed.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sinewin_fixed.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,3 @@
+#define CONFIG_FIXED 1
+#include "sinewin.h"
+#include "sinewin_tablegen.h"
diff -uNr ffmpeg-0.7.12/libavcodec/sinewin_fixed_tablegen.c ffmpeg-0.7.12-140902/libavcodec/sinewin_fixed_tablegen.c
--- ffmpeg-0.7.12/libavcodec/sinewin_fixed_tablegen.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sinewin_fixed_tablegen.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,2 @@
+#define CONFIG_FIXED 1
+#include "sinewin_tablegen_template.c"
diff -uNr ffmpeg-0.7.12/libavcodec/sinewin.h ffmpeg-0.7.12-140902/libavcodec/sinewin.h
--- ffmpeg-0.7.12/libavcodec/sinewin.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sinewin.h	2013-10-31 11:10:02.000000000 +0800
@@ -30,20 +30,32 @@
 #   define SINETABLE_CONST
 #endif
 
+#ifndef CONFIG_FIXED
+#define CONFIG_FIXED 0
+#endif
+
+#if CONFIG_FIXED
+#define SINEWIN_SUFFIX(a) a ## _fixed
+#define INTFLOAT int
+#else
+#define SINEWIN_SUFFIX(a) a
+#define INTFLOAT float
+#endif
+
 #define SINETABLE(size) \
-    SINETABLE_CONST DECLARE_ALIGNED(16, float, ff_sine_##size)[size]
+    SINETABLE_CONST DECLARE_ALIGNED(32, INTFLOAT, SINEWIN_SUFFIX(ff_sine_##size))[size]
 
 /**
  * Generate a sine window.
  * @param   window  pointer to half window
  * @param   n       size of half window
  */
-void ff_sine_window_init(float *window, int n);
+void SINEWIN_SUFFIX(ff_sine_window_init)(INTFLOAT *window, int n);
 
 /**
  * initialize the specified entry of ff_sine_windows
  */
-void ff_init_ff_sine_windows(int index);
+void SINEWIN_SUFFIX(ff_init_ff_sine_windows)(int index);
 
 extern SINETABLE(  32);
 extern SINETABLE(  64);
@@ -54,6 +66,8 @@
 extern SINETABLE(2048);
 extern SINETABLE(4096);
 
-extern SINETABLE_CONST float * const ff_sine_windows[13];
+extern SINETABLE(8192);
+
+extern SINETABLE_CONST INTFLOAT * const SINEWIN_SUFFIX(ff_sine_windows)[14];//??
 
 #endif /* AVCODEC_SINEWIN_H */
diff -uNr ffmpeg-0.7.12/libavcodec/sinewin_tablegen.c ffmpeg-0.7.12-140902/libavcodec/sinewin_tablegen.c
--- ffmpeg-0.7.12/libavcodec/sinewin_tablegen.c	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sinewin_tablegen.c	2014-09-02 15:51:38.000000000 +0800
@@ -1,49 +1,11 @@
-/*
- * Generate a header file for hardcoded sine windows
- *
- * Copyright (c) 2009 Reimar Döffinger <Reimar.Doeffinger@gmx.de>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
 #include <stdlib.h>
 #define CONFIG_HARDCODED_TABLES 0
 #define SINETABLE_CONST
 #define SINETABLE(size) \
     float ff_sine_##size[size]
 #define FF_ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))
-#ifndef M_PI
-#define M_PI 3.14159265358979323846
-#endif
 #include "sinewin_tablegen.h"
 #include "tableprint.h"
 
-int main(void)
-{
-    int i;
-
-    write_fileheader();
-
-    for (i = 5; i <= 12; i++) {
-        ff_init_ff_sine_windows(i);
-        printf("SINETABLE(%4i) = {\n", 1 << i);
-        write_float_array(ff_sine_windows[i], 1 << i);
-        printf("};\n");
-    }
-
-    return 0;
-}
+#define CONFIG_FIXED 0                                                                                                                                   
+#include "sinewin_tablegen_template.c" 
diff -uNr ffmpeg-0.7.12/libavcodec/sinewin_tablegen.h ffmpeg-0.7.12-140902/libavcodec/sinewin_tablegen.h
--- ffmpeg-0.7.12/libavcodec/sinewin_tablegen.h	2012-01-27 06:15:59.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sinewin_tablegen.h	2013-10-31 11:10:02.000000000 +0800
@@ -38,27 +38,44 @@
 SINETABLE(1024);
 SINETABLE(2048);
 SINETABLE(4096);
+SINETABLE(8192);
 #else
-#include "libavcodec/sinewin_tables.h"
+#if CONFIG_FIXED
+#include "libavcodec/sinewin_fixed_tables.h"
+#else
+ #include "libavcodec/sinewin_tables.h"
+ #endif
+#endif
+
+
+#if CONFIG_FIXED
+#define SINEWIN_SUFFIX(a) a ## _fixed
+#define INTFLOAT int
+#define SIN_FIX(a) (int)floor((a) * 0x80000000 + 0.5)
+#else
+#define SINEWIN_SUFFIX(a) a
+#define INTFLOAT float
+#define SIN_FIX(a) a
 #endif
 
-SINETABLE_CONST float * const ff_sine_windows[] = {
+SINETABLE_CONST INTFLOAT * const SINEWIN_SUFFIX(ff_sine_windows)[] = {
     NULL, NULL, NULL, NULL, NULL, // unused
-    ff_sine_32 , ff_sine_64 ,
-    ff_sine_128, ff_sine_256, ff_sine_512, ff_sine_1024, ff_sine_2048, ff_sine_4096
+    SINEWIN_SUFFIX(ff_sine_32) , SINEWIN_SUFFIX(ff_sine_64), SINEWIN_SUFFIX(ff_sine_128),
+    SINEWIN_SUFFIX(ff_sine_256), SINEWIN_SUFFIX(ff_sine_512), SINEWIN_SUFFIX(ff_sine_1024),
+    SINEWIN_SUFFIX(ff_sine_2048), SINEWIN_SUFFIX(ff_sine_4096), SINEWIN_SUFFIX(ff_sine_8192)
 };
 
 // Generate a sine window.
-av_cold void ff_sine_window_init(float *window, int n) {
+av_cold void SINEWIN_SUFFIX(ff_sine_window_init)(INTFLOAT *window, int n) {
     int i;
     for(i = 0; i < n; i++)
-        window[i] = sinf((i + 0.5) * (M_PI / (2.0 * n)));
+        window[i] = SIN_FIX(sinf((i + 0.5) * (M_PI / (2.0 * n))));
 }
 
-av_cold void ff_init_ff_sine_windows(int index) {
-    assert(index >= 0 && index < FF_ARRAY_ELEMS(ff_sine_windows));
+av_cold void SINEWIN_SUFFIX(ff_init_ff_sine_windows)(int index) {
+    assert(index >= 0 && index < FF_ARRAY_ELEMS(SINEWIN_SUFFIX(ff_sine_windows)));
 #if !CONFIG_HARDCODED_TABLES
-    ff_sine_window_init(ff_sine_windows[index], 1 << index);
+    SINEWIN_SUFFIX(ff_sine_window_init)(SINEWIN_SUFFIX(ff_sine_windows)[index], 1 << index);
 #endif
 }
 
diff -uNr ffmpeg-0.7.12/libavcodec/sinewin_tablegen_template.c ffmpeg-0.7.12-140902/libavcodec/sinewin_tablegen_template.c
--- ffmpeg-0.7.12/libavcodec/sinewin_tablegen_template.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/sinewin_tablegen_template.c	2013-10-31 11:10:02.000000000 +0800
@@ -0,0 +1,38 @@
+#include <stdlib.h>
+#define CONFIG_HARDCODED_TABLES 0
+
+#if CONFIG_FIXED
+#define ADD_SUFFIX(a) a ## _fixed
+#define INTFLOAT int
+#define WRITE_FUNC write_int32_t_array
+
+#else
+
+#define ADD_SUFFIX(a) a
+#define INTFLOAT float
+#define WRITE_FUNC write_float_array
+
+#endif
+
+#define SINETABLE_CONST
+#define SINETABLE(size) \
+    INTFLOAT ADD_SUFFIX(ff_sine_##size)[size]
+#define FF_ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))
+#include "sinewin_tablegen.h"
+#include "tableprint.h"
+
+int main(void)
+{
+    int i;
+
+    write_fileheader();
+
+    for (i = 5; i <= 13; i++) {
+        ADD_SUFFIX(ff_init_ff_sine_windows)(i);
+        printf("SINETABLE(%4i) = {\n", 1 << i);
+        WRITE_FUNC(ADD_SUFFIX(ff_sine_windows)[i], 1 << i);
+        printf("};\n");
+    }
+
+    return 0;
+}
diff -uNr ffmpeg-0.7.12/libavcodec/tableprint.h ffmpeg-0.7.12-140902/libavcodec/tableprint.h
--- ffmpeg-0.7.12/libavcodec/tableprint.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/tableprint.h	2013-10-31 11:10:02.000000000 +0800
@@ -63,6 +63,7 @@
 void write_uint8_t_array    (const uint8_t  *, int);
 void write_uint16_t_array   (const uint16_t *, int);
 void write_uint32_t_array   (const uint32_t *, int);
+void write_int32_t_array    (const int32_t  *, int);
 void write_float_array      (const float    *, int);
 void write_int8_t_2d_array  (const void *, int, int);
 void write_uint8_t_2d_array (const void *, int, int);
@@ -94,6 +95,7 @@
 WRITE_1D_FUNC(uint8_t,  "0x%02"PRIx8, 15)
 WRITE_1D_FUNC(uint16_t, "0x%08"PRIx16, 7)
 WRITE_1D_FUNC(uint32_t, "0x%08"PRIx32, 7)
+WRITE_1D_FUNC(int32_t,  "0x%08"PRIx32, 7)
 WRITE_1D_FUNC(float,    "%.18e", 3)
 
 WRITE_2D_FUNC(int8_t)
diff -uNr ffmpeg-0.7.12/libavcodec/vorbis.c ffmpeg-0.7.12-140902/libavcodec/vorbis.c
--- ffmpeg-0.7.12/libavcodec/vorbis.c	2012-04-10 01:05:33.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/vorbis.c	2013-10-31 11:10:02.000000000 +0800
@@ -20,6 +20,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 1
+#define CONFIG_VORBIS_FIXED 1
+#define CONFIG_FIXED 1
+
 #define ALT_BITSTREAM_READER_LE
 #include "avcodec.h"
 #include "get_bits.h"
@@ -152,7 +157,7 @@
 
 static inline void render_line_unrolled(intptr_t x, int y, int x1,
                                         intptr_t sy, int ady, int adx,
-                                        float *buf)
+                                        INTFLOAT *buf)
 {
     int err = -adx;
     x -= x1 - 1;
@@ -164,16 +169,16 @@
             y   += sy;
             buf[x++] = ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)];
         }
-        buf[x] = ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)];
+        buf[x] = ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)];// av_log(NULL,AV_LOG_INFO,"%d:%d,y=%d/%d",x,buf[x],av_clip_uint8(y),ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)]);
     }
     if (x <= 0) {
         if (err + ady >= 0)
             y += sy;
-        buf[x] = ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)];
+        buf[x] = ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)]; //av_log(NULL,AV_LOG_INFO,"%d:%d,y=%d/%d",x,buf[x],av_clip_uint8(y),ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)]);
     }
 }
 
-static void render_line(int x0, int y0, int x1, int y1, float *buf)
+static void render_line(int x0, int y0, int x1, int y1, INTFLOAT *buf)
 {
     int dy  = y1 - y0;
     int adx = x1 - x0;
@@ -195,14 +200,17 @@
                 err -= adx;
                 y   += sy;
             }
-            buf[x] = ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)];
+            buf[x] = ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)];// av_log(NULL,AV_LOG_INFO,"=%d:%d,y=%d/%d",x,buf[x],av_clip_uint8(y),ff_vorbis_floor1_inverse_db_table[av_clip_uint8(y)]);
         }
     }
+int ii;
+/*for(ii = 0; ii < 100;ii++ )
+    av_log(NULL,AV_LOG_INFO,"%d,",buf[ii]);*/
 }
 
 void ff_vorbis_floor1_render_list(vorbis_floor1_entry * list, int values,
                                   uint16_t *y_list, int *flag,
-                                  int multiplier, float *out, int samples)
+                                  int multiplier, INTFLOAT *out, int samples)
 {
     int lx, ly, i;
     lx = 0;
@@ -213,7 +221,7 @@
             int x1 = list[pos].x;
             int y1 = y_list[pos] * multiplier;
             if (lx < samples)
-                render_line(lx, ly, FFMIN(x1,samples), y1, out);
+            { /*av_log(NULL,AV_LOG_INFO,"00%d,%d,%d,%d=\n",lx,ly,FFMIN(x1,samples),y1); */  render_line(lx, ly, FFMIN(x1,samples), y1, out);}
             lx = x1;
             ly = y1;
         }
@@ -221,5 +229,6 @@
             break;
     }
     if (lx < samples)
-        render_line(lx, ly, samples, ly, out);
+       { /*av_log(NULL,AV_LOG_INFO,"11%d,%d,%d,%d=\n",lx,ly,samples,ly); */render_line(lx, ly, samples, ly, out);}
+
 }
diff -uNr ffmpeg-0.7.12/libavcodec/vorbis_data.c ffmpeg-0.7.12-140902/libavcodec/vorbis_data.c
--- ffmpeg-0.7.12/libavcodec/vorbis_data.c	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/vorbis_data.c	2013-10-31 11:10:02.000000000 +0800
@@ -18,6 +18,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 1
+#define CONFIG_VORBIS_FIXED 1
+#define CONFIG_FIXED 1
+
 #include "dsputil.h"
 #include "vorbis.h"
 #include "libavutil/audioconvert.h"
@@ -56,2138 +61,2138 @@
     0
 };
 
-DECLARE_ALIGNED(16, static const float, vwin64)[32] = {
-    0.0009460463F, 0.0085006468F, 0.0235352254F, 0.0458950567F,
-    0.0753351908F, 0.1115073077F, 0.1539457973F, 0.2020557475F,
-    0.2551056759F, 0.3122276645F, 0.3724270287F, 0.4346027792F,
-    0.4975789974F, 0.5601459521F, 0.6211085051F, 0.6793382689F,
-    0.7338252629F, 0.7837245849F, 0.8283939355F, 0.8674186656F,
-    0.9006222429F, 0.9280614787F, 0.9500073081F, 0.9669131782F,
-    0.9793740220F, 0.9880792941F, 0.9937636139F, 0.9971582668F,
-    0.9989462667F, 0.9997230082F, 0.9999638688F, 0.9999995525F,
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin64)[32] = {
+    Q31(0.0009460463F),Q31(0.0085006468F),Q31(0.0235352254F),Q31(0.0458950567F),
+    Q31(0.0753351908F),Q31(0.1115073077F),Q31(0.1539457973F),Q31(0.2020557475F),
+    Q31(0.2551056759F),Q31(0.3122276645F),Q31(0.3724270287F),Q31(0.4346027792F),
+    Q31(0.4975789974F),Q31(0.5601459521F),Q31(0.6211085051F),Q31(0.6793382689F),
+    Q31(0.7338252629F),Q31(0.7837245849F),Q31(0.8283939355F),Q31(0.8674186656F),
+    Q31(0.9006222429F),Q31(0.9280614787F),Q31(0.9500073081F),Q31(0.9669131782F),
+    Q31(0.9793740220F),Q31(0.9880792941F),Q31(0.9937636139F),Q31(0.9971582668F),
+    Q31(0.9989462667F),Q31(0.9997230082F),Q31(0.9999638688F),Q31(0.9999995525F),
 };
 
-DECLARE_ALIGNED(16, static const float, vwin128)[64] = {
-    0.0002365472F, 0.0021280687F, 0.0059065254F, 0.0115626550F,
-    0.0190823442F, 0.0284463735F, 0.0396300935F, 0.0526030430F,
-    0.0673285281F, 0.0837631763F, 0.1018564887F, 0.1215504095F,
-    0.1427789367F, 0.1654677960F, 0.1895342001F, 0.2148867160F,
-    0.2414252576F, 0.2690412240F, 0.2976177952F, 0.3270303960F,
-    0.3571473350F, 0.3878306189F, 0.4189369387F, 0.4503188188F,
-    0.4818259135F, 0.5133064334F, 0.5446086751F, 0.5755826278F,
-    0.6060816248F, 0.6359640047F, 0.6650947483F, 0.6933470543F,
-    0.7206038179F, 0.7467589810F, 0.7717187213F, 0.7954024542F,
-    0.8177436264F, 0.8386902831F, 0.8582053981F, 0.8762669622F,
-    0.8928678298F, 0.9080153310F, 0.9217306608F, 0.9340480615F,
-    0.9450138200F, 0.9546851041F, 0.9631286621F, 0.9704194171F,
-    0.9766389810F, 0.9818741197F, 0.9862151938F, 0.9897546035F,
-    0.9925852598F, 0.9947991032F, 0.9964856900F, 0.9977308602F,
-    0.9986155015F, 0.9992144193F, 0.9995953200F, 0.9998179155F,
-    0.9999331503F, 0.9999825563F, 0.9999977357F, 0.9999999720F,
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin128)[64] = {
+    Q31(0.0002365472F),Q31(0.0021280687F),Q31(0.0059065254F),Q31(0.0115626550F),
+    Q31(0.0190823442F),Q31(0.0284463735F),Q31(0.0396300935F),Q31(0.0526030430F),
+    Q31(0.0673285281F),Q31(0.0837631763F),Q31(0.1018564887F),Q31(0.1215504095F),
+    Q31(0.1427789367F),Q31(0.1654677960F),Q31(0.1895342001F),Q31(0.2148867160F),
+    Q31(0.2414252576F),Q31(0.2690412240F),Q31(0.2976177952F),Q31(0.3270303960F),
+    Q31(0.3571473350F),Q31(0.3878306189F),Q31(0.4189369387F),Q31(0.4503188188F),
+    Q31(0.4818259135F),Q31(0.5133064334F),Q31(0.5446086751F),Q31(0.5755826278F),
+    Q31(0.6060816248F),Q31(0.6359640047F),Q31(0.6650947483F),Q31(0.6933470543F),
+    Q31(0.7206038179F),Q31(0.7467589810F),Q31(0.7717187213F),Q31(0.7954024542F),
+    Q31(0.8177436264F),Q31(0.8386902831F),Q31(0.8582053981F),Q31(0.8762669622F),
+    Q31(0.8928678298F),Q31(0.9080153310F),Q31(0.9217306608F),Q31(0.9340480615F),
+    Q31(0.9450138200F),Q31(0.9546851041F),Q31(0.9631286621F),Q31(0.9704194171F),
+    Q31(0.9766389810F),Q31(0.9818741197F),Q31(0.9862151938F),Q31(0.9897546035F),
+    Q31(0.9925852598F),Q31(0.9947991032F),Q31(0.9964856900F),Q31(0.9977308602F),
+    Q31(0.9986155015F),Q31(0.9992144193F),Q31(0.9995953200F),Q31(0.9998179155F),
+    Q31(0.9999331503F),Q31(0.9999825563F),Q31(0.9999977357F),Q31(0.9999999720F),
 };
 
-DECLARE_ALIGNED(16, static const float, vwin256)[128] = {
-    0.0000591390F, 0.0005321979F, 0.0014780301F, 0.0028960636F,
-    0.0047854363F, 0.0071449926F, 0.0099732775F, 0.0132685298F,
-    0.0170286741F, 0.0212513119F, 0.0259337111F, 0.0310727950F,
-    0.0366651302F, 0.0427069140F, 0.0491939614F, 0.0561216907F,
-    0.0634851102F, 0.0712788035F, 0.0794969160F, 0.0881331402F,
-    0.0971807028F, 0.1066323515F, 0.1164803426F, 0.1267164297F,
-    0.1373318534F, 0.1483173323F, 0.1596630553F, 0.1713586755F,
-    0.1833933062F, 0.1957555184F, 0.2084333404F, 0.2214142599F,
-    0.2346852280F, 0.2482326664F, 0.2620424757F, 0.2761000481F,
-    0.2903902813F, 0.3048975959F, 0.3196059553F, 0.3344988887F,
-    0.3495595160F, 0.3647705766F, 0.3801144597F, 0.3955732382F,
-    0.4111287047F, 0.4267624093F, 0.4424557009F, 0.4581897696F,
-    0.4739456913F, 0.4897044744F, 0.5054471075F, 0.5211546088F,
-    0.5368080763F, 0.5523887395F, 0.5678780103F, 0.5832575361F,
-    0.5985092508F, 0.6136154277F, 0.6285587300F, 0.6433222619F,
-    0.6578896175F, 0.6722449294F, 0.6863729144F, 0.7002589187F,
-    0.7138889597F, 0.7272497662F, 0.7403288154F, 0.7531143679F,
-    0.7655954985F, 0.7777621249F, 0.7896050322F, 0.8011158947F,
-    0.8122872932F, 0.8231127294F, 0.8335866365F, 0.8437043850F,
-    0.8534622861F, 0.8628575905F, 0.8718884835F, 0.8805540765F,
-    0.8888543947F, 0.8967903616F, 0.9043637797F, 0.9115773078F,
-    0.9184344360F, 0.9249394562F, 0.9310974312F, 0.9369141608F,
-    0.9423961446F, 0.9475505439F, 0.9523851406F, 0.9569082947F,
-    0.9611289005F, 0.9650563408F, 0.9687004405F, 0.9720714191F,
-    0.9751798427F, 0.9780365753F, 0.9806527301F, 0.9830396204F,
-    0.9852087111F, 0.9871715701F, 0.9889398207F, 0.9905250941F,
-    0.9919389832F, 0.9931929973F, 0.9942985174F, 0.9952667537F,
-    0.9961087037F, 0.9968351119F, 0.9974564312F, 0.9979827858F,
-    0.9984239359F, 0.9987892441F, 0.9990876435F, 0.9993276081F,
-    0.9995171241F, 0.9996636648F, 0.9997741654F, 0.9998550016F,
-    0.9999119692F, 0.9999502656F, 0.9999744742F, 0.9999885497F,
-    0.9999958064F, 0.9999989077F, 0.9999998584F, 0.9999999983F,
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin256)[128] = {
+    Q31(0.0000591390F),Q31(0.0005321979F),Q31(0.0014780301F),Q31(0.0028960636F),
+    Q31(0.0047854363F),Q31(0.0071449926F),Q31(0.0099732775F),Q31(0.0132685298F),
+    Q31(0.0170286741F),Q31(0.0212513119F),Q31(0.0259337111F),Q31(0.0310727950F),
+    Q31(0.0366651302F),Q31(0.0427069140F),Q31(0.0491939614F),Q31(0.0561216907F),
+    Q31(0.0634851102F),Q31(0.0712788035F),Q31(0.0794969160F),Q31(0.0881331402F),
+    Q31(0.0971807028F),Q31(0.1066323515F),Q31(0.1164803426F),Q31(0.1267164297F),
+    Q31(0.1373318534F),Q31(0.1483173323F),Q31(0.1596630553F),Q31(0.1713586755F),
+    Q31(0.1833933062F),Q31(0.1957555184F),Q31(0.2084333404F),Q31(0.2214142599F),
+    Q31(0.2346852280F),Q31(0.2482326664F),Q31(0.2620424757F),Q31(0.2761000481F),
+    Q31(0.2903902813F),Q31(0.3048975959F),Q31(0.3196059553F),Q31(0.3344988887F),
+    Q31(0.3495595160F),Q31(0.3647705766F),Q31(0.3801144597F),Q31(0.3955732382F),
+    Q31(0.4111287047F),Q31(0.4267624093F),Q31(0.4424557009F),Q31(0.4581897696F),
+    Q31(0.4739456913F),Q31(0.4897044744F),Q31(0.5054471075F),Q31(0.5211546088F),
+    Q31(0.5368080763F),Q31(0.5523887395F),Q31(0.5678780103F),Q31(0.5832575361F),
+    Q31(0.5985092508F),Q31(0.6136154277F),Q31(0.6285587300F),Q31(0.6433222619F),
+    Q31(0.6578896175F),Q31(0.6722449294F),Q31(0.6863729144F),Q31(0.7002589187F),
+    Q31(0.7138889597F),Q31(0.7272497662F),Q31(0.7403288154F),Q31(0.7531143679F),
+    Q31(0.7655954985F),Q31(0.7777621249F),Q31(0.7896050322F),Q31(0.8011158947F),
+    Q31(0.8122872932F),Q31(0.8231127294F),Q31(0.8335866365F),Q31(0.8437043850F),
+    Q31(0.8534622861F),Q31(0.8628575905F),Q31(0.8718884835F),Q31(0.8805540765F),
+    Q31(0.8888543947F),Q31(0.8967903616F),Q31(0.9043637797F),Q31(0.9115773078F),
+    Q31(0.9184344360F),Q31(0.9249394562F),Q31(0.9310974312F),Q31(0.9369141608F),
+    Q31(0.9423961446F),Q31(0.9475505439F),Q31(0.9523851406F),Q31(0.9569082947F),
+    Q31(0.9611289005F),Q31(0.9650563408F),Q31(0.9687004405F),Q31(0.9720714191F),
+    Q31(0.9751798427F),Q31(0.9780365753F),Q31(0.9806527301F),Q31(0.9830396204F),
+    Q31(0.9852087111F),Q31(0.9871715701F),Q31(0.9889398207F),Q31(0.9905250941F),
+    Q31(0.9919389832F),Q31(0.9931929973F),Q31(0.9942985174F),Q31(0.9952667537F),
+    Q31(0.9961087037F),Q31(0.9968351119F),Q31(0.9974564312F),Q31(0.9979827858F),
+    Q31(0.9984239359F),Q31(0.9987892441F),Q31(0.9990876435F),Q31(0.9993276081F),
+    Q31(0.9995171241F),Q31(0.9996636648F),Q31(0.9997741654F),Q31(0.9998550016F),
+    Q31(0.9999119692F),Q31(0.9999502656F),Q31(0.9999744742F),Q31(0.9999885497F),
+    Q31(0.9999958064F),Q31(0.9999989077F),Q31(0.9999998584F),Q31(0.9999999983F),
 };
 
-DECLARE_ALIGNED(16, static const float, vwin512)[256] = {
-    0.0000147849F, 0.0001330607F, 0.0003695946F, 0.0007243509F,
-    0.0011972759F, 0.0017882983F, 0.0024973285F, 0.0033242588F,
-    0.0042689632F, 0.0053312973F, 0.0065110982F, 0.0078081841F,
-    0.0092223540F, 0.0107533880F, 0.0124010466F, 0.0141650703F,
-    0.0160451800F, 0.0180410758F, 0.0201524373F, 0.0223789233F,
-    0.0247201710F, 0.0271757958F, 0.0297453914F, 0.0324285286F,
-    0.0352247556F, 0.0381335972F, 0.0411545545F, 0.0442871045F,
-    0.0475306997F, 0.0508847676F, 0.0543487103F, 0.0579219038F,
-    0.0616036982F, 0.0653934164F, 0.0692903546F, 0.0732937809F,
-    0.0774029356F, 0.0816170305F, 0.0859352485F, 0.0903567428F,
-    0.0948806375F, 0.0995060259F, 0.1042319712F, 0.1090575056F,
-    0.1139816300F, 0.1190033137F, 0.1241214941F, 0.1293350764F,
-    0.1346429333F, 0.1400439046F, 0.1455367974F, 0.1511203852F,
-    0.1567934083F, 0.1625545735F, 0.1684025537F, 0.1743359881F,
-    0.1803534820F, 0.1864536069F, 0.1926349000F, 0.1988958650F,
-    0.2052349715F, 0.2116506555F, 0.2181413191F, 0.2247053313F,
-    0.2313410275F, 0.2380467105F, 0.2448206500F, 0.2516610835F,
-    0.2585662164F, 0.2655342226F, 0.2725632448F, 0.2796513950F,
-    0.2867967551F, 0.2939973773F, 0.3012512852F, 0.3085564739F,
-    0.3159109111F, 0.3233125375F, 0.3307592680F, 0.3382489922F,
-    0.3457795756F, 0.3533488602F, 0.3609546657F, 0.3685947904F,
-    0.3762670121F, 0.3839690896F, 0.3916987634F, 0.3994537572F,
-    0.4072317788F, 0.4150305215F, 0.4228476653F, 0.4306808783F,
-    0.4385278181F, 0.4463861329F, 0.4542534630F, 0.4621274424F,
-    0.4700057001F, 0.4778858615F, 0.4857655502F, 0.4936423891F,
-    0.5015140023F, 0.5093780165F, 0.5172320626F, 0.5250737772F,
-    0.5329008043F, 0.5407107971F, 0.5485014192F, 0.5562703465F,
-    0.5640152688F, 0.5717338914F, 0.5794239366F, 0.5870831457F,
-    0.5947092801F, 0.6023001235F, 0.6098534829F, 0.6173671907F,
-    0.6248391059F, 0.6322671161F, 0.6396491384F, 0.6469831217F,
-    0.6542670475F, 0.6614989319F, 0.6686768267F, 0.6757988210F,
-    0.6828630426F, 0.6898676592F, 0.6968108799F, 0.7036909564F,
-    0.7105061843F, 0.7172549043F, 0.7239355032F, 0.7305464154F,
-    0.7370861235F, 0.7435531598F, 0.7499461068F, 0.7562635986F,
-    0.7625043214F, 0.7686670148F, 0.7747504721F, 0.7807535410F,
-    0.7866751247F, 0.7925141825F, 0.7982697296F, 0.8039408387F,
-    0.8095266395F, 0.8150263196F, 0.8204391248F, 0.8257643590F,
-    0.8310013848F, 0.8361496236F, 0.8412085555F, 0.8461777194F,
-    0.8510567129F, 0.8558451924F, 0.8605428730F, 0.8651495278F,
-    0.8696649882F, 0.8740891432F, 0.8784219392F, 0.8826633797F,
-    0.8868135244F, 0.8908724888F, 0.8948404441F, 0.8987176157F,
-    0.9025042831F, 0.9062007791F, 0.9098074886F, 0.9133248482F,
-    0.9167533451F, 0.9200935163F, 0.9233459472F, 0.9265112712F,
-    0.9295901680F, 0.9325833632F, 0.9354916263F, 0.9383157705F,
-    0.9410566504F, 0.9437151618F, 0.9462922398F, 0.9487888576F,
-    0.9512060252F, 0.9535447882F, 0.9558062262F, 0.9579914516F,
-    0.9601016078F, 0.9621378683F, 0.9641014348F, 0.9659935361F,
-    0.9678154261F, 0.9695683830F, 0.9712537071F, 0.9728727198F,
-    0.9744267618F, 0.9759171916F, 0.9773453842F, 0.9787127293F,
-    0.9800206298F, 0.9812705006F, 0.9824637665F, 0.9836018613F,
-    0.9846862258F, 0.9857183066F, 0.9866995544F, 0.9876314227F,
-    0.9885153662F, 0.9893528393F, 0.9901452948F, 0.9908941823F,
-    0.9916009470F, 0.9922670279F, 0.9928938570F, 0.9934828574F,
-    0.9940354423F, 0.9945530133F, 0.9950369595F, 0.9954886562F,
-    0.9959094633F, 0.9963007242F, 0.9966637649F, 0.9969998925F,
-    0.9973103939F, 0.9975965351F, 0.9978595598F, 0.9981006885F,
-    0.9983211172F, 0.9985220166F, 0.9987045311F, 0.9988697776F,
-    0.9990188449F, 0.9991527924F, 0.9992726499F, 0.9993794157F,
-    0.9994740570F, 0.9995575079F, 0.9996306699F, 0.9996944099F,
-    0.9997495605F, 0.9997969190F, 0.9998372465F, 0.9998712678F,
-    0.9998996704F, 0.9999231041F, 0.9999421807F, 0.9999574732F,
-    0.9999695157F, 0.9999788026F, 0.9999857885F, 0.9999908879F,
-    0.9999944746F, 0.9999968817F, 0.9999984010F, 0.9999992833F,
-    0.9999997377F, 0.9999999317F, 0.9999999911F, 0.9999999999F,
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin512)[256] = {
+    Q31(0.0000147849F),Q31(0.0001330607F),Q31(0.0003695946F),Q31(0.0007243509F),
+    Q31(0.0011972759F),Q31(0.0017882983F),Q31(0.0024973285F),Q31(0.0033242588F),
+    Q31(0.0042689632F),Q31(0.0053312973F),Q31(0.0065110982F),Q31(0.0078081841F),
+    Q31(0.0092223540F),Q31(0.0107533880F),Q31(0.0124010466F),Q31(0.0141650703F),
+    Q31(0.0160451800F),Q31(0.0180410758F),Q31(0.0201524373F),Q31(0.0223789233F),
+    Q31(0.0247201710F),Q31(0.0271757958F),Q31(0.0297453914F),Q31(0.0324285286F),
+    Q31(0.0352247556F),Q31(0.0381335972F),Q31(0.0411545545F),Q31(0.0442871045F),
+    Q31(0.0475306997F),Q31(0.0508847676F),Q31(0.0543487103F),Q31(0.0579219038F),
+    Q31(0.0616036982F),Q31(0.0653934164F),Q31(0.0692903546F),Q31(0.0732937809F),
+    Q31(0.0774029356F),Q31(0.0816170305F),Q31(0.0859352485F),Q31(0.0903567428F),
+    Q31(0.0948806375F),Q31(0.0995060259F),Q31(0.1042319712F),Q31(0.1090575056F),
+    Q31(0.1139816300F),Q31(0.1190033137F),Q31(0.1241214941F),Q31(0.1293350764F),
+    Q31(0.1346429333F),Q31(0.1400439046F),Q31(0.1455367974F),Q31(0.1511203852F),
+    Q31(0.1567934083F),Q31(0.1625545735F),Q31(0.1684025537F),Q31(0.1743359881F),
+    Q31(0.1803534820F),Q31(0.1864536069F),Q31(0.1926349000F),Q31(0.1988958650F),
+    Q31(0.2052349715F),Q31(0.2116506555F),Q31(0.2181413191F),Q31(0.2247053313F),
+    Q31(0.2313410275F),Q31(0.2380467105F),Q31(0.2448206500F),Q31(0.2516610835F),
+    Q31(0.2585662164F),Q31(0.2655342226F),Q31(0.2725632448F),Q31(0.2796513950F),
+    Q31(0.2867967551F),Q31(0.2939973773F),Q31(0.3012512852F),Q31(0.3085564739F),
+    Q31(0.3159109111F),Q31(0.3233125375F),Q31(0.3307592680F),Q31(0.3382489922F),
+    Q31(0.3457795756F),Q31(0.3533488602F),Q31(0.3609546657F),Q31(0.3685947904F),
+    Q31(0.3762670121F),Q31(0.3839690896F),Q31(0.3916987634F),Q31(0.3994537572F),
+    Q31(0.4072317788F),Q31(0.4150305215F),Q31(0.4228476653F),Q31(0.4306808783F),
+    Q31(0.4385278181F),Q31(0.4463861329F),Q31(0.4542534630F),Q31(0.4621274424F),
+    Q31(0.4700057001F),Q31(0.4778858615F),Q31(0.4857655502F),Q31(0.4936423891F),
+    Q31(0.5015140023F),Q31(0.5093780165F),Q31(0.5172320626F),Q31(0.5250737772F),
+    Q31(0.5329008043F),Q31(0.5407107971F),Q31(0.5485014192F),Q31(0.5562703465F),
+    Q31(0.5640152688F),Q31(0.5717338914F),Q31(0.5794239366F),Q31(0.5870831457F),
+    Q31(0.5947092801F),Q31(0.6023001235F),Q31(0.6098534829F),Q31(0.6173671907F),
+    Q31(0.6248391059F),Q31(0.6322671161F),Q31(0.6396491384F),Q31(0.6469831217F),
+    Q31(0.6542670475F),Q31(0.6614989319F),Q31(0.6686768267F),Q31(0.6757988210F),
+    Q31(0.6828630426F),Q31(0.6898676592F),Q31(0.6968108799F),Q31(0.7036909564F),
+    Q31(0.7105061843F),Q31(0.7172549043F),Q31(0.7239355032F),Q31(0.7305464154F),
+    Q31(0.7370861235F),Q31(0.7435531598F),Q31(0.7499461068F),Q31(0.7562635986F),
+    Q31(0.7625043214F),Q31(0.7686670148F),Q31(0.7747504721F),Q31(0.7807535410F),
+    Q31(0.7866751247F),Q31(0.7925141825F),Q31(0.7982697296F),Q31(0.8039408387F),
+    Q31(0.8095266395F),Q31(0.8150263196F),Q31(0.8204391248F),Q31(0.8257643590F),
+    Q31(0.8310013848F),Q31(0.8361496236F),Q31(0.8412085555F),Q31(0.8461777194F),
+    Q31(0.8510567129F),Q31(0.8558451924F),Q31(0.8605428730F),Q31(0.8651495278F),
+    Q31(0.8696649882F),Q31(0.8740891432F),Q31(0.8784219392F),Q31(0.8826633797F),
+    Q31(0.8868135244F),Q31(0.8908724888F),Q31(0.8948404441F),Q31(0.8987176157F),
+    Q31(0.9025042831F),Q31(0.9062007791F),Q31(0.9098074886F),Q31(0.9133248482F),
+    Q31(0.9167533451F),Q31(0.9200935163F),Q31(0.9233459472F),Q31(0.9265112712F),
+    Q31(0.9295901680F),Q31(0.9325833632F),Q31(0.9354916263F),Q31(0.9383157705F),
+    Q31(0.9410566504F),Q31(0.9437151618F),Q31(0.9462922398F),Q31(0.9487888576F),
+    Q31(0.9512060252F),Q31(0.9535447882F),Q31(0.9558062262F),Q31(0.9579914516F),
+    Q31(0.9601016078F),Q31(0.9621378683F),Q31(0.9641014348F),Q31(0.9659935361F),
+    Q31(0.9678154261F),Q31(0.9695683830F),Q31(0.9712537071F),Q31(0.9728727198F),
+    Q31(0.9744267618F),Q31(0.9759171916F),Q31(0.9773453842F),Q31(0.9787127293F),
+    Q31(0.9800206298F),Q31(0.9812705006F),Q31(0.9824637665F),Q31(0.9836018613F),
+    Q31(0.9846862258F),Q31(0.9857183066F),Q31(0.9866995544F),Q31(0.9876314227F),
+    Q31(0.9885153662F),Q31(0.9893528393F),Q31(0.9901452948F),Q31(0.9908941823F),
+    Q31(0.9916009470F),Q31(0.9922670279F),Q31(0.9928938570F),Q31(0.9934828574F),
+    Q31(0.9940354423F),Q31(0.9945530133F),Q31(0.9950369595F),Q31(0.9954886562F),
+    Q31(0.9959094633F),Q31(0.9963007242F),Q31(0.9966637649F),Q31(0.9969998925F),
+    Q31(0.9973103939F),Q31(0.9975965351F),Q31(0.9978595598F),Q31(0.9981006885F),
+    Q31(0.9983211172F),Q31(0.9985220166F),Q31(0.9987045311F),Q31(0.9988697776F),
+    Q31(0.9990188449F),Q31(0.9991527924F),Q31(0.9992726499F),Q31(0.9993794157F),
+    Q31(0.9994740570F),Q31(0.9995575079F),Q31(0.9996306699F),Q31(0.9996944099F),
+    Q31(0.9997495605F),Q31(0.9997969190F),Q31(0.9998372465F),Q31(0.9998712678F),
+    Q31(0.9998996704F),Q31(0.9999231041F),Q31(0.9999421807F),Q31(0.9999574732F),
+    Q31(0.9999695157F),Q31(0.9999788026F),Q31(0.9999857885F),Q31(0.9999908879F),
+    Q31(0.9999944746F),Q31(0.9999968817F),Q31(0.9999984010F),Q31(0.9999992833F),
+    Q31(0.9999997377F),Q31(0.9999999317F),Q31(0.9999999911F),Q31(0.9999999999F),
 };
 
-DECLARE_ALIGNED(16, static const float, vwin1024)[512] = {
-    0.0000036962F, 0.0000332659F, 0.0000924041F, 0.0001811086F,
-    0.0002993761F, 0.0004472021F, 0.0006245811F, 0.0008315063F,
-    0.0010679699F, 0.0013339631F, 0.0016294757F, 0.0019544965F,
-    0.0023090133F, 0.0026930125F, 0.0031064797F, 0.0035493989F,
-    0.0040217533F, 0.0045235250F, 0.0050546946F, 0.0056152418F,
-    0.0062051451F, 0.0068243817F, 0.0074729278F, 0.0081507582F,
-    0.0088578466F, 0.0095941655F, 0.0103596863F, 0.0111543789F,
-    0.0119782122F, 0.0128311538F, 0.0137131701F, 0.0146242260F,
-    0.0155642855F, 0.0165333111F, 0.0175312640F, 0.0185581042F,
-    0.0196137903F, 0.0206982797F, 0.0218115284F, 0.0229534910F,
-    0.0241241208F, 0.0253233698F, 0.0265511886F, 0.0278075263F,
-    0.0290923308F, 0.0304055484F, 0.0317471241F, 0.0331170013F,
-    0.0345151222F, 0.0359414274F, 0.0373958560F, 0.0388783456F,
-    0.0403888325F, 0.0419272511F, 0.0434935347F, 0.0450876148F,
-    0.0467094213F, 0.0483588828F, 0.0500359261F, 0.0517404765F,
-    0.0534724575F, 0.0552317913F, 0.0570183983F, 0.0588321971F,
-    0.0606731048F, 0.0625410369F, 0.0644359070F, 0.0663576272F,
-    0.0683061077F, 0.0702812571F, 0.0722829821F, 0.0743111878F,
-    0.0763657775F, 0.0784466526F, 0.0805537129F, 0.0826868561F,
-    0.0848459782F, 0.0870309736F, 0.0892417345F, 0.0914781514F,
-    0.0937401128F, 0.0960275056F, 0.0983402145F, 0.1006781223F,
-    0.1030411101F, 0.1054290568F, 0.1078418397F, 0.1102793336F,
-    0.1127414119F, 0.1152279457F, 0.1177388042F, 0.1202738544F,
-    0.1228329618F, 0.1254159892F, 0.1280227980F, 0.1306532471F,
-    0.1333071937F, 0.1359844927F, 0.1386849970F, 0.1414085575F,
-    0.1441550230F, 0.1469242403F, 0.1497160539F, 0.1525303063F,
-    0.1553668381F, 0.1582254875F, 0.1611060909F, 0.1640084822F,
-    0.1669324936F, 0.1698779549F, 0.1728446939F, 0.1758325362F,
-    0.1788413055F, 0.1818708232F, 0.1849209084F, 0.1879913785F,
-    0.1910820485F, 0.1941927312F, 0.1973232376F, 0.2004733764F,
-    0.2036429541F, 0.2068317752F, 0.2100396421F, 0.2132663552F,
-    0.2165117125F, 0.2197755102F, 0.2230575422F, 0.2263576007F,
-    0.2296754753F, 0.2330109540F, 0.2363638225F, 0.2397338646F,
-    0.2431208619F, 0.2465245941F, 0.2499448389F, 0.2533813719F,
-    0.2568339669F, 0.2603023956F, 0.2637864277F, 0.2672858312F,
-    0.2708003718F, 0.2743298135F, 0.2778739186F, 0.2814324472F,
-    0.2850051576F, 0.2885918065F, 0.2921921485F, 0.2958059366F,
-    0.2994329219F, 0.3030728538F, 0.3067254799F, 0.3103905462F,
-    0.3140677969F, 0.3177569747F, 0.3214578205F, 0.3251700736F,
-    0.3288934718F, 0.3326277513F, 0.3363726468F, 0.3401278914F,
-    0.3438932168F, 0.3476683533F, 0.3514530297F, 0.3552469734F,
-    0.3590499106F, 0.3628615659F, 0.3666816630F, 0.3705099239F,
-    0.3743460698F, 0.3781898204F, 0.3820408945F, 0.3858990095F,
-    0.3897638820F, 0.3936352274F, 0.3975127601F, 0.4013961936F,
-    0.4052852405F, 0.4091796123F, 0.4130790198F, 0.4169831732F,
-    0.4208917815F, 0.4248045534F, 0.4287211965F, 0.4326414181F,
-    0.4365649248F, 0.4404914225F, 0.4444206167F, 0.4483522125F,
-    0.4522859146F, 0.4562214270F, 0.4601584538F, 0.4640966984F,
-    0.4680358644F, 0.4719756548F, 0.4759157726F, 0.4798559209F,
-    0.4837958024F, 0.4877351199F, 0.4916735765F, 0.4956108751F,
-    0.4995467188F, 0.5034808109F, 0.5074128550F, 0.5113425550F,
-    0.5152696149F, 0.5191937395F, 0.5231146336F, 0.5270320028F,
-    0.5309455530F, 0.5348549910F, 0.5387600239F, 0.5426603597F,
-    0.5465557070F, 0.5504457754F, 0.5543302752F, 0.5582089175F,
-    0.5620814145F, 0.5659474793F, 0.5698068262F, 0.5736591704F,
-    0.5775042283F, 0.5813417176F, 0.5851713571F, 0.5889928670F,
-    0.5928059689F, 0.5966103856F, 0.6004058415F, 0.6041920626F,
-    0.6079687761F, 0.6117357113F, 0.6154925986F, 0.6192391705F,
-    0.6229751612F, 0.6267003064F, 0.6304143441F, 0.6341170137F,
-    0.6378080569F, 0.6414872173F, 0.6451542405F, 0.6488088741F,
-    0.6524508681F, 0.6560799742F, 0.6596959469F, 0.6632985424F,
-    0.6668875197F, 0.6704626398F, 0.6740236662F, 0.6775703649F,
-    0.6811025043F, 0.6846198554F, 0.6881221916F, 0.6916092892F,
-    0.6950809269F, 0.6985368861F, 0.7019769510F, 0.7054009085F,
-    0.7088085484F, 0.7121996632F, 0.7155740484F, 0.7189315023F,
-    0.7222718263F, 0.7255948245F, 0.7289003043F, 0.7321880760F,
-    0.7354579530F, 0.7387097518F, 0.7419432921F, 0.7451583966F,
-    0.7483548915F, 0.7515326059F, 0.7546913723F, 0.7578310265F,
-    0.7609514077F, 0.7640523581F, 0.7671337237F, 0.7701953535F,
-    0.7732371001F, 0.7762588195F, 0.7792603711F, 0.7822416178F,
-    0.7852024259F, 0.7881426654F, 0.7910622097F, 0.7939609356F,
-    0.7968387237F, 0.7996954579F, 0.8025310261F, 0.8053453193F,
-    0.8081382324F, 0.8109096638F, 0.8136595156F, 0.8163876936F,
-    0.8190941071F, 0.8217786690F, 0.8244412960F, 0.8270819086F,
-    0.8297004305F, 0.8322967896F, 0.8348709171F, 0.8374227481F,
-    0.8399522213F, 0.8424592789F, 0.8449438672F, 0.8474059356F,
-    0.8498454378F, 0.8522623306F, 0.8546565748F, 0.8570281348F,
-    0.8593769787F, 0.8617030779F, 0.8640064080F, 0.8662869477F,
-    0.8685446796F, 0.8707795899F, 0.8729916682F, 0.8751809079F,
-    0.8773473059F, 0.8794908626F, 0.8816115819F, 0.8837094713F,
-    0.8857845418F, 0.8878368079F, 0.8898662874F, 0.8918730019F,
-    0.8938569760F, 0.8958182380F, 0.8977568194F, 0.8996727552F,
-    0.9015660837F, 0.9034368465F, 0.9052850885F, 0.9071108577F,
-    0.9089142057F, 0.9106951869F, 0.9124538591F, 0.9141902832F,
-    0.9159045233F, 0.9175966464F, 0.9192667228F, 0.9209148257F,
-    0.9225410313F, 0.9241454187F, 0.9257280701F, 0.9272890704F,
-    0.9288285075F, 0.9303464720F, 0.9318430576F, 0.9333183603F,
-    0.9347724792F, 0.9362055158F, 0.9376175745F, 0.9390087622F,
-    0.9403791881F, 0.9417289644F, 0.9430582055F, 0.9443670283F,
-    0.9456555521F, 0.9469238986F, 0.9481721917F, 0.9494005577F,
-    0.9506091252F, 0.9517980248F, 0.9529673894F, 0.9541173540F,
-    0.9552480557F, 0.9563596334F, 0.9574522282F, 0.9585259830F,
-    0.9595810428F, 0.9606175542F, 0.9616356656F, 0.9626355274F,
-    0.9636172915F, 0.9645811114F, 0.9655271425F, 0.9664555414F,
-    0.9673664664F, 0.9682600774F, 0.9691365355F, 0.9699960034F,
-    0.9708386448F, 0.9716646250F, 0.9724741103F, 0.9732672685F,
-    0.9740442683F, 0.9748052795F, 0.9755504729F, 0.9762800205F,
-    0.9769940950F, 0.9776928703F, 0.9783765210F, 0.9790452223F,
-    0.9796991504F, 0.9803384823F, 0.9809633954F, 0.9815740679F,
-    0.9821706784F, 0.9827534063F, 0.9833224312F, 0.9838779332F,
-    0.9844200928F, 0.9849490910F, 0.9854651087F, 0.9859683274F,
-    0.9864589286F, 0.9869370940F, 0.9874030054F, 0.9878568447F,
-    0.9882987937F, 0.9887290343F, 0.9891477481F, 0.9895551169F,
-    0.9899513220F, 0.9903365446F, 0.9907109658F, 0.9910747662F,
-    0.9914281260F, 0.9917712252F, 0.9921042433F, 0.9924273593F,
-    0.9927407516F, 0.9930445982F, 0.9933390763F, 0.9936243626F,
-    0.9939006331F, 0.9941680631F, 0.9944268269F, 0.9946770982F,
-    0.9949190498F, 0.9951528537F, 0.9953786808F, 0.9955967011F,
-    0.9958070836F, 0.9960099963F, 0.9962056061F, 0.9963940787F,
-    0.9965755786F, 0.9967502693F, 0.9969183129F, 0.9970798704F,
-    0.9972351013F, 0.9973841640F, 0.9975272151F, 0.9976644103F,
-    0.9977959036F, 0.9979218476F, 0.9980423932F, 0.9981576901F,
-    0.9982678862F, 0.9983731278F, 0.9984735596F, 0.9985693247F,
-    0.9986605645F, 0.9987474186F, 0.9988300248F, 0.9989085193F,
-    0.9989830364F, 0.9990537085F, 0.9991206662F, 0.9991840382F,
-    0.9992439513F, 0.9993005303F, 0.9993538982F, 0.9994041757F,
-    0.9994514817F, 0.9994959330F, 0.9995376444F, 0.9995767286F,
-    0.9996132960F, 0.9996474550F, 0.9996793121F, 0.9997089710F,
-    0.9997365339F, 0.9997621003F, 0.9997857677F, 0.9998076311F,
-    0.9998277836F, 0.9998463156F, 0.9998633155F, 0.9998788692F,
-    0.9998930603F, 0.9999059701F, 0.9999176774F, 0.9999282586F,
-    0.9999377880F, 0.9999463370F, 0.9999539749F, 0.9999607685F,
-    0.9999667820F, 0.9999720773F, 0.9999767136F, 0.9999807479F,
-    0.9999842344F, 0.9999872249F, 0.9999897688F, 0.9999919127F,
-    0.9999937009F, 0.9999951749F, 0.9999963738F, 0.9999973342F,
-    0.9999980900F, 0.9999986724F, 0.9999991103F, 0.9999994297F,
-    0.9999996543F, 0.9999998049F, 0.9999999000F, 0.9999999552F,
-    0.9999999836F, 0.9999999957F, 0.9999999994F, 1.0000000000F,
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin1024)[512] = {
+    Q31(0.0000036962F),Q31(0.0000332659F),Q31(0.0000924041F),Q31(0.0001811086F),
+    Q31(0.0002993761F),Q31(0.0004472021F),Q31(0.0006245811F),Q31(0.0008315063F),
+    Q31(0.0010679699F),Q31(0.0013339631F),Q31(0.0016294757F),Q31(0.0019544965F),
+    Q31(0.0023090133F),Q31(0.0026930125F),Q31(0.0031064797F),Q31(0.0035493989F),
+    Q31(0.0040217533F),Q31(0.0045235250F),Q31(0.0050546946F),Q31(0.0056152418F),
+    Q31(0.0062051451F),Q31(0.0068243817F),Q31(0.0074729278F),Q31(0.0081507582F),
+    Q31(0.0088578466F),Q31(0.0095941655F),Q31(0.0103596863F),Q31(0.0111543789F),
+    Q31(0.0119782122F),Q31(0.0128311538F),Q31(0.0137131701F),Q31(0.0146242260F),
+    Q31(0.0155642855F),Q31(0.0165333111F),Q31(0.0175312640F),Q31(0.0185581042F),
+    Q31(0.0196137903F),Q31(0.0206982797F),Q31(0.0218115284F),Q31(0.0229534910F),
+    Q31(0.0241241208F),Q31(0.0253233698F),Q31(0.0265511886F),Q31(0.0278075263F),
+    Q31(0.0290923308F),Q31(0.0304055484F),Q31(0.0317471241F),Q31(0.0331170013F),
+    Q31(0.0345151222F),Q31(0.0359414274F),Q31(0.0373958560F),Q31(0.0388783456F),
+    Q31(0.0403888325F),Q31(0.0419272511F),Q31(0.0434935347F),Q31(0.0450876148F),
+    Q31(0.0467094213F),Q31(0.0483588828F),Q31(0.0500359261F),Q31(0.0517404765F),
+    Q31(0.0534724575F),Q31(0.0552317913F),Q31(0.0570183983F),Q31(0.0588321971F),
+    Q31(0.0606731048F),Q31(0.0625410369F),Q31(0.0644359070F),Q31(0.0663576272F),
+    Q31(0.0683061077F),Q31(0.0702812571F),Q31(0.0722829821F),Q31(0.0743111878F),
+    Q31(0.0763657775F),Q31(0.0784466526F),Q31(0.0805537129F),Q31(0.0826868561F),
+    Q31(0.0848459782F),Q31(0.0870309736F),Q31(0.0892417345F),Q31(0.0914781514F),
+    Q31(0.0937401128F),Q31(0.0960275056F),Q31(0.0983402145F),Q31(0.1006781223F),
+    Q31(0.1030411101F),Q31(0.1054290568F),Q31(0.1078418397F),Q31(0.1102793336F),
+    Q31(0.1127414119F),Q31(0.1152279457F),Q31(0.1177388042F),Q31(0.1202738544F),
+    Q31(0.1228329618F),Q31(0.1254159892F),Q31(0.1280227980F),Q31(0.1306532471F),
+    Q31(0.1333071937F),Q31(0.1359844927F),Q31(0.1386849970F),Q31(0.1414085575F),
+    Q31(0.1441550230F),Q31(0.1469242403F),Q31(0.1497160539F),Q31(0.1525303063F),
+    Q31(0.1553668381F),Q31(0.1582254875F),Q31(0.1611060909F),Q31(0.1640084822F),
+    Q31(0.1669324936F),Q31(0.1698779549F),Q31(0.1728446939F),Q31(0.1758325362F),
+    Q31(0.1788413055F),Q31(0.1818708232F),Q31(0.1849209084F),Q31(0.1879913785F),
+    Q31(0.1910820485F),Q31(0.1941927312F),Q31(0.1973232376F),Q31(0.2004733764F),
+    Q31(0.2036429541F),Q31(0.2068317752F),Q31(0.2100396421F),Q31(0.2132663552F),
+    Q31(0.2165117125F),Q31(0.2197755102F),Q31(0.2230575422F),Q31(0.2263576007F),
+    Q31(0.2296754753F),Q31(0.2330109540F),Q31(0.2363638225F),Q31(0.2397338646F),
+    Q31(0.2431208619F),Q31(0.2465245941F),Q31(0.2499448389F),Q31(0.2533813719F),
+    Q31(0.2568339669F),Q31(0.2603023956F),Q31(0.2637864277F),Q31(0.2672858312F),
+    Q31(0.2708003718F),Q31(0.2743298135F),Q31(0.2778739186F),Q31(0.2814324472F),
+    Q31(0.2850051576F),Q31(0.2885918065F),Q31(0.2921921485F),Q31(0.2958059366F),
+    Q31(0.2994329219F),Q31(0.3030728538F),Q31(0.3067254799F),Q31(0.3103905462F),
+    Q31(0.3140677969F),Q31(0.3177569747F),Q31(0.3214578205F),Q31(0.3251700736F),
+    Q31(0.3288934718F),Q31(0.3326277513F),Q31(0.3363726468F),Q31(0.3401278914F),
+    Q31(0.3438932168F),Q31(0.3476683533F),Q31(0.3514530297F),Q31(0.3552469734F),
+    Q31(0.3590499106F),Q31(0.3628615659F),Q31(0.3666816630F),Q31(0.3705099239F),
+    Q31(0.3743460698F),Q31(0.3781898204F),Q31(0.3820408945F),Q31(0.3858990095F),
+    Q31(0.3897638820F),Q31(0.3936352274F),Q31(0.3975127601F),Q31(0.4013961936F),
+    Q31(0.4052852405F),Q31(0.4091796123F),Q31(0.4130790198F),Q31(0.4169831732F),
+    Q31(0.4208917815F),Q31(0.4248045534F),Q31(0.4287211965F),Q31(0.4326414181F),
+    Q31(0.4365649248F),Q31(0.4404914225F),Q31(0.4444206167F),Q31(0.4483522125F),
+    Q31(0.4522859146F),Q31(0.4562214270F),Q31(0.4601584538F),Q31(0.4640966984F),
+    Q31(0.4680358644F),Q31(0.4719756548F),Q31(0.4759157726F),Q31(0.4798559209F),
+    Q31(0.4837958024F),Q31(0.4877351199F),Q31(0.4916735765F),Q31(0.4956108751F),
+    Q31(0.4995467188F),Q31(0.5034808109F),Q31(0.5074128550F),Q31(0.5113425550F),
+    Q31(0.5152696149F),Q31(0.5191937395F),Q31(0.5231146336F),Q31(0.5270320028F),
+    Q31(0.5309455530F),Q31(0.5348549910F),Q31(0.5387600239F),Q31(0.5426603597F),
+    Q31(0.5465557070F),Q31(0.5504457754F),Q31(0.5543302752F),Q31(0.5582089175F),
+    Q31(0.5620814145F),Q31(0.5659474793F),Q31(0.5698068262F),Q31(0.5736591704F),
+    Q31(0.5775042283F),Q31(0.5813417176F),Q31(0.5851713571F),Q31(0.5889928670F),
+    Q31(0.5928059689F),Q31(0.5966103856F),Q31(0.6004058415F),Q31(0.6041920626F),
+    Q31(0.6079687761F),Q31(0.6117357113F),Q31(0.6154925986F),Q31(0.6192391705F),
+    Q31(0.6229751612F),Q31(0.6267003064F),Q31(0.6304143441F),Q31(0.6341170137F),
+    Q31(0.6378080569F),Q31(0.6414872173F),Q31(0.6451542405F),Q31(0.6488088741F),
+    Q31(0.6524508681F),Q31(0.6560799742F),Q31(0.6596959469F),Q31(0.6632985424F),
+    Q31(0.6668875197F),Q31(0.6704626398F),Q31(0.6740236662F),Q31(0.6775703649F),
+    Q31(0.6811025043F),Q31(0.6846198554F),Q31(0.6881221916F),Q31(0.6916092892F),
+    Q31(0.6950809269F),Q31(0.6985368861F),Q31(0.7019769510F),Q31(0.7054009085F),
+    Q31(0.7088085484F),Q31(0.7121996632F),Q31(0.7155740484F),Q31(0.7189315023F),
+    Q31(0.7222718263F),Q31(0.7255948245F),Q31(0.7289003043F),Q31(0.7321880760F),
+    Q31(0.7354579530F),Q31(0.7387097518F),Q31(0.7419432921F),Q31(0.7451583966F),
+    Q31(0.7483548915F),Q31(0.7515326059F),Q31(0.7546913723F),Q31(0.7578310265F),
+    Q31(0.7609514077F),Q31(0.7640523581F),Q31(0.7671337237F),Q31(0.7701953535F),
+    Q31(0.7732371001F),Q31(0.7762588195F),Q31(0.7792603711F),Q31(0.7822416178F),
+    Q31(0.7852024259F),Q31(0.7881426654F),Q31(0.7910622097F),Q31(0.7939609356F),
+    Q31(0.7968387237F),Q31(0.7996954579F),Q31(0.8025310261F),Q31(0.8053453193F),
+    Q31(0.8081382324F),Q31(0.8109096638F),Q31(0.8136595156F),Q31(0.8163876936F),
+    Q31(0.8190941071F),Q31(0.8217786690F),Q31(0.8244412960F),Q31(0.8270819086F),
+    Q31(0.8297004305F),Q31(0.8322967896F),Q31(0.8348709171F),Q31(0.8374227481F),
+    Q31(0.8399522213F),Q31(0.8424592789F),Q31(0.8449438672F),Q31(0.8474059356F),
+    Q31(0.8498454378F),Q31(0.8522623306F),Q31(0.8546565748F),Q31(0.8570281348F),
+    Q31(0.8593769787F),Q31(0.8617030779F),Q31(0.8640064080F),Q31(0.8662869477F),
+    Q31(0.8685446796F),Q31(0.8707795899F),Q31(0.8729916682F),Q31(0.8751809079F),
+    Q31(0.8773473059F),Q31(0.8794908626F),Q31(0.8816115819F),Q31(0.8837094713F),
+    Q31(0.8857845418F),Q31(0.8878368079F),Q31(0.8898662874F),Q31(0.8918730019F),
+    Q31(0.8938569760F),Q31(0.8958182380F),Q31(0.8977568194F),Q31(0.8996727552F),
+    Q31(0.9015660837F),Q31(0.9034368465F),Q31(0.9052850885F),Q31(0.9071108577F),
+    Q31(0.9089142057F),Q31(0.9106951869F),Q31(0.9124538591F),Q31(0.9141902832F),
+    Q31(0.9159045233F),Q31(0.9175966464F),Q31(0.9192667228F),Q31(0.9209148257F),
+    Q31(0.9225410313F),Q31(0.9241454187F),Q31(0.9257280701F),Q31(0.9272890704F),
+    Q31(0.9288285075F),Q31(0.9303464720F),Q31(0.9318430576F),Q31(0.9333183603F),
+    Q31(0.9347724792F),Q31(0.9362055158F),Q31(0.9376175745F),Q31(0.9390087622F),
+    Q31(0.9403791881F),Q31(0.9417289644F),Q31(0.9430582055F),Q31(0.9443670283F),
+    Q31(0.9456555521F),Q31(0.9469238986F),Q31(0.9481721917F),Q31(0.9494005577F),
+    Q31(0.9506091252F),Q31(0.9517980248F),Q31(0.9529673894F),Q31(0.9541173540F),
+    Q31(0.9552480557F),Q31(0.9563596334F),Q31(0.9574522282F),Q31(0.9585259830F),
+    Q31(0.9595810428F),Q31(0.9606175542F),Q31(0.9616356656F),Q31(0.9626355274F),
+    Q31(0.9636172915F),Q31(0.9645811114F),Q31(0.9655271425F),Q31(0.9664555414F),
+    Q31(0.9673664664F),Q31(0.9682600774F),Q31(0.9691365355F),Q31(0.9699960034F),
+    Q31(0.9708386448F),Q31(0.9716646250F),Q31(0.9724741103F),Q31(0.9732672685F),
+    Q31(0.9740442683F),Q31(0.9748052795F),Q31(0.9755504729F),Q31(0.9762800205F),
+    Q31(0.9769940950F),Q31(0.9776928703F),Q31(0.9783765210F),Q31(0.9790452223F),
+    Q31(0.9796991504F),Q31(0.9803384823F),Q31(0.9809633954F),Q31(0.9815740679F),
+    Q31(0.9821706784F),Q31(0.9827534063F),Q31(0.9833224312F),Q31(0.9838779332F),
+    Q31(0.9844200928F),Q31(0.9849490910F),Q31(0.9854651087F),Q31(0.9859683274F),
+    Q31(0.9864589286F),Q31(0.9869370940F),Q31(0.9874030054F),Q31(0.9878568447F),
+    Q31(0.9882987937F),Q31(0.9887290343F),Q31(0.9891477481F),Q31(0.9895551169F),
+    Q31(0.9899513220F),Q31(0.9903365446F),Q31(0.9907109658F),Q31(0.9910747662F),
+    Q31(0.9914281260F),Q31(0.9917712252F),Q31(0.9921042433F),Q31(0.9924273593F),
+    Q31(0.9927407516F),Q31(0.9930445982F),Q31(0.9933390763F),Q31(0.9936243626F),
+    Q31(0.9939006331F),Q31(0.9941680631F),Q31(0.9944268269F),Q31(0.9946770982F),
+    Q31(0.9949190498F),Q31(0.9951528537F),Q31(0.9953786808F),Q31(0.9955967011F),
+    Q31(0.9958070836F),Q31(0.9960099963F),Q31(0.9962056061F),Q31(0.9963940787F),
+    Q31(0.9965755786F),Q31(0.9967502693F),Q31(0.9969183129F),Q31(0.9970798704F),
+    Q31(0.9972351013F),Q31(0.9973841640F),Q31(0.9975272151F),Q31(0.9976644103F),
+    Q31(0.9977959036F),Q31(0.9979218476F),Q31(0.9980423932F),Q31(0.9981576901F),
+    Q31(0.9982678862F),Q31(0.9983731278F),Q31(0.9984735596F),Q31(0.9985693247F),
+    Q31(0.9986605645F),Q31(0.9987474186F),Q31(0.9988300248F),Q31(0.9989085193F),
+    Q31(0.9989830364F),Q31(0.9990537085F),Q31(0.9991206662F),Q31(0.9991840382F),
+    Q31(0.9992439513F),Q31(0.9993005303F),Q31(0.9993538982F),Q31(0.9994041757F),
+    Q31(0.9994514817F),Q31(0.9994959330F),Q31(0.9995376444F),Q31(0.9995767286F),
+    Q31(0.9996132960F),Q31(0.9996474550F),Q31(0.9996793121F),Q31(0.9997089710F),
+    Q31(0.9997365339F),Q31(0.9997621003F),Q31(0.9997857677F),Q31(0.9998076311F),
+    Q31(0.9998277836F),Q31(0.9998463156F),Q31(0.9998633155F),Q31(0.9998788692F),
+    Q31(0.9998930603F),Q31(0.9999059701F),Q31(0.9999176774F),Q31(0.9999282586F),
+    Q31(0.9999377880F),Q31(0.9999463370F),Q31(0.9999539749F),Q31(0.9999607685F),
+    Q31(0.9999667820F),Q31(0.9999720773F),Q31(0.9999767136F),Q31(0.9999807479F),
+    Q31(0.9999842344F),Q31(0.9999872249F),Q31(0.9999897688F),Q31(0.9999919127F),
+    Q31(0.9999937009F),Q31(0.9999951749F),Q31(0.9999963738F),Q31(0.9999973342F),
+    Q31(0.9999980900F),Q31(0.9999986724F),Q31(0.9999991103F),Q31(0.9999994297F),
+    Q31(0.9999996543F),Q31(0.9999998049F),Q31(0.9999999000F),Q31(0.9999999552F),
+    Q31(0.9999999836F),Q31(0.9999999957F),Q31(0.9999999994F),Q31(1.0000000000F),
 };
 
-DECLARE_ALIGNED(16, static const float, vwin2048)[1024] = {
-    0.0000009241F, 0.0000083165F, 0.0000231014F, 0.0000452785F,
-    0.0000748476F, 0.0001118085F, 0.0001561608F, 0.0002079041F,
-    0.0002670379F, 0.0003335617F, 0.0004074748F, 0.0004887765F,
-    0.0005774661F, 0.0006735427F, 0.0007770054F, 0.0008878533F,
-    0.0010060853F, 0.0011317002F, 0.0012646969F, 0.0014050742F,
-    0.0015528307F, 0.0017079650F, 0.0018704756F, 0.0020403610F,
-    0.0022176196F, 0.0024022497F, 0.0025942495F, 0.0027936173F,
-    0.0030003511F, 0.0032144490F, 0.0034359088F, 0.0036647286F,
-    0.0039009061F, 0.0041444391F, 0.0043953253F, 0.0046535621F,
-    0.0049191472F, 0.0051920781F, 0.0054723520F, 0.0057599664F,
-    0.0060549184F, 0.0063572052F, 0.0066668239F, 0.0069837715F,
-    0.0073080449F, 0.0076396410F, 0.0079785566F, 0.0083247884F,
-    0.0086783330F, 0.0090391871F, 0.0094073470F, 0.0097828092F,
-    0.0101655700F, 0.0105556258F, 0.0109529726F, 0.0113576065F,
-    0.0117695237F, 0.0121887200F, 0.0126151913F, 0.0130489335F,
-    0.0134899422F, 0.0139382130F, 0.0143937415F, 0.0148565233F,
-    0.0153265536F, 0.0158038279F, 0.0162883413F, 0.0167800889F,
-    0.0172790660F, 0.0177852675F, 0.0182986882F, 0.0188193231F,
-    0.0193471668F, 0.0198822141F, 0.0204244594F, 0.0209738974F,
-    0.0215305225F, 0.0220943289F, 0.0226653109F, 0.0232434627F,
-    0.0238287784F, 0.0244212519F, 0.0250208772F, 0.0256276481F,
-    0.0262415582F, 0.0268626014F, 0.0274907711F, 0.0281260608F,
-    0.0287684638F, 0.0294179736F, 0.0300745833F, 0.0307382859F,
-    0.0314090747F, 0.0320869424F, 0.0327718819F, 0.0334638860F,
-    0.0341629474F, 0.0348690586F, 0.0355822122F, 0.0363024004F,
-    0.0370296157F, 0.0377638502F, 0.0385050960F, 0.0392533451F,
-    0.0400085896F, 0.0407708211F, 0.0415400315F, 0.0423162123F,
-    0.0430993552F, 0.0438894515F, 0.0446864926F, 0.0454904698F,
-    0.0463013742F, 0.0471191969F, 0.0479439288F, 0.0487755607F,
-    0.0496140836F, 0.0504594879F, 0.0513117642F, 0.0521709031F,
-    0.0530368949F, 0.0539097297F, 0.0547893979F, 0.0556758894F,
-    0.0565691941F, 0.0574693019F, 0.0583762026F, 0.0592898858F,
-    0.0602103410F, 0.0611375576F, 0.0620715250F, 0.0630122324F,
-    0.0639596688F, 0.0649138234F, 0.0658746848F, 0.0668422421F,
-    0.0678164838F, 0.0687973985F, 0.0697849746F, 0.0707792005F,
-    0.0717800645F, 0.0727875547F, 0.0738016591F, 0.0748223656F,
-    0.0758496620F, 0.0768835359F, 0.0779239751F, 0.0789709668F,
-    0.0800244985F, 0.0810845574F, 0.0821511306F, 0.0832242052F,
-    0.0843037679F, 0.0853898056F, 0.0864823050F, 0.0875812525F,
-    0.0886866347F, 0.0897984378F, 0.0909166480F, 0.0920412513F,
-    0.0931722338F, 0.0943095813F, 0.0954532795F, 0.0966033140F,
-    0.0977596702F, 0.0989223336F, 0.1000912894F, 0.1012665227F,
-    0.1024480185F, 0.1036357616F, 0.1048297369F, 0.1060299290F,
-    0.1072363224F, 0.1084489014F, 0.1096676504F, 0.1108925534F,
-    0.1121235946F, 0.1133607577F, 0.1146040267F, 0.1158533850F,
-    0.1171088163F, 0.1183703040F, 0.1196378312F, 0.1209113812F,
-    0.1221909370F, 0.1234764815F, 0.1247679974F, 0.1260654674F,
-    0.1273688740F, 0.1286781995F, 0.1299934263F, 0.1313145365F,
-    0.1326415121F, 0.1339743349F, 0.1353129866F, 0.1366574490F,
-    0.1380077035F, 0.1393637315F, 0.1407255141F, 0.1420930325F,
-    0.1434662677F, 0.1448452004F, 0.1462298115F, 0.1476200814F,
-    0.1490159906F, 0.1504175195F, 0.1518246482F, 0.1532373569F,
-    0.1546556253F, 0.1560794333F, 0.1575087606F, 0.1589435866F,
-    0.1603838909F, 0.1618296526F, 0.1632808509F, 0.1647374648F,
-    0.1661994731F, 0.1676668546F, 0.1691395880F, 0.1706176516F,
-    0.1721010238F, 0.1735896829F, 0.1750836068F, 0.1765827736F,
-    0.1780871610F, 0.1795967468F, 0.1811115084F, 0.1826314234F,
-    0.1841564689F, 0.1856866221F, 0.1872218600F, 0.1887621595F,
-    0.1903074974F, 0.1918578503F, 0.1934131947F, 0.1949735068F,
-    0.1965387630F, 0.1981089393F, 0.1996840117F, 0.2012639560F,
-    0.2028487479F, 0.2044383630F, 0.2060327766F, 0.2076319642F,
-    0.2092359007F, 0.2108445614F, 0.2124579211F, 0.2140759545F,
-    0.2156986364F, 0.2173259411F, 0.2189578432F, 0.2205943168F,
-    0.2222353361F, 0.2238808751F, 0.2255309076F, 0.2271854073F,
-    0.2288443480F, 0.2305077030F, 0.2321754457F, 0.2338475493F,
-    0.2355239869F, 0.2372047315F, 0.2388897560F, 0.2405790329F,
-    0.2422725350F, 0.2439702347F, 0.2456721043F, 0.2473781159F,
-    0.2490882418F, 0.2508024539F, 0.2525207240F, 0.2542430237F,
-    0.2559693248F, 0.2576995986F, 0.2594338166F, 0.2611719498F,
-    0.2629139695F, 0.2646598466F, 0.2664095520F, 0.2681630564F,
-    0.2699203304F, 0.2716813445F, 0.2734460691F, 0.2752144744F,
-    0.2769865307F, 0.2787622079F, 0.2805414760F, 0.2823243047F,
-    0.2841106637F, 0.2859005227F, 0.2876938509F, 0.2894906179F,
-    0.2912907928F, 0.2930943447F, 0.2949012426F, 0.2967114554F,
-    0.2985249520F, 0.3003417009F, 0.3021616708F, 0.3039848301F,
-    0.3058111471F, 0.3076405901F, 0.3094731273F, 0.3113087266F,
-    0.3131473560F, 0.3149889833F, 0.3168335762F, 0.3186811024F,
-    0.3205315294F, 0.3223848245F, 0.3242409552F, 0.3260998886F,
-    0.3279615918F, 0.3298260319F, 0.3316931758F, 0.3335629903F,
-    0.3354354423F, 0.3373104982F, 0.3391881247F, 0.3410682882F,
-    0.3429509551F, 0.3448360917F, 0.3467236642F, 0.3486136387F,
-    0.3505059811F, 0.3524006575F, 0.3542976336F, 0.3561968753F,
-    0.3580983482F, 0.3600020179F, 0.3619078499F, 0.3638158096F,
-    0.3657258625F, 0.3676379737F, 0.3695521086F, 0.3714682321F,
-    0.3733863094F, 0.3753063055F, 0.3772281852F, 0.3791519134F,
-    0.3810774548F, 0.3830047742F, 0.3849338362F, 0.3868646053F,
-    0.3887970459F, 0.3907311227F, 0.3926667998F, 0.3946040417F,
-    0.3965428125F, 0.3984830765F, 0.4004247978F, 0.4023679403F,
-    0.4043124683F, 0.4062583455F, 0.4082055359F, 0.4101540034F,
-    0.4121037117F, 0.4140546246F, 0.4160067058F, 0.4179599190F,
-    0.4199142277F, 0.4218695956F, 0.4238259861F, 0.4257833627F,
-    0.4277416888F, 0.4297009279F, 0.4316610433F, 0.4336219983F,
-    0.4355837562F, 0.4375462803F, 0.4395095337F, 0.4414734797F,
-    0.4434380815F, 0.4454033021F, 0.4473691046F, 0.4493354521F,
-    0.4513023078F, 0.4532696345F, 0.4552373954F, 0.4572055533F,
-    0.4591740713F, 0.4611429123F, 0.4631120393F, 0.4650814151F,
-    0.4670510028F, 0.4690207650F, 0.4709906649F, 0.4729606651F,
-    0.4749307287F, 0.4769008185F, 0.4788708972F, 0.4808409279F,
-    0.4828108732F, 0.4847806962F, 0.4867503597F, 0.4887198264F,
-    0.4906890593F, 0.4926580213F, 0.4946266753F, 0.4965949840F,
-    0.4985629105F, 0.5005304176F, 0.5024974683F, 0.5044640255F,
-    0.5064300522F, 0.5083955114F, 0.5103603659F, 0.5123245790F,
-    0.5142881136F, 0.5162509328F, 0.5182129997F, 0.5201742774F,
-    0.5221347290F, 0.5240943178F, 0.5260530070F, 0.5280107598F,
-    0.5299675395F, 0.5319233095F, 0.5338780330F, 0.5358316736F,
-    0.5377841946F, 0.5397355596F, 0.5416857320F, 0.5436346755F,
-    0.5455823538F, 0.5475287304F, 0.5494737691F, 0.5514174337F,
-    0.5533596881F, 0.5553004962F, 0.5572398218F, 0.5591776291F,
-    0.5611138821F, 0.5630485449F, 0.5649815818F, 0.5669129570F,
-    0.5688426349F, 0.5707705799F, 0.5726967564F, 0.5746211290F,
-    0.5765436624F, 0.5784643212F, 0.5803830702F, 0.5822998743F,
-    0.5842146984F, 0.5861275076F, 0.5880382669F, 0.5899469416F,
-    0.5918534968F, 0.5937578981F, 0.5956601107F, 0.5975601004F,
-    0.5994578326F, 0.6013532732F, 0.6032463880F, 0.6051371429F,
-    0.6070255039F, 0.6089114372F, 0.6107949090F, 0.6126758856F,
-    0.6145543334F, 0.6164302191F, 0.6183035092F, 0.6201741706F,
-    0.6220421700F, 0.6239074745F, 0.6257700513F, 0.6276298674F,
-    0.6294868903F, 0.6313410873F, 0.6331924262F, 0.6350408745F,
-    0.6368864001F, 0.6387289710F, 0.6405685552F, 0.6424051209F,
-    0.6442386364F, 0.6460690702F, 0.6478963910F, 0.6497205673F,
-    0.6515415682F, 0.6533593625F, 0.6551739194F, 0.6569852082F,
-    0.6587931984F, 0.6605978593F, 0.6623991609F, 0.6641970728F,
-    0.6659915652F, 0.6677826081F, 0.6695701718F, 0.6713542268F,
-    0.6731347437F, 0.6749116932F, 0.6766850461F, 0.6784547736F,
-    0.6802208469F, 0.6819832374F, 0.6837419164F, 0.6854968559F,
-    0.6872480275F, 0.6889954034F, 0.6907389556F, 0.6924786566F,
-    0.6942144788F, 0.6959463950F, 0.6976743780F, 0.6993984008F,
-    0.7011184365F, 0.7028344587F, 0.7045464407F, 0.7062543564F,
-    0.7079581796F, 0.7096578844F, 0.7113534450F, 0.7130448359F,
-    0.7147320316F, 0.7164150070F, 0.7180937371F, 0.7197681970F,
-    0.7214383620F, 0.7231042077F, 0.7247657098F, 0.7264228443F,
-    0.7280755871F, 0.7297239147F, 0.7313678035F, 0.7330072301F,
-    0.7346421715F, 0.7362726046F, 0.7378985069F, 0.7395198556F,
-    0.7411366285F, 0.7427488034F, 0.7443563584F, 0.7459592717F,
-    0.7475575218F, 0.7491510873F, 0.7507399471F, 0.7523240803F,
-    0.7539034661F, 0.7554780839F, 0.7570479136F, 0.7586129349F,
-    0.7601731279F, 0.7617284730F, 0.7632789506F, 0.7648245416F,
-    0.7663652267F, 0.7679009872F, 0.7694318044F, 0.7709576599F,
-    0.7724785354F, 0.7739944130F, 0.7755052749F, 0.7770111035F,
-    0.7785118815F, 0.7800075916F, 0.7814982170F, 0.7829837410F,
-    0.7844641472F, 0.7859394191F, 0.7874095408F, 0.7888744965F,
-    0.7903342706F, 0.7917888476F, 0.7932382124F, 0.7946823501F,
-    0.7961212460F, 0.7975548855F, 0.7989832544F, 0.8004063386F,
-    0.8018241244F, 0.8032365981F, 0.8046437463F, 0.8060455560F,
-    0.8074420141F, 0.8088331080F, 0.8102188253F, 0.8115991536F,
-    0.8129740810F, 0.8143435957F, 0.8157076861F, 0.8170663409F,
-    0.8184195489F, 0.8197672994F, 0.8211095817F, 0.8224463853F,
-    0.8237777001F, 0.8251035161F, 0.8264238235F, 0.8277386129F,
-    0.8290478750F, 0.8303516008F, 0.8316497814F, 0.8329424083F,
-    0.8342294731F, 0.8355109677F, 0.8367868841F, 0.8380572148F,
-    0.8393219523F, 0.8405810893F, 0.8418346190F, 0.8430825345F,
-    0.8443248294F, 0.8455614974F, 0.8467925323F, 0.8480179285F,
-    0.8492376802F, 0.8504517822F, 0.8516602292F, 0.8528630164F,
-    0.8540601391F, 0.8552515928F, 0.8564373733F, 0.8576174766F,
-    0.8587918990F, 0.8599606368F, 0.8611236868F, 0.8622810460F,
-    0.8634327113F, 0.8645786802F, 0.8657189504F, 0.8668535195F,
-    0.8679823857F, 0.8691055472F, 0.8702230025F, 0.8713347503F,
-    0.8724407896F, 0.8735411194F, 0.8746357394F, 0.8757246489F,
-    0.8768078479F, 0.8778853364F, 0.8789571146F, 0.8800231832F,
-    0.8810835427F, 0.8821381942F, 0.8831871387F, 0.8842303777F,
-    0.8852679127F, 0.8862997456F, 0.8873258784F, 0.8883463132F,
-    0.8893610527F, 0.8903700994F, 0.8913734562F, 0.8923711263F,
-    0.8933631129F, 0.8943494196F, 0.8953300500F, 0.8963050083F,
-    0.8972742985F, 0.8982379249F, 0.8991958922F, 0.9001482052F,
-    0.9010948688F, 0.9020358883F, 0.9029712690F, 0.9039010165F,
-    0.9048251367F, 0.9057436357F, 0.9066565195F, 0.9075637946F,
-    0.9084654678F, 0.9093615456F, 0.9102520353F, 0.9111369440F,
-    0.9120162792F, 0.9128900484F, 0.9137582595F, 0.9146209204F,
-    0.9154780394F, 0.9163296248F, 0.9171756853F, 0.9180162296F,
-    0.9188512667F, 0.9196808057F, 0.9205048559F, 0.9213234270F,
-    0.9221365285F, 0.9229441704F, 0.9237463629F, 0.9245431160F,
-    0.9253344404F, 0.9261203465F, 0.9269008453F, 0.9276759477F,
-    0.9284456648F, 0.9292100080F, 0.9299689889F, 0.9307226190F,
-    0.9314709103F, 0.9322138747F, 0.9329515245F, 0.9336838721F,
-    0.9344109300F, 0.9351327108F, 0.9358492275F, 0.9365604931F,
-    0.9372665208F, 0.9379673239F, 0.9386629160F, 0.9393533107F,
-    0.9400385220F, 0.9407185637F, 0.9413934501F, 0.9420631954F,
-    0.9427278141F, 0.9433873208F, 0.9440417304F, 0.9446910576F,
-    0.9453353176F, 0.9459745255F, 0.9466086968F, 0.9472378469F,
-    0.9478619915F, 0.9484811463F, 0.9490953274F, 0.9497045506F,
-    0.9503088323F, 0.9509081888F, 0.9515026365F, 0.9520921921F,
-    0.9526768723F, 0.9532566940F, 0.9538316742F, 0.9544018300F,
-    0.9549671786F, 0.9555277375F, 0.9560835241F, 0.9566345562F,
-    0.9571808513F, 0.9577224275F, 0.9582593027F, 0.9587914949F,
-    0.9593190225F, 0.9598419038F, 0.9603601571F, 0.9608738012F,
-    0.9613828546F, 0.9618873361F, 0.9623872646F, 0.9628826591F,
-    0.9633735388F, 0.9638599227F, 0.9643418303F, 0.9648192808F,
-    0.9652922939F, 0.9657608890F, 0.9662250860F, 0.9666849046F,
-    0.9671403646F, 0.9675914861F, 0.9680382891F, 0.9684807937F,
-    0.9689190202F, 0.9693529890F, 0.9697827203F, 0.9702082347F,
-    0.9706295529F, 0.9710466953F, 0.9714596828F, 0.9718685362F,
-    0.9722732762F, 0.9726739240F, 0.9730705005F, 0.9734630267F,
-    0.9738515239F, 0.9742360134F, 0.9746165163F, 0.9749930540F,
-    0.9753656481F, 0.9757343198F, 0.9760990909F, 0.9764599829F,
-    0.9768170175F, 0.9771702164F, 0.9775196013F, 0.9778651941F,
-    0.9782070167F, 0.9785450909F, 0.9788794388F, 0.9792100824F,
-    0.9795370437F, 0.9798603449F, 0.9801800080F, 0.9804960554F,
-    0.9808085092F, 0.9811173916F, 0.9814227251F, 0.9817245318F,
-    0.9820228343F, 0.9823176549F, 0.9826090160F, 0.9828969402F,
-    0.9831814498F, 0.9834625674F, 0.9837403156F, 0.9840147169F,
-    0.9842857939F, 0.9845535692F, 0.9848180654F, 0.9850793052F,
-    0.9853373113F, 0.9855921062F, 0.9858437127F, 0.9860921535F,
-    0.9863374512F, 0.9865796287F, 0.9868187085F, 0.9870547136F,
-    0.9872876664F, 0.9875175899F, 0.9877445067F, 0.9879684396F,
-    0.9881894112F, 0.9884074444F, 0.9886225619F, 0.9888347863F,
-    0.9890441404F, 0.9892506468F, 0.9894543284F, 0.9896552077F,
-    0.9898533074F, 0.9900486502F, 0.9902412587F, 0.9904311555F,
-    0.9906183633F, 0.9908029045F, 0.9909848019F, 0.9911640779F,
-    0.9913407550F, 0.9915148557F, 0.9916864025F, 0.9918554179F,
-    0.9920219241F, 0.9921859437F, 0.9923474989F, 0.9925066120F,
-    0.9926633054F, 0.9928176012F, 0.9929695218F, 0.9931190891F,
-    0.9932663254F, 0.9934112527F, 0.9935538932F, 0.9936942686F,
-    0.9938324012F, 0.9939683126F, 0.9941020248F, 0.9942335597F,
-    0.9943629388F, 0.9944901841F, 0.9946153170F, 0.9947383593F,
-    0.9948593325F, 0.9949782579F, 0.9950951572F, 0.9952100516F,
-    0.9953229625F, 0.9954339111F, 0.9955429186F, 0.9956500062F,
-    0.9957551948F, 0.9958585056F, 0.9959599593F, 0.9960595769F,
-    0.9961573792F, 0.9962533869F, 0.9963476206F, 0.9964401009F,
-    0.9965308483F, 0.9966198833F, 0.9967072261F, 0.9967928971F,
-    0.9968769164F, 0.9969593041F, 0.9970400804F, 0.9971192651F,
-    0.9971968781F, 0.9972729391F, 0.9973474680F, 0.9974204842F,
-    0.9974920074F, 0.9975620569F, 0.9976306521F, 0.9976978122F,
-    0.9977635565F, 0.9978279039F, 0.9978908736F, 0.9979524842F,
-    0.9980127547F, 0.9980717037F, 0.9981293499F, 0.9981857116F,
-    0.9982408073F, 0.9982946554F, 0.9983472739F, 0.9983986810F,
-    0.9984488947F, 0.9984979328F, 0.9985458132F, 0.9985925534F,
-    0.9986381711F, 0.9986826838F, 0.9987261086F, 0.9987684630F,
-    0.9988097640F, 0.9988500286F, 0.9988892738F, 0.9989275163F,
-    0.9989647727F, 0.9990010597F, 0.9990363938F, 0.9990707911F,
-    0.9991042679F, 0.9991368404F, 0.9991685244F, 0.9991993358F,
-    0.9992292905F, 0.9992584038F, 0.9992866914F, 0.9993141686F,
-    0.9993408506F, 0.9993667526F, 0.9993918895F, 0.9994162761F,
-    0.9994399273F, 0.9994628576F, 0.9994850815F, 0.9995066133F,
-    0.9995274672F, 0.9995476574F, 0.9995671978F, 0.9995861021F,
-    0.9996043841F, 0.9996220573F, 0.9996391352F, 0.9996556310F,
-    0.9996715579F, 0.9996869288F, 0.9997017568F, 0.9997160543F,
-    0.9997298342F, 0.9997431088F, 0.9997558905F, 0.9997681914F,
-    0.9997800236F, 0.9997913990F, 0.9998023292F, 0.9998128261F,
-    0.9998229009F, 0.9998325650F, 0.9998418296F, 0.9998507058F,
-    0.9998592044F, 0.9998673362F, 0.9998751117F, 0.9998825415F,
-    0.9998896358F, 0.9998964047F, 0.9999028584F, 0.9999090066F,
-    0.9999148590F, 0.9999204253F, 0.9999257148F, 0.9999307368F,
-    0.9999355003F, 0.9999400144F, 0.9999442878F, 0.9999483293F,
-    0.9999521472F, 0.9999557499F, 0.9999591457F, 0.9999623426F,
-    0.9999653483F, 0.9999681708F, 0.9999708175F, 0.9999732959F,
-    0.9999756132F, 0.9999777765F, 0.9999797928F, 0.9999816688F,
-    0.9999834113F, 0.9999850266F, 0.9999865211F, 0.9999879009F,
-    0.9999891721F, 0.9999903405F, 0.9999914118F, 0.9999923914F,
-    0.9999932849F, 0.9999940972F, 0.9999948336F, 0.9999954989F,
-    0.9999960978F, 0.9999966349F, 0.9999971146F, 0.9999975411F,
-    0.9999979185F, 0.9999982507F, 0.9999985414F, 0.9999987944F,
-    0.9999990129F, 0.9999992003F, 0.9999993596F, 0.9999994939F,
-    0.9999996059F, 0.9999996981F, 0.9999997732F, 0.9999998333F,
-    0.9999998805F, 0.9999999170F, 0.9999999444F, 0.9999999643F,
-    0.9999999784F, 0.9999999878F, 0.9999999937F, 0.9999999972F,
-    0.9999999990F, 0.9999999997F, 1.0000000000F, 1.0000000000F,
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin2048)[1024] = {
+    Q31(0.0000009241F),Q31(0.0000083165F),Q31(0.0000231014F),Q31(0.0000452785F),
+    Q31(0.0000748476F),Q31(0.0001118085F),Q31(0.0001561608F),Q31(0.0002079041F),
+    Q31(0.0002670379F),Q31(0.0003335617F),Q31(0.0004074748F),Q31(0.0004887765F),
+    Q31(0.0005774661F),Q31(0.0006735427F),Q31(0.0007770054F),Q31(0.0008878533F),
+    Q31(0.0010060853F),Q31(0.0011317002F),Q31(0.0012646969F),Q31(0.0014050742F),
+    Q31(0.0015528307F),Q31(0.0017079650F),Q31(0.0018704756F),Q31(0.0020403610F),
+    Q31(0.0022176196F),Q31(0.0024022497F),Q31(0.0025942495F),Q31(0.0027936173F),
+    Q31(0.0030003511F),Q31(0.0032144490F),Q31(0.0034359088F),Q31(0.0036647286F),
+    Q31(0.0039009061F),Q31(0.0041444391F),Q31(0.0043953253F),Q31(0.0046535621F),
+    Q31(0.0049191472F),Q31(0.0051920781F),Q31(0.0054723520F),Q31(0.0057599664F),
+    Q31(0.0060549184F),Q31(0.0063572052F),Q31(0.0066668239F),Q31(0.0069837715F),
+    Q31(0.0073080449F),Q31(0.0076396410F),Q31(0.0079785566F),Q31(0.0083247884F),
+    Q31(0.0086783330F),Q31(0.0090391871F),Q31(0.0094073470F),Q31(0.0097828092F),
+    Q31(0.0101655700F),Q31(0.0105556258F),Q31(0.0109529726F),Q31(0.0113576065F),
+    Q31(0.0117695237F),Q31(0.0121887200F),Q31(0.0126151913F),Q31(0.0130489335F),
+    Q31(0.0134899422F),Q31(0.0139382130F),Q31(0.0143937415F),Q31(0.0148565233F),
+    Q31(0.0153265536F),Q31(0.0158038279F),Q31(0.0162883413F),Q31(0.0167800889F),
+    Q31(0.0172790660F),Q31(0.0177852675F),Q31(0.0182986882F),Q31(0.0188193231F),
+    Q31(0.0193471668F),Q31(0.0198822141F),Q31(0.0204244594F),Q31(0.0209738974F),
+    Q31(0.0215305225F),Q31(0.0220943289F),Q31(0.0226653109F),Q31(0.0232434627F),
+    Q31(0.0238287784F),Q31(0.0244212519F),Q31(0.0250208772F),Q31(0.0256276481F),
+    Q31(0.0262415582F),Q31(0.0268626014F),Q31(0.0274907711F),Q31(0.0281260608F),
+    Q31(0.0287684638F),Q31(0.0294179736F),Q31(0.0300745833F),Q31(0.0307382859F),
+    Q31(0.0314090747F),Q31(0.0320869424F),Q31(0.0327718819F),Q31(0.0334638860F),
+    Q31(0.0341629474F),Q31(0.0348690586F),Q31(0.0355822122F),Q31(0.0363024004F),
+    Q31(0.0370296157F),Q31(0.0377638502F),Q31(0.0385050960F),Q31(0.0392533451F),
+    Q31(0.0400085896F),Q31(0.0407708211F),Q31(0.0415400315F),Q31(0.0423162123F),
+    Q31(0.0430993552F),Q31(0.0438894515F),Q31(0.0446864926F),Q31(0.0454904698F),
+    Q31(0.0463013742F),Q31(0.0471191969F),Q31(0.0479439288F),Q31(0.0487755607F),
+    Q31(0.0496140836F),Q31(0.0504594879F),Q31(0.0513117642F),Q31(0.0521709031F),
+    Q31(0.0530368949F),Q31(0.0539097297F),Q31(0.0547893979F),Q31(0.0556758894F),
+    Q31(0.0565691941F),Q31(0.0574693019F),Q31(0.0583762026F),Q31(0.0592898858F),
+    Q31(0.0602103410F),Q31(0.0611375576F),Q31(0.0620715250F),Q31(0.0630122324F),
+    Q31(0.0639596688F),Q31(0.0649138234F),Q31(0.0658746848F),Q31(0.0668422421F),
+    Q31(0.0678164838F),Q31(0.0687973985F),Q31(0.0697849746F),Q31(0.0707792005F),
+    Q31(0.0717800645F),Q31(0.0727875547F),Q31(0.0738016591F),Q31(0.0748223656F),
+    Q31(0.0758496620F),Q31(0.0768835359F),Q31(0.0779239751F),Q31(0.0789709668F),
+    Q31(0.0800244985F),Q31(0.0810845574F),Q31(0.0821511306F),Q31(0.0832242052F),
+    Q31(0.0843037679F),Q31(0.0853898056F),Q31(0.0864823050F),Q31(0.0875812525F),
+    Q31(0.0886866347F),Q31(0.0897984378F),Q31(0.0909166480F),Q31(0.0920412513F),
+    Q31(0.0931722338F),Q31(0.0943095813F),Q31(0.0954532795F),Q31(0.0966033140F),
+    Q31(0.0977596702F),Q31(0.0989223336F),Q31(0.1000912894F),Q31(0.1012665227F),
+    Q31(0.1024480185F),Q31(0.1036357616F),Q31(0.1048297369F),Q31(0.1060299290F),
+    Q31(0.1072363224F),Q31(0.1084489014F),Q31(0.1096676504F),Q31(0.1108925534F),
+    Q31(0.1121235946F),Q31(0.1133607577F),Q31(0.1146040267F),Q31(0.1158533850F),
+    Q31(0.1171088163F),Q31(0.1183703040F),Q31(0.1196378312F),Q31(0.1209113812F),
+    Q31(0.1221909370F),Q31(0.1234764815F),Q31(0.1247679974F),Q31(0.1260654674F),
+    Q31(0.1273688740F),Q31(0.1286781995F),Q31(0.1299934263F),Q31(0.1313145365F),
+    Q31(0.1326415121F),Q31(0.1339743349F),Q31(0.1353129866F),Q31(0.1366574490F),
+    Q31(0.1380077035F),Q31(0.1393637315F),Q31(0.1407255141F),Q31(0.1420930325F),
+    Q31(0.1434662677F),Q31(0.1448452004F),Q31(0.1462298115F),Q31(0.1476200814F),
+    Q31(0.1490159906F),Q31(0.1504175195F),Q31(0.1518246482F),Q31(0.1532373569F),
+    Q31(0.1546556253F),Q31(0.1560794333F),Q31(0.1575087606F),Q31(0.1589435866F),
+    Q31(0.1603838909F),Q31(0.1618296526F),Q31(0.1632808509F),Q31(0.1647374648F),
+    Q31(0.1661994731F),Q31(0.1676668546F),Q31(0.1691395880F),Q31(0.1706176516F),
+    Q31(0.1721010238F),Q31(0.1735896829F),Q31(0.1750836068F),Q31(0.1765827736F),
+    Q31(0.1780871610F),Q31(0.1795967468F),Q31(0.1811115084F),Q31(0.1826314234F),
+    Q31(0.1841564689F),Q31(0.1856866221F),Q31(0.1872218600F),Q31(0.1887621595F),
+    Q31(0.1903074974F),Q31(0.1918578503F),Q31(0.1934131947F),Q31(0.1949735068F),
+    Q31(0.1965387630F),Q31(0.1981089393F),Q31(0.1996840117F),Q31(0.2012639560F),
+    Q31(0.2028487479F),Q31(0.2044383630F),Q31(0.2060327766F),Q31(0.2076319642F),
+    Q31(0.2092359007F),Q31(0.2108445614F),Q31(0.2124579211F),Q31(0.2140759545F),
+    Q31(0.2156986364F),Q31(0.2173259411F),Q31(0.2189578432F),Q31(0.2205943168F),
+    Q31(0.2222353361F),Q31(0.2238808751F),Q31(0.2255309076F),Q31(0.2271854073F),
+    Q31(0.2288443480F),Q31(0.2305077030F),Q31(0.2321754457F),Q31(0.2338475493F),
+    Q31(0.2355239869F),Q31(0.2372047315F),Q31(0.2388897560F),Q31(0.2405790329F),
+    Q31(0.2422725350F),Q31(0.2439702347F),Q31(0.2456721043F),Q31(0.2473781159F),
+    Q31(0.2490882418F),Q31(0.2508024539F),Q31(0.2525207240F),Q31(0.2542430237F),
+    Q31(0.2559693248F),Q31(0.2576995986F),Q31(0.2594338166F),Q31(0.2611719498F),
+    Q31(0.2629139695F),Q31(0.2646598466F),Q31(0.2664095520F),Q31(0.2681630564F),
+    Q31(0.2699203304F),Q31(0.2716813445F),Q31(0.2734460691F),Q31(0.2752144744F),
+    Q31(0.2769865307F),Q31(0.2787622079F),Q31(0.2805414760F),Q31(0.2823243047F),
+    Q31(0.2841106637F),Q31(0.2859005227F),Q31(0.2876938509F),Q31(0.2894906179F),
+    Q31(0.2912907928F),Q31(0.2930943447F),Q31(0.2949012426F),Q31(0.2967114554F),
+    Q31(0.2985249520F),Q31(0.3003417009F),Q31(0.3021616708F),Q31(0.3039848301F),
+    Q31(0.3058111471F),Q31(0.3076405901F),Q31(0.3094731273F),Q31(0.3113087266F),
+    Q31(0.3131473560F),Q31(0.3149889833F),Q31(0.3168335762F),Q31(0.3186811024F),
+    Q31(0.3205315294F),Q31(0.3223848245F),Q31(0.3242409552F),Q31(0.3260998886F),
+    Q31(0.3279615918F),Q31(0.3298260319F),Q31(0.3316931758F),Q31(0.3335629903F),
+    Q31(0.3354354423F),Q31(0.3373104982F),Q31(0.3391881247F),Q31(0.3410682882F),
+    Q31(0.3429509551F),Q31(0.3448360917F),Q31(0.3467236642F),Q31(0.3486136387F),
+    Q31(0.3505059811F),Q31(0.3524006575F),Q31(0.3542976336F),Q31(0.3561968753F),
+    Q31(0.3580983482F),Q31(0.3600020179F),Q31(0.3619078499F),Q31(0.3638158096F),
+    Q31(0.3657258625F),Q31(0.3676379737F),Q31(0.3695521086F),Q31(0.3714682321F),
+    Q31(0.3733863094F),Q31(0.3753063055F),Q31(0.3772281852F),Q31(0.3791519134F),
+    Q31(0.3810774548F),Q31(0.3830047742F),Q31(0.3849338362F),Q31(0.3868646053F),
+    Q31(0.3887970459F),Q31(0.3907311227F),Q31(0.3926667998F),Q31(0.3946040417F),
+    Q31(0.3965428125F),Q31(0.3984830765F),Q31(0.4004247978F),Q31(0.4023679403F),
+    Q31(0.4043124683F),Q31(0.4062583455F),Q31(0.4082055359F),Q31(0.4101540034F),
+    Q31(0.4121037117F),Q31(0.4140546246F),Q31(0.4160067058F),Q31(0.4179599190F),
+    Q31(0.4199142277F),Q31(0.4218695956F),Q31(0.4238259861F),Q31(0.4257833627F),
+    Q31(0.4277416888F),Q31(0.4297009279F),Q31(0.4316610433F),Q31(0.4336219983F),
+    Q31(0.4355837562F),Q31(0.4375462803F),Q31(0.4395095337F),Q31(0.4414734797F),
+    Q31(0.4434380815F),Q31(0.4454033021F),Q31(0.4473691046F),Q31(0.4493354521F),
+    Q31(0.4513023078F),Q31(0.4532696345F),Q31(0.4552373954F),Q31(0.4572055533F),
+    Q31(0.4591740713F),Q31(0.4611429123F),Q31(0.4631120393F),Q31(0.4650814151F),
+    Q31(0.4670510028F),Q31(0.4690207650F),Q31(0.4709906649F),Q31(0.4729606651F),
+    Q31(0.4749307287F),Q31(0.4769008185F),Q31(0.4788708972F),Q31(0.4808409279F),
+    Q31(0.4828108732F),Q31(0.4847806962F),Q31(0.4867503597F),Q31(0.4887198264F),
+    Q31(0.4906890593F),Q31(0.4926580213F),Q31(0.4946266753F),Q31(0.4965949840F),
+    Q31(0.4985629105F),Q31(0.5005304176F),Q31(0.5024974683F),Q31(0.5044640255F),
+    Q31(0.5064300522F),Q31(0.5083955114F),Q31(0.5103603659F),Q31(0.5123245790F),
+    Q31(0.5142881136F),Q31(0.5162509328F),Q31(0.5182129997F),Q31(0.5201742774F),
+    Q31(0.5221347290F),Q31(0.5240943178F),Q31(0.5260530070F),Q31(0.5280107598F),
+    Q31(0.5299675395F),Q31(0.5319233095F),Q31(0.5338780330F),Q31(0.5358316736F),
+    Q31(0.5377841946F),Q31(0.5397355596F),Q31(0.5416857320F),Q31(0.5436346755F),
+    Q31(0.5455823538F),Q31(0.5475287304F),Q31(0.5494737691F),Q31(0.5514174337F),
+    Q31(0.5533596881F),Q31(0.5553004962F),Q31(0.5572398218F),Q31(0.5591776291F),
+    Q31(0.5611138821F),Q31(0.5630485449F),Q31(0.5649815818F),Q31(0.5669129570F),
+    Q31(0.5688426349F),Q31(0.5707705799F),Q31(0.5726967564F),Q31(0.5746211290F),
+    Q31(0.5765436624F),Q31(0.5784643212F),Q31(0.5803830702F),Q31(0.5822998743F),
+    Q31(0.5842146984F),Q31(0.5861275076F),Q31(0.5880382669F),Q31(0.5899469416F),
+    Q31(0.5918534968F),Q31(0.5937578981F),Q31(0.5956601107F),Q31(0.5975601004F),
+    Q31(0.5994578326F),Q31(0.6013532732F),Q31(0.6032463880F),Q31(0.6051371429F),
+    Q31(0.6070255039F),Q31(0.6089114372F),Q31(0.6107949090F),Q31(0.6126758856F),
+    Q31(0.6145543334F),Q31(0.6164302191F),Q31(0.6183035092F),Q31(0.6201741706F),
+    Q31(0.6220421700F),Q31(0.6239074745F),Q31(0.6257700513F),Q31(0.6276298674F),
+    Q31(0.6294868903F),Q31(0.6313410873F),Q31(0.6331924262F),Q31(0.6350408745F),
+    Q31(0.6368864001F),Q31(0.6387289710F),Q31(0.6405685552F),Q31(0.6424051209F),
+    Q31(0.6442386364F),Q31(0.6460690702F),Q31(0.6478963910F),Q31(0.6497205673F),
+    Q31(0.6515415682F),Q31(0.6533593625F),Q31(0.6551739194F),Q31(0.6569852082F),
+    Q31(0.6587931984F),Q31(0.6605978593F),Q31(0.6623991609F),Q31(0.6641970728F),
+    Q31(0.6659915652F),Q31(0.6677826081F),Q31(0.6695701718F),Q31(0.6713542268F),
+    Q31(0.6731347437F),Q31(0.6749116932F),Q31(0.6766850461F),Q31(0.6784547736F),
+    Q31(0.6802208469F),Q31(0.6819832374F),Q31(0.6837419164F),Q31(0.6854968559F),
+    Q31(0.6872480275F),Q31(0.6889954034F),Q31(0.6907389556F),Q31(0.6924786566F),
+    Q31(0.6942144788F),Q31(0.6959463950F),Q31(0.6976743780F),Q31(0.6993984008F),
+    Q31(0.7011184365F),Q31(0.7028344587F),Q31(0.7045464407F),Q31(0.7062543564F),
+    Q31(0.7079581796F),Q31(0.7096578844F),Q31(0.7113534450F),Q31(0.7130448359F),
+    Q31(0.7147320316F),Q31(0.7164150070F),Q31(0.7180937371F),Q31(0.7197681970F),
+    Q31(0.7214383620F),Q31(0.7231042077F),Q31(0.7247657098F),Q31(0.7264228443F),
+    Q31(0.7280755871F),Q31(0.7297239147F),Q31(0.7313678035F),Q31(0.7330072301F),
+    Q31(0.7346421715F),Q31(0.7362726046F),Q31(0.7378985069F),Q31(0.7395198556F),
+    Q31(0.7411366285F),Q31(0.7427488034F),Q31(0.7443563584F),Q31(0.7459592717F),
+    Q31(0.7475575218F),Q31(0.7491510873F),Q31(0.7507399471F),Q31(0.7523240803F),
+    Q31(0.7539034661F),Q31(0.7554780839F),Q31(0.7570479136F),Q31(0.7586129349F),
+    Q31(0.7601731279F),Q31(0.7617284730F),Q31(0.7632789506F),Q31(0.7648245416F),
+    Q31(0.7663652267F),Q31(0.7679009872F),Q31(0.7694318044F),Q31(0.7709576599F),
+    Q31(0.7724785354F),Q31(0.7739944130F),Q31(0.7755052749F),Q31(0.7770111035F),
+    Q31(0.7785118815F),Q31(0.7800075916F),Q31(0.7814982170F),Q31(0.7829837410F),
+    Q31(0.7844641472F),Q31(0.7859394191F),Q31(0.7874095408F),Q31(0.7888744965F),
+    Q31(0.7903342706F),Q31(0.7917888476F),Q31(0.7932382124F),Q31(0.7946823501F),
+    Q31(0.7961212460F),Q31(0.7975548855F),Q31(0.7989832544F),Q31(0.8004063386F),
+    Q31(0.8018241244F),Q31(0.8032365981F),Q31(0.8046437463F),Q31(0.8060455560F),
+    Q31(0.8074420141F),Q31(0.8088331080F),Q31(0.8102188253F),Q31(0.8115991536F),
+    Q31(0.8129740810F),Q31(0.8143435957F),Q31(0.8157076861F),Q31(0.8170663409F),
+    Q31(0.8184195489F),Q31(0.8197672994F),Q31(0.8211095817F),Q31(0.8224463853F),
+    Q31(0.8237777001F),Q31(0.8251035161F),Q31(0.8264238235F),Q31(0.8277386129F),
+    Q31(0.8290478750F),Q31(0.8303516008F),Q31(0.8316497814F),Q31(0.8329424083F),
+    Q31(0.8342294731F),Q31(0.8355109677F),Q31(0.8367868841F),Q31(0.8380572148F),
+    Q31(0.8393219523F),Q31(0.8405810893F),Q31(0.8418346190F),Q31(0.8430825345F),
+    Q31(0.8443248294F),Q31(0.8455614974F),Q31(0.8467925323F),Q31(0.8480179285F),
+    Q31(0.8492376802F),Q31(0.8504517822F),Q31(0.8516602292F),Q31(0.8528630164F),
+    Q31(0.8540601391F),Q31(0.8552515928F),Q31(0.8564373733F),Q31(0.8576174766F),
+    Q31(0.8587918990F),Q31(0.8599606368F),Q31(0.8611236868F),Q31(0.8622810460F),
+    Q31(0.8634327113F),Q31(0.8645786802F),Q31(0.8657189504F),Q31(0.8668535195F),
+    Q31(0.8679823857F),Q31(0.8691055472F),Q31(0.8702230025F),Q31(0.8713347503F),
+    Q31(0.8724407896F),Q31(0.8735411194F),Q31(0.8746357394F),Q31(0.8757246489F),
+    Q31(0.8768078479F),Q31(0.8778853364F),Q31(0.8789571146F),Q31(0.8800231832F),
+    Q31(0.8810835427F),Q31(0.8821381942F),Q31(0.8831871387F),Q31(0.8842303777F),
+    Q31(0.8852679127F),Q31(0.8862997456F),Q31(0.8873258784F),Q31(0.8883463132F),
+    Q31(0.8893610527F),Q31(0.8903700994F),Q31(0.8913734562F),Q31(0.8923711263F),
+    Q31(0.8933631129F),Q31(0.8943494196F),Q31(0.8953300500F),Q31(0.8963050083F),
+    Q31(0.8972742985F),Q31(0.8982379249F),Q31(0.8991958922F),Q31(0.9001482052F),
+    Q31(0.9010948688F),Q31(0.9020358883F),Q31(0.9029712690F),Q31(0.9039010165F),
+    Q31(0.9048251367F),Q31(0.9057436357F),Q31(0.9066565195F),Q31(0.9075637946F),
+    Q31(0.9084654678F),Q31(0.9093615456F),Q31(0.9102520353F),Q31(0.9111369440F),
+    Q31(0.9120162792F),Q31(0.9128900484F),Q31(0.9137582595F),Q31(0.9146209204F),
+    Q31(0.9154780394F),Q31(0.9163296248F),Q31(0.9171756853F),Q31(0.9180162296F),
+    Q31(0.9188512667F),Q31(0.9196808057F),Q31(0.9205048559F),Q31(0.9213234270F),
+    Q31(0.9221365285F),Q31(0.9229441704F),Q31(0.9237463629F),Q31(0.9245431160F),
+    Q31(0.9253344404F),Q31(0.9261203465F),Q31(0.9269008453F),Q31(0.9276759477F),
+    Q31(0.9284456648F),Q31(0.9292100080F),Q31(0.9299689889F),Q31(0.9307226190F),
+    Q31(0.9314709103F),Q31(0.9322138747F),Q31(0.9329515245F),Q31(0.9336838721F),
+    Q31(0.9344109300F),Q31(0.9351327108F),Q31(0.9358492275F),Q31(0.9365604931F),
+    Q31(0.9372665208F),Q31(0.9379673239F),Q31(0.9386629160F),Q31(0.9393533107F),
+    Q31(0.9400385220F),Q31(0.9407185637F),Q31(0.9413934501F),Q31(0.9420631954F),
+    Q31(0.9427278141F),Q31(0.9433873208F),Q31(0.9440417304F),Q31(0.9446910576F),
+    Q31(0.9453353176F),Q31(0.9459745255F),Q31(0.9466086968F),Q31(0.9472378469F),
+    Q31(0.9478619915F),Q31(0.9484811463F),Q31(0.9490953274F),Q31(0.9497045506F),
+    Q31(0.9503088323F),Q31(0.9509081888F),Q31(0.9515026365F),Q31(0.9520921921F),
+    Q31(0.9526768723F),Q31(0.9532566940F),Q31(0.9538316742F),Q31(0.9544018300F),
+    Q31(0.9549671786F),Q31(0.9555277375F),Q31(0.9560835241F),Q31(0.9566345562F),
+    Q31(0.9571808513F),Q31(0.9577224275F),Q31(0.9582593027F),Q31(0.9587914949F),
+    Q31(0.9593190225F),Q31(0.9598419038F),Q31(0.9603601571F),Q31(0.9608738012F),
+    Q31(0.9613828546F),Q31(0.9618873361F),Q31(0.9623872646F),Q31(0.9628826591F),
+    Q31(0.9633735388F),Q31(0.9638599227F),Q31(0.9643418303F),Q31(0.9648192808F),
+    Q31(0.9652922939F),Q31(0.9657608890F),Q31(0.9662250860F),Q31(0.9666849046F),
+    Q31(0.9671403646F),Q31(0.9675914861F),Q31(0.9680382891F),Q31(0.9684807937F),
+    Q31(0.9689190202F),Q31(0.9693529890F),Q31(0.9697827203F),Q31(0.9702082347F),
+    Q31(0.9706295529F),Q31(0.9710466953F),Q31(0.9714596828F),Q31(0.9718685362F),
+    Q31(0.9722732762F),Q31(0.9726739240F),Q31(0.9730705005F),Q31(0.9734630267F),
+    Q31(0.9738515239F),Q31(0.9742360134F),Q31(0.9746165163F),Q31(0.9749930540F),
+    Q31(0.9753656481F),Q31(0.9757343198F),Q31(0.9760990909F),Q31(0.9764599829F),
+    Q31(0.9768170175F),Q31(0.9771702164F),Q31(0.9775196013F),Q31(0.9778651941F),
+    Q31(0.9782070167F),Q31(0.9785450909F),Q31(0.9788794388F),Q31(0.9792100824F),
+    Q31(0.9795370437F),Q31(0.9798603449F),Q31(0.9801800080F),Q31(0.9804960554F),
+    Q31(0.9808085092F),Q31(0.9811173916F),Q31(0.9814227251F),Q31(0.9817245318F),
+    Q31(0.9820228343F),Q31(0.9823176549F),Q31(0.9826090160F),Q31(0.9828969402F),
+    Q31(0.9831814498F),Q31(0.9834625674F),Q31(0.9837403156F),Q31(0.9840147169F),
+    Q31(0.9842857939F),Q31(0.9845535692F),Q31(0.9848180654F),Q31(0.9850793052F),
+    Q31(0.9853373113F),Q31(0.9855921062F),Q31(0.9858437127F),Q31(0.9860921535F),
+    Q31(0.9863374512F),Q31(0.9865796287F),Q31(0.9868187085F),Q31(0.9870547136F),
+    Q31(0.9872876664F),Q31(0.9875175899F),Q31(0.9877445067F),Q31(0.9879684396F),
+    Q31(0.9881894112F),Q31(0.9884074444F),Q31(0.9886225619F),Q31(0.9888347863F),
+    Q31(0.9890441404F),Q31(0.9892506468F),Q31(0.9894543284F),Q31(0.9896552077F),
+    Q31(0.9898533074F),Q31(0.9900486502F),Q31(0.9902412587F),Q31(0.9904311555F),
+    Q31(0.9906183633F),Q31(0.9908029045F),Q31(0.9909848019F),Q31(0.9911640779F),
+    Q31(0.9913407550F),Q31(0.9915148557F),Q31(0.9916864025F),Q31(0.9918554179F),
+    Q31(0.9920219241F),Q31(0.9921859437F),Q31(0.9923474989F),Q31(0.9925066120F),
+    Q31(0.9926633054F),Q31(0.9928176012F),Q31(0.9929695218F),Q31(0.9931190891F),
+    Q31(0.9932663254F),Q31(0.9934112527F),Q31(0.9935538932F),Q31(0.9936942686F),
+    Q31(0.9938324012F),Q31(0.9939683126F),Q31(0.9941020248F),Q31(0.9942335597F),
+    Q31(0.9943629388F),Q31(0.9944901841F),Q31(0.9946153170F),Q31(0.9947383593F),
+    Q31(0.9948593325F),Q31(0.9949782579F),Q31(0.9950951572F),Q31(0.9952100516F),
+    Q31(0.9953229625F),Q31(0.9954339111F),Q31(0.9955429186F),Q31(0.9956500062F),
+    Q31(0.9957551948F),Q31(0.9958585056F),Q31(0.9959599593F),Q31(0.9960595769F),
+    Q31(0.9961573792F),Q31(0.9962533869F),Q31(0.9963476206F),Q31(0.9964401009F),
+    Q31(0.9965308483F),Q31(0.9966198833F),Q31(0.9967072261F),Q31(0.9967928971F),
+    Q31(0.9968769164F),Q31(0.9969593041F),Q31(0.9970400804F),Q31(0.9971192651F),
+    Q31(0.9971968781F),Q31(0.9972729391F),Q31(0.9973474680F),Q31(0.9974204842F),
+    Q31(0.9974920074F),Q31(0.9975620569F),Q31(0.9976306521F),Q31(0.9976978122F),
+    Q31(0.9977635565F),Q31(0.9978279039F),Q31(0.9978908736F),Q31(0.9979524842F),
+    Q31(0.9980127547F),Q31(0.9980717037F),Q31(0.9981293499F),Q31(0.9981857116F),
+    Q31(0.9982408073F),Q31(0.9982946554F),Q31(0.9983472739F),Q31(0.9983986810F),
+    Q31(0.9984488947F),Q31(0.9984979328F),Q31(0.9985458132F),Q31(0.9985925534F),
+    Q31(0.9986381711F),Q31(0.9986826838F),Q31(0.9987261086F),Q31(0.9987684630F),
+    Q31(0.9988097640F),Q31(0.9988500286F),Q31(0.9988892738F),Q31(0.9989275163F),
+    Q31(0.9989647727F),Q31(0.9990010597F),Q31(0.9990363938F),Q31(0.9990707911F),
+    Q31(0.9991042679F),Q31(0.9991368404F),Q31(0.9991685244F),Q31(0.9991993358F),
+    Q31(0.9992292905F),Q31(0.9992584038F),Q31(0.9992866914F),Q31(0.9993141686F),
+    Q31(0.9993408506F),Q31(0.9993667526F),Q31(0.9993918895F),Q31(0.9994162761F),
+    Q31(0.9994399273F),Q31(0.9994628576F),Q31(0.9994850815F),Q31(0.9995066133F),
+    Q31(0.9995274672F),Q31(0.9995476574F),Q31(0.9995671978F),Q31(0.9995861021F),
+    Q31(0.9996043841F),Q31(0.9996220573F),Q31(0.9996391352F),Q31(0.9996556310F),
+    Q31(0.9996715579F),Q31(0.9996869288F),Q31(0.9997017568F),Q31(0.9997160543F),
+    Q31(0.9997298342F),Q31(0.9997431088F),Q31(0.9997558905F),Q31(0.9997681914F),
+    Q31(0.9997800236F),Q31(0.9997913990F),Q31(0.9998023292F),Q31(0.9998128261F),
+    Q31(0.9998229009F),Q31(0.9998325650F),Q31(0.9998418296F),Q31(0.9998507058F),
+    Q31(0.9998592044F),Q31(0.9998673362F),Q31(0.9998751117F),Q31(0.9998825415F),
+    Q31(0.9998896358F),Q31(0.9998964047F),Q31(0.9999028584F),Q31(0.9999090066F),
+    Q31(0.9999148590F),Q31(0.9999204253F),Q31(0.9999257148F),Q31(0.9999307368F),
+    Q31(0.9999355003F),Q31(0.9999400144F),Q31(0.9999442878F),Q31(0.9999483293F),
+    Q31(0.9999521472F),Q31(0.9999557499F),Q31(0.9999591457F),Q31(0.9999623426F),
+    Q31(0.9999653483F),Q31(0.9999681708F),Q31(0.9999708175F),Q31(0.9999732959F),
+    Q31(0.9999756132F),Q31(0.9999777765F),Q31(0.9999797928F),Q31(0.9999816688F),
+    Q31(0.9999834113F),Q31(0.9999850266F),Q31(0.9999865211F),Q31(0.9999879009F),
+    Q31(0.9999891721F),Q31(0.9999903405F),Q31(0.9999914118F),Q31(0.9999923914F),
+    Q31(0.9999932849F),Q31(0.9999940972F),Q31(0.9999948336F),Q31(0.9999954989F),
+    Q31(0.9999960978F),Q31(0.9999966349F),Q31(0.9999971146F),Q31(0.9999975411F),
+    Q31(0.9999979185F),Q31(0.9999982507F),Q31(0.9999985414F),Q31(0.9999987944F),
+    Q31(0.9999990129F),Q31(0.9999992003F),Q31(0.9999993596F),Q31(0.9999994939F),
+    Q31(0.9999996059F),Q31(0.9999996981F),Q31(0.9999997732F),Q31(0.9999998333F),
+    Q31(0.9999998805F),Q31(0.9999999170F),Q31(0.9999999444F),Q31(0.9999999643F),
+    Q31(0.9999999784F),Q31(0.9999999878F),Q31(0.9999999937F),Q31(0.9999999972F),
+    Q31(0.9999999990F),Q31(0.9999999997F),Q31(1.0000000000F),Q31(1.0000000000F),
 };
 
-DECLARE_ALIGNED(16, static const float, vwin4096)[2048] = {
-    0.0000002310F, 0.0000020791F, 0.0000057754F, 0.0000113197F,
-    0.0000187121F, 0.0000279526F, 0.0000390412F, 0.0000519777F,
-    0.0000667623F, 0.0000833949F, 0.0001018753F, 0.0001222036F,
-    0.0001443798F, 0.0001684037F, 0.0001942754F, 0.0002219947F,
-    0.0002515616F, 0.0002829761F, 0.0003162380F, 0.0003513472F,
-    0.0003883038F, 0.0004271076F, 0.0004677584F, 0.0005102563F,
-    0.0005546011F, 0.0006007928F, 0.0006488311F, 0.0006987160F,
-    0.0007504474F, 0.0008040251F, 0.0008594490F, 0.0009167191F,
-    0.0009758351F, 0.0010367969F, 0.0010996044F, 0.0011642574F,
-    0.0012307558F, 0.0012990994F, 0.0013692880F, 0.0014413216F,
-    0.0015151998F, 0.0015909226F, 0.0016684898F, 0.0017479011F,
-    0.0018291565F, 0.0019122556F, 0.0019971983F, 0.0020839845F,
-    0.0021726138F, 0.0022630861F, 0.0023554012F, 0.0024495588F,
-    0.0025455588F, 0.0026434008F, 0.0027430847F, 0.0028446103F,
-    0.0029479772F, 0.0030531853F, 0.0031602342F, 0.0032691238F,
-    0.0033798538F, 0.0034924239F, 0.0036068338F, 0.0037230833F,
-    0.0038411721F, 0.0039610999F, 0.0040828664F, 0.0042064714F,
-    0.0043319145F, 0.0044591954F, 0.0045883139F, 0.0047192696F,
-    0.0048520622F, 0.0049866914F, 0.0051231569F, 0.0052614583F,
-    0.0054015953F, 0.0055435676F, 0.0056873748F, 0.0058330166F,
-    0.0059804926F, 0.0061298026F, 0.0062809460F, 0.0064339226F,
-    0.0065887320F, 0.0067453738F, 0.0069038476F, 0.0070641531F,
-    0.0072262899F, 0.0073902575F, 0.0075560556F, 0.0077236838F,
-    0.0078931417F, 0.0080644288F, 0.0082375447F, 0.0084124891F,
-    0.0085892615F, 0.0087678614F, 0.0089482885F, 0.0091305422F,
-    0.0093146223F, 0.0095005281F, 0.0096882592F, 0.0098778153F,
-    0.0100691958F, 0.0102624002F, 0.0104574281F, 0.0106542791F,
-    0.0108529525F, 0.0110534480F, 0.0112557651F, 0.0114599032F,
-    0.0116658618F, 0.0118736405F, 0.0120832387F, 0.0122946560F,
-    0.0125078917F, 0.0127229454F, 0.0129398166F, 0.0131585046F,
-    0.0133790090F, 0.0136013292F, 0.0138254647F, 0.0140514149F,
-    0.0142791792F, 0.0145087572F, 0.0147401481F, 0.0149733515F,
-    0.0152083667F, 0.0154451932F, 0.0156838304F, 0.0159242777F,
-    0.0161665345F, 0.0164106001F, 0.0166564741F, 0.0169041557F,
-    0.0171536443F, 0.0174049393F, 0.0176580401F, 0.0179129461F,
-    0.0181696565F, 0.0184281708F, 0.0186884883F, 0.0189506084F,
-    0.0192145303F, 0.0194802535F, 0.0197477772F, 0.0200171008F,
-    0.0202882236F, 0.0205611449F, 0.0208358639F, 0.0211123801F,
-    0.0213906927F, 0.0216708011F, 0.0219527043F, 0.0222364019F,
-    0.0225218930F, 0.0228091769F, 0.0230982529F, 0.0233891203F,
-    0.0236817782F, 0.0239762259F, 0.0242724628F, 0.0245704880F,
-    0.0248703007F, 0.0251719002F, 0.0254752858F, 0.0257804565F,
-    0.0260874117F, 0.0263961506F, 0.0267066722F, 0.0270189760F,
-    0.0273330609F, 0.0276489263F, 0.0279665712F, 0.0282859949F,
-    0.0286071966F, 0.0289301753F, 0.0292549303F, 0.0295814607F,
-    0.0299097656F, 0.0302398442F, 0.0305716957F, 0.0309053191F,
-    0.0312407135F, 0.0315778782F, 0.0319168122F, 0.0322575145F,
-    0.0325999844F, 0.0329442209F, 0.0332902231F, 0.0336379900F,
-    0.0339875208F, 0.0343388146F, 0.0346918703F, 0.0350466871F,
-    0.0354032640F, 0.0357616000F, 0.0361216943F, 0.0364835458F,
-    0.0368471535F, 0.0372125166F, 0.0375796339F, 0.0379485046F,
-    0.0383191276F, 0.0386915020F, 0.0390656267F, 0.0394415008F,
-    0.0398191231F, 0.0401984927F, 0.0405796086F, 0.0409624698F,
-    0.0413470751F, 0.0417334235F, 0.0421215141F, 0.0425113457F,
-    0.0429029172F, 0.0432962277F, 0.0436912760F, 0.0440880610F,
-    0.0444865817F, 0.0448868370F, 0.0452888257F, 0.0456925468F,
-    0.0460979992F, 0.0465051816F, 0.0469140931F, 0.0473247325F,
-    0.0477370986F, 0.0481511902F, 0.0485670064F, 0.0489845458F,
-    0.0494038074F, 0.0498247899F, 0.0502474922F, 0.0506719131F,
-    0.0510980514F, 0.0515259060F, 0.0519554756F, 0.0523867590F,
-    0.0528197550F, 0.0532544624F, 0.0536908800F, 0.0541290066F,
-    0.0545688408F, 0.0550103815F, 0.0554536274F, 0.0558985772F,
-    0.0563452297F, 0.0567935837F, 0.0572436377F, 0.0576953907F,
-    0.0581488412F, 0.0586039880F, 0.0590608297F, 0.0595193651F,
-    0.0599795929F, 0.0604415117F, 0.0609051202F, 0.0613704170F,
-    0.0618374009F, 0.0623060704F, 0.0627764243F, 0.0632484611F,
-    0.0637221795F, 0.0641975781F, 0.0646746555F, 0.0651534104F,
-    0.0656338413F, 0.0661159469F, 0.0665997257F, 0.0670851763F,
-    0.0675722973F, 0.0680610873F, 0.0685515448F, 0.0690436684F,
-    0.0695374567F, 0.0700329081F, 0.0705300213F, 0.0710287947F,
-    0.0715292269F, 0.0720313163F, 0.0725350616F, 0.0730404612F,
-    0.0735475136F, 0.0740562172F, 0.0745665707F, 0.0750785723F,
-    0.0755922207F, 0.0761075143F, 0.0766244515F, 0.0771430307F,
-    0.0776632505F, 0.0781851092F, 0.0787086052F, 0.0792337371F,
-    0.0797605032F, 0.0802889018F, 0.0808189315F, 0.0813505905F,
-    0.0818838773F, 0.0824187903F, 0.0829553277F, 0.0834934881F,
-    0.0840332697F, 0.0845746708F, 0.0851176899F, 0.0856623252F,
-    0.0862085751F, 0.0867564379F, 0.0873059119F, 0.0878569954F,
-    0.0884096867F, 0.0889639840F, 0.0895198858F, 0.0900773902F,
-    0.0906364955F, 0.0911972000F, 0.0917595019F, 0.0923233995F,
-    0.0928888909F, 0.0934559745F, 0.0940246485F, 0.0945949110F,
-    0.0951667604F, 0.0957401946F, 0.0963152121F, 0.0968918109F,
-    0.0974699893F, 0.0980497454F, 0.0986310773F, 0.0992139832F,
-    0.0997984614F, 0.1003845098F, 0.1009721267F, 0.1015613101F,
-    0.1021520582F, 0.1027443692F, 0.1033382410F, 0.1039336718F,
-    0.1045306597F, 0.1051292027F, 0.1057292990F, 0.1063309466F,
-    0.1069341435F, 0.1075388878F, 0.1081451776F, 0.1087530108F,
-    0.1093623856F, 0.1099732998F, 0.1105857516F, 0.1111997389F,
-    0.1118152597F, 0.1124323121F, 0.1130508939F, 0.1136710032F,
-    0.1142926379F, 0.1149157960F, 0.1155404755F, 0.1161666742F,
-    0.1167943901F, 0.1174236211F, 0.1180543652F, 0.1186866202F,
-    0.1193203841F, 0.1199556548F, 0.1205924300F, 0.1212307078F,
-    0.1218704860F, 0.1225117624F, 0.1231545349F, 0.1237988013F,
-    0.1244445596F, 0.1250918074F, 0.1257405427F, 0.1263907632F,
-    0.1270424667F, 0.1276956512F, 0.1283503142F, 0.1290064537F,
-    0.1296640674F, 0.1303231530F, 0.1309837084F, 0.1316457312F,
-    0.1323092193F, 0.1329741703F, 0.1336405820F, 0.1343084520F,
-    0.1349777782F, 0.1356485582F, 0.1363207897F, 0.1369944704F,
-    0.1376695979F, 0.1383461700F, 0.1390241842F, 0.1397036384F,
-    0.1403845300F, 0.1410668567F, 0.1417506162F, 0.1424358061F,
-    0.1431224240F, 0.1438104674F, 0.1444999341F, 0.1451908216F,
-    0.1458831274F, 0.1465768492F, 0.1472719844F, 0.1479685308F,
-    0.1486664857F, 0.1493658468F, 0.1500666115F, 0.1507687775F,
-    0.1514723422F, 0.1521773031F, 0.1528836577F, 0.1535914035F,
-    0.1543005380F, 0.1550110587F, 0.1557229631F, 0.1564362485F,
-    0.1571509124F, 0.1578669524F, 0.1585843657F, 0.1593031499F,
-    0.1600233024F, 0.1607448205F, 0.1614677017F, 0.1621919433F,
-    0.1629175428F, 0.1636444975F, 0.1643728047F, 0.1651024619F,
-    0.1658334665F, 0.1665658156F, 0.1672995067F, 0.1680345371F,
-    0.1687709041F, 0.1695086050F, 0.1702476372F, 0.1709879978F,
-    0.1717296843F, 0.1724726938F, 0.1732170237F, 0.1739626711F,
-    0.1747096335F, 0.1754579079F, 0.1762074916F, 0.1769583819F,
-    0.1777105760F, 0.1784640710F, 0.1792188642F, 0.1799749529F,
-    0.1807323340F, 0.1814910049F, 0.1822509628F, 0.1830122046F,
-    0.1837747277F, 0.1845385292F, 0.1853036062F, 0.1860699558F,
-    0.1868375751F, 0.1876064613F, 0.1883766114F, 0.1891480226F,
-    0.1899206919F, 0.1906946164F, 0.1914697932F, 0.1922462194F,
-    0.1930238919F, 0.1938028079F, 0.1945829643F, 0.1953643583F,
-    0.1961469868F, 0.1969308468F, 0.1977159353F, 0.1985022494F,
-    0.1992897859F, 0.2000785420F, 0.2008685145F, 0.2016597005F,
-    0.2024520968F, 0.2032457005F, 0.2040405084F, 0.2048365175F,
-    0.2056337247F, 0.2064321269F, 0.2072317211F, 0.2080325041F,
-    0.2088344727F, 0.2096376240F, 0.2104419547F, 0.2112474618F,
-    0.2120541420F, 0.2128619923F, 0.2136710094F, 0.2144811902F,
-    0.2152925315F, 0.2161050301F, 0.2169186829F, 0.2177334866F,
-    0.2185494381F, 0.2193665340F, 0.2201847712F, 0.2210041465F,
-    0.2218246565F, 0.2226462981F, 0.2234690680F, 0.2242929629F,
-    0.2251179796F, 0.2259441147F, 0.2267713650F, 0.2275997272F,
-    0.2284291979F, 0.2292597739F, 0.2300914518F, 0.2309242283F,
-    0.2317581001F, 0.2325930638F, 0.2334291160F, 0.2342662534F,
-    0.2351044727F, 0.2359437703F, 0.2367841431F, 0.2376255875F,
-    0.2384681001F, 0.2393116776F, 0.2401563165F, 0.2410020134F,
-    0.2418487649F, 0.2426965675F, 0.2435454178F, 0.2443953122F,
-    0.2452462474F, 0.2460982199F, 0.2469512262F, 0.2478052628F,
-    0.2486603262F, 0.2495164129F, 0.2503735194F, 0.2512316421F,
-    0.2520907776F, 0.2529509222F, 0.2538120726F, 0.2546742250F,
-    0.2555373760F, 0.2564015219F, 0.2572666593F, 0.2581327845F,
-    0.2589998939F, 0.2598679840F, 0.2607370510F, 0.2616070916F,
-    0.2624781019F, 0.2633500783F, 0.2642230173F, 0.2650969152F,
-    0.2659717684F, 0.2668475731F, 0.2677243257F, 0.2686020226F,
-    0.2694806601F, 0.2703602344F, 0.2712407419F, 0.2721221789F,
-    0.2730045417F, 0.2738878265F, 0.2747720297F, 0.2756571474F,
-    0.2765431760F, 0.2774301117F, 0.2783179508F, 0.2792066895F,
-    0.2800963240F, 0.2809868505F, 0.2818782654F, 0.2827705647F,
-    0.2836637447F, 0.2845578016F, 0.2854527315F, 0.2863485307F,
-    0.2872451953F, 0.2881427215F, 0.2890411055F, 0.2899403433F,
-    0.2908404312F, 0.2917413654F, 0.2926431418F, 0.2935457567F,
-    0.2944492061F, 0.2953534863F, 0.2962585932F, 0.2971645230F,
-    0.2980712717F, 0.2989788356F, 0.2998872105F, 0.3007963927F,
-    0.3017063781F, 0.3026171629F, 0.3035287430F, 0.3044411145F,
-    0.3053542736F, 0.3062682161F, 0.3071829381F, 0.3080984356F,
-    0.3090147047F, 0.3099317413F, 0.3108495414F, 0.3117681011F,
-    0.3126874163F, 0.3136074830F, 0.3145282972F, 0.3154498548F,
-    0.3163721517F, 0.3172951841F, 0.3182189477F, 0.3191434385F,
-    0.3200686525F, 0.3209945856F, 0.3219212336F, 0.3228485927F,
-    0.3237766585F, 0.3247054271F, 0.3256348943F, 0.3265650560F,
-    0.3274959081F, 0.3284274465F, 0.3293596671F, 0.3302925657F,
-    0.3312261382F, 0.3321603804F, 0.3330952882F, 0.3340308574F,
-    0.3349670838F, 0.3359039634F, 0.3368414919F, 0.3377796651F,
-    0.3387184789F, 0.3396579290F, 0.3405980113F, 0.3415387216F,
-    0.3424800556F, 0.3434220091F, 0.3443645779F, 0.3453077578F,
-    0.3462515446F, 0.3471959340F, 0.3481409217F, 0.3490865036F,
-    0.3500326754F, 0.3509794328F, 0.3519267715F, 0.3528746873F,
-    0.3538231759F, 0.3547722330F, 0.3557218544F, 0.3566720357F,
-    0.3576227727F, 0.3585740610F, 0.3595258964F, 0.3604782745F,
-    0.3614311910F, 0.3623846417F, 0.3633386221F, 0.3642931280F,
-    0.3652481549F, 0.3662036987F, 0.3671597548F, 0.3681163191F,
-    0.3690733870F, 0.3700309544F, 0.3709890167F, 0.3719475696F,
-    0.3729066089F, 0.3738661299F, 0.3748261285F, 0.3757866002F,
-    0.3767475406F, 0.3777089453F, 0.3786708100F, 0.3796331302F,
-    0.3805959014F, 0.3815591194F, 0.3825227796F, 0.3834868777F,
-    0.3844514093F, 0.3854163698F, 0.3863817549F, 0.3873475601F,
-    0.3883137810F, 0.3892804131F, 0.3902474521F, 0.3912148933F,
-    0.3921827325F, 0.3931509650F, 0.3941195865F, 0.3950885925F,
-    0.3960579785F, 0.3970277400F, 0.3979978725F, 0.3989683716F,
-    0.3999392328F, 0.4009104516F, 0.4018820234F, 0.4028539438F,
-    0.4038262084F, 0.4047988125F, 0.4057717516F, 0.4067450214F,
-    0.4077186172F, 0.4086925345F, 0.4096667688F, 0.4106413155F,
-    0.4116161703F, 0.4125913284F, 0.4135667854F, 0.4145425368F,
-    0.4155185780F, 0.4164949044F, 0.4174715116F, 0.4184483949F,
-    0.4194255498F, 0.4204029718F, 0.4213806563F, 0.4223585987F,
-    0.4233367946F, 0.4243152392F, 0.4252939281F, 0.4262728566F,
-    0.4272520202F, 0.4282314144F, 0.4292110345F, 0.4301908760F,
-    0.4311709343F, 0.4321512047F, 0.4331316828F, 0.4341123639F,
-    0.4350932435F, 0.4360743168F, 0.4370555794F, 0.4380370267F,
-    0.4390186540F, 0.4400004567F, 0.4409824303F, 0.4419645701F,
-    0.4429468716F, 0.4439293300F, 0.4449119409F, 0.4458946996F,
-    0.4468776014F, 0.4478606418F, 0.4488438162F, 0.4498271199F,
-    0.4508105483F, 0.4517940967F, 0.4527777607F, 0.4537615355F,
-    0.4547454165F, 0.4557293991F, 0.4567134786F, 0.4576976505F,
-    0.4586819101F, 0.4596662527F, 0.4606506738F, 0.4616351687F,
-    0.4626197328F, 0.4636043614F, 0.4645890499F, 0.4655737936F,
-    0.4665585880F, 0.4675434284F, 0.4685283101F, 0.4695132286F,
-    0.4704981791F, 0.4714831570F, 0.4724681577F, 0.4734531766F,
-    0.4744382089F, 0.4754232501F, 0.4764082956F, 0.4773933406F,
-    0.4783783806F, 0.4793634108F, 0.4803484267F, 0.4813334237F,
-    0.4823183969F, 0.4833033419F, 0.4842882540F, 0.4852731285F,
-    0.4862579608F, 0.4872427462F, 0.4882274802F, 0.4892121580F,
-    0.4901967751F, 0.4911813267F, 0.4921658083F, 0.4931502151F,
-    0.4941345427F, 0.4951187863F, 0.4961029412F, 0.4970870029F,
-    0.4980709667F, 0.4990548280F, 0.5000385822F, 0.5010222245F,
-    0.5020057505F, 0.5029891553F, 0.5039724345F, 0.5049555834F,
-    0.5059385973F, 0.5069214716F, 0.5079042018F, 0.5088867831F,
-    0.5098692110F, 0.5108514808F, 0.5118335879F, 0.5128155277F,
-    0.5137972956F, 0.5147788869F, 0.5157602971F, 0.5167415215F,
-    0.5177225555F, 0.5187033945F, 0.5196840339F, 0.5206644692F,
-    0.5216446956F, 0.5226247086F, 0.5236045035F, 0.5245840759F,
-    0.5255634211F, 0.5265425344F, 0.5275214114F, 0.5285000474F,
-    0.5294784378F, 0.5304565781F, 0.5314344637F, 0.5324120899F,
-    0.5333894522F, 0.5343665461F, 0.5353433670F, 0.5363199102F,
-    0.5372961713F, 0.5382721457F, 0.5392478287F, 0.5402232159F,
-    0.5411983027F, 0.5421730845F, 0.5431475569F, 0.5441217151F,
-    0.5450955548F, 0.5460690714F, 0.5470422602F, 0.5480151169F,
-    0.5489876368F, 0.5499598155F, 0.5509316484F, 0.5519031310F,
-    0.5528742587F, 0.5538450271F, 0.5548154317F, 0.5557854680F,
-    0.5567551314F, 0.5577244174F, 0.5586933216F, 0.5596618395F,
-    0.5606299665F, 0.5615976983F, 0.5625650302F, 0.5635319580F,
-    0.5644984770F, 0.5654645828F, 0.5664302709F, 0.5673955370F,
-    0.5683603765F, 0.5693247850F, 0.5702887580F, 0.5712522912F,
-    0.5722153800F, 0.5731780200F, 0.5741402069F, 0.5751019362F,
-    0.5760632034F, 0.5770240042F, 0.5779843341F, 0.5789441889F,
-    0.5799035639F, 0.5808624549F, 0.5818208575F, 0.5827787673F,
-    0.5837361800F, 0.5846930910F, 0.5856494961F, 0.5866053910F,
-    0.5875607712F, 0.5885156324F, 0.5894699703F, 0.5904237804F,
-    0.5913770586F, 0.5923298004F, 0.5932820016F, 0.5942336578F,
-    0.5951847646F, 0.5961353179F, 0.5970853132F, 0.5980347464F,
-    0.5989836131F, 0.5999319090F, 0.6008796298F, 0.6018267713F,
-    0.6027733292F, 0.6037192993F, 0.6046646773F, 0.6056094589F,
-    0.6065536400F, 0.6074972162F, 0.6084401833F, 0.6093825372F,
-    0.6103242736F, 0.6112653884F, 0.6122058772F, 0.6131457359F,
-    0.6140849604F, 0.6150235464F, 0.6159614897F, 0.6168987862F,
-    0.6178354318F, 0.6187714223F, 0.6197067535F, 0.6206414213F,
-    0.6215754215F, 0.6225087501F, 0.6234414028F, 0.6243733757F,
-    0.6253046646F, 0.6262352654F, 0.6271651739F, 0.6280943862F,
-    0.6290228982F, 0.6299507057F, 0.6308778048F, 0.6318041913F,
-    0.6327298612F, 0.6336548105F, 0.6345790352F, 0.6355025312F,
-    0.6364252945F, 0.6373473211F, 0.6382686070F, 0.6391891483F,
-    0.6401089409F, 0.6410279808F, 0.6419462642F, 0.6428637869F,
-    0.6437805452F, 0.6446965350F, 0.6456117524F, 0.6465261935F,
-    0.6474398544F, 0.6483527311F, 0.6492648197F, 0.6501761165F,
-    0.6510866174F, 0.6519963186F, 0.6529052162F, 0.6538133064F,
-    0.6547205854F, 0.6556270492F, 0.6565326941F, 0.6574375162F,
-    0.6583415117F, 0.6592446769F, 0.6601470079F, 0.6610485009F,
-    0.6619491521F, 0.6628489578F, 0.6637479143F, 0.6646460177F,
-    0.6655432643F, 0.6664396505F, 0.6673351724F, 0.6682298264F,
-    0.6691236087F, 0.6700165157F, 0.6709085436F, 0.6717996889F,
-    0.6726899478F, 0.6735793167F, 0.6744677918F, 0.6753553697F,
-    0.6762420466F, 0.6771278190F, 0.6780126832F, 0.6788966357F,
-    0.6797796728F, 0.6806617909F, 0.6815429866F, 0.6824232562F,
-    0.6833025961F, 0.6841810030F, 0.6850584731F, 0.6859350031F,
-    0.6868105894F, 0.6876852284F, 0.6885589168F, 0.6894316510F,
-    0.6903034275F, 0.6911742430F, 0.6920440939F, 0.6929129769F,
-    0.6937808884F, 0.6946478251F, 0.6955137837F, 0.6963787606F,
-    0.6972427525F, 0.6981057560F, 0.6989677678F, 0.6998287845F,
-    0.7006888028F, 0.7015478194F, 0.7024058309F, 0.7032628340F,
-    0.7041188254F, 0.7049738019F, 0.7058277601F, 0.7066806969F,
-    0.7075326089F, 0.7083834929F, 0.7092333457F, 0.7100821640F,
-    0.7109299447F, 0.7117766846F, 0.7126223804F, 0.7134670291F,
-    0.7143106273F, 0.7151531721F, 0.7159946602F, 0.7168350885F,
-    0.7176744539F, 0.7185127534F, 0.7193499837F, 0.7201861418F,
-    0.7210212247F, 0.7218552293F, 0.7226881526F, 0.7235199914F,
-    0.7243507428F, 0.7251804039F, 0.7260089715F, 0.7268364426F,
-    0.7276628144F, 0.7284880839F, 0.7293122481F, 0.7301353040F,
-    0.7309572487F, 0.7317780794F, 0.7325977930F, 0.7334163868F,
-    0.7342338579F, 0.7350502033F, 0.7358654202F, 0.7366795059F,
-    0.7374924573F, 0.7383042718F, 0.7391149465F, 0.7399244787F,
-    0.7407328655F, 0.7415401041F, 0.7423461920F, 0.7431511261F,
-    0.7439549040F, 0.7447575227F, 0.7455589797F, 0.7463592723F,
-    0.7471583976F, 0.7479563532F, 0.7487531363F, 0.7495487443F,
-    0.7503431745F, 0.7511364244F, 0.7519284913F, 0.7527193726F,
-    0.7535090658F, 0.7542975683F, 0.7550848776F, 0.7558709910F,
-    0.7566559062F, 0.7574396205F, 0.7582221314F, 0.7590034366F,
-    0.7597835334F, 0.7605624194F, 0.7613400923F, 0.7621165495F,
-    0.7628917886F, 0.7636658072F, 0.7644386030F, 0.7652101735F,
-    0.7659805164F, 0.7667496292F, 0.7675175098F, 0.7682841556F,
-    0.7690495645F, 0.7698137341F, 0.7705766622F, 0.7713383463F,
-    0.7720987844F, 0.7728579741F, 0.7736159132F, 0.7743725994F,
-    0.7751280306F, 0.7758822046F, 0.7766351192F, 0.7773867722F,
-    0.7781371614F, 0.7788862848F, 0.7796341401F, 0.7803807253F,
-    0.7811260383F, 0.7818700769F, 0.7826128392F, 0.7833543230F,
-    0.7840945263F, 0.7848334471F, 0.7855710833F, 0.7863074330F,
-    0.7870424941F, 0.7877762647F, 0.7885087428F, 0.7892399264F,
-    0.7899698137F, 0.7906984026F, 0.7914256914F, 0.7921516780F,
-    0.7928763607F, 0.7935997375F, 0.7943218065F, 0.7950425661F,
-    0.7957620142F, 0.7964801492F, 0.7971969692F, 0.7979124724F,
-    0.7986266570F, 0.7993395214F, 0.8000510638F, 0.8007612823F,
-    0.8014701754F, 0.8021777413F, 0.8028839784F, 0.8035888849F,
-    0.8042924592F, 0.8049946997F, 0.8056956048F, 0.8063951727F,
-    0.8070934020F, 0.8077902910F, 0.8084858381F, 0.8091800419F,
-    0.8098729007F, 0.8105644130F, 0.8112545774F, 0.8119433922F,
-    0.8126308561F, 0.8133169676F, 0.8140017251F, 0.8146851272F,
-    0.8153671726F, 0.8160478598F, 0.8167271874F, 0.8174051539F,
-    0.8180817582F, 0.8187569986F, 0.8194308741F, 0.8201033831F,
-    0.8207745244F, 0.8214442966F, 0.8221126986F, 0.8227797290F,
-    0.8234453865F, 0.8241096700F, 0.8247725781F, 0.8254341097F,
-    0.8260942636F, 0.8267530385F, 0.8274104334F, 0.8280664470F,
-    0.8287210782F, 0.8293743259F, 0.8300261889F, 0.8306766662F,
-    0.8313257566F, 0.8319734591F, 0.8326197727F, 0.8332646963F,
-    0.8339082288F, 0.8345503692F, 0.8351911167F, 0.8358304700F,
-    0.8364684284F, 0.8371049907F, 0.8377401562F, 0.8383739238F,
-    0.8390062927F, 0.8396372618F, 0.8402668305F, 0.8408949977F,
-    0.8415217626F, 0.8421471245F, 0.8427710823F, 0.8433936354F,
-    0.8440147830F, 0.8446345242F, 0.8452528582F, 0.8458697844F,
-    0.8464853020F, 0.8470994102F, 0.8477121084F, 0.8483233958F,
-    0.8489332718F, 0.8495417356F, 0.8501487866F, 0.8507544243F,
-    0.8513586479F, 0.8519614568F, 0.8525628505F, 0.8531628283F,
-    0.8537613897F, 0.8543585341F, 0.8549542611F, 0.8555485699F,
-    0.8561414603F, 0.8567329315F, 0.8573229832F, 0.8579116149F,
-    0.8584988262F, 0.8590846165F, 0.8596689855F, 0.8602519327F,
-    0.8608334577F, 0.8614135603F, 0.8619922399F, 0.8625694962F,
-    0.8631453289F, 0.8637197377F, 0.8642927222F, 0.8648642821F,
-    0.8654344172F, 0.8660031272F, 0.8665704118F, 0.8671362708F,
-    0.8677007039F, 0.8682637109F, 0.8688252917F, 0.8693854460F,
-    0.8699441737F, 0.8705014745F, 0.8710573485F, 0.8716117953F,
-    0.8721648150F, 0.8727164073F, 0.8732665723F, 0.8738153098F,
-    0.8743626197F, 0.8749085021F, 0.8754529569F, 0.8759959840F,
-    0.8765375835F, 0.8770777553F, 0.8776164996F, 0.8781538162F,
-    0.8786897054F, 0.8792241670F, 0.8797572013F, 0.8802888082F,
-    0.8808189880F, 0.8813477407F, 0.8818750664F, 0.8824009653F,
-    0.8829254375F, 0.8834484833F, 0.8839701028F, 0.8844902961F,
-    0.8850090636F, 0.8855264054F, 0.8860423218F, 0.8865568131F,
-    0.8870698794F, 0.8875815212F, 0.8880917386F, 0.8886005319F,
-    0.8891079016F, 0.8896138479F, 0.8901183712F, 0.8906214719F,
-    0.8911231503F, 0.8916234067F, 0.8921222417F, 0.8926196556F,
-    0.8931156489F, 0.8936102219F, 0.8941033752F, 0.8945951092F,
-    0.8950854244F, 0.8955743212F, 0.8960618003F, 0.8965478621F,
-    0.8970325071F, 0.8975157359F, 0.8979975490F, 0.8984779471F,
-    0.8989569307F, 0.8994345004F, 0.8999106568F, 0.9003854005F,
-    0.9008587323F, 0.9013306526F, 0.9018011623F, 0.9022702619F,
-    0.9027379521F, 0.9032042337F, 0.9036691074F, 0.9041325739F,
-    0.9045946339F, 0.9050552882F, 0.9055145376F, 0.9059723828F,
-    0.9064288246F, 0.9068838638F, 0.9073375013F, 0.9077897379F,
-    0.9082405743F, 0.9086900115F, 0.9091380503F, 0.9095846917F,
-    0.9100299364F, 0.9104737854F, 0.9109162397F, 0.9113573001F,
-    0.9117969675F, 0.9122352430F, 0.9126721275F, 0.9131076219F,
-    0.9135417273F, 0.9139744447F, 0.9144057750F, 0.9148357194F,
-    0.9152642787F, 0.9156914542F, 0.9161172468F, 0.9165416576F,
-    0.9169646877F, 0.9173863382F, 0.9178066102F, 0.9182255048F,
-    0.9186430232F, 0.9190591665F, 0.9194739359F, 0.9198873324F,
-    0.9202993574F, 0.9207100120F, 0.9211192973F, 0.9215272147F,
-    0.9219337653F, 0.9223389504F, 0.9227427713F, 0.9231452290F,
-    0.9235463251F, 0.9239460607F, 0.9243444371F, 0.9247414557F,
-    0.9251371177F, 0.9255314245F, 0.9259243774F, 0.9263159778F,
-    0.9267062270F, 0.9270951264F, 0.9274826774F, 0.9278688814F,
-    0.9282537398F, 0.9286372540F, 0.9290194254F, 0.9294002555F,
-    0.9297797458F, 0.9301578976F, 0.9305347125F, 0.9309101919F,
-    0.9312843373F, 0.9316571503F, 0.9320286323F, 0.9323987849F,
-    0.9327676097F, 0.9331351080F, 0.9335012816F, 0.9338661320F,
-    0.9342296607F, 0.9345918694F, 0.9349527596F, 0.9353123330F,
-    0.9356705911F, 0.9360275357F, 0.9363831683F, 0.9367374905F,
-    0.9370905042F, 0.9374422108F, 0.9377926122F, 0.9381417099F,
-    0.9384895057F, 0.9388360014F, 0.9391811985F, 0.9395250989F,
-    0.9398677043F, 0.9402090165F, 0.9405490371F, 0.9408877680F,
-    0.9412252110F, 0.9415613678F, 0.9418962402F, 0.9422298301F,
-    0.9425621392F, 0.9428931695F, 0.9432229226F, 0.9435514005F,
-    0.9438786050F, 0.9442045381F, 0.9445292014F, 0.9448525971F,
-    0.9451747268F, 0.9454955926F, 0.9458151963F, 0.9461335399F,
-    0.9464506253F, 0.9467664545F, 0.9470810293F, 0.9473943517F,
-    0.9477064238F, 0.9480172474F, 0.9483268246F, 0.9486351573F,
-    0.9489422475F, 0.9492480973F, 0.9495527087F, 0.9498560837F,
-    0.9501582243F, 0.9504591325F, 0.9507588105F, 0.9510572603F,
-    0.9513544839F, 0.9516504834F, 0.9519452609F, 0.9522388186F,
-    0.9525311584F, 0.9528222826F, 0.9531121932F, 0.9534008923F,
-    0.9536883821F, 0.9539746647F, 0.9542597424F, 0.9545436171F,
-    0.9548262912F, 0.9551077667F, 0.9553880459F, 0.9556671309F,
-    0.9559450239F, 0.9562217272F, 0.9564972429F, 0.9567715733F,
-    0.9570447206F, 0.9573166871F, 0.9575874749F, 0.9578570863F,
-    0.9581255236F, 0.9583927890F, 0.9586588849F, 0.9589238134F,
-    0.9591875769F, 0.9594501777F, 0.9597116180F, 0.9599719003F,
-    0.9602310267F, 0.9604889995F, 0.9607458213F, 0.9610014942F,
-    0.9612560206F, 0.9615094028F, 0.9617616433F, 0.9620127443F,
-    0.9622627083F, 0.9625115376F, 0.9627592345F, 0.9630058016F,
-    0.9632512411F, 0.9634955555F, 0.9637387471F, 0.9639808185F,
-    0.9642217720F, 0.9644616100F, 0.9647003349F, 0.9649379493F,
-    0.9651744556F, 0.9654098561F, 0.9656441534F, 0.9658773499F,
-    0.9661094480F, 0.9663404504F, 0.9665703593F, 0.9667991774F,
-    0.9670269071F, 0.9672535509F, 0.9674791114F, 0.9677035909F,
-    0.9679269921F, 0.9681493174F, 0.9683705694F, 0.9685907506F,
-    0.9688098636F, 0.9690279108F, 0.9692448948F, 0.9694608182F,
-    0.9696756836F, 0.9698894934F, 0.9701022503F, 0.9703139569F,
-    0.9705246156F, 0.9707342291F, 0.9709428000F, 0.9711503309F,
-    0.9713568243F, 0.9715622829F, 0.9717667093F, 0.9719701060F,
-    0.9721724757F, 0.9723738210F, 0.9725741446F, 0.9727734490F,
-    0.9729717369F, 0.9731690109F, 0.9733652737F, 0.9735605279F,
-    0.9737547762F, 0.9739480212F, 0.9741402656F, 0.9743315120F,
-    0.9745217631F, 0.9747110216F, 0.9748992901F, 0.9750865714F,
-    0.9752728681F, 0.9754581829F, 0.9756425184F, 0.9758258775F,
-    0.9760082627F, 0.9761896768F, 0.9763701224F, 0.9765496024F,
-    0.9767281193F, 0.9769056760F, 0.9770822751F, 0.9772579193F,
-    0.9774326114F, 0.9776063542F, 0.9777791502F, 0.9779510023F,
-    0.9781219133F, 0.9782918858F, 0.9784609226F, 0.9786290264F,
-    0.9787962000F, 0.9789624461F, 0.9791277676F, 0.9792921671F,
-    0.9794556474F, 0.9796182113F, 0.9797798615F, 0.9799406009F,
-    0.9801004321F, 0.9802593580F, 0.9804173813F, 0.9805745049F,
-    0.9807307314F, 0.9808860637F, 0.9810405046F, 0.9811940568F,
-    0.9813467232F, 0.9814985065F, 0.9816494095F, 0.9817994351F,
-    0.9819485860F, 0.9820968650F, 0.9822442750F, 0.9823908186F,
-    0.9825364988F, 0.9826813184F, 0.9828252801F, 0.9829683868F,
-    0.9831106413F, 0.9832520463F, 0.9833926048F, 0.9835323195F,
-    0.9836711932F, 0.9838092288F, 0.9839464291F, 0.9840827969F,
-    0.9842183351F, 0.9843530464F, 0.9844869337F, 0.9846199998F,
-    0.9847522475F, 0.9848836798F, 0.9850142993F, 0.9851441090F,
-    0.9852731117F, 0.9854013101F, 0.9855287073F, 0.9856553058F,
-    0.9857811087F, 0.9859061188F, 0.9860303388F, 0.9861537717F,
-    0.9862764202F, 0.9863982872F, 0.9865193756F, 0.9866396882F,
-    0.9867592277F, 0.9868779972F, 0.9869959993F, 0.9871132370F,
-    0.9872297131F, 0.9873454304F, 0.9874603918F, 0.9875746001F,
-    0.9876880581F, 0.9878007688F, 0.9879127348F, 0.9880239592F,
-    0.9881344447F, 0.9882441941F, 0.9883532104F, 0.9884614962F,
-    0.9885690546F, 0.9886758883F, 0.9887820001F, 0.9888873930F,
-    0.9889920697F, 0.9890960331F, 0.9891992859F, 0.9893018312F,
-    0.9894036716F, 0.9895048100F, 0.9896052493F, 0.9897049923F,
-    0.9898040418F, 0.9899024006F, 0.9900000717F, 0.9900970577F,
-    0.9901933616F, 0.9902889862F, 0.9903839343F, 0.9904782087F,
-    0.9905718122F, 0.9906647477F, 0.9907570180F, 0.9908486259F,
-    0.9909395742F, 0.9910298658F, 0.9911195034F, 0.9912084899F,
-    0.9912968281F, 0.9913845208F, 0.9914715708F, 0.9915579810F,
-    0.9916437540F, 0.9917288928F, 0.9918134001F, 0.9918972788F,
-    0.9919805316F, 0.9920631613F, 0.9921451707F, 0.9922265626F,
-    0.9923073399F, 0.9923875052F, 0.9924670615F, 0.9925460114F,
-    0.9926243577F, 0.9927021033F, 0.9927792508F, 0.9928558032F,
-    0.9929317631F, 0.9930071333F, 0.9930819167F, 0.9931561158F,
-    0.9932297337F, 0.9933027728F, 0.9933752362F, 0.9934471264F,
-    0.9935184462F, 0.9935891985F, 0.9936593859F, 0.9937290112F,
-    0.9937980771F, 0.9938665864F, 0.9939345418F, 0.9940019460F,
-    0.9940688018F, 0.9941351118F, 0.9942008789F, 0.9942661057F,
-    0.9943307950F, 0.9943949494F, 0.9944585717F, 0.9945216645F,
-    0.9945842307F, 0.9946462728F, 0.9947077936F, 0.9947687957F,
-    0.9948292820F, 0.9948892550F, 0.9949487174F, 0.9950076719F,
-    0.9950661212F, 0.9951240679F, 0.9951815148F, 0.9952384645F,
-    0.9952949196F, 0.9953508828F, 0.9954063568F, 0.9954613442F,
-    0.9955158476F, 0.9955698697F, 0.9956234132F, 0.9956764806F,
-    0.9957290746F, 0.9957811978F, 0.9958328528F, 0.9958840423F,
-    0.9959347688F, 0.9959850351F, 0.9960348435F, 0.9960841969F,
-    0.9961330977F, 0.9961815486F, 0.9962295521F, 0.9962771108F,
-    0.9963242274F, 0.9963709043F, 0.9964171441F, 0.9964629494F,
-    0.9965083228F, 0.9965532668F, 0.9965977840F, 0.9966418768F,
-    0.9966855479F, 0.9967287998F, 0.9967716350F, 0.9968140559F,
-    0.9968560653F, 0.9968976655F, 0.9969388591F, 0.9969796485F,
-    0.9970200363F, 0.9970600250F, 0.9970996170F, 0.9971388149F,
-    0.9971776211F, 0.9972160380F, 0.9972540683F, 0.9972917142F,
-    0.9973289783F, 0.9973658631F, 0.9974023709F, 0.9974385042F,
-    0.9974742655F, 0.9975096571F, 0.9975446816F, 0.9975793413F,
-    0.9976136386F, 0.9976475759F, 0.9976811557F, 0.9977143803F,
-    0.9977472521F, 0.9977797736F, 0.9978119470F, 0.9978437748F,
-    0.9978752593F, 0.9979064029F, 0.9979372079F, 0.9979676768F,
-    0.9979978117F, 0.9980276151F, 0.9980570893F, 0.9980862367F,
-    0.9981150595F, 0.9981435600F, 0.9981717406F, 0.9981996035F,
-    0.9982271511F, 0.9982543856F, 0.9982813093F, 0.9983079246F,
-    0.9983342336F, 0.9983602386F, 0.9983859418F, 0.9984113456F,
-    0.9984364522F, 0.9984612638F, 0.9984857825F, 0.9985100108F,
-    0.9985339507F, 0.9985576044F, 0.9985809743F, 0.9986040624F,
-    0.9986268710F, 0.9986494022F, 0.9986716583F, 0.9986936413F,
-    0.9987153535F, 0.9987367969F, 0.9987579738F, 0.9987788864F,
-    0.9987995366F, 0.9988199267F, 0.9988400587F, 0.9988599348F,
-    0.9988795572F, 0.9988989278F, 0.9989180487F, 0.9989369222F,
-    0.9989555501F, 0.9989739347F, 0.9989920780F, 0.9990099820F,
-    0.9990276487F, 0.9990450803F, 0.9990622787F, 0.9990792460F,
-    0.9990959841F, 0.9991124952F, 0.9991287812F, 0.9991448440F,
-    0.9991606858F, 0.9991763084F, 0.9991917139F, 0.9992069042F,
-    0.9992218813F, 0.9992366471F, 0.9992512035F, 0.9992655525F,
-    0.9992796961F, 0.9992936361F, 0.9993073744F, 0.9993209131F,
-    0.9993342538F, 0.9993473987F, 0.9993603494F, 0.9993731080F,
-    0.9993856762F, 0.9993980559F, 0.9994102490F, 0.9994222573F,
-    0.9994340827F, 0.9994457269F, 0.9994571918F, 0.9994684793F,
-    0.9994795910F, 0.9994905288F, 0.9995012945F, 0.9995118898F,
-    0.9995223165F, 0.9995325765F, 0.9995426713F, 0.9995526029F,
-    0.9995623728F, 0.9995719829F, 0.9995814349F, 0.9995907304F,
-    0.9995998712F, 0.9996088590F, 0.9996176954F, 0.9996263821F,
-    0.9996349208F, 0.9996433132F, 0.9996515609F, 0.9996596656F,
-    0.9996676288F, 0.9996754522F, 0.9996831375F, 0.9996906862F,
-    0.9996981000F, 0.9997053804F, 0.9997125290F, 0.9997195474F,
-    0.9997264371F, 0.9997331998F, 0.9997398369F, 0.9997463500F,
-    0.9997527406F, 0.9997590103F, 0.9997651606F, 0.9997711930F,
-    0.9997771089F, 0.9997829098F, 0.9997885973F, 0.9997941728F,
-    0.9997996378F, 0.9998049936F, 0.9998102419F, 0.9998153839F,
-    0.9998204211F, 0.9998253550F, 0.9998301868F, 0.9998349182F,
-    0.9998395503F, 0.9998440847F, 0.9998485226F, 0.9998528654F,
-    0.9998571146F, 0.9998612713F, 0.9998653370F, 0.9998693130F,
-    0.9998732007F, 0.9998770012F, 0.9998807159F, 0.9998843461F,
-    0.9998878931F, 0.9998913581F, 0.9998947424F, 0.9998980473F,
-    0.9999012740F, 0.9999044237F, 0.9999074976F, 0.9999104971F,
-    0.9999134231F, 0.9999162771F, 0.9999190601F, 0.9999217733F,
-    0.9999244179F, 0.9999269950F, 0.9999295058F, 0.9999319515F,
-    0.9999343332F, 0.9999366519F, 0.9999389088F, 0.9999411050F,
-    0.9999432416F, 0.9999453196F, 0.9999473402F, 0.9999493044F,
-    0.9999512132F, 0.9999530677F, 0.9999548690F, 0.9999566180F,
-    0.9999583157F, 0.9999599633F, 0.9999615616F, 0.9999631116F,
-    0.9999646144F, 0.9999660709F, 0.9999674820F, 0.9999688487F,
-    0.9999701719F, 0.9999714526F, 0.9999726917F, 0.9999738900F,
-    0.9999750486F, 0.9999761682F, 0.9999772497F, 0.9999782941F,
-    0.9999793021F, 0.9999802747F, 0.9999812126F, 0.9999821167F,
-    0.9999829878F, 0.9999838268F, 0.9999846343F, 0.9999854113F,
-    0.9999861584F, 0.9999868765F, 0.9999875664F, 0.9999882287F,
-    0.9999888642F, 0.9999894736F, 0.9999900577F, 0.9999906172F,
-    0.9999911528F, 0.9999916651F, 0.9999921548F, 0.9999926227F,
-    0.9999930693F, 0.9999934954F, 0.9999939015F, 0.9999942883F,
-    0.9999946564F, 0.9999950064F, 0.9999953390F, 0.9999956547F,
-    0.9999959541F, 0.9999962377F, 0.9999965062F, 0.9999967601F,
-    0.9999969998F, 0.9999972260F, 0.9999974392F, 0.9999976399F,
-    0.9999978285F, 0.9999980056F, 0.9999981716F, 0.9999983271F,
-    0.9999984724F, 0.9999986081F, 0.9999987345F, 0.9999988521F,
-    0.9999989613F, 0.9999990625F, 0.9999991562F, 0.9999992426F,
-    0.9999993223F, 0.9999993954F, 0.9999994625F, 0.9999995239F,
-    0.9999995798F, 0.9999996307F, 0.9999996768F, 0.9999997184F,
-    0.9999997559F, 0.9999997895F, 0.9999998195F, 0.9999998462F,
-    0.9999998698F, 0.9999998906F, 0.9999999088F, 0.9999999246F,
-    0.9999999383F, 0.9999999500F, 0.9999999600F, 0.9999999684F,
-    0.9999999754F, 0.9999999811F, 0.9999999858F, 0.9999999896F,
-    0.9999999925F, 0.9999999948F, 0.9999999965F, 0.9999999978F,
-    0.9999999986F, 0.9999999992F, 0.9999999996F, 0.9999999998F,
-    0.9999999999F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
-};
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin4096)[2048] = {
+    Q31(0.0000002310F),Q31(0.0000020791F),Q31(0.0000057754F),Q31(0.0000113197F),
+    Q31(0.0000187121F),Q31(0.0000279526F),Q31(0.0000390412F),Q31(0.0000519777F),
+    Q31(0.0000667623F),Q31(0.0000833949F),Q31(0.0001018753F),Q31(0.0001222036F),
+    Q31(0.0001443798F),Q31(0.0001684037F),Q31(0.0001942754F),Q31(0.0002219947F),
+    Q31(0.0002515616F),Q31(0.0002829761F),Q31(0.0003162380F),Q31(0.0003513472F),
+    Q31(0.0003883038F),Q31(0.0004271076F),Q31(0.0004677584F),Q31(0.0005102563F),
+    Q31(0.0005546011F),Q31(0.0006007928F),Q31(0.0006488311F),Q31(0.0006987160F),
+    Q31(0.0007504474F),Q31(0.0008040251F),Q31(0.0008594490F),Q31(0.0009167191F),
+    Q31(0.0009758351F),Q31(0.0010367969F),Q31(0.0010996044F),Q31(0.0011642574F),
+    Q31(0.0012307558F),Q31(0.0012990994F),Q31(0.0013692880F),Q31(0.0014413216F),
+    Q31(0.0015151998F),Q31(0.0015909226F),Q31(0.0016684898F),Q31(0.0017479011F),
+    Q31(0.0018291565F),Q31(0.0019122556F),Q31(0.0019971983F),Q31(0.0020839845F),
+    Q31(0.0021726138F),Q31(0.0022630861F),Q31(0.0023554012F),Q31(0.0024495588F),
+    Q31(0.0025455588F),Q31(0.0026434008F),Q31(0.0027430847F),Q31(0.0028446103F),
+    Q31(0.0029479772F),Q31(0.0030531853F),Q31(0.0031602342F),Q31(0.0032691238F),
+    Q31(0.0033798538F),Q31(0.0034924239F),Q31(0.0036068338F),Q31(0.0037230833F),
+    Q31(0.0038411721F),Q31(0.0039610999F),Q31(0.0040828664F),Q31(0.0042064714F),
+    Q31(0.0043319145F),Q31(0.0044591954F),Q31(0.0045883139F),Q31(0.0047192696F),
+    Q31(0.0048520622F),Q31(0.0049866914F),Q31(0.0051231569F),Q31(0.0052614583F),
+    Q31(0.0054015953F),Q31(0.0055435676F),Q31(0.0056873748F),Q31(0.0058330166F),
+    Q31(0.0059804926F),Q31(0.0061298026F),Q31(0.0062809460F),Q31(0.0064339226F),
+    Q31(0.0065887320F),Q31(0.0067453738F),Q31(0.0069038476F),Q31(0.0070641531F),
+    Q31(0.0072262899F),Q31(0.0073902575F),Q31(0.0075560556F),Q31(0.0077236838F),
+    Q31(0.0078931417F),Q31(0.0080644288F),Q31(0.0082375447F),Q31(0.0084124891F),
+    Q31(0.0085892615F),Q31(0.0087678614F),Q31(0.0089482885F),Q31(0.0091305422F),
+    Q31(0.0093146223F),Q31(0.0095005281F),Q31(0.0096882592F),Q31(0.0098778153F),
+    Q31(0.0100691958F),Q31(0.0102624002F),Q31(0.0104574281F),Q31(0.0106542791F),
+    Q31(0.0108529525F),Q31(0.0110534480F),Q31(0.0112557651F),Q31(0.0114599032F),
+    Q31(0.0116658618F),Q31(0.0118736405F),Q31(0.0120832387F),Q31(0.0122946560F),
+    Q31(0.0125078917F),Q31(0.0127229454F),Q31(0.0129398166F),Q31(0.0131585046F),
+    Q31(0.0133790090F),Q31(0.0136013292F),Q31(0.0138254647F),Q31(0.0140514149F),
+    Q31(0.0142791792F),Q31(0.0145087572F),Q31(0.0147401481F),Q31(0.0149733515F),
+    Q31(0.0152083667F),Q31(0.0154451932F),Q31(0.0156838304F),Q31(0.0159242777F),
+    Q31(0.0161665345F),Q31(0.0164106001F),Q31(0.0166564741F),Q31(0.0169041557F),
+    Q31(0.0171536443F),Q31(0.0174049393F),Q31(0.0176580401F),Q31(0.0179129461F),
+    Q31(0.0181696565F),Q31(0.0184281708F),Q31(0.0186884883F),Q31(0.0189506084F),
+    Q31(0.0192145303F),Q31(0.0194802535F),Q31(0.0197477772F),Q31(0.0200171008F),
+    Q31(0.0202882236F),Q31(0.0205611449F),Q31(0.0208358639F),Q31(0.0211123801F),
+    Q31(0.0213906927F),Q31(0.0216708011F),Q31(0.0219527043F),Q31(0.0222364019F),
+    Q31(0.0225218930F),Q31(0.0228091769F),Q31(0.0230982529F),Q31(0.0233891203F),
+    Q31(0.0236817782F),Q31(0.0239762259F),Q31(0.0242724628F),Q31(0.0245704880F),
+    Q31(0.0248703007F),Q31(0.0251719002F),Q31(0.0254752858F),Q31(0.0257804565F),
+    Q31(0.0260874117F),Q31(0.0263961506F),Q31(0.0267066722F),Q31(0.0270189760F),
+    Q31(0.0273330609F),Q31(0.0276489263F),Q31(0.0279665712F),Q31(0.0282859949F),
+    Q31(0.0286071966F),Q31(0.0289301753F),Q31(0.0292549303F),Q31(0.0295814607F),
+    Q31(0.0299097656F),Q31(0.0302398442F),Q31(0.0305716957F),Q31(0.0309053191F),
+    Q31(0.0312407135F),Q31(0.0315778782F),Q31(0.0319168122F),Q31(0.0322575145F),
+    Q31(0.0325999844F),Q31(0.0329442209F),Q31(0.0332902231F),Q31(0.0336379900F),
+    Q31(0.0339875208F),Q31(0.0343388146F),Q31(0.0346918703F),Q31(0.0350466871F),
+    Q31(0.0354032640F),Q31(0.0357616000F),Q31(0.0361216943F),Q31(0.0364835458F),
+    Q31(0.0368471535F),Q31(0.0372125166F),Q31(0.0375796339F),Q31(0.0379485046F),
+    Q31(0.0383191276F),Q31(0.0386915020F),Q31(0.0390656267F),Q31(0.0394415008F),
+    Q31(0.0398191231F),Q31(0.0401984927F),Q31(0.0405796086F),Q31(0.0409624698F),
+    Q31(0.0413470751F),Q31(0.0417334235F),Q31(0.0421215141F),Q31(0.0425113457F),
+    Q31(0.0429029172F),Q31(0.0432962277F),Q31(0.0436912760F),Q31(0.0440880610F),
+    Q31(0.0444865817F),Q31(0.0448868370F),Q31(0.0452888257F),Q31(0.0456925468F),
+    Q31(0.0460979992F),Q31(0.0465051816F),Q31(0.0469140931F),Q31(0.0473247325F),
+    Q31(0.0477370986F),Q31(0.0481511902F),Q31(0.0485670064F),Q31(0.0489845458F),
+    Q31(0.0494038074F),Q31(0.0498247899F),Q31(0.0502474922F),Q31(0.0506719131F),
+    Q31(0.0510980514F),Q31(0.0515259060F),Q31(0.0519554756F),Q31(0.0523867590F),
+    Q31(0.0528197550F),Q31(0.0532544624F),Q31(0.0536908800F),Q31(0.0541290066F),
+    Q31(0.0545688408F),Q31(0.0550103815F),Q31(0.0554536274F),Q31(0.0558985772F),
+    Q31(0.0563452297F),Q31(0.0567935837F),Q31(0.0572436377F),Q31(0.0576953907F),
+    Q31(0.0581488412F),Q31(0.0586039880F),Q31(0.0590608297F),Q31(0.0595193651F),
+    Q31(0.0599795929F),Q31(0.0604415117F),Q31(0.0609051202F),Q31(0.0613704170F),
+    Q31(0.0618374009F),Q31(0.0623060704F),Q31(0.0627764243F),Q31(0.0632484611F),
+    Q31(0.0637221795F),Q31(0.0641975781F),Q31(0.0646746555F),Q31(0.0651534104F),
+    Q31(0.0656338413F),Q31(0.0661159469F),Q31(0.0665997257F),Q31(0.0670851763F),
+    Q31(0.0675722973F),Q31(0.0680610873F),Q31(0.0685515448F),Q31(0.0690436684F),
+    Q31(0.0695374567F),Q31(0.0700329081F),Q31(0.0705300213F),Q31(0.0710287947F),
+    Q31(0.0715292269F),Q31(0.0720313163F),Q31(0.0725350616F),Q31(0.0730404612F),
+    Q31(0.0735475136F),Q31(0.0740562172F),Q31(0.0745665707F),Q31(0.0750785723F),
+    Q31(0.0755922207F),Q31(0.0761075143F),Q31(0.0766244515F),Q31(0.0771430307F),
+    Q31(0.0776632505F),Q31(0.0781851092F),Q31(0.0787086052F),Q31(0.0792337371F),
+    Q31(0.0797605032F),Q31(0.0802889018F),Q31(0.0808189315F),Q31(0.0813505905F),
+    Q31(0.0818838773F),Q31(0.0824187903F),Q31(0.0829553277F),Q31(0.0834934881F),
+    Q31(0.0840332697F),Q31(0.0845746708F),Q31(0.0851176899F),Q31(0.0856623252F),
+    Q31(0.0862085751F),Q31(0.0867564379F),Q31(0.0873059119F),Q31(0.0878569954F),
+    Q31(0.0884096867F),Q31(0.0889639840F),Q31(0.0895198858F),Q31(0.0900773902F),
+    Q31(0.0906364955F),Q31(0.0911972000F),Q31(0.0917595019F),Q31(0.0923233995F),
+    Q31(0.0928888909F),Q31(0.0934559745F),Q31(0.0940246485F),Q31(0.0945949110F),
+    Q31(0.0951667604F),Q31(0.0957401946F),Q31(0.0963152121F),Q31(0.0968918109F),
+    Q31(0.0974699893F),Q31(0.0980497454F),Q31(0.0986310773F),Q31(0.0992139832F),
+    Q31(0.0997984614F),Q31(0.1003845098F),Q31(0.1009721267F),Q31(0.1015613101F),
+    Q31(0.1021520582F),Q31(0.1027443692F),Q31(0.1033382410F),Q31(0.1039336718F),
+    Q31(0.1045306597F),Q31(0.1051292027F),Q31(0.1057292990F),Q31(0.1063309466F),
+    Q31(0.1069341435F),Q31(0.1075388878F),Q31(0.1081451776F),Q31(0.1087530108F),
+    Q31(0.1093623856F),Q31(0.1099732998F),Q31(0.1105857516F),Q31(0.1111997389F),
+    Q31(0.1118152597F),Q31(0.1124323121F),Q31(0.1130508939F),Q31(0.1136710032F),
+    Q31(0.1142926379F),Q31(0.1149157960F),Q31(0.1155404755F),Q31(0.1161666742F),
+    Q31(0.1167943901F),Q31(0.1174236211F),Q31(0.1180543652F),Q31(0.1186866202F),
+    Q31(0.1193203841F),Q31(0.1199556548F),Q31(0.1205924300F),Q31(0.1212307078F),
+    Q31(0.1218704860F),Q31(0.1225117624F),Q31(0.1231545349F),Q31(0.1237988013F),
+    Q31(0.1244445596F),Q31(0.1250918074F),Q31(0.1257405427F),Q31(0.1263907632F),
+    Q31(0.1270424667F),Q31(0.1276956512F),Q31(0.1283503142F),Q31(0.1290064537F),
+    Q31(0.1296640674F),Q31(0.1303231530F),Q31(0.1309837084F),Q31(0.1316457312F),
+    Q31(0.1323092193F),Q31(0.1329741703F),Q31(0.1336405820F),Q31(0.1343084520F),
+    Q31(0.1349777782F),Q31(0.1356485582F),Q31(0.1363207897F),Q31(0.1369944704F),
+    Q31(0.1376695979F),Q31(0.1383461700F),Q31(0.1390241842F),Q31(0.1397036384F),
+    Q31(0.1403845300F),Q31(0.1410668567F),Q31(0.1417506162F),Q31(0.1424358061F),
+    Q31(0.1431224240F),Q31(0.1438104674F),Q31(0.1444999341F),Q31(0.1451908216F),
+    Q31(0.1458831274F),Q31(0.1465768492F),Q31(0.1472719844F),Q31(0.1479685308F),
+    Q31(0.1486664857F),Q31(0.1493658468F),Q31(0.1500666115F),Q31(0.1507687775F),
+    Q31(0.1514723422F),Q31(0.1521773031F),Q31(0.1528836577F),Q31(0.1535914035F),
+    Q31(0.1543005380F),Q31(0.1550110587F),Q31(0.1557229631F),Q31(0.1564362485F),
+    Q31(0.1571509124F),Q31(0.1578669524F),Q31(0.1585843657F),Q31(0.1593031499F),
+    Q31(0.1600233024F),Q31(0.1607448205F),Q31(0.1614677017F),Q31(0.1621919433F),
+    Q31(0.1629175428F),Q31(0.1636444975F),Q31(0.1643728047F),Q31(0.1651024619F),
+    Q31(0.1658334665F),Q31(0.1665658156F),Q31(0.1672995067F),Q31(0.1680345371F),
+    Q31(0.1687709041F),Q31(0.1695086050F),Q31(0.1702476372F),Q31(0.1709879978F),
+    Q31(0.1717296843F),Q31(0.1724726938F),Q31(0.1732170237F),Q31(0.1739626711F),
+    Q31(0.1747096335F),Q31(0.1754579079F),Q31(0.1762074916F),Q31(0.1769583819F),
+    Q31(0.1777105760F),Q31(0.1784640710F),Q31(0.1792188642F),Q31(0.1799749529F),
+    Q31(0.1807323340F),Q31(0.1814910049F),Q31(0.1822509628F),Q31(0.1830122046F),
+    Q31(0.1837747277F),Q31(0.1845385292F),Q31(0.1853036062F),Q31(0.1860699558F),
+    Q31(0.1868375751F),Q31(0.1876064613F),Q31(0.1883766114F),Q31(0.1891480226F),
+    Q31(0.1899206919F),Q31(0.1906946164F),Q31(0.1914697932F),Q31(0.1922462194F),
+    Q31(0.1930238919F),Q31(0.1938028079F),Q31(0.1945829643F),Q31(0.1953643583F),
+    Q31(0.1961469868F),Q31(0.1969308468F),Q31(0.1977159353F),Q31(0.1985022494F),
+    Q31(0.1992897859F),Q31(0.2000785420F),Q31(0.2008685145F),Q31(0.2016597005F),
+    Q31(0.2024520968F),Q31(0.2032457005F),Q31(0.2040405084F),Q31(0.2048365175F),
+    Q31(0.2056337247F),Q31(0.2064321269F),Q31(0.2072317211F),Q31(0.2080325041F),
+    Q31(0.2088344727F),Q31(0.2096376240F),Q31(0.2104419547F),Q31(0.2112474618F),
+    Q31(0.2120541420F),Q31(0.2128619923F),Q31(0.2136710094F),Q31(0.2144811902F),
+    Q31(0.2152925315F),Q31(0.2161050301F),Q31(0.2169186829F),Q31(0.2177334866F),
+    Q31(0.2185494381F),Q31(0.2193665340F),Q31(0.2201847712F),Q31(0.2210041465F),
+    Q31(0.2218246565F),Q31(0.2226462981F),Q31(0.2234690680F),Q31(0.2242929629F),
+    Q31(0.2251179796F),Q31(0.2259441147F),Q31(0.2267713650F),Q31(0.2275997272F),
+    Q31(0.2284291979F),Q31(0.2292597739F),Q31(0.2300914518F),Q31(0.2309242283F),
+    Q31(0.2317581001F),Q31(0.2325930638F),Q31(0.2334291160F),Q31(0.2342662534F),
+    Q31(0.2351044727F),Q31(0.2359437703F),Q31(0.2367841431F),Q31(0.2376255875F),
+    Q31(0.2384681001F),Q31(0.2393116776F),Q31(0.2401563165F),Q31(0.2410020134F),
+    Q31(0.2418487649F),Q31(0.2426965675F),Q31(0.2435454178F),Q31(0.2443953122F),
+    Q31(0.2452462474F),Q31(0.2460982199F),Q31(0.2469512262F),Q31(0.2478052628F),
+    Q31(0.2486603262F),Q31(0.2495164129F),Q31(0.2503735194F),Q31(0.2512316421F),
+    Q31(0.2520907776F),Q31(0.2529509222F),Q31(0.2538120726F),Q31(0.2546742250F),
+    Q31(0.2555373760F),Q31(0.2564015219F),Q31(0.2572666593F),Q31(0.2581327845F),
+    Q31(0.2589998939F),Q31(0.2598679840F),Q31(0.2607370510F),Q31(0.2616070916F),
+    Q31(0.2624781019F),Q31(0.2633500783F),Q31(0.2642230173F),Q31(0.2650969152F),
+    Q31(0.2659717684F),Q31(0.2668475731F),Q31(0.2677243257F),Q31(0.2686020226F),
+    Q31(0.2694806601F),Q31(0.2703602344F),Q31(0.2712407419F),Q31(0.2721221789F),
+    Q31(0.2730045417F),Q31(0.2738878265F),Q31(0.2747720297F),Q31(0.2756571474F),
+    Q31(0.2765431760F),Q31(0.2774301117F),Q31(0.2783179508F),Q31(0.2792066895F),
+    Q31(0.2800963240F),Q31(0.2809868505F),Q31(0.2818782654F),Q31(0.2827705647F),
+    Q31(0.2836637447F),Q31(0.2845578016F),Q31(0.2854527315F),Q31(0.2863485307F),
+    Q31(0.2872451953F),Q31(0.2881427215F),Q31(0.2890411055F),Q31(0.2899403433F),
+    Q31(0.2908404312F),Q31(0.2917413654F),Q31(0.2926431418F),Q31(0.2935457567F),
+    Q31(0.2944492061F),Q31(0.2953534863F),Q31(0.2962585932F),Q31(0.2971645230F),
+    Q31(0.2980712717F),Q31(0.2989788356F),Q31(0.2998872105F),Q31(0.3007963927F),
+    Q31(0.3017063781F),Q31(0.3026171629F),Q31(0.3035287430F),Q31(0.3044411145F),
+    Q31(0.3053542736F),Q31(0.3062682161F),Q31(0.3071829381F),Q31(0.3080984356F),
+    Q31(0.3090147047F),Q31(0.3099317413F),Q31(0.3108495414F),Q31(0.3117681011F),
+    Q31(0.3126874163F),Q31(0.3136074830F),Q31(0.3145282972F),Q31(0.3154498548F),
+    Q31(0.3163721517F),Q31(0.3172951841F),Q31(0.3182189477F),Q31(0.3191434385F),
+    Q31(0.3200686525F),Q31(0.3209945856F),Q31(0.3219212336F),Q31(0.3228485927F),
+    Q31(0.3237766585F),Q31(0.3247054271F),Q31(0.3256348943F),Q31(0.3265650560F),
+    Q31(0.3274959081F),Q31(0.3284274465F),Q31(0.3293596671F),Q31(0.3302925657F),
+    Q31(0.3312261382F),Q31(0.3321603804F),Q31(0.3330952882F),Q31(0.3340308574F),
+    Q31(0.3349670838F),Q31(0.3359039634F),Q31(0.3368414919F),Q31(0.3377796651F),
+    Q31(0.3387184789F),Q31(0.3396579290F),Q31(0.3405980113F),Q31(0.3415387216F),
+    Q31(0.3424800556F),Q31(0.3434220091F),Q31(0.3443645779F),Q31(0.3453077578F),
+    Q31(0.3462515446F),Q31(0.3471959340F),Q31(0.3481409217F),Q31(0.3490865036F),
+    Q31(0.3500326754F),Q31(0.3509794328F),Q31(0.3519267715F),Q31(0.3528746873F),
+    Q31(0.3538231759F),Q31(0.3547722330F),Q31(0.3557218544F),Q31(0.3566720357F),
+    Q31(0.3576227727F),Q31(0.3585740610F),Q31(0.3595258964F),Q31(0.3604782745F),
+    Q31(0.3614311910F),Q31(0.3623846417F),Q31(0.3633386221F),Q31(0.3642931280F),
+    Q31(0.3652481549F),Q31(0.3662036987F),Q31(0.3671597548F),Q31(0.3681163191F),
+    Q31(0.3690733870F),Q31(0.3700309544F),Q31(0.3709890167F),Q31(0.3719475696F),
+    Q31(0.3729066089F),Q31(0.3738661299F),Q31(0.3748261285F),Q31(0.3757866002F),
+    Q31(0.3767475406F),Q31(0.3777089453F),Q31(0.3786708100F),Q31(0.3796331302F),
+    Q31(0.3805959014F),Q31(0.3815591194F),Q31(0.3825227796F),Q31(0.3834868777F),
+    Q31(0.3844514093F),Q31(0.3854163698F),Q31(0.3863817549F),Q31(0.3873475601F),
+    Q31(0.3883137810F),Q31(0.3892804131F),Q31(0.3902474521F),Q31(0.3912148933F),
+    Q31(0.3921827325F),Q31(0.3931509650F),Q31(0.3941195865F),Q31(0.3950885925F),
+    Q31(0.3960579785F),Q31(0.3970277400F),Q31(0.3979978725F),Q31(0.3989683716F),
+    Q31(0.3999392328F),Q31(0.4009104516F),Q31(0.4018820234F),Q31(0.4028539438F),
+    Q31(0.4038262084F),Q31(0.4047988125F),Q31(0.4057717516F),Q31(0.4067450214F),
+    Q31(0.4077186172F),Q31(0.4086925345F),Q31(0.4096667688F),Q31(0.4106413155F),
+    Q31(0.4116161703F),Q31(0.4125913284F),Q31(0.4135667854F),Q31(0.4145425368F),
+    Q31(0.4155185780F),Q31(0.4164949044F),Q31(0.4174715116F),Q31(0.4184483949F),
+    Q31(0.4194255498F),Q31(0.4204029718F),Q31(0.4213806563F),Q31(0.4223585987F),
+    Q31(0.4233367946F),Q31(0.4243152392F),Q31(0.4252939281F),Q31(0.4262728566F),
+    Q31(0.4272520202F),Q31(0.4282314144F),Q31(0.4292110345F),Q31(0.4301908760F),
+    Q31(0.4311709343F),Q31(0.4321512047F),Q31(0.4331316828F),Q31(0.4341123639F),
+    Q31(0.4350932435F),Q31(0.4360743168F),Q31(0.4370555794F),Q31(0.4380370267F),
+    Q31(0.4390186540F),Q31(0.4400004567F),Q31(0.4409824303F),Q31(0.4419645701F),
+    Q31(0.4429468716F),Q31(0.4439293300F),Q31(0.4449119409F),Q31(0.4458946996F),
+    Q31(0.4468776014F),Q31(0.4478606418F),Q31(0.4488438162F),Q31(0.4498271199F),
+    Q31(0.4508105483F),Q31(0.4517940967F),Q31(0.4527777607F),Q31(0.4537615355F),
+    Q31(0.4547454165F),Q31(0.4557293991F),Q31(0.4567134786F),Q31(0.4576976505F),
+    Q31(0.4586819101F),Q31(0.4596662527F),Q31(0.4606506738F),Q31(0.4616351687F),
+    Q31(0.4626197328F),Q31(0.4636043614F),Q31(0.4645890499F),Q31(0.4655737936F),
+    Q31(0.4665585880F),Q31(0.4675434284F),Q31(0.4685283101F),Q31(0.4695132286F),
+    Q31(0.4704981791F),Q31(0.4714831570F),Q31(0.4724681577F),Q31(0.4734531766F),
+    Q31(0.4744382089F),Q31(0.4754232501F),Q31(0.4764082956F),Q31(0.4773933406F),
+    Q31(0.4783783806F),Q31(0.4793634108F),Q31(0.4803484267F),Q31(0.4813334237F),
+    Q31(0.4823183969F),Q31(0.4833033419F),Q31(0.4842882540F),Q31(0.4852731285F),
+    Q31(0.4862579608F),Q31(0.4872427462F),Q31(0.4882274802F),Q31(0.4892121580F),
+    Q31(0.4901967751F),Q31(0.4911813267F),Q31(0.4921658083F),Q31(0.4931502151F),
+    Q31(0.4941345427F),Q31(0.4951187863F),Q31(0.4961029412F),Q31(0.4970870029F),
+    Q31(0.4980709667F),Q31(0.4990548280F),Q31(0.5000385822F),Q31(0.5010222245F),
+    Q31(0.5020057505F),Q31(0.5029891553F),Q31(0.5039724345F),Q31(0.5049555834F),
+    Q31(0.5059385973F),Q31(0.5069214716F),Q31(0.5079042018F),Q31(0.5088867831F),
+    Q31(0.5098692110F),Q31(0.5108514808F),Q31(0.5118335879F),Q31(0.5128155277F),
+    Q31(0.5137972956F),Q31(0.5147788869F),Q31(0.5157602971F),Q31(0.5167415215F),
+    Q31(0.5177225555F),Q31(0.5187033945F),Q31(0.5196840339F),Q31(0.5206644692F),
+    Q31(0.5216446956F),Q31(0.5226247086F),Q31(0.5236045035F),Q31(0.5245840759F),
+    Q31(0.5255634211F),Q31(0.5265425344F),Q31(0.5275214114F),Q31(0.5285000474F),
+    Q31(0.5294784378F),Q31(0.5304565781F),Q31(0.5314344637F),Q31(0.5324120899F),
+    Q31(0.5333894522F),Q31(0.5343665461F),Q31(0.5353433670F),Q31(0.5363199102F),
+    Q31(0.5372961713F),Q31(0.5382721457F),Q31(0.5392478287F),Q31(0.5402232159F),
+    Q31(0.5411983027F),Q31(0.5421730845F),Q31(0.5431475569F),Q31(0.5441217151F),
+    Q31(0.5450955548F),Q31(0.5460690714F),Q31(0.5470422602F),Q31(0.5480151169F),
+    Q31(0.5489876368F),Q31(0.5499598155F),Q31(0.5509316484F),Q31(0.5519031310F),
+    Q31(0.5528742587F),Q31(0.5538450271F),Q31(0.5548154317F),Q31(0.5557854680F),
+    Q31(0.5567551314F),Q31(0.5577244174F),Q31(0.5586933216F),Q31(0.5596618395F),
+    Q31(0.5606299665F),Q31(0.5615976983F),Q31(0.5625650302F),Q31(0.5635319580F),
+    Q31(0.5644984770F),Q31(0.5654645828F),Q31(0.5664302709F),Q31(0.5673955370F),
+    Q31(0.5683603765F),Q31(0.5693247850F),Q31(0.5702887580F),Q31(0.5712522912F),
+    Q31(0.5722153800F),Q31(0.5731780200F),Q31(0.5741402069F),Q31(0.5751019362F),
+    Q31(0.5760632034F),Q31(0.5770240042F),Q31(0.5779843341F),Q31(0.5789441889F),
+    Q31(0.5799035639F),Q31(0.5808624549F),Q31(0.5818208575F),Q31(0.5827787673F),
+    Q31(0.5837361800F),Q31(0.5846930910F),Q31(0.5856494961F),Q31(0.5866053910F),
+    Q31(0.5875607712F),Q31(0.5885156324F),Q31(0.5894699703F),Q31(0.5904237804F),
+    Q31(0.5913770586F),Q31(0.5923298004F),Q31(0.5932820016F),Q31(0.5942336578F),
+    Q31(0.5951847646F),Q31(0.5961353179F),Q31(0.5970853132F),Q31(0.5980347464F),
+    Q31(0.5989836131F),Q31(0.5999319090F),Q31(0.6008796298F),Q31(0.6018267713F),
+    Q31(0.6027733292F),Q31(0.6037192993F),Q31(0.6046646773F),Q31(0.6056094589F),
+    Q31(0.6065536400F),Q31(0.6074972162F),Q31(0.6084401833F),Q31(0.6093825372F),
+    Q31(0.6103242736F),Q31(0.6112653884F),Q31(0.6122058772F),Q31(0.6131457359F),
+    Q31(0.6140849604F),Q31(0.6150235464F),Q31(0.6159614897F),Q31(0.6168987862F),
+    Q31(0.6178354318F),Q31(0.6187714223F),Q31(0.6197067535F),Q31(0.6206414213F),
+    Q31(0.6215754215F),Q31(0.6225087501F),Q31(0.6234414028F),Q31(0.6243733757F),
+    Q31(0.6253046646F),Q31(0.6262352654F),Q31(0.6271651739F),Q31(0.6280943862F),
+    Q31(0.6290228982F),Q31(0.6299507057F),Q31(0.6308778048F),Q31(0.6318041913F),
+    Q31(0.6327298612F),Q31(0.6336548105F),Q31(0.6345790352F),Q31(0.6355025312F),
+    Q31(0.6364252945F),Q31(0.6373473211F),Q31(0.6382686070F),Q31(0.6391891483F),
+    Q31(0.6401089409F),Q31(0.6410279808F),Q31(0.6419462642F),Q31(0.6428637869F),
+    Q31(0.6437805452F),Q31(0.6446965350F),Q31(0.6456117524F),Q31(0.6465261935F),
+    Q31(0.6474398544F),Q31(0.6483527311F),Q31(0.6492648197F),Q31(0.6501761165F),
+    Q31(0.6510866174F),Q31(0.6519963186F),Q31(0.6529052162F),Q31(0.6538133064F),
+    Q31(0.6547205854F),Q31(0.6556270492F),Q31(0.6565326941F),Q31(0.6574375162F),
+    Q31(0.6583415117F),Q31(0.6592446769F),Q31(0.6601470079F),Q31(0.6610485009F),
+    Q31(0.6619491521F),Q31(0.6628489578F),Q31(0.6637479143F),Q31(0.6646460177F),
+    Q31(0.6655432643F),Q31(0.6664396505F),Q31(0.6673351724F),Q31(0.6682298264F),
+    Q31(0.6691236087F),Q31(0.6700165157F),Q31(0.6709085436F),Q31(0.6717996889F),
+    Q31(0.6726899478F),Q31(0.6735793167F),Q31(0.6744677918F),Q31(0.6753553697F),
+    Q31(0.6762420466F),Q31(0.6771278190F),Q31(0.6780126832F),Q31(0.6788966357F),
+    Q31(0.6797796728F),Q31(0.6806617909F),Q31(0.6815429866F),Q31(0.6824232562F),
+    Q31(0.6833025961F),Q31(0.6841810030F),Q31(0.6850584731F),Q31(0.6859350031F),
+    Q31(0.6868105894F),Q31(0.6876852284F),Q31(0.6885589168F),Q31(0.6894316510F),
+    Q31(0.6903034275F),Q31(0.6911742430F),Q31(0.6920440939F),Q31(0.6929129769F),
+    Q31(0.6937808884F),Q31(0.6946478251F),Q31(0.6955137837F),Q31(0.6963787606F),
+    Q31(0.6972427525F),Q31(0.6981057560F),Q31(0.6989677678F),Q31(0.6998287845F),
+    Q31(0.7006888028F),Q31(0.7015478194F),Q31(0.7024058309F),Q31(0.7032628340F),
+    Q31(0.7041188254F),Q31(0.7049738019F),Q31(0.7058277601F),Q31(0.7066806969F),
+    Q31(0.7075326089F),Q31(0.7083834929F),Q31(0.7092333457F),Q31(0.7100821640F),
+    Q31(0.7109299447F),Q31(0.7117766846F),Q31(0.7126223804F),Q31(0.7134670291F),
+    Q31(0.7143106273F),Q31(0.7151531721F),Q31(0.7159946602F),Q31(0.7168350885F),
+    Q31(0.7176744539F),Q31(0.7185127534F),Q31(0.7193499837F),Q31(0.7201861418F),
+    Q31(0.7210212247F),Q31(0.7218552293F),Q31(0.7226881526F),Q31(0.7235199914F),
+    Q31(0.7243507428F),Q31(0.7251804039F),Q31(0.7260089715F),Q31(0.7268364426F),
+    Q31(0.7276628144F),Q31(0.7284880839F),Q31(0.7293122481F),Q31(0.7301353040F),
+    Q31(0.7309572487F),Q31(0.7317780794F),Q31(0.7325977930F),Q31(0.7334163868F),
+    Q31(0.7342338579F),Q31(0.7350502033F),Q31(0.7358654202F),Q31(0.7366795059F),
+    Q31(0.7374924573F),Q31(0.7383042718F),Q31(0.7391149465F),Q31(0.7399244787F),
+    Q31(0.7407328655F),Q31(0.7415401041F),Q31(0.7423461920F),Q31(0.7431511261F),
+    Q31(0.7439549040F),Q31(0.7447575227F),Q31(0.7455589797F),Q31(0.7463592723F),
+    Q31(0.7471583976F),Q31(0.7479563532F),Q31(0.7487531363F),Q31(0.7495487443F),
+    Q31(0.7503431745F),Q31(0.7511364244F),Q31(0.7519284913F),Q31(0.7527193726F),
+    Q31(0.7535090658F),Q31(0.7542975683F),Q31(0.7550848776F),Q31(0.7558709910F),
+    Q31(0.7566559062F),Q31(0.7574396205F),Q31(0.7582221314F),Q31(0.7590034366F),
+    Q31(0.7597835334F),Q31(0.7605624194F),Q31(0.7613400923F),Q31(0.7621165495F),
+    Q31(0.7628917886F),Q31(0.7636658072F),Q31(0.7644386030F),Q31(0.7652101735F),
+    Q31(0.7659805164F),Q31(0.7667496292F),Q31(0.7675175098F),Q31(0.7682841556F),
+    Q31(0.7690495645F),Q31(0.7698137341F),Q31(0.7705766622F),Q31(0.7713383463F),
+    Q31(0.7720987844F),Q31(0.7728579741F),Q31(0.7736159132F),Q31(0.7743725994F),
+    Q31(0.7751280306F),Q31(0.7758822046F),Q31(0.7766351192F),Q31(0.7773867722F),
+    Q31(0.7781371614F),Q31(0.7788862848F),Q31(0.7796341401F),Q31(0.7803807253F),
+    Q31(0.7811260383F),Q31(0.7818700769F),Q31(0.7826128392F),Q31(0.7833543230F),
+    Q31(0.7840945263F),Q31(0.7848334471F),Q31(0.7855710833F),Q31(0.7863074330F),
+    Q31(0.7870424941F),Q31(0.7877762647F),Q31(0.7885087428F),Q31(0.7892399264F),
+    Q31(0.7899698137F),Q31(0.7906984026F),Q31(0.7914256914F),Q31(0.7921516780F),
+    Q31(0.7928763607F),Q31(0.7935997375F),Q31(0.7943218065F),Q31(0.7950425661F),
+    Q31(0.7957620142F),Q31(0.7964801492F),Q31(0.7971969692F),Q31(0.7979124724F),
+    Q31(0.7986266570F),Q31(0.7993395214F),Q31(0.8000510638F),Q31(0.8007612823F),
+    Q31(0.8014701754F),Q31(0.8021777413F),Q31(0.8028839784F),Q31(0.8035888849F),
+    Q31(0.8042924592F),Q31(0.8049946997F),Q31(0.8056956048F),Q31(0.8063951727F),
+    Q31(0.8070934020F),Q31(0.8077902910F),Q31(0.8084858381F),Q31(0.8091800419F),
+    Q31(0.8098729007F),Q31(0.8105644130F),Q31(0.8112545774F),Q31(0.8119433922F),
+    Q31(0.8126308561F),Q31(0.8133169676F),Q31(0.8140017251F),Q31(0.8146851272F),
+    Q31(0.8153671726F),Q31(0.8160478598F),Q31(0.8167271874F),Q31(0.8174051539F),
+    Q31(0.8180817582F),Q31(0.8187569986F),Q31(0.8194308741F),Q31(0.8201033831F),
+    Q31(0.8207745244F),Q31(0.8214442966F),Q31(0.8221126986F),Q31(0.8227797290F),
+    Q31(0.8234453865F),Q31(0.8241096700F),Q31(0.8247725781F),Q31(0.8254341097F),
+    Q31(0.8260942636F),Q31(0.8267530385F),Q31(0.8274104334F),Q31(0.8280664470F),
+    Q31(0.8287210782F),Q31(0.8293743259F),Q31(0.8300261889F),Q31(0.8306766662F),
+    Q31(0.8313257566F),Q31(0.8319734591F),Q31(0.8326197727F),Q31(0.8332646963F),
+    Q31(0.8339082288F),Q31(0.8345503692F),Q31(0.8351911167F),Q31(0.8358304700F),
+    Q31(0.8364684284F),Q31(0.8371049907F),Q31(0.8377401562F),Q31(0.8383739238F),
+    Q31(0.8390062927F),Q31(0.8396372618F),Q31(0.8402668305F),Q31(0.8408949977F),
+    Q31(0.8415217626F),Q31(0.8421471245F),Q31(0.8427710823F),Q31(0.8433936354F),
+    Q31(0.8440147830F),Q31(0.8446345242F),Q31(0.8452528582F),Q31(0.8458697844F),
+    Q31(0.8464853020F),Q31(0.8470994102F),Q31(0.8477121084F),Q31(0.8483233958F),
+    Q31(0.8489332718F),Q31(0.8495417356F),Q31(0.8501487866F),Q31(0.8507544243F),
+    Q31(0.8513586479F),Q31(0.8519614568F),Q31(0.8525628505F),Q31(0.8531628283F),
+    Q31(0.8537613897F),Q31(0.8543585341F),Q31(0.8549542611F),Q31(0.8555485699F),
+    Q31(0.8561414603F),Q31(0.8567329315F),Q31(0.8573229832F),Q31(0.8579116149F),
+    Q31(0.8584988262F),Q31(0.8590846165F),Q31(0.8596689855F),Q31(0.8602519327F),
+    Q31(0.8608334577F),Q31(0.8614135603F),Q31(0.8619922399F),Q31(0.8625694962F),
+    Q31(0.8631453289F),Q31(0.8637197377F),Q31(0.8642927222F),Q31(0.8648642821F),
+    Q31(0.8654344172F),Q31(0.8660031272F),Q31(0.8665704118F),Q31(0.8671362708F),
+    Q31(0.8677007039F),Q31(0.8682637109F),Q31(0.8688252917F),Q31(0.8693854460F),
+    Q31(0.8699441737F),Q31(0.8705014745F),Q31(0.8710573485F),Q31(0.8716117953F),
+    Q31(0.8721648150F),Q31(0.8727164073F),Q31(0.8732665723F),Q31(0.8738153098F),
+    Q31(0.8743626197F),Q31(0.8749085021F),Q31(0.8754529569F),Q31(0.8759959840F),
+    Q31(0.8765375835F),Q31(0.8770777553F),Q31(0.8776164996F),Q31(0.8781538162F),
+    Q31(0.8786897054F),Q31(0.8792241670F),Q31(0.8797572013F),Q31(0.8802888082F),
+    Q31(0.8808189880F),Q31(0.8813477407F),Q31(0.8818750664F),Q31(0.8824009653F),
+    Q31(0.8829254375F),Q31(0.8834484833F),Q31(0.8839701028F),Q31(0.8844902961F),
+    Q31(0.8850090636F),Q31(0.8855264054F),Q31(0.8860423218F),Q31(0.8865568131F),
+    Q31(0.8870698794F),Q31(0.8875815212F),Q31(0.8880917386F),Q31(0.8886005319F),
+    Q31(0.8891079016F),Q31(0.8896138479F),Q31(0.8901183712F),Q31(0.8906214719F),
+    Q31(0.8911231503F),Q31(0.8916234067F),Q31(0.8921222417F),Q31(0.8926196556F),
+    Q31(0.8931156489F),Q31(0.8936102219F),Q31(0.8941033752F),Q31(0.8945951092F),
+    Q31(0.8950854244F),Q31(0.8955743212F),Q31(0.8960618003F),Q31(0.8965478621F),
+    Q31(0.8970325071F),Q31(0.8975157359F),Q31(0.8979975490F),Q31(0.8984779471F),
+    Q31(0.8989569307F),Q31(0.8994345004F),Q31(0.8999106568F),Q31(0.9003854005F),
+    Q31(0.9008587323F),Q31(0.9013306526F),Q31(0.9018011623F),Q31(0.9022702619F),
+    Q31(0.9027379521F),Q31(0.9032042337F),Q31(0.9036691074F),Q31(0.9041325739F),
+    Q31(0.9045946339F),Q31(0.9050552882F),Q31(0.9055145376F),Q31(0.9059723828F),
+    Q31(0.9064288246F),Q31(0.9068838638F),Q31(0.9073375013F),Q31(0.9077897379F),
+    Q31(0.9082405743F),Q31(0.9086900115F),Q31(0.9091380503F),Q31(0.9095846917F),
+    Q31(0.9100299364F),Q31(0.9104737854F),Q31(0.9109162397F),Q31(0.9113573001F),
+    Q31(0.9117969675F),Q31(0.9122352430F),Q31(0.9126721275F),Q31(0.9131076219F),
+    Q31(0.9135417273F),Q31(0.9139744447F),Q31(0.9144057750F),Q31(0.9148357194F),
+    Q31(0.9152642787F),Q31(0.9156914542F),Q31(0.9161172468F),Q31(0.9165416576F),
+    Q31(0.9169646877F),Q31(0.9173863382F),Q31(0.9178066102F),Q31(0.9182255048F),
+    Q31(0.9186430232F),Q31(0.9190591665F),Q31(0.9194739359F),Q31(0.9198873324F),
+    Q31(0.9202993574F),Q31(0.9207100120F),Q31(0.9211192973F),Q31(0.9215272147F),
+    Q31(0.9219337653F),Q31(0.9223389504F),Q31(0.9227427713F),Q31(0.9231452290F),
+    Q31(0.9235463251F),Q31(0.9239460607F),Q31(0.9243444371F),Q31(0.9247414557F),
+    Q31(0.9251371177F),Q31(0.9255314245F),Q31(0.9259243774F),Q31(0.9263159778F),
+    Q31(0.9267062270F),Q31(0.9270951264F),Q31(0.9274826774F),Q31(0.9278688814F),
+    Q31(0.9282537398F),Q31(0.9286372540F),Q31(0.9290194254F),Q31(0.9294002555F),
+    Q31(0.9297797458F),Q31(0.9301578976F),Q31(0.9305347125F),Q31(0.9309101919F),
+    Q31(0.9312843373F),Q31(0.9316571503F),Q31(0.9320286323F),Q31(0.9323987849F),
+    Q31(0.9327676097F),Q31(0.9331351080F),Q31(0.9335012816F),Q31(0.9338661320F),
+    Q31(0.9342296607F),Q31(0.9345918694F),Q31(0.9349527596F),Q31(0.9353123330F),
+    Q31(0.9356705911F),Q31(0.9360275357F),Q31(0.9363831683F),Q31(0.9367374905F),
+    Q31(0.9370905042F),Q31(0.9374422108F),Q31(0.9377926122F),Q31(0.9381417099F),
+    Q31(0.9384895057F),Q31(0.9388360014F),Q31(0.9391811985F),Q31(0.9395250989F),
+    Q31(0.9398677043F),Q31(0.9402090165F),Q31(0.9405490371F),Q31(0.9408877680F),
+    Q31(0.9412252110F),Q31(0.9415613678F),Q31(0.9418962402F),Q31(0.9422298301F),
+    Q31(0.9425621392F),Q31(0.9428931695F),Q31(0.9432229226F),Q31(0.9435514005F),
+    Q31(0.9438786050F),Q31(0.9442045381F),Q31(0.9445292014F),Q31(0.9448525971F),
+    Q31(0.9451747268F),Q31(0.9454955926F),Q31(0.9458151963F),Q31(0.9461335399F),
+    Q31(0.9464506253F),Q31(0.9467664545F),Q31(0.9470810293F),Q31(0.9473943517F),
+    Q31(0.9477064238F),Q31(0.9480172474F),Q31(0.9483268246F),Q31(0.9486351573F),
+    Q31(0.9489422475F),Q31(0.9492480973F),Q31(0.9495527087F),Q31(0.9498560837F),
+    Q31(0.9501582243F),Q31(0.9504591325F),Q31(0.9507588105F),Q31(0.9510572603F),
+    Q31(0.9513544839F),Q31(0.9516504834F),Q31(0.9519452609F),Q31(0.9522388186F),
+    Q31(0.9525311584F),Q31(0.9528222826F),Q31(0.9531121932F),Q31(0.9534008923F),
+    Q31(0.9536883821F),Q31(0.9539746647F),Q31(0.9542597424F),Q31(0.9545436171F),
+    Q31(0.9548262912F),Q31(0.9551077667F),Q31(0.9553880459F),Q31(0.9556671309F),
+    Q31(0.9559450239F),Q31(0.9562217272F),Q31(0.9564972429F),Q31(0.9567715733F),
+    Q31(0.9570447206F),Q31(0.9573166871F),Q31(0.9575874749F),Q31(0.9578570863F),
+    Q31(0.9581255236F),Q31(0.9583927890F),Q31(0.9586588849F),Q31(0.9589238134F),
+    Q31(0.9591875769F),Q31(0.9594501777F),Q31(0.9597116180F),Q31(0.9599719003F),
+    Q31(0.9602310267F),Q31(0.9604889995F),Q31(0.9607458213F),Q31(0.9610014942F),
+    Q31(0.9612560206F),Q31(0.9615094028F),Q31(0.9617616433F),Q31(0.9620127443F),
+    Q31(0.9622627083F),Q31(0.9625115376F),Q31(0.9627592345F),Q31(0.9630058016F),
+    Q31(0.9632512411F),Q31(0.9634955555F),Q31(0.9637387471F),Q31(0.9639808185F),
+    Q31(0.9642217720F),Q31(0.9644616100F),Q31(0.9647003349F),Q31(0.9649379493F),
+    Q31(0.9651744556F),Q31(0.9654098561F),Q31(0.9656441534F),Q31(0.9658773499F),
+    Q31(0.9661094480F),Q31(0.9663404504F),Q31(0.9665703593F),Q31(0.9667991774F),
+    Q31(0.9670269071F),Q31(0.9672535509F),Q31(0.9674791114F),Q31(0.9677035909F),
+    Q31(0.9679269921F),Q31(0.9681493174F),Q31(0.9683705694F),Q31(0.9685907506F),
+    Q31(0.9688098636F),Q31(0.9690279108F),Q31(0.9692448948F),Q31(0.9694608182F),
+    Q31(0.9696756836F),Q31(0.9698894934F),Q31(0.9701022503F),Q31(0.9703139569F),
+    Q31(0.9705246156F),Q31(0.9707342291F),Q31(0.9709428000F),Q31(0.9711503309F),
+    Q31(0.9713568243F),Q31(0.9715622829F),Q31(0.9717667093F),Q31(0.9719701060F),
+    Q31(0.9721724757F),Q31(0.9723738210F),Q31(0.9725741446F),Q31(0.9727734490F),
+    Q31(0.9729717369F),Q31(0.9731690109F),Q31(0.9733652737F),Q31(0.9735605279F),
+    Q31(0.9737547762F),Q31(0.9739480212F),Q31(0.9741402656F),Q31(0.9743315120F),
+    Q31(0.9745217631F),Q31(0.9747110216F),Q31(0.9748992901F),Q31(0.9750865714F),
+    Q31(0.9752728681F),Q31(0.9754581829F),Q31(0.9756425184F),Q31(0.9758258775F),
+    Q31(0.9760082627F),Q31(0.9761896768F),Q31(0.9763701224F),Q31(0.9765496024F),
+    Q31(0.9767281193F),Q31(0.9769056760F),Q31(0.9770822751F),Q31(0.9772579193F),
+    Q31(0.9774326114F),Q31(0.9776063542F),Q31(0.9777791502F),Q31(0.9779510023F),
+    Q31(0.9781219133F),Q31(0.9782918858F),Q31(0.9784609226F),Q31(0.9786290264F),
+    Q31(0.9787962000F),Q31(0.9789624461F),Q31(0.9791277676F),Q31(0.9792921671F),
+    Q31(0.9794556474F),Q31(0.9796182113F),Q31(0.9797798615F),Q31(0.9799406009F),
+    Q31(0.9801004321F),Q31(0.9802593580F),Q31(0.9804173813F),Q31(0.9805745049F),
+    Q31(0.9807307314F),Q31(0.9808860637F),Q31(0.9810405046F),Q31(0.9811940568F),
+    Q31(0.9813467232F),Q31(0.9814985065F),Q31(0.9816494095F),Q31(0.9817994351F),
+    Q31(0.9819485860F),Q31(0.9820968650F),Q31(0.9822442750F),Q31(0.9823908186F),
+    Q31(0.9825364988F),Q31(0.9826813184F),Q31(0.9828252801F),Q31(0.9829683868F),
+    Q31(0.9831106413F),Q31(0.9832520463F),Q31(0.9833926048F),Q31(0.9835323195F),
+    Q31(0.9836711932F),Q31(0.9838092288F),Q31(0.9839464291F),Q31(0.9840827969F),
+    Q31(0.9842183351F),Q31(0.9843530464F),Q31(0.9844869337F),Q31(0.9846199998F),
+    Q31(0.9847522475F),Q31(0.9848836798F),Q31(0.9850142993F),Q31(0.9851441090F),
+    Q31(0.9852731117F),Q31(0.9854013101F),Q31(0.9855287073F),Q31(0.9856553058F),
+    Q31(0.9857811087F),Q31(0.9859061188F),Q31(0.9860303388F),Q31(0.9861537717F),
+    Q31(0.9862764202F),Q31(0.9863982872F),Q31(0.9865193756F),Q31(0.9866396882F),
+    Q31(0.9867592277F),Q31(0.9868779972F),Q31(0.9869959993F),Q31(0.9871132370F),
+    Q31(0.9872297131F),Q31(0.9873454304F),Q31(0.9874603918F),Q31(0.9875746001F),
+    Q31(0.9876880581F),Q31(0.9878007688F),Q31(0.9879127348F),Q31(0.9880239592F),
+    Q31(0.9881344447F),Q31(0.9882441941F),Q31(0.9883532104F),Q31(0.9884614962F),
+    Q31(0.9885690546F),Q31(0.9886758883F),Q31(0.9887820001F),Q31(0.9888873930F),
+    Q31(0.9889920697F),Q31(0.9890960331F),Q31(0.9891992859F),Q31(0.9893018312F),
+    Q31(0.9894036716F),Q31(0.9895048100F),Q31(0.9896052493F),Q31(0.9897049923F),
+    Q31(0.9898040418F),Q31(0.9899024006F),Q31(0.9900000717F),Q31(0.9900970577F),
+    Q31(0.9901933616F),Q31(0.9902889862F),Q31(0.9903839343F),Q31(0.9904782087F),
+    Q31(0.9905718122F),Q31(0.9906647477F),Q31(0.9907570180F),Q31(0.9908486259F),
+    Q31(0.9909395742F),Q31(0.9910298658F),Q31(0.9911195034F),Q31(0.9912084899F),
+    Q31(0.9912968281F),Q31(0.9913845208F),Q31(0.9914715708F),Q31(0.9915579810F),
+    Q31(0.9916437540F),Q31(0.9917288928F),Q31(0.9918134001F),Q31(0.9918972788F),
+    Q31(0.9919805316F),Q31(0.9920631613F),Q31(0.9921451707F),Q31(0.9922265626F),
+    Q31(0.9923073399F),Q31(0.9923875052F),Q31(0.9924670615F),Q31(0.9925460114F),
+    Q31(0.9926243577F),Q31(0.9927021033F),Q31(0.9927792508F),Q31(0.9928558032F),
+    Q31(0.9929317631F),Q31(0.9930071333F),Q31(0.9930819167F),Q31(0.9931561158F),
+    Q31(0.9932297337F),Q31(0.9933027728F),Q31(0.9933752362F),Q31(0.9934471264F),
+    Q31(0.9935184462F),Q31(0.9935891985F),Q31(0.9936593859F),Q31(0.9937290112F),
+    Q31(0.9937980771F),Q31(0.9938665864F),Q31(0.9939345418F),Q31(0.9940019460F),
+    Q31(0.9940688018F),Q31(0.9941351118F),Q31(0.9942008789F),Q31(0.9942661057F),
+    Q31(0.9943307950F),Q31(0.9943949494F),Q31(0.9944585717F),Q31(0.9945216645F),
+    Q31(0.9945842307F),Q31(0.9946462728F),Q31(0.9947077936F),Q31(0.9947687957F),
+    Q31(0.9948292820F),Q31(0.9948892550F),Q31(0.9949487174F),Q31(0.9950076719F),
+    Q31(0.9950661212F),Q31(0.9951240679F),Q31(0.9951815148F),Q31(0.9952384645F),
+    Q31(0.9952949196F),Q31(0.9953508828F),Q31(0.9954063568F),Q31(0.9954613442F),
+    Q31(0.9955158476F),Q31(0.9955698697F),Q31(0.9956234132F),Q31(0.9956764806F),
+    Q31(0.9957290746F),Q31(0.9957811978F),Q31(0.9958328528F),Q31(0.9958840423F),
+    Q31(0.9959347688F),Q31(0.9959850351F),Q31(0.9960348435F),Q31(0.9960841969F),
+    Q31(0.9961330977F),Q31(0.9961815486F),Q31(0.9962295521F),Q31(0.9962771108F),
+    Q31(0.9963242274F),Q31(0.9963709043F),Q31(0.9964171441F),Q31(0.9964629494F),
+    Q31(0.9965083228F),Q31(0.9965532668F),Q31(0.9965977840F),Q31(0.9966418768F),
+    Q31(0.9966855479F),Q31(0.9967287998F),Q31(0.9967716350F),Q31(0.9968140559F),
+    Q31(0.9968560653F),Q31(0.9968976655F),Q31(0.9969388591F),Q31(0.9969796485F),
+    Q31(0.9970200363F),Q31(0.9970600250F),Q31(0.9970996170F),Q31(0.9971388149F),
+    Q31(0.9971776211F),Q31(0.9972160380F),Q31(0.9972540683F),Q31(0.9972917142F),
+    Q31(0.9973289783F),Q31(0.9973658631F),Q31(0.9974023709F),Q31(0.9974385042F),
+    Q31(0.9974742655F),Q31(0.9975096571F),Q31(0.9975446816F),Q31(0.9975793413F),
+    Q31(0.9976136386F),Q31(0.9976475759F),Q31(0.9976811557F),Q31(0.9977143803F),
+    Q31(0.9977472521F),Q31(0.9977797736F),Q31(0.9978119470F),Q31(0.9978437748F),
+    Q31(0.9978752593F),Q31(0.9979064029F),Q31(0.9979372079F),Q31(0.9979676768F),
+    Q31(0.9979978117F),Q31(0.9980276151F),Q31(0.9980570893F),Q31(0.9980862367F),
+    Q31(0.9981150595F),Q31(0.9981435600F),Q31(0.9981717406F),Q31(0.9981996035F),
+    Q31(0.9982271511F),Q31(0.9982543856F),Q31(0.9982813093F),Q31(0.9983079246F),
+    Q31(0.9983342336F),Q31(0.9983602386F),Q31(0.9983859418F),Q31(0.9984113456F),
+    Q31(0.9984364522F),Q31(0.9984612638F),Q31(0.9984857825F),Q31(0.9985100108F),
+    Q31(0.9985339507F),Q31(0.9985576044F),Q31(0.9985809743F),Q31(0.9986040624F),
+    Q31(0.9986268710F),Q31(0.9986494022F),Q31(0.9986716583F),Q31(0.9986936413F),
+    Q31(0.9987153535F),Q31(0.9987367969F),Q31(0.9987579738F),Q31(0.9987788864F),
+    Q31(0.9987995366F),Q31(0.9988199267F),Q31(0.9988400587F),Q31(0.9988599348F),
+    Q31(0.9988795572F),Q31(0.9988989278F),Q31(0.9989180487F),Q31(0.9989369222F),
+    Q31(0.9989555501F),Q31(0.9989739347F),Q31(0.9989920780F),Q31(0.9990099820F),
+    Q31(0.9990276487F),Q31(0.9990450803F),Q31(0.9990622787F),Q31(0.9990792460F),
+    Q31(0.9990959841F),Q31(0.9991124952F),Q31(0.9991287812F),Q31(0.9991448440F),
+    Q31(0.9991606858F),Q31(0.9991763084F),Q31(0.9991917139F),Q31(0.9992069042F),
+    Q31(0.9992218813F),Q31(0.9992366471F),Q31(0.9992512035F),Q31(0.9992655525F),
+    Q31(0.9992796961F),Q31(0.9992936361F),Q31(0.9993073744F),Q31(0.9993209131F),
+    Q31(0.9993342538F),Q31(0.9993473987F),Q31(0.9993603494F),Q31(0.9993731080F),
+    Q31(0.9993856762F),Q31(0.9993980559F),Q31(0.9994102490F),Q31(0.9994222573F),
+    Q31(0.9994340827F),Q31(0.9994457269F),Q31(0.9994571918F),Q31(0.9994684793F),
+    Q31(0.9994795910F),Q31(0.9994905288F),Q31(0.9995012945F),Q31(0.9995118898F),
+    Q31(0.9995223165F),Q31(0.9995325765F),Q31(0.9995426713F),Q31(0.9995526029F),
+    Q31(0.9995623728F),Q31(0.9995719829F),Q31(0.9995814349F),Q31(0.9995907304F),
+    Q31(0.9995998712F),Q31(0.9996088590F),Q31(0.9996176954F),Q31(0.9996263821F),
+    Q31(0.9996349208F),Q31(0.9996433132F),Q31(0.9996515609F),Q31(0.9996596656F),
+    Q31(0.9996676288F),Q31(0.9996754522F),Q31(0.9996831375F),Q31(0.9996906862F),
+    Q31(0.9996981000F),Q31(0.9997053804F),Q31(0.9997125290F),Q31(0.9997195474F),
+    Q31(0.9997264371F),Q31(0.9997331998F),Q31(0.9997398369F),Q31(0.9997463500F),
+    Q31(0.9997527406F),Q31(0.9997590103F),Q31(0.9997651606F),Q31(0.9997711930F),
+    Q31(0.9997771089F),Q31(0.9997829098F),Q31(0.9997885973F),Q31(0.9997941728F),
+    Q31(0.9997996378F),Q31(0.9998049936F),Q31(0.9998102419F),Q31(0.9998153839F),
+    Q31(0.9998204211F),Q31(0.9998253550F),Q31(0.9998301868F),Q31(0.9998349182F),
+    Q31(0.9998395503F),Q31(0.9998440847F),Q31(0.9998485226F),Q31(0.9998528654F),
+    Q31(0.9998571146F),Q31(0.9998612713F),Q31(0.9998653370F),Q31(0.9998693130F),
+    Q31(0.9998732007F),Q31(0.9998770012F),Q31(0.9998807159F),Q31(0.9998843461F),
+    Q31(0.9998878931F),Q31(0.9998913581F),Q31(0.9998947424F),Q31(0.9998980473F),
+    Q31(0.9999012740F),Q31(0.9999044237F),Q31(0.9999074976F),Q31(0.9999104971F),
+    Q31(0.9999134231F),Q31(0.9999162771F),Q31(0.9999190601F),Q31(0.9999217733F),
+    Q31(0.9999244179F),Q31(0.9999269950F),Q31(0.9999295058F),Q31(0.9999319515F),
+    Q31(0.9999343332F),Q31(0.9999366519F),Q31(0.9999389088F),Q31(0.9999411050F),
+    Q31(0.9999432416F),Q31(0.9999453196F),Q31(0.9999473402F),Q31(0.9999493044F),
+    Q31(0.9999512132F),Q31(0.9999530677F),Q31(0.9999548690F),Q31(0.9999566180F),
+    Q31(0.9999583157F),Q31(0.9999599633F),Q31(0.9999615616F),Q31(0.9999631116F),
+    Q31(0.9999646144F),Q31(0.9999660709F),Q31(0.9999674820F),Q31(0.9999688487F),
+    Q31(0.9999701719F),Q31(0.9999714526F),Q31(0.9999726917F),Q31(0.9999738900F),
+    Q31(0.9999750486F),Q31(0.9999761682F),Q31(0.9999772497F),Q31(0.9999782941F),
+    Q31(0.9999793021F),Q31(0.9999802747F),Q31(0.9999812126F),Q31(0.9999821167F),
+    Q31(0.9999829878F),Q31(0.9999838268F),Q31(0.9999846343F),Q31(0.9999854113F),
+    Q31(0.9999861584F),Q31(0.9999868765F),Q31(0.9999875664F),Q31(0.9999882287F),
+    Q31(0.9999888642F),Q31(0.9999894736F),Q31(0.9999900577F),Q31(0.9999906172F),
+    Q31(0.9999911528F),Q31(0.9999916651F),Q31(0.9999921548F),Q31(0.9999926227F),
+    Q31(0.9999930693F),Q31(0.9999934954F),Q31(0.9999939015F),Q31(0.9999942883F),
+    Q31(0.9999946564F),Q31(0.9999950064F),Q31(0.9999953390F),Q31(0.9999956547F),
+    Q31(0.9999959541F),Q31(0.9999962377F),Q31(0.9999965062F),Q31(0.9999967601F),
+    Q31(0.9999969998F),Q31(0.9999972260F),Q31(0.9999974392F),Q31(0.9999976399F),
+    Q31(0.9999978285F),Q31(0.9999980056F),Q31(0.9999981716F),Q31(0.9999983271F),
+    Q31(0.9999984724F),Q31(0.9999986081F),Q31(0.9999987345F),Q31(0.9999988521F),
+    Q31(0.9999989613F),Q31(0.9999990625F),Q31(0.9999991562F),Q31(0.9999992426F),
+    Q31(0.9999993223F),Q31(0.9999993954F),Q31(0.9999994625F),Q31(0.9999995239F),
+    Q31(0.9999995798F),Q31(0.9999996307F),Q31(0.9999996768F),Q31(0.9999997184F),
+    Q31(0.9999997559F),Q31(0.9999997895F),Q31(0.9999998195F),Q31(0.9999998462F),
+    Q31(0.9999998698F),Q31(0.9999998906F),Q31(0.9999999088F),Q31(0.9999999246F),
+    Q31(0.9999999383F),Q31(0.9999999500F),Q31(0.9999999600F),Q31(0.9999999684F),
+    Q31(0.9999999754F),Q31(0.9999999811F),Q31(0.9999999858F),Q31(0.9999999896F),
+    Q31(0.9999999925F),Q31(0.9999999948F),Q31(0.9999999965F),Q31(0.9999999978F),
+    Q31(0.9999999986F),Q31(0.9999999992F),Q31(0.9999999996F),Q31(0.9999999998F),
+    Q31(0.9999999999F),Q31(1.0000000000F),Q31(1.0000000000F),Q31(1.0000000000F),
+};                                                            
 
-DECLARE_ALIGNED(16, static const float, vwin8192)[4096] = {
-    0.0000000578F, 0.0000005198F, 0.0000014438F, 0.0000028299F,
-    0.0000046780F, 0.0000069882F, 0.0000097604F, 0.0000129945F,
-    0.0000166908F, 0.0000208490F, 0.0000254692F, 0.0000305515F,
-    0.0000360958F, 0.0000421021F, 0.0000485704F, 0.0000555006F,
-    0.0000628929F, 0.0000707472F, 0.0000790635F, 0.0000878417F,
-    0.0000970820F, 0.0001067842F, 0.0001169483F, 0.0001275744F,
-    0.0001386625F, 0.0001502126F, 0.0001622245F, 0.0001746984F,
-    0.0001876343F, 0.0002010320F, 0.0002148917F, 0.0002292132F,
-    0.0002439967F, 0.0002592421F, 0.0002749493F, 0.0002911184F,
-    0.0003077493F, 0.0003248421F, 0.0003423967F, 0.0003604132F,
-    0.0003788915F, 0.0003978316F, 0.0004172335F, 0.0004370971F,
-    0.0004574226F, 0.0004782098F, 0.0004994587F, 0.0005211694F,
-    0.0005433418F, 0.0005659759F, 0.0005890717F, 0.0006126292F,
-    0.0006366484F, 0.0006611292F, 0.0006860716F, 0.0007114757F,
-    0.0007373414F, 0.0007636687F, 0.0007904576F, 0.0008177080F,
-    0.0008454200F, 0.0008735935F, 0.0009022285F, 0.0009313250F,
-    0.0009608830F, 0.0009909025F, 0.0010213834F, 0.0010523257F,
-    0.0010837295F, 0.0011155946F, 0.0011479211F, 0.0011807090F,
-    0.0012139582F, 0.0012476687F, 0.0012818405F, 0.0013164736F,
-    0.0013515679F, 0.0013871235F, 0.0014231402F, 0.0014596182F,
-    0.0014965573F, 0.0015339576F, 0.0015718190F, 0.0016101415F,
-    0.0016489251F, 0.0016881698F, 0.0017278754F, 0.0017680421F,
-    0.0018086698F, 0.0018497584F, 0.0018913080F, 0.0019333185F,
-    0.0019757898F, 0.0020187221F, 0.0020621151F, 0.0021059690F,
-    0.0021502837F, 0.0021950591F, 0.0022402953F, 0.0022859921F,
-    0.0023321497F, 0.0023787679F, 0.0024258467F, 0.0024733861F,
-    0.0025213861F, 0.0025698466F, 0.0026187676F, 0.0026681491F,
-    0.0027179911F, 0.0027682935F, 0.0028190562F, 0.0028702794F,
-    0.0029219628F, 0.0029741066F, 0.0030267107F, 0.0030797749F,
-    0.0031332994F, 0.0031872841F, 0.0032417289F, 0.0032966338F,
-    0.0033519988F, 0.0034078238F, 0.0034641089F, 0.0035208539F,
-    0.0035780589F, 0.0036357237F, 0.0036938485F, 0.0037524331F,
-    0.0038114775F, 0.0038709817F, 0.0039309456F, 0.0039913692F,
-    0.0040522524F, 0.0041135953F, 0.0041753978F, 0.0042376599F,
-    0.0043003814F, 0.0043635624F, 0.0044272029F, 0.0044913028F,
-    0.0045558620F, 0.0046208806F, 0.0046863585F, 0.0047522955F,
-    0.0048186919F, 0.0048855473F, 0.0049528619F, 0.0050206356F,
-    0.0050888684F, 0.0051575601F, 0.0052267108F, 0.0052963204F,
-    0.0053663890F, 0.0054369163F, 0.0055079025F, 0.0055793474F,
-    0.0056512510F, 0.0057236133F, 0.0057964342F, 0.0058697137F,
-    0.0059434517F, 0.0060176482F, 0.0060923032F, 0.0061674166F,
-    0.0062429883F, 0.0063190183F, 0.0063955066F, 0.0064724532F,
-    0.0065498579F, 0.0066277207F, 0.0067060416F, 0.0067848205F,
-    0.0068640575F, 0.0069437523F, 0.0070239051F, 0.0071045157F,
-    0.0071855840F, 0.0072671102F, 0.0073490940F, 0.0074315355F,
-    0.0075144345F, 0.0075977911F, 0.0076816052F, 0.0077658768F,
-    0.0078506057F, 0.0079357920F, 0.0080214355F, 0.0081075363F,
-    0.0081940943F, 0.0082811094F, 0.0083685816F, 0.0084565108F,
-    0.0085448970F, 0.0086337401F, 0.0087230401F, 0.0088127969F,
-    0.0089030104F, 0.0089936807F, 0.0090848076F, 0.0091763911F,
-    0.0092684311F, 0.0093609276F, 0.0094538805F, 0.0095472898F,
-    0.0096411554F, 0.0097354772F, 0.0098302552F, 0.0099254894F,
-    0.0100211796F, 0.0101173259F, 0.0102139281F, 0.0103109863F,
-    0.0104085002F, 0.0105064700F, 0.0106048955F, 0.0107037766F,
-    0.0108031133F, 0.0109029056F, 0.0110031534F, 0.0111038565F,
-    0.0112050151F, 0.0113066289F, 0.0114086980F, 0.0115112222F,
-    0.0116142015F, 0.0117176359F, 0.0118215252F, 0.0119258695F,
-    0.0120306686F, 0.0121359225F, 0.0122416312F, 0.0123477944F,
-    0.0124544123F, 0.0125614847F, 0.0126690116F, 0.0127769928F,
-    0.0128854284F, 0.0129943182F, 0.0131036623F, 0.0132134604F,
-    0.0133237126F, 0.0134344188F, 0.0135455790F, 0.0136571929F,
-    0.0137692607F, 0.0138817821F, 0.0139947572F, 0.0141081859F,
-    0.0142220681F, 0.0143364037F, 0.0144511927F, 0.0145664350F,
-    0.0146821304F, 0.0147982791F, 0.0149148808F, 0.0150319355F,
-    0.0151494431F, 0.0152674036F, 0.0153858168F, 0.0155046828F,
-    0.0156240014F, 0.0157437726F, 0.0158639962F, 0.0159846723F,
-    0.0161058007F, 0.0162273814F, 0.0163494142F, 0.0164718991F,
-    0.0165948361F, 0.0167182250F, 0.0168420658F, 0.0169663584F,
-    0.0170911027F, 0.0172162987F, 0.0173419462F, 0.0174680452F,
-    0.0175945956F, 0.0177215974F, 0.0178490504F, 0.0179769545F,
-    0.0181053098F, 0.0182341160F, 0.0183633732F, 0.0184930812F,
-    0.0186232399F, 0.0187538494F, 0.0188849094F, 0.0190164200F,
-    0.0191483809F, 0.0192807923F, 0.0194136539F, 0.0195469656F,
-    0.0196807275F, 0.0198149394F, 0.0199496012F, 0.0200847128F,
-    0.0202202742F, 0.0203562853F, 0.0204927460F, 0.0206296561F,
-    0.0207670157F, 0.0209048245F, 0.0210430826F, 0.0211817899F,
-    0.0213209462F, 0.0214605515F, 0.0216006057F, 0.0217411086F,
-    0.0218820603F, 0.0220234605F, 0.0221653093F, 0.0223076066F,
-    0.0224503521F, 0.0225935459F, 0.0227371879F, 0.0228812779F,
-    0.0230258160F, 0.0231708018F, 0.0233162355F, 0.0234621169F,
-    0.0236084459F, 0.0237552224F, 0.0239024462F, 0.0240501175F,
-    0.0241982359F, 0.0243468015F, 0.0244958141F, 0.0246452736F,
-    0.0247951800F, 0.0249455331F, 0.0250963329F, 0.0252475792F,
-    0.0253992720F, 0.0255514111F, 0.0257039965F, 0.0258570281F,
-    0.0260105057F, 0.0261644293F, 0.0263187987F, 0.0264736139F,
-    0.0266288747F, 0.0267845811F, 0.0269407330F, 0.0270973302F,
-    0.0272543727F, 0.0274118604F, 0.0275697930F, 0.0277281707F,
-    0.0278869932F, 0.0280462604F, 0.0282059723F, 0.0283661287F,
-    0.0285267295F, 0.0286877747F, 0.0288492641F, 0.0290111976F,
-    0.0291735751F, 0.0293363965F, 0.0294996617F, 0.0296633706F,
-    0.0298275231F, 0.0299921190F, 0.0301571583F, 0.0303226409F,
-    0.0304885667F, 0.0306549354F, 0.0308217472F, 0.0309890017F,
-    0.0311566989F, 0.0313248388F, 0.0314934211F, 0.0316624459F,
-    0.0318319128F, 0.0320018220F, 0.0321721732F, 0.0323429663F,
-    0.0325142013F, 0.0326858779F, 0.0328579962F, 0.0330305559F,
-    0.0332035570F, 0.0333769994F, 0.0335508829F, 0.0337252074F,
-    0.0338999728F, 0.0340751790F, 0.0342508259F, 0.0344269134F,
-    0.0346034412F, 0.0347804094F, 0.0349578178F, 0.0351356663F,
-    0.0353139548F, 0.0354926831F, 0.0356718511F, 0.0358514588F,
-    0.0360315059F, 0.0362119924F, 0.0363929182F, 0.0365742831F,
-    0.0367560870F, 0.0369383297F, 0.0371210113F, 0.0373041315F,
-    0.0374876902F, 0.0376716873F, 0.0378561226F, 0.0380409961F,
-    0.0382263077F, 0.0384120571F, 0.0385982443F, 0.0387848691F,
-    0.0389719315F, 0.0391594313F, 0.0393473683F, 0.0395357425F,
-    0.0397245537F, 0.0399138017F, 0.0401034866F, 0.0402936080F,
-    0.0404841660F, 0.0406751603F, 0.0408665909F, 0.0410584576F,
-    0.0412507603F, 0.0414434988F, 0.0416366731F, 0.0418302829F,
-    0.0420243282F, 0.0422188088F, 0.0424137246F, 0.0426090755F,
-    0.0428048613F, 0.0430010819F, 0.0431977371F, 0.0433948269F,
-    0.0435923511F, 0.0437903095F, 0.0439887020F, 0.0441875285F,
-    0.0443867889F, 0.0445864830F, 0.0447866106F, 0.0449871717F,
-    0.0451881661F, 0.0453895936F, 0.0455914542F, 0.0457937477F,
-    0.0459964738F, 0.0461996326F, 0.0464032239F, 0.0466072475F,
-    0.0468117032F, 0.0470165910F, 0.0472219107F, 0.0474276622F,
-    0.0476338452F, 0.0478404597F, 0.0480475056F, 0.0482549827F,
-    0.0484628907F, 0.0486712297F, 0.0488799994F, 0.0490891998F,
-    0.0492988306F, 0.0495088917F, 0.0497193830F, 0.0499303043F,
-    0.0501416554F, 0.0503534363F, 0.0505656468F, 0.0507782867F,
-    0.0509913559F, 0.0512048542F, 0.0514187815F, 0.0516331376F,
-    0.0518479225F, 0.0520631358F, 0.0522787775F, 0.0524948475F,
-    0.0527113455F, 0.0529282715F, 0.0531456252F, 0.0533634066F,
-    0.0535816154F, 0.0538002515F, 0.0540193148F, 0.0542388051F,
-    0.0544587222F, 0.0546790660F, 0.0548998364F, 0.0551210331F,
-    0.0553426561F, 0.0555647051F, 0.0557871801F, 0.0560100807F,
-    0.0562334070F, 0.0564571587F, 0.0566813357F, 0.0569059378F,
-    0.0571309649F, 0.0573564168F, 0.0575822933F, 0.0578085942F,
-    0.0580353195F, 0.0582624689F, 0.0584900423F, 0.0587180396F,
-    0.0589464605F, 0.0591753049F, 0.0594045726F, 0.0596342635F,
-    0.0598643774F, 0.0600949141F, 0.0603258735F, 0.0605572555F,
-    0.0607890597F, 0.0610212862F, 0.0612539346F, 0.0614870049F,
-    0.0617204968F, 0.0619544103F, 0.0621887451F, 0.0624235010F,
-    0.0626586780F, 0.0628942758F, 0.0631302942F, 0.0633667331F,
-    0.0636035923F, 0.0638408717F, 0.0640785710F, 0.0643166901F,
-    0.0645552288F, 0.0647941870F, 0.0650335645F, 0.0652733610F,
-    0.0655135765F, 0.0657542108F, 0.0659952636F, 0.0662367348F,
-    0.0664786242F, 0.0667209316F, 0.0669636570F, 0.0672068000F,
-    0.0674503605F, 0.0676943384F, 0.0679387334F, 0.0681835454F,
-    0.0684287742F, 0.0686744196F, 0.0689204814F, 0.0691669595F,
-    0.0694138536F, 0.0696611637F, 0.0699088894F, 0.0701570307F,
-    0.0704055873F, 0.0706545590F, 0.0709039458F, 0.0711537473F,
-    0.0714039634F, 0.0716545939F, 0.0719056387F, 0.0721570975F,
-    0.0724089702F, 0.0726612565F, 0.0729139563F, 0.0731670694F,
-    0.0734205956F, 0.0736745347F, 0.0739288866F, 0.0741836510F,
-    0.0744388277F, 0.0746944166F, 0.0749504175F, 0.0752068301F,
-    0.0754636543F, 0.0757208899F, 0.0759785367F, 0.0762365946F,
-    0.0764950632F, 0.0767539424F, 0.0770132320F, 0.0772729319F,
-    0.0775330418F, 0.0777935616F, 0.0780544909F, 0.0783158298F,
-    0.0785775778F, 0.0788397349F, 0.0791023009F, 0.0793652755F,
-    0.0796286585F, 0.0798924498F, 0.0801566492F, 0.0804212564F,
-    0.0806862712F, 0.0809516935F, 0.0812175231F, 0.0814837597F,
-    0.0817504031F, 0.0820174532F, 0.0822849097F, 0.0825527724F,
-    0.0828210412F, 0.0830897158F, 0.0833587960F, 0.0836282816F,
-    0.0838981724F, 0.0841684682F, 0.0844391688F, 0.0847102740F,
-    0.0849817835F, 0.0852536973F, 0.0855260150F, 0.0857987364F,
-    0.0860718614F, 0.0863453897F, 0.0866193211F, 0.0868936554F,
-    0.0871683924F, 0.0874435319F, 0.0877190737F, 0.0879950175F,
-    0.0882713632F, 0.0885481105F, 0.0888252592F, 0.0891028091F,
-    0.0893807600F, 0.0896591117F, 0.0899378639F, 0.0902170165F,
-    0.0904965692F, 0.0907765218F, 0.0910568740F, 0.0913376258F,
-    0.0916187767F, 0.0919003268F, 0.0921822756F, 0.0924646230F,
-    0.0927473687F, 0.0930305126F, 0.0933140545F, 0.0935979940F,
-    0.0938823310F, 0.0941670653F, 0.0944521966F, 0.0947377247F,
-    0.0950236494F, 0.0953099704F, 0.0955966876F, 0.0958838007F,
-    0.0961713094F, 0.0964592136F, 0.0967475131F, 0.0970362075F,
-    0.0973252967F, 0.0976147805F, 0.0979046585F, 0.0981949307F,
-    0.0984855967F, 0.0987766563F, 0.0990681093F, 0.0993599555F,
-    0.0996521945F, 0.0999448263F, 0.1002378506F, 0.1005312671F,
-    0.1008250755F, 0.1011192757F, 0.1014138675F, 0.1017088505F,
-    0.1020042246F, 0.1022999895F, 0.1025961450F, 0.1028926909F,
-    0.1031896268F, 0.1034869526F, 0.1037846680F, 0.1040827729F,
-    0.1043812668F, 0.1046801497F, 0.1049794213F, 0.1052790813F,
-    0.1055791294F, 0.1058795656F, 0.1061803894F, 0.1064816006F,
-    0.1067831991F, 0.1070851846F, 0.1073875568F, 0.1076903155F,
-    0.1079934604F, 0.1082969913F, 0.1086009079F, 0.1089052101F,
-    0.1092098975F, 0.1095149699F, 0.1098204270F, 0.1101262687F,
-    0.1104324946F, 0.1107391045F, 0.1110460982F, 0.1113534754F,
-    0.1116612359F, 0.1119693793F, 0.1122779055F, 0.1125868142F,
-    0.1128961052F, 0.1132057781F, 0.1135158328F, 0.1138262690F,
-    0.1141370863F, 0.1144482847F, 0.1147598638F, 0.1150718233F,
-    0.1153841631F, 0.1156968828F, 0.1160099822F, 0.1163234610F,
-    0.1166373190F, 0.1169515559F, 0.1172661714F, 0.1175811654F,
-    0.1178965374F, 0.1182122874F, 0.1185284149F, 0.1188449198F,
-    0.1191618018F, 0.1194790606F, 0.1197966960F, 0.1201147076F,
-    0.1204330953F, 0.1207518587F, 0.1210709976F, 0.1213905118F,
-    0.1217104009F, 0.1220306647F, 0.1223513029F, 0.1226723153F,
-    0.1229937016F, 0.1233154615F, 0.1236375948F, 0.1239601011F,
-    0.1242829803F, 0.1246062319F, 0.1249298559F, 0.1252538518F,
-    0.1255782195F, 0.1259029586F, 0.1262280689F, 0.1265535501F,
-    0.1268794019F, 0.1272056241F, 0.1275322163F, 0.1278591784F,
-    0.1281865099F, 0.1285142108F, 0.1288422805F, 0.1291707190F,
-    0.1294995259F, 0.1298287009F, 0.1301582437F, 0.1304881542F,
-    0.1308184319F, 0.1311490766F, 0.1314800881F, 0.1318114660F,
-    0.1321432100F, 0.1324753200F, 0.1328077955F, 0.1331406364F,
-    0.1334738422F, 0.1338074129F, 0.1341413479F, 0.1344756472F,
-    0.1348103103F, 0.1351453370F, 0.1354807270F, 0.1358164801F,
-    0.1361525959F, 0.1364890741F, 0.1368259145F, 0.1371631167F,
-    0.1375006805F, 0.1378386056F, 0.1381768917F, 0.1385155384F,
-    0.1388545456F, 0.1391939129F, 0.1395336400F, 0.1398737266F,
-    0.1402141724F, 0.1405549772F, 0.1408961406F, 0.1412376623F,
-    0.1415795421F, 0.1419217797F, 0.1422643746F, 0.1426073268F,
-    0.1429506358F, 0.1432943013F, 0.1436383231F, 0.1439827008F,
-    0.1443274342F, 0.1446725229F, 0.1450179667F, 0.1453637652F,
-    0.1457099181F, 0.1460564252F, 0.1464032861F, 0.1467505006F,
-    0.1470980682F, 0.1474459888F, 0.1477942620F, 0.1481428875F,
-    0.1484918651F, 0.1488411942F, 0.1491908748F, 0.1495409065F,
-    0.1498912889F, 0.1502420218F, 0.1505931048F, 0.1509445376F,
-    0.1512963200F, 0.1516484516F, 0.1520009321F, 0.1523537612F,
-    0.1527069385F, 0.1530604638F, 0.1534143368F, 0.1537685571F,
-    0.1541231244F, 0.1544780384F, 0.1548332987F, 0.1551889052F,
-    0.1555448574F, 0.1559011550F, 0.1562577978F, 0.1566147853F,
-    0.1569721173F, 0.1573297935F, 0.1576878135F, 0.1580461771F,
-    0.1584048838F, 0.1587639334F, 0.1591233255F, 0.1594830599F,
-    0.1598431361F, 0.1602035540F, 0.1605643131F, 0.1609254131F,
-    0.1612868537F, 0.1616486346F, 0.1620107555F, 0.1623732160F,
-    0.1627360158F, 0.1630991545F, 0.1634626319F, 0.1638264476F,
-    0.1641906013F, 0.1645550926F, 0.1649199212F, 0.1652850869F,
-    0.1656505892F, 0.1660164278F, 0.1663826024F, 0.1667491127F,
-    0.1671159583F, 0.1674831388F, 0.1678506541F, 0.1682185036F,
-    0.1685866872F, 0.1689552044F, 0.1693240549F, 0.1696932384F,
-    0.1700627545F, 0.1704326029F, 0.1708027833F, 0.1711732952F,
-    0.1715441385F, 0.1719153127F, 0.1722868175F, 0.1726586526F,
-    0.1730308176F, 0.1734033121F, 0.1737761359F, 0.1741492886F,
-    0.1745227698F, 0.1748965792F, 0.1752707164F, 0.1756451812F,
-    0.1760199731F, 0.1763950918F, 0.1767705370F, 0.1771463083F,
-    0.1775224054F, 0.1778988279F, 0.1782755754F, 0.1786526477F,
-    0.1790300444F, 0.1794077651F, 0.1797858094F, 0.1801641771F,
-    0.1805428677F, 0.1809218810F, 0.1813012165F, 0.1816808739F,
-    0.1820608528F, 0.1824411530F, 0.1828217739F, 0.1832027154F,
-    0.1835839770F, 0.1839655584F, 0.1843474592F, 0.1847296790F,
-    0.1851122175F, 0.1854950744F, 0.1858782492F, 0.1862617417F,
-    0.1866455514F, 0.1870296780F, 0.1874141211F, 0.1877988804F,
-    0.1881839555F, 0.1885693461F, 0.1889550517F, 0.1893410721F,
-    0.1897274068F, 0.1901140555F, 0.1905010178F, 0.1908882933F,
-    0.1912758818F, 0.1916637828F, 0.1920519959F, 0.1924405208F,
-    0.1928293571F, 0.1932185044F, 0.1936079625F, 0.1939977308F,
-    0.1943878091F, 0.1947781969F, 0.1951688939F, 0.1955598998F,
-    0.1959512141F, 0.1963428364F, 0.1967347665F, 0.1971270038F,
-    0.1975195482F, 0.1979123990F, 0.1983055561F, 0.1986990190F,
-    0.1990927873F, 0.1994868607F, 0.1998812388F, 0.2002759212F,
-    0.2006709075F, 0.2010661974F, 0.2014617904F, 0.2018576862F,
-    0.2022538844F, 0.2026503847F, 0.2030471865F, 0.2034442897F,
-    0.2038416937F, 0.2042393982F, 0.2046374028F, 0.2050357071F,
-    0.2054343107F, 0.2058332133F, 0.2062324145F, 0.2066319138F,
-    0.2070317110F, 0.2074318055F, 0.2078321970F, 0.2082328852F,
-    0.2086338696F, 0.2090351498F, 0.2094367255F, 0.2098385962F,
-    0.2102407617F, 0.2106432213F, 0.2110459749F, 0.2114490220F,
-    0.2118523621F, 0.2122559950F, 0.2126599202F, 0.2130641373F,
-    0.2134686459F, 0.2138734456F, 0.2142785361F, 0.2146839168F,
-    0.2150895875F, 0.2154955478F, 0.2159017972F, 0.2163083353F,
-    0.2167151617F, 0.2171222761F, 0.2175296780F, 0.2179373670F,
-    0.2183453428F, 0.2187536049F, 0.2191621529F, 0.2195709864F,
-    0.2199801051F, 0.2203895085F, 0.2207991961F, 0.2212091677F,
-    0.2216194228F, 0.2220299610F, 0.2224407818F, 0.2228518850F,
-    0.2232632699F, 0.2236749364F, 0.2240868839F, 0.2244991121F,
-    0.2249116204F, 0.2253244086F, 0.2257374763F, 0.2261508229F,
-    0.2265644481F, 0.2269783514F, 0.2273925326F, 0.2278069911F,
-    0.2282217265F, 0.2286367384F, 0.2290520265F, 0.2294675902F,
-    0.2298834292F, 0.2302995431F, 0.2307159314F, 0.2311325937F,
-    0.2315495297F, 0.2319667388F, 0.2323842207F, 0.2328019749F,
-    0.2332200011F, 0.2336382988F, 0.2340568675F, 0.2344757070F,
-    0.2348948166F, 0.2353141961F, 0.2357338450F, 0.2361537629F,
-    0.2365739493F, 0.2369944038F, 0.2374151261F, 0.2378361156F,
-    0.2382573720F, 0.2386788948F, 0.2391006836F, 0.2395227380F,
-    0.2399450575F, 0.2403676417F, 0.2407904902F, 0.2412136026F,
-    0.2416369783F, 0.2420606171F, 0.2424845185F, 0.2429086820F,
-    0.2433331072F, 0.2437577936F, 0.2441827409F, 0.2446079486F,
-    0.2450334163F, 0.2454591435F, 0.2458851298F, 0.2463113747F,
-    0.2467378779F, 0.2471646389F, 0.2475916573F, 0.2480189325F,
-    0.2484464643F, 0.2488742521F, 0.2493022955F, 0.2497305940F,
-    0.2501591473F, 0.2505879549F, 0.2510170163F, 0.2514463311F,
-    0.2518758989F, 0.2523057193F, 0.2527357916F, 0.2531661157F,
-    0.2535966909F, 0.2540275169F, 0.2544585931F, 0.2548899193F,
-    0.2553214948F, 0.2557533193F, 0.2561853924F, 0.2566177135F,
-    0.2570502822F, 0.2574830981F, 0.2579161608F, 0.2583494697F,
-    0.2587830245F, 0.2592168246F, 0.2596508697F, 0.2600851593F,
-    0.2605196929F, 0.2609544701F, 0.2613894904F, 0.2618247534F,
-    0.2622602586F, 0.2626960055F, 0.2631319938F, 0.2635682230F,
-    0.2640046925F, 0.2644414021F, 0.2648783511F, 0.2653155391F,
-    0.2657529657F, 0.2661906305F, 0.2666285329F, 0.2670666725F,
-    0.2675050489F, 0.2679436616F, 0.2683825101F, 0.2688215940F,
-    0.2692609127F, 0.2697004660F, 0.2701402532F, 0.2705802739F,
-    0.2710205278F, 0.2714610142F, 0.2719017327F, 0.2723426830F,
-    0.2727838644F, 0.2732252766F, 0.2736669191F, 0.2741087914F,
-    0.2745508930F, 0.2749932235F, 0.2754357824F, 0.2758785693F,
-    0.2763215837F, 0.2767648251F, 0.2772082930F, 0.2776519870F,
-    0.2780959066F, 0.2785400513F, 0.2789844207F, 0.2794290143F,
-    0.2798738316F, 0.2803188722F, 0.2807641355F, 0.2812096211F,
-    0.2816553286F, 0.2821012574F, 0.2825474071F, 0.2829937773F,
-    0.2834403673F, 0.2838871768F, 0.2843342053F, 0.2847814523F,
-    0.2852289174F, 0.2856765999F, 0.2861244996F, 0.2865726159F,
-    0.2870209482F, 0.2874694962F, 0.2879182594F, 0.2883672372F,
-    0.2888164293F, 0.2892658350F, 0.2897154540F, 0.2901652858F,
-    0.2906153298F, 0.2910655856F, 0.2915160527F, 0.2919667306F,
-    0.2924176189F, 0.2928687171F, 0.2933200246F, 0.2937715409F,
-    0.2942232657F, 0.2946751984F, 0.2951273386F, 0.2955796856F,
-    0.2960322391F, 0.2964849986F, 0.2969379636F, 0.2973911335F,
-    0.2978445080F, 0.2982980864F, 0.2987518684F, 0.2992058534F,
-    0.2996600409F, 0.3001144305F, 0.3005690217F, 0.3010238139F,
-    0.3014788067F, 0.3019339995F, 0.3023893920F, 0.3028449835F,
-    0.3033007736F, 0.3037567618F, 0.3042129477F, 0.3046693306F,
-    0.3051259102F, 0.3055826859F, 0.3060396572F, 0.3064968236F,
-    0.3069541847F, 0.3074117399F, 0.3078694887F, 0.3083274307F,
-    0.3087855653F, 0.3092438920F, 0.3097024104F, 0.3101611199F,
-    0.3106200200F, 0.3110791103F, 0.3115383902F, 0.3119978592F,
-    0.3124575169F, 0.3129173627F, 0.3133773961F, 0.3138376166F,
-    0.3142980238F, 0.3147586170F, 0.3152193959F, 0.3156803598F,
-    0.3161415084F, 0.3166028410F, 0.3170643573F, 0.3175260566F,
-    0.3179879384F, 0.3184500023F, 0.3189122478F, 0.3193746743F,
-    0.3198372814F, 0.3203000685F, 0.3207630351F, 0.3212261807F,
-    0.3216895048F, 0.3221530069F, 0.3226166865F, 0.3230805430F,
-    0.3235445760F, 0.3240087849F, 0.3244731693F, 0.3249377285F,
-    0.3254024622F, 0.3258673698F, 0.3263324507F, 0.3267977045F,
-    0.3272631306F, 0.3277287286F, 0.3281944978F, 0.3286604379F,
-    0.3291265482F, 0.3295928284F, 0.3300592777F, 0.3305258958F,
-    0.3309926821F, 0.3314596361F, 0.3319267573F, 0.3323940451F,
-    0.3328614990F, 0.3333291186F, 0.3337969033F, 0.3342648525F,
-    0.3347329658F, 0.3352012427F, 0.3356696825F, 0.3361382849F,
-    0.3366070492F, 0.3370759749F, 0.3375450616F, 0.3380143087F,
-    0.3384837156F, 0.3389532819F, 0.3394230071F, 0.3398928905F,
-    0.3403629317F, 0.3408331302F, 0.3413034854F, 0.3417739967F,
-    0.3422446638F, 0.3427154860F, 0.3431864628F, 0.3436575938F,
-    0.3441288782F, 0.3446003158F, 0.3450719058F, 0.3455436478F,
-    0.3460155412F, 0.3464875856F, 0.3469597804F, 0.3474321250F,
-    0.3479046189F, 0.3483772617F, 0.3488500527F, 0.3493229914F,
-    0.3497960774F, 0.3502693100F, 0.3507426887F, 0.3512162131F,
-    0.3516898825F, 0.3521636965F, 0.3526376545F, 0.3531117559F,
-    0.3535860003F, 0.3540603870F, 0.3545349157F, 0.3550095856F,
-    0.3554843964F, 0.3559593474F, 0.3564344381F, 0.3569096680F,
-    0.3573850366F, 0.3578605432F, 0.3583361875F, 0.3588119687F,
-    0.3592878865F, 0.3597639402F, 0.3602401293F, 0.3607164533F,
-    0.3611929117F, 0.3616695038F, 0.3621462292F, 0.3626230873F,
-    0.3631000776F, 0.3635771995F, 0.3640544525F, 0.3645318360F,
-    0.3650093496F, 0.3654869926F, 0.3659647645F, 0.3664426648F,
-    0.3669206930F, 0.3673988484F, 0.3678771306F, 0.3683555390F,
-    0.3688340731F, 0.3693127322F, 0.3697915160F, 0.3702704237F,
-    0.3707494549F, 0.3712286091F, 0.3717078857F, 0.3721872840F,
-    0.3726668037F, 0.3731464441F, 0.3736262047F, 0.3741060850F,
-    0.3745860843F, 0.3750662023F, 0.3755464382F, 0.3760267915F,
-    0.3765072618F, 0.3769878484F, 0.3774685509F, 0.3779493686F,
-    0.3784303010F, 0.3789113475F, 0.3793925076F, 0.3798737809F,
-    0.3803551666F, 0.3808366642F, 0.3813182733F, 0.3817999932F,
-    0.3822818234F, 0.3827637633F, 0.3832458124F, 0.3837279702F,
-    0.3842102360F, 0.3846926093F, 0.3851750897F, 0.3856576764F,
-    0.3861403690F, 0.3866231670F, 0.3871060696F, 0.3875890765F,
-    0.3880721870F, 0.3885554007F, 0.3890387168F, 0.3895221349F,
-    0.3900056544F, 0.3904892748F, 0.3909729955F, 0.3914568160F,
-    0.3919407356F, 0.3924247539F, 0.3929088702F, 0.3933930841F,
-    0.3938773949F, 0.3943618021F, 0.3948463052F, 0.3953309035F,
-    0.3958155966F, 0.3963003838F, 0.3967852646F, 0.3972702385F,
-    0.3977553048F, 0.3982404631F, 0.3987257127F, 0.3992110531F,
-    0.3996964838F, 0.4001820041F, 0.4006676136F, 0.4011533116F,
-    0.4016390976F, 0.4021249710F, 0.4026109313F, 0.4030969779F,
-    0.4035831102F, 0.4040693277F, 0.4045556299F, 0.4050420160F,
-    0.4055284857F, 0.4060150383F, 0.4065016732F, 0.4069883899F,
-    0.4074751879F, 0.4079620665F, 0.4084490252F, 0.4089360635F,
-    0.4094231807F, 0.4099103763F, 0.4103976498F, 0.4108850005F,
-    0.4113724280F, 0.4118599315F, 0.4123475107F, 0.4128351648F,
-    0.4133228934F, 0.4138106959F, 0.4142985716F, 0.4147865201F,
-    0.4152745408F, 0.4157626330F, 0.4162507963F, 0.4167390301F,
-    0.4172273337F, 0.4177157067F, 0.4182041484F, 0.4186926583F,
-    0.4191812359F, 0.4196698805F, 0.4201585915F, 0.4206473685F,
-    0.4211362108F, 0.4216251179F, 0.4221140892F, 0.4226031241F,
-    0.4230922221F, 0.4235813826F, 0.4240706050F, 0.4245598887F,
-    0.4250492332F, 0.4255386379F, 0.4260281022F, 0.4265176256F,
-    0.4270072075F, 0.4274968473F, 0.4279865445F, 0.4284762984F,
-    0.4289661086F, 0.4294559743F, 0.4299458951F, 0.4304358704F,
-    0.4309258996F, 0.4314159822F, 0.4319061175F, 0.4323963050F,
-    0.4328865441F, 0.4333768342F, 0.4338671749F, 0.4343575654F,
-    0.4348480052F, 0.4353384938F, 0.4358290306F, 0.4363196149F,
-    0.4368102463F, 0.4373009241F, 0.4377916478F, 0.4382824168F,
-    0.4387732305F, 0.4392640884F, 0.4397549899F, 0.4402459343F,
-    0.4407369212F, 0.4412279499F, 0.4417190198F, 0.4422101305F,
-    0.4427012813F, 0.4431924717F, 0.4436837010F, 0.4441749686F,
-    0.4446662742F, 0.4451576169F, 0.4456489963F, 0.4461404118F,
-    0.4466318628F, 0.4471233487F, 0.4476148690F, 0.4481064230F,
-    0.4485980103F, 0.4490896302F, 0.4495812821F, 0.4500729654F,
-    0.4505646797F, 0.4510564243F, 0.4515481986F, 0.4520400021F,
-    0.4525318341F, 0.4530236942F, 0.4535155816F, 0.4540074959F,
-    0.4544994365F, 0.4549914028F, 0.4554833941F, 0.4559754100F,
-    0.4564674499F, 0.4569595131F, 0.4574515991F, 0.4579437074F,
-    0.4584358372F, 0.4589279881F, 0.4594201595F, 0.4599123508F,
-    0.4604045615F, 0.4608967908F, 0.4613890383F, 0.4618813034F,
-    0.4623735855F, 0.4628658841F, 0.4633581984F, 0.4638505281F,
-    0.4643428724F, 0.4648352308F, 0.4653276028F, 0.4658199877F,
-    0.4663123849F, 0.4668047940F, 0.4672972143F, 0.4677896451F,
-    0.4682820861F, 0.4687745365F, 0.4692669958F, 0.4697594634F,
-    0.4702519387F, 0.4707444211F, 0.4712369102F, 0.4717294052F,
-    0.4722219056F, 0.4727144109F, 0.4732069204F, 0.4736994336F,
-    0.4741919498F, 0.4746844686F, 0.4751769893F, 0.4756695113F,
-    0.4761620341F, 0.4766545571F, 0.4771470797F, 0.4776396013F,
-    0.4781321213F, 0.4786246392F, 0.4791171544F, 0.4796096663F,
-    0.4801021744F, 0.4805946779F, 0.4810871765F, 0.4815796694F,
-    0.4820721561F, 0.4825646360F, 0.4830571086F, 0.4835495732F,
-    0.4840420293F, 0.4845344763F, 0.4850269136F, 0.4855193407F,
-    0.4860117569F, 0.4865041617F, 0.4869965545F, 0.4874889347F,
-    0.4879813018F, 0.4884736551F, 0.4889659941F, 0.4894583182F,
-    0.4899506268F, 0.4904429193F, 0.4909351952F, 0.4914274538F,
-    0.4919196947F, 0.4924119172F, 0.4929041207F, 0.4933963046F,
-    0.4938884685F, 0.4943806116F, 0.4948727335F, 0.4953648335F,
-    0.4958569110F, 0.4963489656F, 0.4968409965F, 0.4973330032F,
-    0.4978249852F, 0.4983169419F, 0.4988088726F, 0.4993007768F,
-    0.4997926539F, 0.5002845034F, 0.5007763247F, 0.5012681171F,
-    0.5017598801F, 0.5022516132F, 0.5027433157F, 0.5032349871F,
-    0.5037266268F, 0.5042182341F, 0.5047098086F, 0.5052013497F,
-    0.5056928567F, 0.5061843292F, 0.5066757664F, 0.5071671679F,
-    0.5076585330F, 0.5081498613F, 0.5086411520F, 0.5091324047F,
-    0.5096236187F, 0.5101147934F, 0.5106059284F, 0.5110970230F,
-    0.5115880766F, 0.5120790887F, 0.5125700587F, 0.5130609860F,
-    0.5135518700F, 0.5140427102F, 0.5145335059F, 0.5150242566F,
-    0.5155149618F, 0.5160056208F, 0.5164962331F, 0.5169867980F,
-    0.5174773151F, 0.5179677837F, 0.5184582033F, 0.5189485733F,
-    0.5194388931F, 0.5199291621F, 0.5204193798F, 0.5209095455F,
-    0.5213996588F, 0.5218897190F, 0.5223797256F, 0.5228696779F,
-    0.5233595755F, 0.5238494177F, 0.5243392039F, 0.5248289337F,
-    0.5253186063F, 0.5258082213F, 0.5262977781F, 0.5267872760F,
-    0.5272767146F, 0.5277660932F, 0.5282554112F, 0.5287446682F,
-    0.5292338635F, 0.5297229965F, 0.5302120667F, 0.5307010736F,
-    0.5311900164F, 0.5316788947F, 0.5321677079F, 0.5326564554F,
-    0.5331451366F, 0.5336337511F, 0.5341222981F, 0.5346107771F,
-    0.5350991876F, 0.5355875290F, 0.5360758007F, 0.5365640021F,
-    0.5370521327F, 0.5375401920F, 0.5380281792F, 0.5385160939F,
-    0.5390039355F, 0.5394917034F, 0.5399793971F, 0.5404670159F,
-    0.5409545594F, 0.5414420269F, 0.5419294179F, 0.5424167318F,
-    0.5429039680F, 0.5433911261F, 0.5438782053F, 0.5443652051F,
-    0.5448521250F, 0.5453389644F, 0.5458257228F, 0.5463123995F,
-    0.5467989940F, 0.5472855057F, 0.5477719341F, 0.5482582786F,
-    0.5487445387F, 0.5492307137F, 0.5497168031F, 0.5502028063F,
-    0.5506887228F, 0.5511745520F, 0.5516602934F, 0.5521459463F,
-    0.5526315103F, 0.5531169847F, 0.5536023690F, 0.5540876626F,
-    0.5545728649F, 0.5550579755F, 0.5555429937F, 0.5560279189F,
-    0.5565127507F, 0.5569974884F, 0.5574821315F, 0.5579666794F,
-    0.5584511316F, 0.5589354875F, 0.5594197465F, 0.5599039080F,
-    0.5603879716F, 0.5608719367F, 0.5613558026F, 0.5618395689F,
-    0.5623232350F, 0.5628068002F, 0.5632902642F, 0.5637736262F,
-    0.5642568858F, 0.5647400423F, 0.5652230953F, 0.5657060442F,
-    0.5661888883F, 0.5666716272F, 0.5671542603F, 0.5676367870F,
-    0.5681192069F, 0.5686015192F, 0.5690837235F, 0.5695658192F,
-    0.5700478058F, 0.5705296827F, 0.5710114494F, 0.5714931052F,
-    0.5719746497F, 0.5724560822F, 0.5729374023F, 0.5734186094F,
-    0.5738997029F, 0.5743806823F, 0.5748615470F, 0.5753422965F,
-    0.5758229301F, 0.5763034475F, 0.5767838480F, 0.5772641310F,
-    0.5777442960F, 0.5782243426F, 0.5787042700F, 0.5791840778F,
-    0.5796637654F, 0.5801433322F, 0.5806227778F, 0.5811021016F,
-    0.5815813029F, 0.5820603814F, 0.5825393363F, 0.5830181673F,
-    0.5834968737F, 0.5839754549F, 0.5844539105F, 0.5849322399F,
-    0.5854104425F, 0.5858885179F, 0.5863664653F, 0.5868442844F,
-    0.5873219746F, 0.5877995353F, 0.5882769660F, 0.5887542661F,
-    0.5892314351F, 0.5897084724F, 0.5901853776F, 0.5906621500F,
-    0.5911387892F, 0.5916152945F, 0.5920916655F, 0.5925679016F,
-    0.5930440022F, 0.5935199669F, 0.5939957950F, 0.5944714861F,
-    0.5949470396F, 0.5954224550F, 0.5958977317F, 0.5963728692F,
-    0.5968478669F, 0.5973227244F, 0.5977974411F, 0.5982720163F,
-    0.5987464497F, 0.5992207407F, 0.5996948887F, 0.6001688932F,
-    0.6006427537F, 0.6011164696F, 0.6015900405F, 0.6020634657F,
-    0.6025367447F, 0.6030098770F, 0.6034828621F, 0.6039556995F,
-    0.6044283885F, 0.6049009288F, 0.6053733196F, 0.6058455606F,
-    0.6063176512F, 0.6067895909F, 0.6072613790F, 0.6077330152F,
-    0.6082044989F, 0.6086758295F, 0.6091470065F, 0.6096180294F,
-    0.6100888977F, 0.6105596108F, 0.6110301682F, 0.6115005694F,
-    0.6119708139F, 0.6124409011F, 0.6129108305F, 0.6133806017F,
-    0.6138502139F, 0.6143196669F, 0.6147889599F, 0.6152580926F,
-    0.6157270643F, 0.6161958746F, 0.6166645230F, 0.6171330088F,
-    0.6176013317F, 0.6180694910F, 0.6185374863F, 0.6190053171F,
-    0.6194729827F, 0.6199404828F, 0.6204078167F, 0.6208749841F,
-    0.6213419842F, 0.6218088168F, 0.6222754811F, 0.6227419768F,
-    0.6232083032F, 0.6236744600F, 0.6241404465F, 0.6246062622F,
-    0.6250719067F, 0.6255373795F, 0.6260026799F, 0.6264678076F,
-    0.6269327619F, 0.6273975425F, 0.6278621487F, 0.6283265800F,
-    0.6287908361F, 0.6292549163F, 0.6297188201F, 0.6301825471F,
-    0.6306460966F, 0.6311094683F, 0.6315726617F, 0.6320356761F,
-    0.6324985111F, 0.6329611662F, 0.6334236410F, 0.6338859348F,
-    0.6343480472F, 0.6348099777F, 0.6352717257F, 0.6357332909F,
-    0.6361946726F, 0.6366558704F, 0.6371168837F, 0.6375777122F,
-    0.6380383552F, 0.6384988123F, 0.6389590830F, 0.6394191668F,
-    0.6398790631F, 0.6403387716F, 0.6407982916F, 0.6412576228F,
-    0.6417167645F, 0.6421757163F, 0.6426344778F, 0.6430930483F,
-    0.6435514275F, 0.6440096149F, 0.6444676098F, 0.6449254119F,
-    0.6453830207F, 0.6458404356F, 0.6462976562F, 0.6467546820F,
-    0.6472115125F, 0.6476681472F, 0.6481245856F, 0.6485808273F,
-    0.6490368717F, 0.6494927183F, 0.6499483667F, 0.6504038164F,
-    0.6508590670F, 0.6513141178F, 0.6517689684F, 0.6522236185F,
-    0.6526780673F, 0.6531323146F, 0.6535863598F, 0.6540402024F,
-    0.6544938419F, 0.6549472779F, 0.6554005099F, 0.6558535373F,
-    0.6563063598F, 0.6567589769F, 0.6572113880F, 0.6576635927F,
-    0.6581155906F, 0.6585673810F, 0.6590189637F, 0.6594703380F,
-    0.6599215035F, 0.6603724598F, 0.6608232064F, 0.6612737427F,
-    0.6617240684F, 0.6621741829F, 0.6626240859F, 0.6630737767F,
-    0.6635232550F, 0.6639725202F, 0.6644215720F, 0.6648704098F,
-    0.6653190332F, 0.6657674417F, 0.6662156348F, 0.6666636121F,
-    0.6671113731F, 0.6675589174F, 0.6680062445F, 0.6684533538F,
-    0.6689002450F, 0.6693469177F, 0.6697933712F, 0.6702396052F,
-    0.6706856193F, 0.6711314129F, 0.6715769855F, 0.6720223369F,
-    0.6724674664F, 0.6729123736F, 0.6733570581F, 0.6738015194F,
-    0.6742457570F, 0.6746897706F, 0.6751335596F, 0.6755771236F,
-    0.6760204621F, 0.6764635747F, 0.6769064609F, 0.6773491204F,
-    0.6777915525F, 0.6782337570F, 0.6786757332F, 0.6791174809F,
-    0.6795589995F, 0.6800002886F, 0.6804413477F, 0.6808821765F,
-    0.6813227743F, 0.6817631409F, 0.6822032758F, 0.6826431785F,
-    0.6830828485F, 0.6835222855F, 0.6839614890F, 0.6844004585F,
-    0.6848391936F, 0.6852776939F, 0.6857159589F, 0.6861539883F,
-    0.6865917815F, 0.6870293381F, 0.6874666576F, 0.6879037398F,
-    0.6883405840F, 0.6887771899F, 0.6892135571F, 0.6896496850F,
-    0.6900855733F, 0.6905212216F, 0.6909566294F, 0.6913917963F,
-    0.6918267218F, 0.6922614055F, 0.6926958471F, 0.6931300459F,
-    0.6935640018F, 0.6939977141F, 0.6944311825F, 0.6948644066F,
-    0.6952973859F, 0.6957301200F, 0.6961626085F, 0.6965948510F,
-    0.6970268470F, 0.6974585961F, 0.6978900980F, 0.6983213521F,
-    0.6987523580F, 0.6991831154F, 0.6996136238F, 0.7000438828F,
-    0.7004738921F, 0.7009036510F, 0.7013331594F, 0.7017624166F,
-    0.7021914224F, 0.7026201763F, 0.7030486779F, 0.7034769268F,
-    0.7039049226F, 0.7043326648F, 0.7047601531F, 0.7051873870F,
-    0.7056143662F, 0.7060410902F, 0.7064675586F, 0.7068937711F,
-    0.7073197271F, 0.7077454264F, 0.7081708684F, 0.7085960529F,
-    0.7090209793F, 0.7094456474F, 0.7098700566F, 0.7102942066F,
-    0.7107180970F, 0.7111417274F, 0.7115650974F, 0.7119882066F,
-    0.7124110545F, 0.7128336409F, 0.7132559653F, 0.7136780272F,
-    0.7140998264F, 0.7145213624F, 0.7149426348F, 0.7153636433F,
-    0.7157843874F, 0.7162048668F, 0.7166250810F, 0.7170450296F,
-    0.7174647124F, 0.7178841289F, 0.7183032786F, 0.7187221613F,
-    0.7191407765F, 0.7195591239F, 0.7199772030F, 0.7203950135F,
-    0.7208125550F, 0.7212298271F, 0.7216468294F, 0.7220635616F,
-    0.7224800233F, 0.7228962140F, 0.7233121335F, 0.7237277813F,
-    0.7241431571F, 0.7245582604F, 0.7249730910F, 0.7253876484F,
-    0.7258019322F, 0.7262159422F, 0.7266296778F, 0.7270431388F,
-    0.7274563247F, 0.7278692353F, 0.7282818700F, 0.7286942287F,
-    0.7291063108F, 0.7295181160F, 0.7299296440F, 0.7303408944F,
-    0.7307518669F, 0.7311625609F, 0.7315729763F, 0.7319831126F,
-    0.7323929695F, 0.7328025466F, 0.7332118435F, 0.7336208600F,
-    0.7340295955F, 0.7344380499F, 0.7348462226F, 0.7352541134F,
-    0.7356617220F, 0.7360690478F, 0.7364760907F, 0.7368828502F,
-    0.7372893259F, 0.7376955176F, 0.7381014249F, 0.7385070475F,
-    0.7389123849F, 0.7393174368F, 0.7397222029F, 0.7401266829F,
-    0.7405308763F, 0.7409347829F, 0.7413384023F, 0.7417417341F,
-    0.7421447780F, 0.7425475338F, 0.7429500009F, 0.7433521791F,
-    0.7437540681F, 0.7441556674F, 0.7445569769F, 0.7449579960F,
-    0.7453587245F, 0.7457591621F, 0.7461593084F, 0.7465591631F,
-    0.7469587259F, 0.7473579963F, 0.7477569741F, 0.7481556590F,
-    0.7485540506F, 0.7489521486F, 0.7493499526F, 0.7497474623F,
-    0.7501446775F, 0.7505415977F, 0.7509382227F, 0.7513345521F,
-    0.7517305856F, 0.7521263229F, 0.7525217636F, 0.7529169074F,
-    0.7533117541F, 0.7537063032F, 0.7541005545F, 0.7544945076F,
-    0.7548881623F, 0.7552815182F, 0.7556745749F, 0.7560673323F,
-    0.7564597899F, 0.7568519474F, 0.7572438046F, 0.7576353611F,
-    0.7580266166F, 0.7584175708F, 0.7588082235F, 0.7591985741F,
-    0.7595886226F, 0.7599783685F, 0.7603678116F, 0.7607569515F,
-    0.7611457879F, 0.7615343206F, 0.7619225493F, 0.7623104735F,
-    0.7626980931F, 0.7630854078F, 0.7634724171F, 0.7638591209F,
-    0.7642455188F, 0.7646316106F, 0.7650173959F, 0.7654028744F,
-    0.7657880459F, 0.7661729100F, 0.7665574664F, 0.7669417150F,
-    0.7673256553F, 0.7677092871F, 0.7680926100F, 0.7684756239F,
-    0.7688583284F, 0.7692407232F, 0.7696228080F, 0.7700045826F,
-    0.7703860467F, 0.7707671999F, 0.7711480420F, 0.7715285728F,
-    0.7719087918F, 0.7722886989F, 0.7726682938F, 0.7730475762F,
-    0.7734265458F, 0.7738052023F, 0.7741835454F, 0.7745615750F,
-    0.7749392906F, 0.7753166921F, 0.7756937791F, 0.7760705514F,
-    0.7764470087F, 0.7768231508F, 0.7771989773F, 0.7775744880F,
-    0.7779496827F, 0.7783245610F, 0.7786991227F, 0.7790733676F,
-    0.7794472953F, 0.7798209056F, 0.7801941982F, 0.7805671729F,
-    0.7809398294F, 0.7813121675F, 0.7816841869F, 0.7820558873F,
-    0.7824272684F, 0.7827983301F, 0.7831690720F, 0.7835394940F,
-    0.7839095957F, 0.7842793768F, 0.7846488373F, 0.7850179767F,
-    0.7853867948F, 0.7857552914F, 0.7861234663F, 0.7864913191F,
-    0.7868588497F, 0.7872260578F, 0.7875929431F, 0.7879595055F,
-    0.7883257445F, 0.7886916601F, 0.7890572520F, 0.7894225198F,
-    0.7897874635F, 0.7901520827F, 0.7905163772F, 0.7908803468F,
-    0.7912439912F, 0.7916073102F, 0.7919703035F, 0.7923329710F,
-    0.7926953124F, 0.7930573274F, 0.7934190158F, 0.7937803774F,
-    0.7941414120F, 0.7945021193F, 0.7948624991F, 0.7952225511F,
-    0.7955822752F, 0.7959416711F, 0.7963007387F, 0.7966594775F,
-    0.7970178875F, 0.7973759685F, 0.7977337201F, 0.7980911422F,
-    0.7984482346F, 0.7988049970F, 0.7991614292F, 0.7995175310F,
-    0.7998733022F, 0.8002287426F, 0.8005838519F, 0.8009386299F,
-    0.8012930765F, 0.8016471914F, 0.8020009744F, 0.8023544253F,
-    0.8027075438F, 0.8030603298F, 0.8034127831F, 0.8037649035F,
-    0.8041166906F, 0.8044681445F, 0.8048192647F, 0.8051700512F,
-    0.8055205038F, 0.8058706222F, 0.8062204062F, 0.8065698556F,
-    0.8069189702F, 0.8072677499F, 0.8076161944F, 0.8079643036F,
-    0.8083120772F, 0.8086595151F, 0.8090066170F, 0.8093533827F,
-    0.8096998122F, 0.8100459051F, 0.8103916613F, 0.8107370806F,
-    0.8110821628F, 0.8114269077F, 0.8117713151F, 0.8121153849F,
-    0.8124591169F, 0.8128025108F, 0.8131455666F, 0.8134882839F,
-    0.8138306627F, 0.8141727027F, 0.8145144038F, 0.8148557658F,
-    0.8151967886F, 0.8155374718F, 0.8158778154F, 0.8162178192F,
-    0.8165574830F, 0.8168968067F, 0.8172357900F, 0.8175744328F,
-    0.8179127349F, 0.8182506962F, 0.8185883164F, 0.8189255955F,
-    0.8192625332F, 0.8195991295F, 0.8199353840F, 0.8202712967F,
-    0.8206068673F, 0.8209420958F, 0.8212769820F, 0.8216115256F,
-    0.8219457266F, 0.8222795848F, 0.8226131000F, 0.8229462721F,
-    0.8232791009F, 0.8236115863F, 0.8239437280F, 0.8242755260F,
-    0.8246069801F, 0.8249380901F, 0.8252688559F, 0.8255992774F,
-    0.8259293544F, 0.8262590867F, 0.8265884741F, 0.8269175167F,
-    0.8272462141F, 0.8275745663F, 0.8279025732F, 0.8282302344F,
-    0.8285575501F, 0.8288845199F, 0.8292111437F, 0.8295374215F,
-    0.8298633530F, 0.8301889382F, 0.8305141768F, 0.8308390688F,
-    0.8311636141F, 0.8314878124F, 0.8318116637F, 0.8321351678F,
-    0.8324583246F, 0.8327811340F, 0.8331035957F, 0.8334257098F,
-    0.8337474761F, 0.8340688944F, 0.8343899647F, 0.8347106867F,
-    0.8350310605F, 0.8353510857F, 0.8356707624F, 0.8359900904F,
-    0.8363090696F, 0.8366276999F, 0.8369459811F, 0.8372639131F,
-    0.8375814958F, 0.8378987292F, 0.8382156130F, 0.8385321472F,
-    0.8388483316F, 0.8391641662F, 0.8394796508F, 0.8397947853F,
-    0.8401095697F, 0.8404240037F, 0.8407380873F, 0.8410518204F,
-    0.8413652029F, 0.8416782347F, 0.8419909156F, 0.8423032456F,
-    0.8426152245F, 0.8429268523F, 0.8432381289F, 0.8435490541F,
-    0.8438596279F, 0.8441698502F, 0.8444797208F, 0.8447892396F,
-    0.8450984067F, 0.8454072218F, 0.8457156849F, 0.8460237959F,
-    0.8463315547F, 0.8466389612F, 0.8469460154F, 0.8472527170F,
-    0.8475590661F, 0.8478650625F, 0.8481707063F, 0.8484759971F,
-    0.8487809351F, 0.8490855201F, 0.8493897521F, 0.8496936308F,
-    0.8499971564F, 0.8503003286F, 0.8506031474F, 0.8509056128F,
-    0.8512077246F, 0.8515094828F, 0.8518108872F, 0.8521119379F,
-    0.8524126348F, 0.8527129777F, 0.8530129666F, 0.8533126015F,
-    0.8536118822F, 0.8539108087F, 0.8542093809F, 0.8545075988F,
-    0.8548054623F, 0.8551029712F, 0.8554001257F, 0.8556969255F,
-    0.8559933707F, 0.8562894611F, 0.8565851968F, 0.8568805775F,
-    0.8571756034F, 0.8574702743F, 0.8577645902F, 0.8580585509F,
-    0.8583521566F, 0.8586454070F, 0.8589383021F, 0.8592308420F,
-    0.8595230265F, 0.8598148556F, 0.8601063292F, 0.8603974473F,
-    0.8606882098F, 0.8609786167F, 0.8612686680F, 0.8615583636F,
-    0.8618477034F, 0.8621366874F, 0.8624253156F, 0.8627135878F,
-    0.8630015042F, 0.8632890646F, 0.8635762690F, 0.8638631173F,
-    0.8641496096F, 0.8644357457F, 0.8647215257F, 0.8650069495F,
-    0.8652920171F, 0.8655767283F, 0.8658610833F, 0.8661450820F,
-    0.8664287243F, 0.8667120102F, 0.8669949397F, 0.8672775127F,
-    0.8675597293F, 0.8678415894F, 0.8681230929F, 0.8684042398F,
-    0.8686850302F, 0.8689654640F, 0.8692455412F, 0.8695252617F,
-    0.8698046255F, 0.8700836327F, 0.8703622831F, 0.8706405768F,
-    0.8709185138F, 0.8711960940F, 0.8714733174F, 0.8717501840F,
-    0.8720266939F, 0.8723028469F, 0.8725786430F, 0.8728540824F,
-    0.8731291648F, 0.8734038905F, 0.8736782592F, 0.8739522711F,
-    0.8742259261F, 0.8744992242F, 0.8747721653F, 0.8750447496F,
-    0.8753169770F, 0.8755888475F, 0.8758603611F, 0.8761315177F,
-    0.8764023175F, 0.8766727603F, 0.8769428462F, 0.8772125752F,
-    0.8774819474F, 0.8777509626F, 0.8780196209F, 0.8782879224F,
-    0.8785558669F, 0.8788234546F, 0.8790906854F, 0.8793575594F,
-    0.8796240765F, 0.8798902368F, 0.8801560403F, 0.8804214870F,
-    0.8806865768F, 0.8809513099F, 0.8812156863F, 0.8814797059F,
-    0.8817433687F, 0.8820066749F, 0.8822696243F, 0.8825322171F,
-    0.8827944532F, 0.8830563327F, 0.8833178556F, 0.8835790219F,
-    0.8838398316F, 0.8841002848F, 0.8843603815F, 0.8846201217F,
-    0.8848795054F, 0.8851385327F, 0.8853972036F, 0.8856555182F,
-    0.8859134764F, 0.8861710783F, 0.8864283239F, 0.8866852133F,
-    0.8869417464F, 0.8871979234F, 0.8874537443F, 0.8877092090F,
-    0.8879643177F, 0.8882190704F, 0.8884734671F, 0.8887275078F,
-    0.8889811927F, 0.8892345216F, 0.8894874948F, 0.8897401122F,
-    0.8899923738F, 0.8902442798F, 0.8904958301F, 0.8907470248F,
-    0.8909978640F, 0.8912483477F, 0.8914984759F, 0.8917482487F,
-    0.8919976662F, 0.8922467284F, 0.8924954353F, 0.8927437871F,
-    0.8929917837F, 0.8932394252F, 0.8934867118F, 0.8937336433F,
-    0.8939802199F, 0.8942264417F, 0.8944723087F, 0.8947178210F,
-    0.8949629785F, 0.8952077815F, 0.8954522299F, 0.8956963239F,
-    0.8959400634F, 0.8961834486F, 0.8964264795F, 0.8966691561F,
-    0.8969114786F, 0.8971534470F, 0.8973950614F, 0.8976363219F,
-    0.8978772284F, 0.8981177812F, 0.8983579802F, 0.8985978256F,
-    0.8988373174F, 0.8990764556F, 0.8993152405F, 0.8995536720F,
-    0.8997917502F, 0.9000294751F, 0.9002668470F, 0.9005038658F,
-    0.9007405317F, 0.9009768446F, 0.9012128048F, 0.9014484123F,
-    0.9016836671F, 0.9019185693F, 0.9021531191F, 0.9023873165F,
-    0.9026211616F, 0.9028546546F, 0.9030877954F, 0.9033205841F,
-    0.9035530210F, 0.9037851059F, 0.9040168392F, 0.9042482207F,
-    0.9044792507F, 0.9047099293F, 0.9049402564F, 0.9051702323F,
-    0.9053998569F, 0.9056291305F, 0.9058580531F, 0.9060866248F,
-    0.9063148457F, 0.9065427159F, 0.9067702355F, 0.9069974046F,
-    0.9072242233F, 0.9074506917F, 0.9076768100F, 0.9079025782F,
-    0.9081279964F, 0.9083530647F, 0.9085777833F, 0.9088021523F,
-    0.9090261717F, 0.9092498417F, 0.9094731623F, 0.9096961338F,
-    0.9099187561F, 0.9101410295F, 0.9103629540F, 0.9105845297F,
-    0.9108057568F, 0.9110266354F, 0.9112471656F, 0.9114673475F,
-    0.9116871812F, 0.9119066668F, 0.9121258046F, 0.9123445945F,
-    0.9125630367F, 0.9127811314F, 0.9129988786F, 0.9132162785F,
-    0.9134333312F, 0.9136500368F, 0.9138663954F, 0.9140824073F,
-    0.9142980724F, 0.9145133910F, 0.9147283632F, 0.9149429890F,
-    0.9151572687F, 0.9153712023F, 0.9155847900F, 0.9157980319F,
-    0.9160109282F, 0.9162234790F, 0.9164356844F, 0.9166475445F,
-    0.9168590595F, 0.9170702296F, 0.9172810548F, 0.9174915354F,
-    0.9177016714F, 0.9179114629F, 0.9181209102F, 0.9183300134F,
-    0.9185387726F, 0.9187471879F, 0.9189552595F, 0.9191629876F,
-    0.9193703723F, 0.9195774136F, 0.9197841119F, 0.9199904672F,
-    0.9201964797F, 0.9204021495F, 0.9206074767F, 0.9208124616F,
-    0.9210171043F, 0.9212214049F, 0.9214253636F, 0.9216289805F,
-    0.9218322558F, 0.9220351896F, 0.9222377821F, 0.9224400335F,
-    0.9226419439F, 0.9228435134F, 0.9230447423F, 0.9232456307F,
-    0.9234461787F, 0.9236463865F, 0.9238462543F, 0.9240457822F,
-    0.9242449704F, 0.9244438190F, 0.9246423282F, 0.9248404983F,
-    0.9250383293F, 0.9252358214F, 0.9254329747F, 0.9256297896F,
-    0.9258262660F, 0.9260224042F, 0.9262182044F, 0.9264136667F,
-    0.9266087913F, 0.9268035783F, 0.9269980280F, 0.9271921405F,
-    0.9273859160F, 0.9275793546F, 0.9277724566F, 0.9279652221F,
-    0.9281576513F, 0.9283497443F, 0.9285415014F, 0.9287329227F,
-    0.9289240084F, 0.9291147586F, 0.9293051737F, 0.9294952536F,
-    0.9296849987F, 0.9298744091F, 0.9300634850F, 0.9302522266F,
-    0.9304406340F, 0.9306287074F, 0.9308164471F, 0.9310038532F,
-    0.9311909259F, 0.9313776654F, 0.9315640719F, 0.9317501455F,
-    0.9319358865F, 0.9321212951F, 0.9323063713F, 0.9324911155F,
-    0.9326755279F, 0.9328596085F, 0.9330433577F, 0.9332267756F,
-    0.9334098623F, 0.9335926182F, 0.9337750434F, 0.9339571380F,
-    0.9341389023F, 0.9343203366F, 0.9345014409F, 0.9346822155F,
-    0.9348626606F, 0.9350427763F, 0.9352225630F, 0.9354020207F,
-    0.9355811498F, 0.9357599503F, 0.9359384226F, 0.9361165667F,
-    0.9362943830F, 0.9364718716F, 0.9366490327F, 0.9368258666F,
-    0.9370023733F, 0.9371785533F, 0.9373544066F, 0.9375299335F,
-    0.9377051341F, 0.9378800087F, 0.9380545576F, 0.9382287809F,
-    0.9384026787F, 0.9385762515F, 0.9387494993F, 0.9389224223F,
-    0.9390950209F, 0.9392672951F, 0.9394392453F, 0.9396108716F,
-    0.9397821743F, 0.9399531536F, 0.9401238096F, 0.9402941427F,
-    0.9404641530F, 0.9406338407F, 0.9408032061F, 0.9409722495F,
-    0.9411409709F, 0.9413093707F, 0.9414774491F, 0.9416452062F,
-    0.9418126424F, 0.9419797579F, 0.9421465528F, 0.9423130274F,
-    0.9424791819F, 0.9426450166F, 0.9428105317F, 0.9429757274F,
-    0.9431406039F, 0.9433051616F, 0.9434694005F, 0.9436333209F,
-    0.9437969232F, 0.9439602074F, 0.9441231739F, 0.9442858229F,
-    0.9444481545F, 0.9446101691F, 0.9447718669F, 0.9449332481F,
-    0.9450943129F, 0.9452550617F, 0.9454154945F, 0.9455756118F,
-    0.9457354136F, 0.9458949003F, 0.9460540721F, 0.9462129292F,
-    0.9463714719F, 0.9465297003F, 0.9466876149F, 0.9468452157F,
-    0.9470025031F, 0.9471594772F, 0.9473161384F, 0.9474724869F,
-    0.9476285229F, 0.9477842466F, 0.9479396584F, 0.9480947585F,
-    0.9482495470F, 0.9484040243F, 0.9485581906F, 0.9487120462F,
-    0.9488655913F, 0.9490188262F, 0.9491717511F, 0.9493243662F,
-    0.9494766718F, 0.9496286683F, 0.9497803557F, 0.9499317345F,
-    0.9500828047F, 0.9502335668F, 0.9503840209F, 0.9505341673F,
-    0.9506840062F, 0.9508335380F, 0.9509827629F, 0.9511316810F,
-    0.9512802928F, 0.9514285984F, 0.9515765982F, 0.9517242923F,
-    0.9518716810F, 0.9520187646F, 0.9521655434F, 0.9523120176F,
-    0.9524581875F, 0.9526040534F, 0.9527496154F, 0.9528948739F,
-    0.9530398292F, 0.9531844814F, 0.9533288310F, 0.9534728780F,
-    0.9536166229F, 0.9537600659F, 0.9539032071F, 0.9540460470F,
-    0.9541885858F, 0.9543308237F, 0.9544727611F, 0.9546143981F,
-    0.9547557351F, 0.9548967723F, 0.9550375100F, 0.9551779485F,
-    0.9553180881F, 0.9554579290F, 0.9555974714F, 0.9557367158F,
-    0.9558756623F, 0.9560143112F, 0.9561526628F, 0.9562907174F,
-    0.9564284752F, 0.9565659366F, 0.9567031017F, 0.9568399710F,
-    0.9569765446F, 0.9571128229F, 0.9572488061F, 0.9573844944F,
-    0.9575198883F, 0.9576549879F, 0.9577897936F, 0.9579243056F,
-    0.9580585242F, 0.9581924497F, 0.9583260824F, 0.9584594226F,
-    0.9585924705F, 0.9587252264F, 0.9588576906F, 0.9589898634F,
-    0.9591217452F, 0.9592533360F, 0.9593846364F, 0.9595156465F,
-    0.9596463666F, 0.9597767971F, 0.9599069382F, 0.9600367901F,
-    0.9601663533F, 0.9602956279F, 0.9604246143F, 0.9605533128F,
-    0.9606817236F, 0.9608098471F, 0.9609376835F, 0.9610652332F,
-    0.9611924963F, 0.9613194733F, 0.9614461644F, 0.9615725699F,
-    0.9616986901F, 0.9618245253F, 0.9619500757F, 0.9620753418F,
-    0.9622003238F, 0.9623250219F, 0.9624494365F, 0.9625735679F,
-    0.9626974163F, 0.9628209821F, 0.9629442656F, 0.9630672671F,
-    0.9631899868F, 0.9633124251F, 0.9634345822F, 0.9635564585F,
-    0.9636780543F, 0.9637993699F, 0.9639204056F, 0.9640411616F,
-    0.9641616383F, 0.9642818359F, 0.9644017549F, 0.9645213955F,
-    0.9646407579F, 0.9647598426F, 0.9648786497F, 0.9649971797F,
-    0.9651154328F, 0.9652334092F, 0.9653511095F, 0.9654685337F,
-    0.9655856823F, 0.9657025556F, 0.9658191538F, 0.9659354773F,
-    0.9660515263F, 0.9661673013F, 0.9662828024F, 0.9663980300F,
-    0.9665129845F, 0.9666276660F, 0.9667420750F, 0.9668562118F,
-    0.9669700766F, 0.9670836698F, 0.9671969917F, 0.9673100425F,
-    0.9674228227F, 0.9675353325F, 0.9676475722F, 0.9677595422F,
-    0.9678712428F, 0.9679826742F, 0.9680938368F, 0.9682047309F,
-    0.9683153569F, 0.9684257150F, 0.9685358056F, 0.9686456289F,
-    0.9687551853F, 0.9688644752F, 0.9689734987F, 0.9690822564F,
-    0.9691907483F, 0.9692989750F, 0.9694069367F, 0.9695146337F,
-    0.9696220663F, 0.9697292349F, 0.9698361398F, 0.9699427813F,
-    0.9700491597F, 0.9701552754F, 0.9702611286F, 0.9703667197F,
-    0.9704720490F, 0.9705771169F, 0.9706819236F, 0.9707864695F,
-    0.9708907549F, 0.9709947802F, 0.9710985456F, 0.9712020514F,
-    0.9713052981F, 0.9714082859F, 0.9715110151F, 0.9716134862F,
-    0.9717156993F, 0.9718176549F, 0.9719193532F, 0.9720207946F,
-    0.9721219794F, 0.9722229080F, 0.9723235806F, 0.9724239976F,
-    0.9725241593F, 0.9726240661F, 0.9727237183F, 0.9728231161F,
-    0.9729222601F, 0.9730211503F, 0.9731197873F, 0.9732181713F,
-    0.9733163027F, 0.9734141817F, 0.9735118088F, 0.9736091842F,
-    0.9737063083F, 0.9738031814F, 0.9738998039F, 0.9739961760F,
-    0.9740922981F, 0.9741881706F, 0.9742837938F, 0.9743791680F,
-    0.9744742935F, 0.9745691707F, 0.9746637999F, 0.9747581814F,
-    0.9748523157F, 0.9749462029F, 0.9750398435F, 0.9751332378F,
-    0.9752263861F, 0.9753192887F, 0.9754119461F, 0.9755043585F,
-    0.9755965262F, 0.9756884496F, 0.9757801291F, 0.9758715650F,
-    0.9759627575F, 0.9760537071F, 0.9761444141F, 0.9762348789F,
-    0.9763251016F, 0.9764150828F, 0.9765048228F, 0.9765943218F,
-    0.9766835802F, 0.9767725984F, 0.9768613767F, 0.9769499154F,
-    0.9770382149F, 0.9771262755F, 0.9772140976F, 0.9773016815F,
-    0.9773890275F, 0.9774761360F, 0.9775630073F, 0.9776496418F,
-    0.9777360398F, 0.9778222016F, 0.9779081277F, 0.9779938182F,
-    0.9780792736F, 0.9781644943F, 0.9782494805F, 0.9783342326F,
-    0.9784187509F, 0.9785030359F, 0.9785870877F, 0.9786709069F,
-    0.9787544936F, 0.9788378484F, 0.9789209714F, 0.9790038631F,
-    0.9790865238F, 0.9791689538F, 0.9792511535F, 0.9793331232F,
-    0.9794148633F, 0.9794963742F, 0.9795776561F, 0.9796587094F,
-    0.9797395345F, 0.9798201316F, 0.9799005013F, 0.9799806437F,
-    0.9800605593F, 0.9801402483F, 0.9802197112F, 0.9802989483F,
-    0.9803779600F, 0.9804567465F, 0.9805353082F, 0.9806136455F,
-    0.9806917587F, 0.9807696482F, 0.9808473143F, 0.9809247574F,
-    0.9810019778F, 0.9810789759F, 0.9811557519F, 0.9812323064F,
-    0.9813086395F, 0.9813847517F, 0.9814606433F, 0.9815363147F,
-    0.9816117662F, 0.9816869981F, 0.9817620108F, 0.9818368047F,
-    0.9819113801F, 0.9819857374F, 0.9820598769F, 0.9821337989F,
-    0.9822075038F, 0.9822809920F, 0.9823542638F, 0.9824273195F,
-    0.9825001596F, 0.9825727843F, 0.9826451940F, 0.9827173891F,
-    0.9827893700F, 0.9828611368F, 0.9829326901F, 0.9830040302F,
-    0.9830751574F, 0.9831460720F, 0.9832167745F, 0.9832872652F,
-    0.9833575444F, 0.9834276124F, 0.9834974697F, 0.9835671166F,
-    0.9836365535F, 0.9837057806F, 0.9837747983F, 0.9838436071F,
-    0.9839122072F, 0.9839805990F, 0.9840487829F, 0.9841167591F,
-    0.9841845282F, 0.9842520903F, 0.9843194459F, 0.9843865953F,
-    0.9844535389F, 0.9845202771F, 0.9845868101F, 0.9846531383F,
-    0.9847192622F, 0.9847851820F, 0.9848508980F, 0.9849164108F,
-    0.9849817205F, 0.9850468276F, 0.9851117324F, 0.9851764352F,
-    0.9852409365F, 0.9853052366F, 0.9853693358F, 0.9854332344F,
-    0.9854969330F, 0.9855604317F, 0.9856237309F, 0.9856868310F,
-    0.9857497325F, 0.9858124355F, 0.9858749404F, 0.9859372477F,
-    0.9859993577F, 0.9860612707F, 0.9861229871F, 0.9861845072F,
-    0.9862458315F, 0.9863069601F, 0.9863678936F, 0.9864286322F,
-    0.9864891764F, 0.9865495264F, 0.9866096826F, 0.9866696454F,
-    0.9867294152F, 0.9867889922F, 0.9868483769F, 0.9869075695F,
-    0.9869665706F, 0.9870253803F, 0.9870839991F, 0.9871424273F,
-    0.9872006653F, 0.9872587135F, 0.9873165721F, 0.9873742415F,
-    0.9874317222F, 0.9874890144F, 0.9875461185F, 0.9876030348F,
-    0.9876597638F, 0.9877163057F, 0.9877726610F, 0.9878288300F,
-    0.9878848130F, 0.9879406104F, 0.9879962225F, 0.9880516497F,
-    0.9881068924F, 0.9881619509F, 0.9882168256F, 0.9882715168F,
-    0.9883260249F, 0.9883803502F, 0.9884344931F, 0.9884884539F,
-    0.9885422331F, 0.9885958309F, 0.9886492477F, 0.9887024838F,
-    0.9887555397F, 0.9888084157F, 0.9888611120F, 0.9889136292F,
-    0.9889659675F, 0.9890181273F, 0.9890701089F, 0.9891219128F,
-    0.9891735392F, 0.9892249885F, 0.9892762610F, 0.9893273572F,
-    0.9893782774F, 0.9894290219F, 0.9894795911F, 0.9895299853F,
-    0.9895802049F, 0.9896302502F, 0.9896801217F, 0.9897298196F,
-    0.9897793443F, 0.9898286961F, 0.9898778755F, 0.9899268828F,
-    0.9899757183F, 0.9900243823F, 0.9900728753F, 0.9901211976F,
-    0.9901693495F, 0.9902173314F, 0.9902651436F, 0.9903127865F,
-    0.9903602605F, 0.9904075659F, 0.9904547031F, 0.9905016723F,
-    0.9905484740F, 0.9905951086F, 0.9906415763F, 0.9906878775F,
-    0.9907340126F, 0.9907799819F, 0.9908257858F, 0.9908714247F,
-    0.9909168988F, 0.9909622086F, 0.9910073543F, 0.9910523364F,
-    0.9910971552F, 0.9911418110F, 0.9911863042F, 0.9912306351F,
-    0.9912748042F, 0.9913188117F, 0.9913626580F, 0.9914063435F,
-    0.9914498684F, 0.9914932333F, 0.9915364383F, 0.9915794839F,
-    0.9916223703F, 0.9916650981F, 0.9917076674F, 0.9917500787F,
-    0.9917923323F, 0.9918344286F, 0.9918763679F, 0.9919181505F,
-    0.9919597769F, 0.9920012473F, 0.9920425621F, 0.9920837217F,
-    0.9921247263F, 0.9921655765F, 0.9922062724F, 0.9922468145F,
-    0.9922872030F, 0.9923274385F, 0.9923675211F, 0.9924074513F,
-    0.9924472294F, 0.9924868557F, 0.9925263306F, 0.9925656544F,
-    0.9926048275F, 0.9926438503F, 0.9926827230F, 0.9927214461F,
-    0.9927600199F, 0.9927984446F, 0.9928367208F, 0.9928748486F,
-    0.9929128285F, 0.9929506608F, 0.9929883459F, 0.9930258841F,
-    0.9930632757F, 0.9931005211F, 0.9931376207F, 0.9931745747F,
-    0.9932113836F, 0.9932480476F, 0.9932845671F, 0.9933209425F,
-    0.9933571742F, 0.9933932623F, 0.9934292074F, 0.9934650097F,
-    0.9935006696F, 0.9935361874F, 0.9935715635F, 0.9936067982F,
-    0.9936418919F, 0.9936768448F, 0.9937116574F, 0.9937463300F,
-    0.9937808629F, 0.9938152565F, 0.9938495111F, 0.9938836271F,
-    0.9939176047F, 0.9939514444F, 0.9939851465F, 0.9940187112F,
-    0.9940521391F, 0.9940854303F, 0.9941185853F, 0.9941516044F,
-    0.9941844879F, 0.9942172361F, 0.9942498495F, 0.9942823283F,
-    0.9943146729F, 0.9943468836F, 0.9943789608F, 0.9944109047F,
-    0.9944427158F, 0.9944743944F, 0.9945059408F, 0.9945373553F,
-    0.9945686384F, 0.9945997902F, 0.9946308112F, 0.9946617017F,
-    0.9946924621F, 0.9947230926F, 0.9947535937F, 0.9947839656F,
-    0.9948142086F, 0.9948443232F, 0.9948743097F, 0.9949041683F,
-    0.9949338995F, 0.9949635035F, 0.9949929807F, 0.9950223315F,
-    0.9950515561F, 0.9950806549F, 0.9951096282F, 0.9951384764F,
-    0.9951671998F, 0.9951957987F, 0.9952242735F, 0.9952526245F,
-    0.9952808520F, 0.9953089564F, 0.9953369380F, 0.9953647971F,
-    0.9953925340F, 0.9954201491F, 0.9954476428F, 0.9954750153F,
-    0.9955022670F, 0.9955293981F, 0.9955564092F, 0.9955833003F,
-    0.9956100720F, 0.9956367245F, 0.9956632582F, 0.9956896733F,
-    0.9957159703F, 0.9957421494F, 0.9957682110F, 0.9957941553F,
-    0.9958199828F, 0.9958456937F, 0.9958712884F, 0.9958967672F,
-    0.9959221305F, 0.9959473784F, 0.9959725115F, 0.9959975300F,
-    0.9960224342F, 0.9960472244F, 0.9960719011F, 0.9960964644F,
-    0.9961209148F, 0.9961452525F, 0.9961694779F, 0.9961935913F,
-    0.9962175930F, 0.9962414834F, 0.9962652627F, 0.9962889313F,
-    0.9963124895F, 0.9963359377F, 0.9963592761F, 0.9963825051F,
-    0.9964056250F, 0.9964286361F, 0.9964515387F, 0.9964743332F,
-    0.9964970198F, 0.9965195990F, 0.9965420709F, 0.9965644360F,
-    0.9965866946F, 0.9966088469F, 0.9966308932F, 0.9966528340F,
-    0.9966746695F, 0.9966964001F, 0.9967180260F, 0.9967395475F,
-    0.9967609651F, 0.9967822789F, 0.9968034894F, 0.9968245968F,
-    0.9968456014F, 0.9968665036F, 0.9968873037F, 0.9969080019F,
-    0.9969285987F, 0.9969490942F, 0.9969694889F, 0.9969897830F,
-    0.9970099769F, 0.9970300708F, 0.9970500651F, 0.9970699601F,
-    0.9970897561F, 0.9971094533F, 0.9971290522F, 0.9971485531F,
-    0.9971679561F, 0.9971872617F, 0.9972064702F, 0.9972255818F,
-    0.9972445968F, 0.9972635157F, 0.9972823386F, 0.9973010659F,
-    0.9973196980F, 0.9973382350F, 0.9973566773F, 0.9973750253F,
-    0.9973932791F, 0.9974114392F, 0.9974295059F, 0.9974474793F,
-    0.9974653599F, 0.9974831480F, 0.9975008438F, 0.9975184476F,
-    0.9975359598F, 0.9975533806F, 0.9975707104F, 0.9975879495F,
-    0.9976050981F, 0.9976221566F, 0.9976391252F, 0.9976560043F,
-    0.9976727941F, 0.9976894950F, 0.9977061073F, 0.9977226312F,
-    0.9977390671F, 0.9977554152F, 0.9977716759F, 0.9977878495F,
-    0.9978039361F, 0.9978199363F, 0.9978358501F, 0.9978516780F,
-    0.9978674202F, 0.9978830771F, 0.9978986488F, 0.9979141358F,
-    0.9979295383F, 0.9979448566F, 0.9979600909F, 0.9979752417F,
-    0.9979903091F, 0.9980052936F, 0.9980201952F, 0.9980350145F,
-    0.9980497515F, 0.9980644067F, 0.9980789804F, 0.9980934727F,
-    0.9981078841F, 0.9981222147F, 0.9981364649F, 0.9981506350F,
-    0.9981647253F, 0.9981787360F, 0.9981926674F, 0.9982065199F,
-    0.9982202936F, 0.9982339890F, 0.9982476062F, 0.9982611456F,
-    0.9982746074F, 0.9982879920F, 0.9983012996F, 0.9983145304F,
-    0.9983276849F, 0.9983407632F, 0.9983537657F, 0.9983666926F,
-    0.9983795442F, 0.9983923208F, 0.9984050226F, 0.9984176501F,
-    0.9984302033F, 0.9984426827F, 0.9984550884F, 0.9984674208F,
-    0.9984796802F, 0.9984918667F, 0.9985039808F, 0.9985160227F,
-    0.9985279926F, 0.9985398909F, 0.9985517177F, 0.9985634734F,
-    0.9985751583F, 0.9985867727F, 0.9985983167F, 0.9986097907F,
-    0.9986211949F, 0.9986325297F, 0.9986437953F, 0.9986549919F,
-    0.9986661199F, 0.9986771795F, 0.9986881710F, 0.9986990946F,
-    0.9987099507F, 0.9987207394F, 0.9987314611F, 0.9987421161F,
-    0.9987527045F, 0.9987632267F, 0.9987736829F, 0.9987840734F,
-    0.9987943985F, 0.9988046584F, 0.9988148534F, 0.9988249838F,
-    0.9988350498F, 0.9988450516F, 0.9988549897F, 0.9988648641F,
-    0.9988746753F, 0.9988844233F, 0.9988941086F, 0.9989037313F,
-    0.9989132918F, 0.9989227902F, 0.9989322269F, 0.9989416021F,
-    0.9989509160F, 0.9989601690F, 0.9989693613F, 0.9989784931F,
-    0.9989875647F, 0.9989965763F, 0.9990055283F, 0.9990144208F,
-    0.9990232541F, 0.9990320286F, 0.9990407443F, 0.9990494016F,
-    0.9990580008F, 0.9990665421F, 0.9990750257F, 0.9990834519F,
-    0.9990918209F, 0.9991001331F, 0.9991083886F, 0.9991165877F,
-    0.9991247307F, 0.9991328177F, 0.9991408491F, 0.9991488251F,
-    0.9991567460F, 0.9991646119F, 0.9991724232F, 0.9991801801F,
-    0.9991878828F, 0.9991955316F, 0.9992031267F, 0.9992106684F,
-    0.9992181569F, 0.9992255925F, 0.9992329753F, 0.9992403057F,
-    0.9992475839F, 0.9992548101F, 0.9992619846F, 0.9992691076F,
-    0.9992761793F, 0.9992832001F, 0.9992901701F, 0.9992970895F,
-    0.9993039587F, 0.9993107777F, 0.9993175470F, 0.9993242667F,
-    0.9993309371F, 0.9993375583F, 0.9993441307F, 0.9993506545F,
-    0.9993571298F, 0.9993635570F, 0.9993699362F, 0.9993762678F,
-    0.9993825519F, 0.9993887887F, 0.9993949785F, 0.9994011216F,
-    0.9994072181F, 0.9994132683F, 0.9994192725F, 0.9994252307F,
-    0.9994311434F, 0.9994370107F, 0.9994428327F, 0.9994486099F,
-    0.9994543423F, 0.9994600303F, 0.9994656739F, 0.9994712736F,
-    0.9994768294F, 0.9994823417F, 0.9994878105F, 0.9994932363F,
-    0.9994986191F, 0.9995039592F, 0.9995092568F, 0.9995145122F,
-    0.9995197256F, 0.9995248971F, 0.9995300270F, 0.9995351156F,
-    0.9995401630F, 0.9995451695F, 0.9995501352F, 0.9995550604F,
-    0.9995599454F, 0.9995647903F, 0.9995695953F, 0.9995743607F,
-    0.9995790866F, 0.9995837734F, 0.9995884211F, 0.9995930300F,
-    0.9995976004F, 0.9996021324F, 0.9996066263F, 0.9996110822F,
-    0.9996155004F, 0.9996198810F, 0.9996242244F, 0.9996285306F,
-    0.9996327999F, 0.9996370326F, 0.9996412287F, 0.9996453886F,
-    0.9996495125F, 0.9996536004F, 0.9996576527F, 0.9996616696F,
-    0.9996656512F, 0.9996695977F, 0.9996735094F, 0.9996773865F,
-    0.9996812291F, 0.9996850374F, 0.9996888118F, 0.9996925523F,
-    0.9996962591F, 0.9996999325F, 0.9997035727F, 0.9997071798F,
-    0.9997107541F, 0.9997142957F, 0.9997178049F, 0.9997212818F,
-    0.9997247266F, 0.9997281396F, 0.9997315209F, 0.9997348708F,
-    0.9997381893F, 0.9997414767F, 0.9997447333F, 0.9997479591F,
-    0.9997511544F, 0.9997543194F, 0.9997574542F, 0.9997605591F,
-    0.9997636342F, 0.9997666797F, 0.9997696958F, 0.9997726828F,
-    0.9997756407F, 0.9997785698F, 0.9997814703F, 0.9997843423F,
-    0.9997871860F, 0.9997900016F, 0.9997927894F, 0.9997955494F,
-    0.9997982818F, 0.9998009869F, 0.9998036648F, 0.9998063157F,
-    0.9998089398F, 0.9998115373F, 0.9998141082F, 0.9998166529F,
-    0.9998191715F, 0.9998216642F, 0.9998241311F, 0.9998265724F,
-    0.9998289884F, 0.9998313790F, 0.9998337447F, 0.9998360854F,
-    0.9998384015F, 0.9998406930F, 0.9998429602F, 0.9998452031F,
-    0.9998474221F, 0.9998496171F, 0.9998517885F, 0.9998539364F,
-    0.9998560610F, 0.9998581624F, 0.9998602407F, 0.9998622962F,
-    0.9998643291F, 0.9998663394F, 0.9998683274F, 0.9998702932F,
-    0.9998722370F, 0.9998741589F, 0.9998760591F, 0.9998779378F,
-    0.9998797952F, 0.9998816313F, 0.9998834464F, 0.9998852406F,
-    0.9998870141F, 0.9998887670F, 0.9998904995F, 0.9998922117F,
-    0.9998939039F, 0.9998955761F, 0.9998972285F, 0.9998988613F,
-    0.9999004746F, 0.9999020686F, 0.9999036434F, 0.9999051992F,
-    0.9999067362F, 0.9999082544F, 0.9999097541F, 0.9999112354F,
-    0.9999126984F, 0.9999141433F, 0.9999155703F, 0.9999169794F,
-    0.9999183709F, 0.9999197449F, 0.9999211014F, 0.9999224408F,
-    0.9999237631F, 0.9999250684F, 0.9999263570F, 0.9999276289F,
-    0.9999288843F, 0.9999301233F, 0.9999313461F, 0.9999325529F,
-    0.9999337437F, 0.9999349187F, 0.9999360780F, 0.9999372218F,
-    0.9999383503F, 0.9999394635F, 0.9999405616F, 0.9999416447F,
-    0.9999427129F, 0.9999437665F, 0.9999448055F, 0.9999458301F,
-    0.9999468404F, 0.9999478365F, 0.9999488185F, 0.9999497867F,
-    0.9999507411F, 0.9999516819F, 0.9999526091F, 0.9999535230F,
-    0.9999544236F, 0.9999553111F, 0.9999561856F, 0.9999570472F,
-    0.9999578960F, 0.9999587323F, 0.9999595560F, 0.9999603674F,
-    0.9999611666F, 0.9999619536F, 0.9999627286F, 0.9999634917F,
-    0.9999642431F, 0.9999649828F, 0.9999657110F, 0.9999664278F,
-    0.9999671334F, 0.9999678278F, 0.9999685111F, 0.9999691835F,
-    0.9999698451F, 0.9999704960F, 0.9999711364F, 0.9999717662F,
-    0.9999723858F, 0.9999729950F, 0.9999735942F, 0.9999741834F,
-    0.9999747626F, 0.9999753321F, 0.9999758919F, 0.9999764421F,
-    0.9999769828F, 0.9999775143F, 0.9999780364F, 0.9999785495F,
-    0.9999790535F, 0.9999795485F, 0.9999800348F, 0.9999805124F,
-    0.9999809813F, 0.9999814417F, 0.9999818938F, 0.9999823375F,
-    0.9999827731F, 0.9999832005F, 0.9999836200F, 0.9999840316F,
-    0.9999844353F, 0.9999848314F, 0.9999852199F, 0.9999856008F,
-    0.9999859744F, 0.9999863407F, 0.9999866997F, 0.9999870516F,
-    0.9999873965F, 0.9999877345F, 0.9999880656F, 0.9999883900F,
-    0.9999887078F, 0.9999890190F, 0.9999893237F, 0.9999896220F,
-    0.9999899140F, 0.9999901999F, 0.9999904796F, 0.9999907533F,
-    0.9999910211F, 0.9999912830F, 0.9999915391F, 0.9999917896F,
-    0.9999920345F, 0.9999922738F, 0.9999925077F, 0.9999927363F,
-    0.9999929596F, 0.9999931777F, 0.9999933907F, 0.9999935987F,
-    0.9999938018F, 0.9999940000F, 0.9999941934F, 0.9999943820F,
-    0.9999945661F, 0.9999947456F, 0.9999949206F, 0.9999950912F,
-    0.9999952575F, 0.9999954195F, 0.9999955773F, 0.9999957311F,
-    0.9999958807F, 0.9999960265F, 0.9999961683F, 0.9999963063F,
-    0.9999964405F, 0.9999965710F, 0.9999966979F, 0.9999968213F,
-    0.9999969412F, 0.9999970576F, 0.9999971707F, 0.9999972805F,
-    0.9999973871F, 0.9999974905F, 0.9999975909F, 0.9999976881F,
-    0.9999977824F, 0.9999978738F, 0.9999979624F, 0.9999980481F,
-    0.9999981311F, 0.9999982115F, 0.9999982892F, 0.9999983644F,
-    0.9999984370F, 0.9999985072F, 0.9999985750F, 0.9999986405F,
-    0.9999987037F, 0.9999987647F, 0.9999988235F, 0.9999988802F,
-    0.9999989348F, 0.9999989873F, 0.9999990379F, 0.9999990866F,
-    0.9999991334F, 0.9999991784F, 0.9999992217F, 0.9999992632F,
-    0.9999993030F, 0.9999993411F, 0.9999993777F, 0.9999994128F,
-    0.9999994463F, 0.9999994784F, 0.9999995091F, 0.9999995384F,
-    0.9999995663F, 0.9999995930F, 0.9999996184F, 0.9999996426F,
-    0.9999996657F, 0.9999996876F, 0.9999997084F, 0.9999997282F,
-    0.9999997469F, 0.9999997647F, 0.9999997815F, 0.9999997973F,
-    0.9999998123F, 0.9999998265F, 0.9999998398F, 0.9999998524F,
-    0.9999998642F, 0.9999998753F, 0.9999998857F, 0.9999998954F,
-    0.9999999045F, 0.9999999130F, 0.9999999209F, 0.9999999282F,
-    0.9999999351F, 0.9999999414F, 0.9999999472F, 0.9999999526F,
-    0.9999999576F, 0.9999999622F, 0.9999999664F, 0.9999999702F,
-    0.9999999737F, 0.9999999769F, 0.9999999798F, 0.9999999824F,
-    0.9999999847F, 0.9999999868F, 0.9999999887F, 0.9999999904F,
-    0.9999999919F, 0.9999999932F, 0.9999999943F, 0.9999999953F,
-    0.9999999961F, 0.9999999969F, 0.9999999975F, 0.9999999980F,
-    0.9999999985F, 0.9999999988F, 0.9999999991F, 0.9999999993F,
-    0.9999999995F, 0.9999999997F, 0.9999999998F, 0.9999999999F,
-    0.9999999999F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
-    1.0000000000F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
+DECLARE_ALIGNED(16, static const INTFLOAT, vwin8192)[4096] = {
+    Q31(0.0000000578F),Q31(0.0000005198F),Q31(0.0000014438F),Q31(0.0000028299F),
+    Q31(0.0000046780F),Q31(0.0000069882F),Q31(0.0000097604F),Q31(0.0000129945F),
+    Q31(0.0000166908F),Q31(0.0000208490F),Q31(0.0000254692F),Q31(0.0000305515F),
+    Q31(0.0000360958F),Q31(0.0000421021F),Q31(0.0000485704F),Q31(0.0000555006F),
+    Q31(0.0000628929F),Q31(0.0000707472F),Q31(0.0000790635F),Q31(0.0000878417F),
+    Q31(0.0000970820F),Q31(0.0001067842F),Q31(0.0001169483F),Q31(0.0001275744F),
+    Q31(0.0001386625F),Q31(0.0001502126F),Q31(0.0001622245F),Q31(0.0001746984F),
+    Q31(0.0001876343F),Q31(0.0002010320F),Q31(0.0002148917F),Q31(0.0002292132F),
+    Q31(0.0002439967F),Q31(0.0002592421F),Q31(0.0002749493F),Q31(0.0002911184F),
+    Q31(0.0003077493F),Q31(0.0003248421F),Q31(0.0003423967F),Q31(0.0003604132F),
+    Q31(0.0003788915F),Q31(0.0003978316F),Q31(0.0004172335F),Q31(0.0004370971F),
+    Q31(0.0004574226F),Q31(0.0004782098F),Q31(0.0004994587F),Q31(0.0005211694F),
+    Q31(0.0005433418F),Q31(0.0005659759F),Q31(0.0005890717F),Q31(0.0006126292F),
+    Q31(0.0006366484F),Q31(0.0006611292F),Q31(0.0006860716F),Q31(0.0007114757F),
+    Q31(0.0007373414F),Q31(0.0007636687F),Q31(0.0007904576F),Q31(0.0008177080F),
+    Q31(0.0008454200F),Q31(0.0008735935F),Q31(0.0009022285F),Q31(0.0009313250F),
+    Q31(0.0009608830F),Q31(0.0009909025F),Q31(0.0010213834F),Q31(0.0010523257F),
+    Q31(0.0010837295F),Q31(0.0011155946F),Q31(0.0011479211F),Q31(0.0011807090F),
+    Q31(0.0012139582F),Q31(0.0012476687F),Q31(0.0012818405F),Q31(0.0013164736F),
+    Q31(0.0013515679F),Q31(0.0013871235F),Q31(0.0014231402F),Q31(0.0014596182F),
+    Q31(0.0014965573F),Q31(0.0015339576F),Q31(0.0015718190F),Q31(0.0016101415F),
+    Q31(0.0016489251F),Q31(0.0016881698F),Q31(0.0017278754F),Q31(0.0017680421F),
+    Q31(0.0018086698F),Q31(0.0018497584F),Q31(0.0018913080F),Q31(0.0019333185F),
+    Q31(0.0019757898F),Q31(0.0020187221F),Q31(0.0020621151F),Q31(0.0021059690F),
+    Q31(0.0021502837F),Q31(0.0021950591F),Q31(0.0022402953F),Q31(0.0022859921F),
+    Q31(0.0023321497F),Q31(0.0023787679F),Q31(0.0024258467F),Q31(0.0024733861F),
+    Q31(0.0025213861F),Q31(0.0025698466F),Q31(0.0026187676F),Q31(0.0026681491F),
+    Q31(0.0027179911F),Q31(0.0027682935F),Q31(0.0028190562F),Q31(0.0028702794F),
+    Q31(0.0029219628F),Q31(0.0029741066F),Q31(0.0030267107F),Q31(0.0030797749F),
+    Q31(0.0031332994F),Q31(0.0031872841F),Q31(0.0032417289F),Q31(0.0032966338F),
+    Q31(0.0033519988F),Q31(0.0034078238F),Q31(0.0034641089F),Q31(0.0035208539F),
+    Q31(0.0035780589F),Q31(0.0036357237F),Q31(0.0036938485F),Q31(0.0037524331F),
+    Q31(0.0038114775F),Q31(0.0038709817F),Q31(0.0039309456F),Q31(0.0039913692F),
+    Q31(0.0040522524F),Q31(0.0041135953F),Q31(0.0041753978F),Q31(0.0042376599F),
+    Q31(0.0043003814F),Q31(0.0043635624F),Q31(0.0044272029F),Q31(0.0044913028F),
+    Q31(0.0045558620F),Q31(0.0046208806F),Q31(0.0046863585F),Q31(0.0047522955F),
+    Q31(0.0048186919F),Q31(0.0048855473F),Q31(0.0049528619F),Q31(0.0050206356F),
+    Q31(0.0050888684F),Q31(0.0051575601F),Q31(0.0052267108F),Q31(0.0052963204F),
+    Q31(0.0053663890F),Q31(0.0054369163F),Q31(0.0055079025F),Q31(0.0055793474F),
+    Q31(0.0056512510F),Q31(0.0057236133F),Q31(0.0057964342F),Q31(0.0058697137F),
+    Q31(0.0059434517F),Q31(0.0060176482F),Q31(0.0060923032F),Q31(0.0061674166F),
+    Q31(0.0062429883F),Q31(0.0063190183F),Q31(0.0063955066F),Q31(0.0064724532F),
+    Q31(0.0065498579F),Q31(0.0066277207F),Q31(0.0067060416F),Q31(0.0067848205F),
+    Q31(0.0068640575F),Q31(0.0069437523F),Q31(0.0070239051F),Q31(0.0071045157F),
+    Q31(0.0071855840F),Q31(0.0072671102F),Q31(0.0073490940F),Q31(0.0074315355F),
+    Q31(0.0075144345F),Q31(0.0075977911F),Q31(0.0076816052F),Q31(0.0077658768F),
+    Q31(0.0078506057F),Q31(0.0079357920F),Q31(0.0080214355F),Q31(0.0081075363F),
+    Q31(0.0081940943F),Q31(0.0082811094F),Q31(0.0083685816F),Q31(0.0084565108F),
+    Q31(0.0085448970F),Q31(0.0086337401F),Q31(0.0087230401F),Q31(0.0088127969F),
+    Q31(0.0089030104F),Q31(0.0089936807F),Q31(0.0090848076F),Q31(0.0091763911F),
+    Q31(0.0092684311F),Q31(0.0093609276F),Q31(0.0094538805F),Q31(0.0095472898F),
+    Q31(0.0096411554F),Q31(0.0097354772F),Q31(0.0098302552F),Q31(0.0099254894F),
+    Q31(0.0100211796F),Q31(0.0101173259F),Q31(0.0102139281F),Q31(0.0103109863F),
+    Q31(0.0104085002F),Q31(0.0105064700F),Q31(0.0106048955F),Q31(0.0107037766F),
+    Q31(0.0108031133F),Q31(0.0109029056F),Q31(0.0110031534F),Q31(0.0111038565F),
+    Q31(0.0112050151F),Q31(0.0113066289F),Q31(0.0114086980F),Q31(0.0115112222F),
+    Q31(0.0116142015F),Q31(0.0117176359F),Q31(0.0118215252F),Q31(0.0119258695F),
+    Q31(0.0120306686F),Q31(0.0121359225F),Q31(0.0122416312F),Q31(0.0123477944F),
+    Q31(0.0124544123F),Q31(0.0125614847F),Q31(0.0126690116F),Q31(0.0127769928F),
+    Q31(0.0128854284F),Q31(0.0129943182F),Q31(0.0131036623F),Q31(0.0132134604F),
+    Q31(0.0133237126F),Q31(0.0134344188F),Q31(0.0135455790F),Q31(0.0136571929F),
+    Q31(0.0137692607F),Q31(0.0138817821F),Q31(0.0139947572F),Q31(0.0141081859F),
+    Q31(0.0142220681F),Q31(0.0143364037F),Q31(0.0144511927F),Q31(0.0145664350F),
+    Q31(0.0146821304F),Q31(0.0147982791F),Q31(0.0149148808F),Q31(0.0150319355F),
+    Q31(0.0151494431F),Q31(0.0152674036F),Q31(0.0153858168F),Q31(0.0155046828F),
+    Q31(0.0156240014F),Q31(0.0157437726F),Q31(0.0158639962F),Q31(0.0159846723F),
+    Q31(0.0161058007F),Q31(0.0162273814F),Q31(0.0163494142F),Q31(0.0164718991F),
+    Q31(0.0165948361F),Q31(0.0167182250F),Q31(0.0168420658F),Q31(0.0169663584F),
+    Q31(0.0170911027F),Q31(0.0172162987F),Q31(0.0173419462F),Q31(0.0174680452F),
+    Q31(0.0175945956F),Q31(0.0177215974F),Q31(0.0178490504F),Q31(0.0179769545F),
+    Q31(0.0181053098F),Q31(0.0182341160F),Q31(0.0183633732F),Q31(0.0184930812F),
+    Q31(0.0186232399F),Q31(0.0187538494F),Q31(0.0188849094F),Q31(0.0190164200F),
+    Q31(0.0191483809F),Q31(0.0192807923F),Q31(0.0194136539F),Q31(0.0195469656F),
+    Q31(0.0196807275F),Q31(0.0198149394F),Q31(0.0199496012F),Q31(0.0200847128F),
+    Q31(0.0202202742F),Q31(0.0203562853F),Q31(0.0204927460F),Q31(0.0206296561F),
+    Q31(0.0207670157F),Q31(0.0209048245F),Q31(0.0210430826F),Q31(0.0211817899F),
+    Q31(0.0213209462F),Q31(0.0214605515F),Q31(0.0216006057F),Q31(0.0217411086F),
+    Q31(0.0218820603F),Q31(0.0220234605F),Q31(0.0221653093F),Q31(0.0223076066F),
+    Q31(0.0224503521F),Q31(0.0225935459F),Q31(0.0227371879F),Q31(0.0228812779F),
+    Q31(0.0230258160F),Q31(0.0231708018F),Q31(0.0233162355F),Q31(0.0234621169F),
+    Q31(0.0236084459F),Q31(0.0237552224F),Q31(0.0239024462F),Q31(0.0240501175F),
+    Q31(0.0241982359F),Q31(0.0243468015F),Q31(0.0244958141F),Q31(0.0246452736F),
+    Q31(0.0247951800F),Q31(0.0249455331F),Q31(0.0250963329F),Q31(0.0252475792F),
+    Q31(0.0253992720F),Q31(0.0255514111F),Q31(0.0257039965F),Q31(0.0258570281F),
+    Q31(0.0260105057F),Q31(0.0261644293F),Q31(0.0263187987F),Q31(0.0264736139F),
+    Q31(0.0266288747F),Q31(0.0267845811F),Q31(0.0269407330F),Q31(0.0270973302F),
+    Q31(0.0272543727F),Q31(0.0274118604F),Q31(0.0275697930F),Q31(0.0277281707F),
+    Q31(0.0278869932F),Q31(0.0280462604F),Q31(0.0282059723F),Q31(0.0283661287F),
+    Q31(0.0285267295F),Q31(0.0286877747F),Q31(0.0288492641F),Q31(0.0290111976F),
+    Q31(0.0291735751F),Q31(0.0293363965F),Q31(0.0294996617F),Q31(0.0296633706F),
+    Q31(0.0298275231F),Q31(0.0299921190F),Q31(0.0301571583F),Q31(0.0303226409F),
+    Q31(0.0304885667F),Q31(0.0306549354F),Q31(0.0308217472F),Q31(0.0309890017F),
+    Q31(0.0311566989F),Q31(0.0313248388F),Q31(0.0314934211F),Q31(0.0316624459F),
+    Q31(0.0318319128F),Q31(0.0320018220F),Q31(0.0321721732F),Q31(0.0323429663F),
+    Q31(0.0325142013F),Q31(0.0326858779F),Q31(0.0328579962F),Q31(0.0330305559F),
+    Q31(0.0332035570F),Q31(0.0333769994F),Q31(0.0335508829F),Q31(0.0337252074F),
+    Q31(0.0338999728F),Q31(0.0340751790F),Q31(0.0342508259F),Q31(0.0344269134F),
+    Q31(0.0346034412F),Q31(0.0347804094F),Q31(0.0349578178F),Q31(0.0351356663F),
+    Q31(0.0353139548F),Q31(0.0354926831F),Q31(0.0356718511F),Q31(0.0358514588F),
+    Q31(0.0360315059F),Q31(0.0362119924F),Q31(0.0363929182F),Q31(0.0365742831F),
+    Q31(0.0367560870F),Q31(0.0369383297F),Q31(0.0371210113F),Q31(0.0373041315F),
+    Q31(0.0374876902F),Q31(0.0376716873F),Q31(0.0378561226F),Q31(0.0380409961F),
+    Q31(0.0382263077F),Q31(0.0384120571F),Q31(0.0385982443F),Q31(0.0387848691F),
+    Q31(0.0389719315F),Q31(0.0391594313F),Q31(0.0393473683F),Q31(0.0395357425F),
+    Q31(0.0397245537F),Q31(0.0399138017F),Q31(0.0401034866F),Q31(0.0402936080F),
+    Q31(0.0404841660F),Q31(0.0406751603F),Q31(0.0408665909F),Q31(0.0410584576F),
+    Q31(0.0412507603F),Q31(0.0414434988F),Q31(0.0416366731F),Q31(0.0418302829F),
+    Q31(0.0420243282F),Q31(0.0422188088F),Q31(0.0424137246F),Q31(0.0426090755F),
+    Q31(0.0428048613F),Q31(0.0430010819F),Q31(0.0431977371F),Q31(0.0433948269F),
+    Q31(0.0435923511F),Q31(0.0437903095F),Q31(0.0439887020F),Q31(0.0441875285F),
+    Q31(0.0443867889F),Q31(0.0445864830F),Q31(0.0447866106F),Q31(0.0449871717F),
+    Q31(0.0451881661F),Q31(0.0453895936F),Q31(0.0455914542F),Q31(0.0457937477F),
+    Q31(0.0459964738F),Q31(0.0461996326F),Q31(0.0464032239F),Q31(0.0466072475F),
+    Q31(0.0468117032F),Q31(0.0470165910F),Q31(0.0472219107F),Q31(0.0474276622F),
+    Q31(0.0476338452F),Q31(0.0478404597F),Q31(0.0480475056F),Q31(0.0482549827F),
+    Q31(0.0484628907F),Q31(0.0486712297F),Q31(0.0488799994F),Q31(0.0490891998F),
+    Q31(0.0492988306F),Q31(0.0495088917F),Q31(0.0497193830F),Q31(0.0499303043F),
+    Q31(0.0501416554F),Q31(0.0503534363F),Q31(0.0505656468F),Q31(0.0507782867F),
+    Q31(0.0509913559F),Q31(0.0512048542F),Q31(0.0514187815F),Q31(0.0516331376F),
+    Q31(0.0518479225F),Q31(0.0520631358F),Q31(0.0522787775F),Q31(0.0524948475F),
+    Q31(0.0527113455F),Q31(0.0529282715F),Q31(0.0531456252F),Q31(0.0533634066F),
+    Q31(0.0535816154F),Q31(0.0538002515F),Q31(0.0540193148F),Q31(0.0542388051F),
+    Q31(0.0544587222F),Q31(0.0546790660F),Q31(0.0548998364F),Q31(0.0551210331F),
+    Q31(0.0553426561F),Q31(0.0555647051F),Q31(0.0557871801F),Q31(0.0560100807F),
+    Q31(0.0562334070F),Q31(0.0564571587F),Q31(0.0566813357F),Q31(0.0569059378F),
+    Q31(0.0571309649F),Q31(0.0573564168F),Q31(0.0575822933F),Q31(0.0578085942F),
+    Q31(0.0580353195F),Q31(0.0582624689F),Q31(0.0584900423F),Q31(0.0587180396F),
+    Q31(0.0589464605F),Q31(0.0591753049F),Q31(0.0594045726F),Q31(0.0596342635F),
+    Q31(0.0598643774F),Q31(0.0600949141F),Q31(0.0603258735F),Q31(0.0605572555F),
+    Q31(0.0607890597F),Q31(0.0610212862F),Q31(0.0612539346F),Q31(0.0614870049F),
+    Q31(0.0617204968F),Q31(0.0619544103F),Q31(0.0621887451F),Q31(0.0624235010F),
+    Q31(0.0626586780F),Q31(0.0628942758F),Q31(0.0631302942F),Q31(0.0633667331F),
+    Q31(0.0636035923F),Q31(0.0638408717F),Q31(0.0640785710F),Q31(0.0643166901F),
+    Q31(0.0645552288F),Q31(0.0647941870F),Q31(0.0650335645F),Q31(0.0652733610F),
+    Q31(0.0655135765F),Q31(0.0657542108F),Q31(0.0659952636F),Q31(0.0662367348F),
+    Q31(0.0664786242F),Q31(0.0667209316F),Q31(0.0669636570F),Q31(0.0672068000F),
+    Q31(0.0674503605F),Q31(0.0676943384F),Q31(0.0679387334F),Q31(0.0681835454F),
+    Q31(0.0684287742F),Q31(0.0686744196F),Q31(0.0689204814F),Q31(0.0691669595F),
+    Q31(0.0694138536F),Q31(0.0696611637F),Q31(0.0699088894F),Q31(0.0701570307F),
+    Q31(0.0704055873F),Q31(0.0706545590F),Q31(0.0709039458F),Q31(0.0711537473F),
+    Q31(0.0714039634F),Q31(0.0716545939F),Q31(0.0719056387F),Q31(0.0721570975F),
+    Q31(0.0724089702F),Q31(0.0726612565F),Q31(0.0729139563F),Q31(0.0731670694F),
+    Q31(0.0734205956F),Q31(0.0736745347F),Q31(0.0739288866F),Q31(0.0741836510F),
+    Q31(0.0744388277F),Q31(0.0746944166F),Q31(0.0749504175F),Q31(0.0752068301F),
+    Q31(0.0754636543F),Q31(0.0757208899F),Q31(0.0759785367F),Q31(0.0762365946F),
+    Q31(0.0764950632F),Q31(0.0767539424F),Q31(0.0770132320F),Q31(0.0772729319F),
+    Q31(0.0775330418F),Q31(0.0777935616F),Q31(0.0780544909F),Q31(0.0783158298F),
+    Q31(0.0785775778F),Q31(0.0788397349F),Q31(0.0791023009F),Q31(0.0793652755F),
+    Q31(0.0796286585F),Q31(0.0798924498F),Q31(0.0801566492F),Q31(0.0804212564F),
+    Q31(0.0806862712F),Q31(0.0809516935F),Q31(0.0812175231F),Q31(0.0814837597F),
+    Q31(0.0817504031F),Q31(0.0820174532F),Q31(0.0822849097F),Q31(0.0825527724F),
+    Q31(0.0828210412F),Q31(0.0830897158F),Q31(0.0833587960F),Q31(0.0836282816F),
+    Q31(0.0838981724F),Q31(0.0841684682F),Q31(0.0844391688F),Q31(0.0847102740F),
+    Q31(0.0849817835F),Q31(0.0852536973F),Q31(0.0855260150F),Q31(0.0857987364F),
+    Q31(0.0860718614F),Q31(0.0863453897F),Q31(0.0866193211F),Q31(0.0868936554F),
+    Q31(0.0871683924F),Q31(0.0874435319F),Q31(0.0877190737F),Q31(0.0879950175F),
+    Q31(0.0882713632F),Q31(0.0885481105F),Q31(0.0888252592F),Q31(0.0891028091F),
+    Q31(0.0893807600F),Q31(0.0896591117F),Q31(0.0899378639F),Q31(0.0902170165F),
+    Q31(0.0904965692F),Q31(0.0907765218F),Q31(0.0910568740F),Q31(0.0913376258F),
+    Q31(0.0916187767F),Q31(0.0919003268F),Q31(0.0921822756F),Q31(0.0924646230F),
+    Q31(0.0927473687F),Q31(0.0930305126F),Q31(0.0933140545F),Q31(0.0935979940F),
+    Q31(0.0938823310F),Q31(0.0941670653F),Q31(0.0944521966F),Q31(0.0947377247F),
+    Q31(0.0950236494F),Q31(0.0953099704F),Q31(0.0955966876F),Q31(0.0958838007F),
+    Q31(0.0961713094F),Q31(0.0964592136F),Q31(0.0967475131F),Q31(0.0970362075F),
+    Q31(0.0973252967F),Q31(0.0976147805F),Q31(0.0979046585F),Q31(0.0981949307F),
+    Q31(0.0984855967F),Q31(0.0987766563F),Q31(0.0990681093F),Q31(0.0993599555F),
+    Q31(0.0996521945F),Q31(0.0999448263F),Q31(0.1002378506F),Q31(0.1005312671F),
+    Q31(0.1008250755F),Q31(0.1011192757F),Q31(0.1014138675F),Q31(0.1017088505F),
+    Q31(0.1020042246F),Q31(0.1022999895F),Q31(0.1025961450F),Q31(0.1028926909F),
+    Q31(0.1031896268F),Q31(0.1034869526F),Q31(0.1037846680F),Q31(0.1040827729F),
+    Q31(0.1043812668F),Q31(0.1046801497F),Q31(0.1049794213F),Q31(0.1052790813F),
+    Q31(0.1055791294F),Q31(0.1058795656F),Q31(0.1061803894F),Q31(0.1064816006F),
+    Q31(0.1067831991F),Q31(0.1070851846F),Q31(0.1073875568F),Q31(0.1076903155F),
+    Q31(0.1079934604F),Q31(0.1082969913F),Q31(0.1086009079F),Q31(0.1089052101F),
+    Q31(0.1092098975F),Q31(0.1095149699F),Q31(0.1098204270F),Q31(0.1101262687F),
+    Q31(0.1104324946F),Q31(0.1107391045F),Q31(0.1110460982F),Q31(0.1113534754F),
+    Q31(0.1116612359F),Q31(0.1119693793F),Q31(0.1122779055F),Q31(0.1125868142F),
+    Q31(0.1128961052F),Q31(0.1132057781F),Q31(0.1135158328F),Q31(0.1138262690F),
+    Q31(0.1141370863F),Q31(0.1144482847F),Q31(0.1147598638F),Q31(0.1150718233F),
+    Q31(0.1153841631F),Q31(0.1156968828F),Q31(0.1160099822F),Q31(0.1163234610F),
+    Q31(0.1166373190F),Q31(0.1169515559F),Q31(0.1172661714F),Q31(0.1175811654F),
+    Q31(0.1178965374F),Q31(0.1182122874F),Q31(0.1185284149F),Q31(0.1188449198F),
+    Q31(0.1191618018F),Q31(0.1194790606F),Q31(0.1197966960F),Q31(0.1201147076F),
+    Q31(0.1204330953F),Q31(0.1207518587F),Q31(0.1210709976F),Q31(0.1213905118F),
+    Q31(0.1217104009F),Q31(0.1220306647F),Q31(0.1223513029F),Q31(0.1226723153F),
+    Q31(0.1229937016F),Q31(0.1233154615F),Q31(0.1236375948F),Q31(0.1239601011F),
+    Q31(0.1242829803F),Q31(0.1246062319F),Q31(0.1249298559F),Q31(0.1252538518F),
+    Q31(0.1255782195F),Q31(0.1259029586F),Q31(0.1262280689F),Q31(0.1265535501F),
+    Q31(0.1268794019F),Q31(0.1272056241F),Q31(0.1275322163F),Q31(0.1278591784F),
+    Q31(0.1281865099F),Q31(0.1285142108F),Q31(0.1288422805F),Q31(0.1291707190F),
+    Q31(0.1294995259F),Q31(0.1298287009F),Q31(0.1301582437F),Q31(0.1304881542F),
+    Q31(0.1308184319F),Q31(0.1311490766F),Q31(0.1314800881F),Q31(0.1318114660F),
+    Q31(0.1321432100F),Q31(0.1324753200F),Q31(0.1328077955F),Q31(0.1331406364F),
+    Q31(0.1334738422F),Q31(0.1338074129F),Q31(0.1341413479F),Q31(0.1344756472F),
+    Q31(0.1348103103F),Q31(0.1351453370F),Q31(0.1354807270F),Q31(0.1358164801F),
+    Q31(0.1361525959F),Q31(0.1364890741F),Q31(0.1368259145F),Q31(0.1371631167F),
+    Q31(0.1375006805F),Q31(0.1378386056F),Q31(0.1381768917F),Q31(0.1385155384F),
+    Q31(0.1388545456F),Q31(0.1391939129F),Q31(0.1395336400F),Q31(0.1398737266F),
+    Q31(0.1402141724F),Q31(0.1405549772F),Q31(0.1408961406F),Q31(0.1412376623F),
+    Q31(0.1415795421F),Q31(0.1419217797F),Q31(0.1422643746F),Q31(0.1426073268F),
+    Q31(0.1429506358F),Q31(0.1432943013F),Q31(0.1436383231F),Q31(0.1439827008F),
+    Q31(0.1443274342F),Q31(0.1446725229F),Q31(0.1450179667F),Q31(0.1453637652F),
+    Q31(0.1457099181F),Q31(0.1460564252F),Q31(0.1464032861F),Q31(0.1467505006F),
+    Q31(0.1470980682F),Q31(0.1474459888F),Q31(0.1477942620F),Q31(0.1481428875F),
+    Q31(0.1484918651F),Q31(0.1488411942F),Q31(0.1491908748F),Q31(0.1495409065F),
+    Q31(0.1498912889F),Q31(0.1502420218F),Q31(0.1505931048F),Q31(0.1509445376F),
+    Q31(0.1512963200F),Q31(0.1516484516F),Q31(0.1520009321F),Q31(0.1523537612F),
+    Q31(0.1527069385F),Q31(0.1530604638F),Q31(0.1534143368F),Q31(0.1537685571F),
+    Q31(0.1541231244F),Q31(0.1544780384F),Q31(0.1548332987F),Q31(0.1551889052F),
+    Q31(0.1555448574F),Q31(0.1559011550F),Q31(0.1562577978F),Q31(0.1566147853F),
+    Q31(0.1569721173F),Q31(0.1573297935F),Q31(0.1576878135F),Q31(0.1580461771F),
+    Q31(0.1584048838F),Q31(0.1587639334F),Q31(0.1591233255F),Q31(0.1594830599F),
+    Q31(0.1598431361F),Q31(0.1602035540F),Q31(0.1605643131F),Q31(0.1609254131F),
+    Q31(0.1612868537F),Q31(0.1616486346F),Q31(0.1620107555F),Q31(0.1623732160F),
+    Q31(0.1627360158F),Q31(0.1630991545F),Q31(0.1634626319F),Q31(0.1638264476F),
+    Q31(0.1641906013F),Q31(0.1645550926F),Q31(0.1649199212F),Q31(0.1652850869F),
+    Q31(0.1656505892F),Q31(0.1660164278F),Q31(0.1663826024F),Q31(0.1667491127F),
+    Q31(0.1671159583F),Q31(0.1674831388F),Q31(0.1678506541F),Q31(0.1682185036F),
+    Q31(0.1685866872F),Q31(0.1689552044F),Q31(0.1693240549F),Q31(0.1696932384F),
+    Q31(0.1700627545F),Q31(0.1704326029F),Q31(0.1708027833F),Q31(0.1711732952F),
+    Q31(0.1715441385F),Q31(0.1719153127F),Q31(0.1722868175F),Q31(0.1726586526F),
+    Q31(0.1730308176F),Q31(0.1734033121F),Q31(0.1737761359F),Q31(0.1741492886F),
+    Q31(0.1745227698F),Q31(0.1748965792F),Q31(0.1752707164F),Q31(0.1756451812F),
+    Q31(0.1760199731F),Q31(0.1763950918F),Q31(0.1767705370F),Q31(0.1771463083F),
+    Q31(0.1775224054F),Q31(0.1778988279F),Q31(0.1782755754F),Q31(0.1786526477F),
+    Q31(0.1790300444F),Q31(0.1794077651F),Q31(0.1797858094F),Q31(0.1801641771F),
+    Q31(0.1805428677F),Q31(0.1809218810F),Q31(0.1813012165F),Q31(0.1816808739F),
+    Q31(0.1820608528F),Q31(0.1824411530F),Q31(0.1828217739F),Q31(0.1832027154F),
+    Q31(0.1835839770F),Q31(0.1839655584F),Q31(0.1843474592F),Q31(0.1847296790F),
+    Q31(0.1851122175F),Q31(0.1854950744F),Q31(0.1858782492F),Q31(0.1862617417F),
+    Q31(0.1866455514F),Q31(0.1870296780F),Q31(0.1874141211F),Q31(0.1877988804F),
+    Q31(0.1881839555F),Q31(0.1885693461F),Q31(0.1889550517F),Q31(0.1893410721F),
+    Q31(0.1897274068F),Q31(0.1901140555F),Q31(0.1905010178F),Q31(0.1908882933F),
+    Q31(0.1912758818F),Q31(0.1916637828F),Q31(0.1920519959F),Q31(0.1924405208F),
+    Q31(0.1928293571F),Q31(0.1932185044F),Q31(0.1936079625F),Q31(0.1939977308F),
+    Q31(0.1943878091F),Q31(0.1947781969F),Q31(0.1951688939F),Q31(0.1955598998F),
+    Q31(0.1959512141F),Q31(0.1963428364F),Q31(0.1967347665F),Q31(0.1971270038F),
+    Q31(0.1975195482F),Q31(0.1979123990F),Q31(0.1983055561F),Q31(0.1986990190F),
+    Q31(0.1990927873F),Q31(0.1994868607F),Q31(0.1998812388F),Q31(0.2002759212F),
+    Q31(0.2006709075F),Q31(0.2010661974F),Q31(0.2014617904F),Q31(0.2018576862F),
+    Q31(0.2022538844F),Q31(0.2026503847F),Q31(0.2030471865F),Q31(0.2034442897F),
+    Q31(0.2038416937F),Q31(0.2042393982F),Q31(0.2046374028F),Q31(0.2050357071F),
+    Q31(0.2054343107F),Q31(0.2058332133F),Q31(0.2062324145F),Q31(0.2066319138F),
+    Q31(0.2070317110F),Q31(0.2074318055F),Q31(0.2078321970F),Q31(0.2082328852F),
+    Q31(0.2086338696F),Q31(0.2090351498F),Q31(0.2094367255F),Q31(0.2098385962F),
+    Q31(0.2102407617F),Q31(0.2106432213F),Q31(0.2110459749F),Q31(0.2114490220F),
+    Q31(0.2118523621F),Q31(0.2122559950F),Q31(0.2126599202F),Q31(0.2130641373F),
+    Q31(0.2134686459F),Q31(0.2138734456F),Q31(0.2142785361F),Q31(0.2146839168F),
+    Q31(0.2150895875F),Q31(0.2154955478F),Q31(0.2159017972F),Q31(0.2163083353F),
+    Q31(0.2167151617F),Q31(0.2171222761F),Q31(0.2175296780F),Q31(0.2179373670F),
+    Q31(0.2183453428F),Q31(0.2187536049F),Q31(0.2191621529F),Q31(0.2195709864F),
+    Q31(0.2199801051F),Q31(0.2203895085F),Q31(0.2207991961F),Q31(0.2212091677F),
+    Q31(0.2216194228F),Q31(0.2220299610F),Q31(0.2224407818F),Q31(0.2228518850F),
+    Q31(0.2232632699F),Q31(0.2236749364F),Q31(0.2240868839F),Q31(0.2244991121F),
+    Q31(0.2249116204F),Q31(0.2253244086F),Q31(0.2257374763F),Q31(0.2261508229F),
+    Q31(0.2265644481F),Q31(0.2269783514F),Q31(0.2273925326F),Q31(0.2278069911F),
+    Q31(0.2282217265F),Q31(0.2286367384F),Q31(0.2290520265F),Q31(0.2294675902F),
+    Q31(0.2298834292F),Q31(0.2302995431F),Q31(0.2307159314F),Q31(0.2311325937F),
+    Q31(0.2315495297F),Q31(0.2319667388F),Q31(0.2323842207F),Q31(0.2328019749F),
+    Q31(0.2332200011F),Q31(0.2336382988F),Q31(0.2340568675F),Q31(0.2344757070F),
+    Q31(0.2348948166F),Q31(0.2353141961F),Q31(0.2357338450F),Q31(0.2361537629F),
+    Q31(0.2365739493F),Q31(0.2369944038F),Q31(0.2374151261F),Q31(0.2378361156F),
+    Q31(0.2382573720F),Q31(0.2386788948F),Q31(0.2391006836F),Q31(0.2395227380F),
+    Q31(0.2399450575F),Q31(0.2403676417F),Q31(0.2407904902F),Q31(0.2412136026F),
+    Q31(0.2416369783F),Q31(0.2420606171F),Q31(0.2424845185F),Q31(0.2429086820F),
+    Q31(0.2433331072F),Q31(0.2437577936F),Q31(0.2441827409F),Q31(0.2446079486F),
+    Q31(0.2450334163F),Q31(0.2454591435F),Q31(0.2458851298F),Q31(0.2463113747F),
+    Q31(0.2467378779F),Q31(0.2471646389F),Q31(0.2475916573F),Q31(0.2480189325F),
+    Q31(0.2484464643F),Q31(0.2488742521F),Q31(0.2493022955F),Q31(0.2497305940F),
+    Q31(0.2501591473F),Q31(0.2505879549F),Q31(0.2510170163F),Q31(0.2514463311F),
+    Q31(0.2518758989F),Q31(0.2523057193F),Q31(0.2527357916F),Q31(0.2531661157F),
+    Q31(0.2535966909F),Q31(0.2540275169F),Q31(0.2544585931F),Q31(0.2548899193F),
+    Q31(0.2553214948F),Q31(0.2557533193F),Q31(0.2561853924F),Q31(0.2566177135F),
+    Q31(0.2570502822F),Q31(0.2574830981F),Q31(0.2579161608F),Q31(0.2583494697F),
+    Q31(0.2587830245F),Q31(0.2592168246F),Q31(0.2596508697F),Q31(0.2600851593F),
+    Q31(0.2605196929F),Q31(0.2609544701F),Q31(0.2613894904F),Q31(0.2618247534F),
+    Q31(0.2622602586F),Q31(0.2626960055F),Q31(0.2631319938F),Q31(0.2635682230F),
+    Q31(0.2640046925F),Q31(0.2644414021F),Q31(0.2648783511F),Q31(0.2653155391F),
+    Q31(0.2657529657F),Q31(0.2661906305F),Q31(0.2666285329F),Q31(0.2670666725F),
+    Q31(0.2675050489F),Q31(0.2679436616F),Q31(0.2683825101F),Q31(0.2688215940F),
+    Q31(0.2692609127F),Q31(0.2697004660F),Q31(0.2701402532F),Q31(0.2705802739F),
+    Q31(0.2710205278F),Q31(0.2714610142F),Q31(0.2719017327F),Q31(0.2723426830F),
+    Q31(0.2727838644F),Q31(0.2732252766F),Q31(0.2736669191F),Q31(0.2741087914F),
+    Q31(0.2745508930F),Q31(0.2749932235F),Q31(0.2754357824F),Q31(0.2758785693F),
+    Q31(0.2763215837F),Q31(0.2767648251F),Q31(0.2772082930F),Q31(0.2776519870F),
+    Q31(0.2780959066F),Q31(0.2785400513F),Q31(0.2789844207F),Q31(0.2794290143F),
+    Q31(0.2798738316F),Q31(0.2803188722F),Q31(0.2807641355F),Q31(0.2812096211F),
+    Q31(0.2816553286F),Q31(0.2821012574F),Q31(0.2825474071F),Q31(0.2829937773F),
+    Q31(0.2834403673F),Q31(0.2838871768F),Q31(0.2843342053F),Q31(0.2847814523F),
+    Q31(0.2852289174F),Q31(0.2856765999F),Q31(0.2861244996F),Q31(0.2865726159F),
+    Q31(0.2870209482F),Q31(0.2874694962F),Q31(0.2879182594F),Q31(0.2883672372F),
+    Q31(0.2888164293F),Q31(0.2892658350F),Q31(0.2897154540F),Q31(0.2901652858F),
+    Q31(0.2906153298F),Q31(0.2910655856F),Q31(0.2915160527F),Q31(0.2919667306F),
+    Q31(0.2924176189F),Q31(0.2928687171F),Q31(0.2933200246F),Q31(0.2937715409F),
+    Q31(0.2942232657F),Q31(0.2946751984F),Q31(0.2951273386F),Q31(0.2955796856F),
+    Q31(0.2960322391F),Q31(0.2964849986F),Q31(0.2969379636F),Q31(0.2973911335F),
+    Q31(0.2978445080F),Q31(0.2982980864F),Q31(0.2987518684F),Q31(0.2992058534F),
+    Q31(0.2996600409F),Q31(0.3001144305F),Q31(0.3005690217F),Q31(0.3010238139F),
+    Q31(0.3014788067F),Q31(0.3019339995F),Q31(0.3023893920F),Q31(0.3028449835F),
+    Q31(0.3033007736F),Q31(0.3037567618F),Q31(0.3042129477F),Q31(0.3046693306F),
+    Q31(0.3051259102F),Q31(0.3055826859F),Q31(0.3060396572F),Q31(0.3064968236F),
+    Q31(0.3069541847F),Q31(0.3074117399F),Q31(0.3078694887F),Q31(0.3083274307F),
+    Q31(0.3087855653F),Q31(0.3092438920F),Q31(0.3097024104F),Q31(0.3101611199F),
+    Q31(0.3106200200F),Q31(0.3110791103F),Q31(0.3115383902F),Q31(0.3119978592F),
+    Q31(0.3124575169F),Q31(0.3129173627F),Q31(0.3133773961F),Q31(0.3138376166F),
+    Q31(0.3142980238F),Q31(0.3147586170F),Q31(0.3152193959F),Q31(0.3156803598F),
+    Q31(0.3161415084F),Q31(0.3166028410F),Q31(0.3170643573F),Q31(0.3175260566F),
+    Q31(0.3179879384F),Q31(0.3184500023F),Q31(0.3189122478F),Q31(0.3193746743F),
+    Q31(0.3198372814F),Q31(0.3203000685F),Q31(0.3207630351F),Q31(0.3212261807F),
+    Q31(0.3216895048F),Q31(0.3221530069F),Q31(0.3226166865F),Q31(0.3230805430F),
+    Q31(0.3235445760F),Q31(0.3240087849F),Q31(0.3244731693F),Q31(0.3249377285F),
+    Q31(0.3254024622F),Q31(0.3258673698F),Q31(0.3263324507F),Q31(0.3267977045F),
+    Q31(0.3272631306F),Q31(0.3277287286F),Q31(0.3281944978F),Q31(0.3286604379F),
+    Q31(0.3291265482F),Q31(0.3295928284F),Q31(0.3300592777F),Q31(0.3305258958F),
+    Q31(0.3309926821F),Q31(0.3314596361F),Q31(0.3319267573F),Q31(0.3323940451F),
+    Q31(0.3328614990F),Q31(0.3333291186F),Q31(0.3337969033F),Q31(0.3342648525F),
+    Q31(0.3347329658F),Q31(0.3352012427F),Q31(0.3356696825F),Q31(0.3361382849F),
+    Q31(0.3366070492F),Q31(0.3370759749F),Q31(0.3375450616F),Q31(0.3380143087F),
+    Q31(0.3384837156F),Q31(0.3389532819F),Q31(0.3394230071F),Q31(0.3398928905F),
+    Q31(0.3403629317F),Q31(0.3408331302F),Q31(0.3413034854F),Q31(0.3417739967F),
+    Q31(0.3422446638F),Q31(0.3427154860F),Q31(0.3431864628F),Q31(0.3436575938F),
+    Q31(0.3441288782F),Q31(0.3446003158F),Q31(0.3450719058F),Q31(0.3455436478F),
+    Q31(0.3460155412F),Q31(0.3464875856F),Q31(0.3469597804F),Q31(0.3474321250F),
+    Q31(0.3479046189F),Q31(0.3483772617F),Q31(0.3488500527F),Q31(0.3493229914F),
+    Q31(0.3497960774F),Q31(0.3502693100F),Q31(0.3507426887F),Q31(0.3512162131F),
+    Q31(0.3516898825F),Q31(0.3521636965F),Q31(0.3526376545F),Q31(0.3531117559F),
+    Q31(0.3535860003F),Q31(0.3540603870F),Q31(0.3545349157F),Q31(0.3550095856F),
+    Q31(0.3554843964F),Q31(0.3559593474F),Q31(0.3564344381F),Q31(0.3569096680F),
+    Q31(0.3573850366F),Q31(0.3578605432F),Q31(0.3583361875F),Q31(0.3588119687F),
+    Q31(0.3592878865F),Q31(0.3597639402F),Q31(0.3602401293F),Q31(0.3607164533F),
+    Q31(0.3611929117F),Q31(0.3616695038F),Q31(0.3621462292F),Q31(0.3626230873F),
+    Q31(0.3631000776F),Q31(0.3635771995F),Q31(0.3640544525F),Q31(0.3645318360F),
+    Q31(0.3650093496F),Q31(0.3654869926F),Q31(0.3659647645F),Q31(0.3664426648F),
+    Q31(0.3669206930F),Q31(0.3673988484F),Q31(0.3678771306F),Q31(0.3683555390F),
+    Q31(0.3688340731F),Q31(0.3693127322F),Q31(0.3697915160F),Q31(0.3702704237F),
+    Q31(0.3707494549F),Q31(0.3712286091F),Q31(0.3717078857F),Q31(0.3721872840F),
+    Q31(0.3726668037F),Q31(0.3731464441F),Q31(0.3736262047F),Q31(0.3741060850F),
+    Q31(0.3745860843F),Q31(0.3750662023F),Q31(0.3755464382F),Q31(0.3760267915F),
+    Q31(0.3765072618F),Q31(0.3769878484F),Q31(0.3774685509F),Q31(0.3779493686F),
+    Q31(0.3784303010F),Q31(0.3789113475F),Q31(0.3793925076F),Q31(0.3798737809F),
+    Q31(0.3803551666F),Q31(0.3808366642F),Q31(0.3813182733F),Q31(0.3817999932F),
+    Q31(0.3822818234F),Q31(0.3827637633F),Q31(0.3832458124F),Q31(0.3837279702F),
+    Q31(0.3842102360F),Q31(0.3846926093F),Q31(0.3851750897F),Q31(0.3856576764F),
+    Q31(0.3861403690F),Q31(0.3866231670F),Q31(0.3871060696F),Q31(0.3875890765F),
+    Q31(0.3880721870F),Q31(0.3885554007F),Q31(0.3890387168F),Q31(0.3895221349F),
+    Q31(0.3900056544F),Q31(0.3904892748F),Q31(0.3909729955F),Q31(0.3914568160F),
+    Q31(0.3919407356F),Q31(0.3924247539F),Q31(0.3929088702F),Q31(0.3933930841F),
+    Q31(0.3938773949F),Q31(0.3943618021F),Q31(0.3948463052F),Q31(0.3953309035F),
+    Q31(0.3958155966F),Q31(0.3963003838F),Q31(0.3967852646F),Q31(0.3972702385F),
+    Q31(0.3977553048F),Q31(0.3982404631F),Q31(0.3987257127F),Q31(0.3992110531F),
+    Q31(0.3996964838F),Q31(0.4001820041F),Q31(0.4006676136F),Q31(0.4011533116F),
+    Q31(0.4016390976F),Q31(0.4021249710F),Q31(0.4026109313F),Q31(0.4030969779F),
+    Q31(0.4035831102F),Q31(0.4040693277F),Q31(0.4045556299F),Q31(0.4050420160F),
+    Q31(0.4055284857F),Q31(0.4060150383F),Q31(0.4065016732F),Q31(0.4069883899F),
+    Q31(0.4074751879F),Q31(0.4079620665F),Q31(0.4084490252F),Q31(0.4089360635F),
+    Q31(0.4094231807F),Q31(0.4099103763F),Q31(0.4103976498F),Q31(0.4108850005F),
+    Q31(0.4113724280F),Q31(0.4118599315F),Q31(0.4123475107F),Q31(0.4128351648F),
+    Q31(0.4133228934F),Q31(0.4138106959F),Q31(0.4142985716F),Q31(0.4147865201F),
+    Q31(0.4152745408F),Q31(0.4157626330F),Q31(0.4162507963F),Q31(0.4167390301F),
+    Q31(0.4172273337F),Q31(0.4177157067F),Q31(0.4182041484F),Q31(0.4186926583F),
+    Q31(0.4191812359F),Q31(0.4196698805F),Q31(0.4201585915F),Q31(0.4206473685F),
+    Q31(0.4211362108F),Q31(0.4216251179F),Q31(0.4221140892F),Q31(0.4226031241F),
+    Q31(0.4230922221F),Q31(0.4235813826F),Q31(0.4240706050F),Q31(0.4245598887F),
+    Q31(0.4250492332F),Q31(0.4255386379F),Q31(0.4260281022F),Q31(0.4265176256F),
+    Q31(0.4270072075F),Q31(0.4274968473F),Q31(0.4279865445F),Q31(0.4284762984F),
+    Q31(0.4289661086F),Q31(0.4294559743F),Q31(0.4299458951F),Q31(0.4304358704F),
+    Q31(0.4309258996F),Q31(0.4314159822F),Q31(0.4319061175F),Q31(0.4323963050F),
+    Q31(0.4328865441F),Q31(0.4333768342F),Q31(0.4338671749F),Q31(0.4343575654F),
+    Q31(0.4348480052F),Q31(0.4353384938F),Q31(0.4358290306F),Q31(0.4363196149F),
+    Q31(0.4368102463F),Q31(0.4373009241F),Q31(0.4377916478F),Q31(0.4382824168F),
+    Q31(0.4387732305F),Q31(0.4392640884F),Q31(0.4397549899F),Q31(0.4402459343F),
+    Q31(0.4407369212F),Q31(0.4412279499F),Q31(0.4417190198F),Q31(0.4422101305F),
+    Q31(0.4427012813F),Q31(0.4431924717F),Q31(0.4436837010F),Q31(0.4441749686F),
+    Q31(0.4446662742F),Q31(0.4451576169F),Q31(0.4456489963F),Q31(0.4461404118F),
+    Q31(0.4466318628F),Q31(0.4471233487F),Q31(0.4476148690F),Q31(0.4481064230F),
+    Q31(0.4485980103F),Q31(0.4490896302F),Q31(0.4495812821F),Q31(0.4500729654F),
+    Q31(0.4505646797F),Q31(0.4510564243F),Q31(0.4515481986F),Q31(0.4520400021F),
+    Q31(0.4525318341F),Q31(0.4530236942F),Q31(0.4535155816F),Q31(0.4540074959F),
+    Q31(0.4544994365F),Q31(0.4549914028F),Q31(0.4554833941F),Q31(0.4559754100F),
+    Q31(0.4564674499F),Q31(0.4569595131F),Q31(0.4574515991F),Q31(0.4579437074F),
+    Q31(0.4584358372F),Q31(0.4589279881F),Q31(0.4594201595F),Q31(0.4599123508F),
+    Q31(0.4604045615F),Q31(0.4608967908F),Q31(0.4613890383F),Q31(0.4618813034F),
+    Q31(0.4623735855F),Q31(0.4628658841F),Q31(0.4633581984F),Q31(0.4638505281F),
+    Q31(0.4643428724F),Q31(0.4648352308F),Q31(0.4653276028F),Q31(0.4658199877F),
+    Q31(0.4663123849F),Q31(0.4668047940F),Q31(0.4672972143F),Q31(0.4677896451F),
+    Q31(0.4682820861F),Q31(0.4687745365F),Q31(0.4692669958F),Q31(0.4697594634F),
+    Q31(0.4702519387F),Q31(0.4707444211F),Q31(0.4712369102F),Q31(0.4717294052F),
+    Q31(0.4722219056F),Q31(0.4727144109F),Q31(0.4732069204F),Q31(0.4736994336F),
+    Q31(0.4741919498F),Q31(0.4746844686F),Q31(0.4751769893F),Q31(0.4756695113F),
+    Q31(0.4761620341F),Q31(0.4766545571F),Q31(0.4771470797F),Q31(0.4776396013F),
+    Q31(0.4781321213F),Q31(0.4786246392F),Q31(0.4791171544F),Q31(0.4796096663F),
+    Q31(0.4801021744F),Q31(0.4805946779F),Q31(0.4810871765F),Q31(0.4815796694F),
+    Q31(0.4820721561F),Q31(0.4825646360F),Q31(0.4830571086F),Q31(0.4835495732F),
+    Q31(0.4840420293F),Q31(0.4845344763F),Q31(0.4850269136F),Q31(0.4855193407F),
+    Q31(0.4860117569F),Q31(0.4865041617F),Q31(0.4869965545F),Q31(0.4874889347F),
+    Q31(0.4879813018F),Q31(0.4884736551F),Q31(0.4889659941F),Q31(0.4894583182F),
+    Q31(0.4899506268F),Q31(0.4904429193F),Q31(0.4909351952F),Q31(0.4914274538F),
+    Q31(0.4919196947F),Q31(0.4924119172F),Q31(0.4929041207F),Q31(0.4933963046F),
+    Q31(0.4938884685F),Q31(0.4943806116F),Q31(0.4948727335F),Q31(0.4953648335F),
+    Q31(0.4958569110F),Q31(0.4963489656F),Q31(0.4968409965F),Q31(0.4973330032F),
+    Q31(0.4978249852F),Q31(0.4983169419F),Q31(0.4988088726F),Q31(0.4993007768F),
+    Q31(0.4997926539F),Q31(0.5002845034F),Q31(0.5007763247F),Q31(0.5012681171F),
+    Q31(0.5017598801F),Q31(0.5022516132F),Q31(0.5027433157F),Q31(0.5032349871F),
+    Q31(0.5037266268F),Q31(0.5042182341F),Q31(0.5047098086F),Q31(0.5052013497F),
+    Q31(0.5056928567F),Q31(0.5061843292F),Q31(0.5066757664F),Q31(0.5071671679F),
+    Q31(0.5076585330F),Q31(0.5081498613F),Q31(0.5086411520F),Q31(0.5091324047F),
+    Q31(0.5096236187F),Q31(0.5101147934F),Q31(0.5106059284F),Q31(0.5110970230F),
+    Q31(0.5115880766F),Q31(0.5120790887F),Q31(0.5125700587F),Q31(0.5130609860F),
+    Q31(0.5135518700F),Q31(0.5140427102F),Q31(0.5145335059F),Q31(0.5150242566F),
+    Q31(0.5155149618F),Q31(0.5160056208F),Q31(0.5164962331F),Q31(0.5169867980F),
+    Q31(0.5174773151F),Q31(0.5179677837F),Q31(0.5184582033F),Q31(0.5189485733F),
+    Q31(0.5194388931F),Q31(0.5199291621F),Q31(0.5204193798F),Q31(0.5209095455F),
+    Q31(0.5213996588F),Q31(0.5218897190F),Q31(0.5223797256F),Q31(0.5228696779F),
+    Q31(0.5233595755F),Q31(0.5238494177F),Q31(0.5243392039F),Q31(0.5248289337F),
+    Q31(0.5253186063F),Q31(0.5258082213F),Q31(0.5262977781F),Q31(0.5267872760F),
+    Q31(0.5272767146F),Q31(0.5277660932F),Q31(0.5282554112F),Q31(0.5287446682F),
+    Q31(0.5292338635F),Q31(0.5297229965F),Q31(0.5302120667F),Q31(0.5307010736F),
+    Q31(0.5311900164F),Q31(0.5316788947F),Q31(0.5321677079F),Q31(0.5326564554F),
+    Q31(0.5331451366F),Q31(0.5336337511F),Q31(0.5341222981F),Q31(0.5346107771F),
+    Q31(0.5350991876F),Q31(0.5355875290F),Q31(0.5360758007F),Q31(0.5365640021F),
+    Q31(0.5370521327F),Q31(0.5375401920F),Q31(0.5380281792F),Q31(0.5385160939F),
+    Q31(0.5390039355F),Q31(0.5394917034F),Q31(0.5399793971F),Q31(0.5404670159F),
+    Q31(0.5409545594F),Q31(0.5414420269F),Q31(0.5419294179F),Q31(0.5424167318F),
+    Q31(0.5429039680F),Q31(0.5433911261F),Q31(0.5438782053F),Q31(0.5443652051F),
+    Q31(0.5448521250F),Q31(0.5453389644F),Q31(0.5458257228F),Q31(0.5463123995F),
+    Q31(0.5467989940F),Q31(0.5472855057F),Q31(0.5477719341F),Q31(0.5482582786F),
+    Q31(0.5487445387F),Q31(0.5492307137F),Q31(0.5497168031F),Q31(0.5502028063F),
+    Q31(0.5506887228F),Q31(0.5511745520F),Q31(0.5516602934F),Q31(0.5521459463F),
+    Q31(0.5526315103F),Q31(0.5531169847F),Q31(0.5536023690F),Q31(0.5540876626F),
+    Q31(0.5545728649F),Q31(0.5550579755F),Q31(0.5555429937F),Q31(0.5560279189F),
+    Q31(0.5565127507F),Q31(0.5569974884F),Q31(0.5574821315F),Q31(0.5579666794F),
+    Q31(0.5584511316F),Q31(0.5589354875F),Q31(0.5594197465F),Q31(0.5599039080F),
+    Q31(0.5603879716F),Q31(0.5608719367F),Q31(0.5613558026F),Q31(0.5618395689F),
+    Q31(0.5623232350F),Q31(0.5628068002F),Q31(0.5632902642F),Q31(0.5637736262F),
+    Q31(0.5642568858F),Q31(0.5647400423F),Q31(0.5652230953F),Q31(0.5657060442F),
+    Q31(0.5661888883F),Q31(0.5666716272F),Q31(0.5671542603F),Q31(0.5676367870F),
+    Q31(0.5681192069F),Q31(0.5686015192F),Q31(0.5690837235F),Q31(0.5695658192F),
+    Q31(0.5700478058F),Q31(0.5705296827F),Q31(0.5710114494F),Q31(0.5714931052F),
+    Q31(0.5719746497F),Q31(0.5724560822F),Q31(0.5729374023F),Q31(0.5734186094F),
+    Q31(0.5738997029F),Q31(0.5743806823F),Q31(0.5748615470F),Q31(0.5753422965F),
+    Q31(0.5758229301F),Q31(0.5763034475F),Q31(0.5767838480F),Q31(0.5772641310F),
+    Q31(0.5777442960F),Q31(0.5782243426F),Q31(0.5787042700F),Q31(0.5791840778F),
+    Q31(0.5796637654F),Q31(0.5801433322F),Q31(0.5806227778F),Q31(0.5811021016F),
+    Q31(0.5815813029F),Q31(0.5820603814F),Q31(0.5825393363F),Q31(0.5830181673F),
+    Q31(0.5834968737F),Q31(0.5839754549F),Q31(0.5844539105F),Q31(0.5849322399F),
+    Q31(0.5854104425F),Q31(0.5858885179F),Q31(0.5863664653F),Q31(0.5868442844F),
+    Q31(0.5873219746F),Q31(0.5877995353F),Q31(0.5882769660F),Q31(0.5887542661F),
+    Q31(0.5892314351F),Q31(0.5897084724F),Q31(0.5901853776F),Q31(0.5906621500F),
+    Q31(0.5911387892F),Q31(0.5916152945F),Q31(0.5920916655F),Q31(0.5925679016F),
+    Q31(0.5930440022F),Q31(0.5935199669F),Q31(0.5939957950F),Q31(0.5944714861F),
+    Q31(0.5949470396F),Q31(0.5954224550F),Q31(0.5958977317F),Q31(0.5963728692F),
+    Q31(0.5968478669F),Q31(0.5973227244F),Q31(0.5977974411F),Q31(0.5982720163F),
+    Q31(0.5987464497F),Q31(0.5992207407F),Q31(0.5996948887F),Q31(0.6001688932F),
+    Q31(0.6006427537F),Q31(0.6011164696F),Q31(0.6015900405F),Q31(0.6020634657F),
+    Q31(0.6025367447F),Q31(0.6030098770F),Q31(0.6034828621F),Q31(0.6039556995F),
+    Q31(0.6044283885F),Q31(0.6049009288F),Q31(0.6053733196F),Q31(0.6058455606F),
+    Q31(0.6063176512F),Q31(0.6067895909F),Q31(0.6072613790F),Q31(0.6077330152F),
+    Q31(0.6082044989F),Q31(0.6086758295F),Q31(0.6091470065F),Q31(0.6096180294F),
+    Q31(0.6100888977F),Q31(0.6105596108F),Q31(0.6110301682F),Q31(0.6115005694F),
+    Q31(0.6119708139F),Q31(0.6124409011F),Q31(0.6129108305F),Q31(0.6133806017F),
+    Q31(0.6138502139F),Q31(0.6143196669F),Q31(0.6147889599F),Q31(0.6152580926F),
+    Q31(0.6157270643F),Q31(0.6161958746F),Q31(0.6166645230F),Q31(0.6171330088F),
+    Q31(0.6176013317F),Q31(0.6180694910F),Q31(0.6185374863F),Q31(0.6190053171F),
+    Q31(0.6194729827F),Q31(0.6199404828F),Q31(0.6204078167F),Q31(0.6208749841F),
+    Q31(0.6213419842F),Q31(0.6218088168F),Q31(0.6222754811F),Q31(0.6227419768F),
+    Q31(0.6232083032F),Q31(0.6236744600F),Q31(0.6241404465F),Q31(0.6246062622F),
+    Q31(0.6250719067F),Q31(0.6255373795F),Q31(0.6260026799F),Q31(0.6264678076F),
+    Q31(0.6269327619F),Q31(0.6273975425F),Q31(0.6278621487F),Q31(0.6283265800F),
+    Q31(0.6287908361F),Q31(0.6292549163F),Q31(0.6297188201F),Q31(0.6301825471F),
+    Q31(0.6306460966F),Q31(0.6311094683F),Q31(0.6315726617F),Q31(0.6320356761F),
+    Q31(0.6324985111F),Q31(0.6329611662F),Q31(0.6334236410F),Q31(0.6338859348F),
+    Q31(0.6343480472F),Q31(0.6348099777F),Q31(0.6352717257F),Q31(0.6357332909F),
+    Q31(0.6361946726F),Q31(0.6366558704F),Q31(0.6371168837F),Q31(0.6375777122F),
+    Q31(0.6380383552F),Q31(0.6384988123F),Q31(0.6389590830F),Q31(0.6394191668F),
+    Q31(0.6398790631F),Q31(0.6403387716F),Q31(0.6407982916F),Q31(0.6412576228F),
+    Q31(0.6417167645F),Q31(0.6421757163F),Q31(0.6426344778F),Q31(0.6430930483F),
+    Q31(0.6435514275F),Q31(0.6440096149F),Q31(0.6444676098F),Q31(0.6449254119F),
+    Q31(0.6453830207F),Q31(0.6458404356F),Q31(0.6462976562F),Q31(0.6467546820F),
+    Q31(0.6472115125F),Q31(0.6476681472F),Q31(0.6481245856F),Q31(0.6485808273F),
+    Q31(0.6490368717F),Q31(0.6494927183F),Q31(0.6499483667F),Q31(0.6504038164F),
+    Q31(0.6508590670F),Q31(0.6513141178F),Q31(0.6517689684F),Q31(0.6522236185F),
+    Q31(0.6526780673F),Q31(0.6531323146F),Q31(0.6535863598F),Q31(0.6540402024F),
+    Q31(0.6544938419F),Q31(0.6549472779F),Q31(0.6554005099F),Q31(0.6558535373F),
+    Q31(0.6563063598F),Q31(0.6567589769F),Q31(0.6572113880F),Q31(0.6576635927F),
+    Q31(0.6581155906F),Q31(0.6585673810F),Q31(0.6590189637F),Q31(0.6594703380F),
+    Q31(0.6599215035F),Q31(0.6603724598F),Q31(0.6608232064F),Q31(0.6612737427F),
+    Q31(0.6617240684F),Q31(0.6621741829F),Q31(0.6626240859F),Q31(0.6630737767F),
+    Q31(0.6635232550F),Q31(0.6639725202F),Q31(0.6644215720F),Q31(0.6648704098F),
+    Q31(0.6653190332F),Q31(0.6657674417F),Q31(0.6662156348F),Q31(0.6666636121F),
+    Q31(0.6671113731F),Q31(0.6675589174F),Q31(0.6680062445F),Q31(0.6684533538F),
+    Q31(0.6689002450F),Q31(0.6693469177F),Q31(0.6697933712F),Q31(0.6702396052F),
+    Q31(0.6706856193F),Q31(0.6711314129F),Q31(0.6715769855F),Q31(0.6720223369F),
+    Q31(0.6724674664F),Q31(0.6729123736F),Q31(0.6733570581F),Q31(0.6738015194F),
+    Q31(0.6742457570F),Q31(0.6746897706F),Q31(0.6751335596F),Q31(0.6755771236F),
+    Q31(0.6760204621F),Q31(0.6764635747F),Q31(0.6769064609F),Q31(0.6773491204F),
+    Q31(0.6777915525F),Q31(0.6782337570F),Q31(0.6786757332F),Q31(0.6791174809F),
+    Q31(0.6795589995F),Q31(0.6800002886F),Q31(0.6804413477F),Q31(0.6808821765F),
+    Q31(0.6813227743F),Q31(0.6817631409F),Q31(0.6822032758F),Q31(0.6826431785F),
+    Q31(0.6830828485F),Q31(0.6835222855F),Q31(0.6839614890F),Q31(0.6844004585F),
+    Q31(0.6848391936F),Q31(0.6852776939F),Q31(0.6857159589F),Q31(0.6861539883F),
+    Q31(0.6865917815F),Q31(0.6870293381F),Q31(0.6874666576F),Q31(0.6879037398F),
+    Q31(0.6883405840F),Q31(0.6887771899F),Q31(0.6892135571F),Q31(0.6896496850F),
+    Q31(0.6900855733F),Q31(0.6905212216F),Q31(0.6909566294F),Q31(0.6913917963F),
+    Q31(0.6918267218F),Q31(0.6922614055F),Q31(0.6926958471F),Q31(0.6931300459F),
+    Q31(0.6935640018F),Q31(0.6939977141F),Q31(0.6944311825F),Q31(0.6948644066F),
+    Q31(0.6952973859F),Q31(0.6957301200F),Q31(0.6961626085F),Q31(0.6965948510F),
+    Q31(0.6970268470F),Q31(0.6974585961F),Q31(0.6978900980F),Q31(0.6983213521F),
+    Q31(0.6987523580F),Q31(0.6991831154F),Q31(0.6996136238F),Q31(0.7000438828F),
+    Q31(0.7004738921F),Q31(0.7009036510F),Q31(0.7013331594F),Q31(0.7017624166F),
+    Q31(0.7021914224F),Q31(0.7026201763F),Q31(0.7030486779F),Q31(0.7034769268F),
+    Q31(0.7039049226F),Q31(0.7043326648F),Q31(0.7047601531F),Q31(0.7051873870F),
+    Q31(0.7056143662F),Q31(0.7060410902F),Q31(0.7064675586F),Q31(0.7068937711F),
+    Q31(0.7073197271F),Q31(0.7077454264F),Q31(0.7081708684F),Q31(0.7085960529F),
+    Q31(0.7090209793F),Q31(0.7094456474F),Q31(0.7098700566F),Q31(0.7102942066F),
+    Q31(0.7107180970F),Q31(0.7111417274F),Q31(0.7115650974F),Q31(0.7119882066F),
+    Q31(0.7124110545F),Q31(0.7128336409F),Q31(0.7132559653F),Q31(0.7136780272F),
+    Q31(0.7140998264F),Q31(0.7145213624F),Q31(0.7149426348F),Q31(0.7153636433F),
+    Q31(0.7157843874F),Q31(0.7162048668F),Q31(0.7166250810F),Q31(0.7170450296F),
+    Q31(0.7174647124F),Q31(0.7178841289F),Q31(0.7183032786F),Q31(0.7187221613F),
+    Q31(0.7191407765F),Q31(0.7195591239F),Q31(0.7199772030F),Q31(0.7203950135F),
+    Q31(0.7208125550F),Q31(0.7212298271F),Q31(0.7216468294F),Q31(0.7220635616F),
+    Q31(0.7224800233F),Q31(0.7228962140F),Q31(0.7233121335F),Q31(0.7237277813F),
+    Q31(0.7241431571F),Q31(0.7245582604F),Q31(0.7249730910F),Q31(0.7253876484F),
+    Q31(0.7258019322F),Q31(0.7262159422F),Q31(0.7266296778F),Q31(0.7270431388F),
+    Q31(0.7274563247F),Q31(0.7278692353F),Q31(0.7282818700F),Q31(0.7286942287F),
+    Q31(0.7291063108F),Q31(0.7295181160F),Q31(0.7299296440F),Q31(0.7303408944F),
+    Q31(0.7307518669F),Q31(0.7311625609F),Q31(0.7315729763F),Q31(0.7319831126F),
+    Q31(0.7323929695F),Q31(0.7328025466F),Q31(0.7332118435F),Q31(0.7336208600F),
+    Q31(0.7340295955F),Q31(0.7344380499F),Q31(0.7348462226F),Q31(0.7352541134F),
+    Q31(0.7356617220F),Q31(0.7360690478F),Q31(0.7364760907F),Q31(0.7368828502F),
+    Q31(0.7372893259F),Q31(0.7376955176F),Q31(0.7381014249F),Q31(0.7385070475F),
+    Q31(0.7389123849F),Q31(0.7393174368F),Q31(0.7397222029F),Q31(0.7401266829F),
+    Q31(0.7405308763F),Q31(0.7409347829F),Q31(0.7413384023F),Q31(0.7417417341F),
+    Q31(0.7421447780F),Q31(0.7425475338F),Q31(0.7429500009F),Q31(0.7433521791F),
+    Q31(0.7437540681F),Q31(0.7441556674F),Q31(0.7445569769F),Q31(0.7449579960F),
+    Q31(0.7453587245F),Q31(0.7457591621F),Q31(0.7461593084F),Q31(0.7465591631F),
+    Q31(0.7469587259F),Q31(0.7473579963F),Q31(0.7477569741F),Q31(0.7481556590F),
+    Q31(0.7485540506F),Q31(0.7489521486F),Q31(0.7493499526F),Q31(0.7497474623F),
+    Q31(0.7501446775F),Q31(0.7505415977F),Q31(0.7509382227F),Q31(0.7513345521F),
+    Q31(0.7517305856F),Q31(0.7521263229F),Q31(0.7525217636F),Q31(0.7529169074F),
+    Q31(0.7533117541F),Q31(0.7537063032F),Q31(0.7541005545F),Q31(0.7544945076F),
+    Q31(0.7548881623F),Q31(0.7552815182F),Q31(0.7556745749F),Q31(0.7560673323F),
+    Q31(0.7564597899F),Q31(0.7568519474F),Q31(0.7572438046F),Q31(0.7576353611F),
+    Q31(0.7580266166F),Q31(0.7584175708F),Q31(0.7588082235F),Q31(0.7591985741F),
+    Q31(0.7595886226F),Q31(0.7599783685F),Q31(0.7603678116F),Q31(0.7607569515F),
+    Q31(0.7611457879F),Q31(0.7615343206F),Q31(0.7619225493F),Q31(0.7623104735F),
+    Q31(0.7626980931F),Q31(0.7630854078F),Q31(0.7634724171F),Q31(0.7638591209F),
+    Q31(0.7642455188F),Q31(0.7646316106F),Q31(0.7650173959F),Q31(0.7654028744F),
+    Q31(0.7657880459F),Q31(0.7661729100F),Q31(0.7665574664F),Q31(0.7669417150F),
+    Q31(0.7673256553F),Q31(0.7677092871F),Q31(0.7680926100F),Q31(0.7684756239F),
+    Q31(0.7688583284F),Q31(0.7692407232F),Q31(0.7696228080F),Q31(0.7700045826F),
+    Q31(0.7703860467F),Q31(0.7707671999F),Q31(0.7711480420F),Q31(0.7715285728F),
+    Q31(0.7719087918F),Q31(0.7722886989F),Q31(0.7726682938F),Q31(0.7730475762F),
+    Q31(0.7734265458F),Q31(0.7738052023F),Q31(0.7741835454F),Q31(0.7745615750F),
+    Q31(0.7749392906F),Q31(0.7753166921F),Q31(0.7756937791F),Q31(0.7760705514F),
+    Q31(0.7764470087F),Q31(0.7768231508F),Q31(0.7771989773F),Q31(0.7775744880F),
+    Q31(0.7779496827F),Q31(0.7783245610F),Q31(0.7786991227F),Q31(0.7790733676F),
+    Q31(0.7794472953F),Q31(0.7798209056F),Q31(0.7801941982F),Q31(0.7805671729F),
+    Q31(0.7809398294F),Q31(0.7813121675F),Q31(0.7816841869F),Q31(0.7820558873F),
+    Q31(0.7824272684F),Q31(0.7827983301F),Q31(0.7831690720F),Q31(0.7835394940F),
+    Q31(0.7839095957F),Q31(0.7842793768F),Q31(0.7846488373F),Q31(0.7850179767F),
+    Q31(0.7853867948F),Q31(0.7857552914F),Q31(0.7861234663F),Q31(0.7864913191F),
+    Q31(0.7868588497F),Q31(0.7872260578F),Q31(0.7875929431F),Q31(0.7879595055F),
+    Q31(0.7883257445F),Q31(0.7886916601F),Q31(0.7890572520F),Q31(0.7894225198F),
+    Q31(0.7897874635F),Q31(0.7901520827F),Q31(0.7905163772F),Q31(0.7908803468F),
+    Q31(0.7912439912F),Q31(0.7916073102F),Q31(0.7919703035F),Q31(0.7923329710F),
+    Q31(0.7926953124F),Q31(0.7930573274F),Q31(0.7934190158F),Q31(0.7937803774F),
+    Q31(0.7941414120F),Q31(0.7945021193F),Q31(0.7948624991F),Q31(0.7952225511F),
+    Q31(0.7955822752F),Q31(0.7959416711F),Q31(0.7963007387F),Q31(0.7966594775F),
+    Q31(0.7970178875F),Q31(0.7973759685F),Q31(0.7977337201F),Q31(0.7980911422F),
+    Q31(0.7984482346F),Q31(0.7988049970F),Q31(0.7991614292F),Q31(0.7995175310F),
+    Q31(0.7998733022F),Q31(0.8002287426F),Q31(0.8005838519F),Q31(0.8009386299F),
+    Q31(0.8012930765F),Q31(0.8016471914F),Q31(0.8020009744F),Q31(0.8023544253F),
+    Q31(0.8027075438F),Q31(0.8030603298F),Q31(0.8034127831F),Q31(0.8037649035F),
+    Q31(0.8041166906F),Q31(0.8044681445F),Q31(0.8048192647F),Q31(0.8051700512F),
+    Q31(0.8055205038F),Q31(0.8058706222F),Q31(0.8062204062F),Q31(0.8065698556F),
+    Q31(0.8069189702F),Q31(0.8072677499F),Q31(0.8076161944F),Q31(0.8079643036F),
+    Q31(0.8083120772F),Q31(0.8086595151F),Q31(0.8090066170F),Q31(0.8093533827F),
+    Q31(0.8096998122F),Q31(0.8100459051F),Q31(0.8103916613F),Q31(0.8107370806F),
+    Q31(0.8110821628F),Q31(0.8114269077F),Q31(0.8117713151F),Q31(0.8121153849F),
+    Q31(0.8124591169F),Q31(0.8128025108F),Q31(0.8131455666F),Q31(0.8134882839F),
+    Q31(0.8138306627F),Q31(0.8141727027F),Q31(0.8145144038F),Q31(0.8148557658F),
+    Q31(0.8151967886F),Q31(0.8155374718F),Q31(0.8158778154F),Q31(0.8162178192F),
+    Q31(0.8165574830F),Q31(0.8168968067F),Q31(0.8172357900F),Q31(0.8175744328F),
+    Q31(0.8179127349F),Q31(0.8182506962F),Q31(0.8185883164F),Q31(0.8189255955F),
+    Q31(0.8192625332F),Q31(0.8195991295F),Q31(0.8199353840F),Q31(0.8202712967F),
+    Q31(0.8206068673F),Q31(0.8209420958F),Q31(0.8212769820F),Q31(0.8216115256F),
+    Q31(0.8219457266F),Q31(0.8222795848F),Q31(0.8226131000F),Q31(0.8229462721F),
+    Q31(0.8232791009F),Q31(0.8236115863F),Q31(0.8239437280F),Q31(0.8242755260F),
+    Q31(0.8246069801F),Q31(0.8249380901F),Q31(0.8252688559F),Q31(0.8255992774F),
+    Q31(0.8259293544F),Q31(0.8262590867F),Q31(0.8265884741F),Q31(0.8269175167F),
+    Q31(0.8272462141F),Q31(0.8275745663F),Q31(0.8279025732F),Q31(0.8282302344F),
+    Q31(0.8285575501F),Q31(0.8288845199F),Q31(0.8292111437F),Q31(0.8295374215F),
+    Q31(0.8298633530F),Q31(0.8301889382F),Q31(0.8305141768F),Q31(0.8308390688F),
+    Q31(0.8311636141F),Q31(0.8314878124F),Q31(0.8318116637F),Q31(0.8321351678F),
+    Q31(0.8324583246F),Q31(0.8327811340F),Q31(0.8331035957F),Q31(0.8334257098F),
+    Q31(0.8337474761F),Q31(0.8340688944F),Q31(0.8343899647F),Q31(0.8347106867F),
+    Q31(0.8350310605F),Q31(0.8353510857F),Q31(0.8356707624F),Q31(0.8359900904F),
+    Q31(0.8363090696F),Q31(0.8366276999F),Q31(0.8369459811F),Q31(0.8372639131F),
+    Q31(0.8375814958F),Q31(0.8378987292F),Q31(0.8382156130F),Q31(0.8385321472F),
+    Q31(0.8388483316F),Q31(0.8391641662F),Q31(0.8394796508F),Q31(0.8397947853F),
+    Q31(0.8401095697F),Q31(0.8404240037F),Q31(0.8407380873F),Q31(0.8410518204F),
+    Q31(0.8413652029F),Q31(0.8416782347F),Q31(0.8419909156F),Q31(0.8423032456F),
+    Q31(0.8426152245F),Q31(0.8429268523F),Q31(0.8432381289F),Q31(0.8435490541F),
+    Q31(0.8438596279F),Q31(0.8441698502F),Q31(0.8444797208F),Q31(0.8447892396F),
+    Q31(0.8450984067F),Q31(0.8454072218F),Q31(0.8457156849F),Q31(0.8460237959F),
+    Q31(0.8463315547F),Q31(0.8466389612F),Q31(0.8469460154F),Q31(0.8472527170F),
+    Q31(0.8475590661F),Q31(0.8478650625F),Q31(0.8481707063F),Q31(0.8484759971F),
+    Q31(0.8487809351F),Q31(0.8490855201F),Q31(0.8493897521F),Q31(0.8496936308F),
+    Q31(0.8499971564F),Q31(0.8503003286F),Q31(0.8506031474F),Q31(0.8509056128F),
+    Q31(0.8512077246F),Q31(0.8515094828F),Q31(0.8518108872F),Q31(0.8521119379F),
+    Q31(0.8524126348F),Q31(0.8527129777F),Q31(0.8530129666F),Q31(0.8533126015F),
+    Q31(0.8536118822F),Q31(0.8539108087F),Q31(0.8542093809F),Q31(0.8545075988F),
+    Q31(0.8548054623F),Q31(0.8551029712F),Q31(0.8554001257F),Q31(0.8556969255F),
+    Q31(0.8559933707F),Q31(0.8562894611F),Q31(0.8565851968F),Q31(0.8568805775F),
+    Q31(0.8571756034F),Q31(0.8574702743F),Q31(0.8577645902F),Q31(0.8580585509F),
+    Q31(0.8583521566F),Q31(0.8586454070F),Q31(0.8589383021F),Q31(0.8592308420F),
+    Q31(0.8595230265F),Q31(0.8598148556F),Q31(0.8601063292F),Q31(0.8603974473F),
+    Q31(0.8606882098F),Q31(0.8609786167F),Q31(0.8612686680F),Q31(0.8615583636F),
+    Q31(0.8618477034F),Q31(0.8621366874F),Q31(0.8624253156F),Q31(0.8627135878F),
+    Q31(0.8630015042F),Q31(0.8632890646F),Q31(0.8635762690F),Q31(0.8638631173F),
+    Q31(0.8641496096F),Q31(0.8644357457F),Q31(0.8647215257F),Q31(0.8650069495F),
+    Q31(0.8652920171F),Q31(0.8655767283F),Q31(0.8658610833F),Q31(0.8661450820F),
+    Q31(0.8664287243F),Q31(0.8667120102F),Q31(0.8669949397F),Q31(0.8672775127F),
+    Q31(0.8675597293F),Q31(0.8678415894F),Q31(0.8681230929F),Q31(0.8684042398F),
+    Q31(0.8686850302F),Q31(0.8689654640F),Q31(0.8692455412F),Q31(0.8695252617F),
+    Q31(0.8698046255F),Q31(0.8700836327F),Q31(0.8703622831F),Q31(0.8706405768F),
+    Q31(0.8709185138F),Q31(0.8711960940F),Q31(0.8714733174F),Q31(0.8717501840F),
+    Q31(0.8720266939F),Q31(0.8723028469F),Q31(0.8725786430F),Q31(0.8728540824F),
+    Q31(0.8731291648F),Q31(0.8734038905F),Q31(0.8736782592F),Q31(0.8739522711F),
+    Q31(0.8742259261F),Q31(0.8744992242F),Q31(0.8747721653F),Q31(0.8750447496F),
+    Q31(0.8753169770F),Q31(0.8755888475F),Q31(0.8758603611F),Q31(0.8761315177F),
+    Q31(0.8764023175F),Q31(0.8766727603F),Q31(0.8769428462F),Q31(0.8772125752F),
+    Q31(0.8774819474F),Q31(0.8777509626F),Q31(0.8780196209F),Q31(0.8782879224F),
+    Q31(0.8785558669F),Q31(0.8788234546F),Q31(0.8790906854F),Q31(0.8793575594F),
+    Q31(0.8796240765F),Q31(0.8798902368F),Q31(0.8801560403F),Q31(0.8804214870F),
+    Q31(0.8806865768F),Q31(0.8809513099F),Q31(0.8812156863F),Q31(0.8814797059F),
+    Q31(0.8817433687F),Q31(0.8820066749F),Q31(0.8822696243F),Q31(0.8825322171F),
+    Q31(0.8827944532F),Q31(0.8830563327F),Q31(0.8833178556F),Q31(0.8835790219F),
+    Q31(0.8838398316F),Q31(0.8841002848F),Q31(0.8843603815F),Q31(0.8846201217F),
+    Q31(0.8848795054F),Q31(0.8851385327F),Q31(0.8853972036F),Q31(0.8856555182F),
+    Q31(0.8859134764F),Q31(0.8861710783F),Q31(0.8864283239F),Q31(0.8866852133F),
+    Q31(0.8869417464F),Q31(0.8871979234F),Q31(0.8874537443F),Q31(0.8877092090F),
+    Q31(0.8879643177F),Q31(0.8882190704F),Q31(0.8884734671F),Q31(0.8887275078F),
+    Q31(0.8889811927F),Q31(0.8892345216F),Q31(0.8894874948F),Q31(0.8897401122F),
+    Q31(0.8899923738F),Q31(0.8902442798F),Q31(0.8904958301F),Q31(0.8907470248F),
+    Q31(0.8909978640F),Q31(0.8912483477F),Q31(0.8914984759F),Q31(0.8917482487F),
+    Q31(0.8919976662F),Q31(0.8922467284F),Q31(0.8924954353F),Q31(0.8927437871F),
+    Q31(0.8929917837F),Q31(0.8932394252F),Q31(0.8934867118F),Q31(0.8937336433F),
+    Q31(0.8939802199F),Q31(0.8942264417F),Q31(0.8944723087F),Q31(0.8947178210F),
+    Q31(0.8949629785F),Q31(0.8952077815F),Q31(0.8954522299F),Q31(0.8956963239F),
+    Q31(0.8959400634F),Q31(0.8961834486F),Q31(0.8964264795F),Q31(0.8966691561F),
+    Q31(0.8969114786F),Q31(0.8971534470F),Q31(0.8973950614F),Q31(0.8976363219F),
+    Q31(0.8978772284F),Q31(0.8981177812F),Q31(0.8983579802F),Q31(0.8985978256F),
+    Q31(0.8988373174F),Q31(0.8990764556F),Q31(0.8993152405F),Q31(0.8995536720F),
+    Q31(0.8997917502F),Q31(0.9000294751F),Q31(0.9002668470F),Q31(0.9005038658F),
+    Q31(0.9007405317F),Q31(0.9009768446F),Q31(0.9012128048F),Q31(0.9014484123F),
+    Q31(0.9016836671F),Q31(0.9019185693F),Q31(0.9021531191F),Q31(0.9023873165F),
+    Q31(0.9026211616F),Q31(0.9028546546F),Q31(0.9030877954F),Q31(0.9033205841F),
+    Q31(0.9035530210F),Q31(0.9037851059F),Q31(0.9040168392F),Q31(0.9042482207F),
+    Q31(0.9044792507F),Q31(0.9047099293F),Q31(0.9049402564F),Q31(0.9051702323F),
+    Q31(0.9053998569F),Q31(0.9056291305F),Q31(0.9058580531F),Q31(0.9060866248F),
+    Q31(0.9063148457F),Q31(0.9065427159F),Q31(0.9067702355F),Q31(0.9069974046F),
+    Q31(0.9072242233F),Q31(0.9074506917F),Q31(0.9076768100F),Q31(0.9079025782F),
+    Q31(0.9081279964F),Q31(0.9083530647F),Q31(0.9085777833F),Q31(0.9088021523F),
+    Q31(0.9090261717F),Q31(0.9092498417F),Q31(0.9094731623F),Q31(0.9096961338F),
+    Q31(0.9099187561F),Q31(0.9101410295F),Q31(0.9103629540F),Q31(0.9105845297F),
+    Q31(0.9108057568F),Q31(0.9110266354F),Q31(0.9112471656F),Q31(0.9114673475F),
+    Q31(0.9116871812F),Q31(0.9119066668F),Q31(0.9121258046F),Q31(0.9123445945F),
+    Q31(0.9125630367F),Q31(0.9127811314F),Q31(0.9129988786F),Q31(0.9132162785F),
+    Q31(0.9134333312F),Q31(0.9136500368F),Q31(0.9138663954F),Q31(0.9140824073F),
+    Q31(0.9142980724F),Q31(0.9145133910F),Q31(0.9147283632F),Q31(0.9149429890F),
+    Q31(0.9151572687F),Q31(0.9153712023F),Q31(0.9155847900F),Q31(0.9157980319F),
+    Q31(0.9160109282F),Q31(0.9162234790F),Q31(0.9164356844F),Q31(0.9166475445F),
+    Q31(0.9168590595F),Q31(0.9170702296F),Q31(0.9172810548F),Q31(0.9174915354F),
+    Q31(0.9177016714F),Q31(0.9179114629F),Q31(0.9181209102F),Q31(0.9183300134F),
+    Q31(0.9185387726F),Q31(0.9187471879F),Q31(0.9189552595F),Q31(0.9191629876F),
+    Q31(0.9193703723F),Q31(0.9195774136F),Q31(0.9197841119F),Q31(0.9199904672F),
+    Q31(0.9201964797F),Q31(0.9204021495F),Q31(0.9206074767F),Q31(0.9208124616F),
+    Q31(0.9210171043F),Q31(0.9212214049F),Q31(0.9214253636F),Q31(0.9216289805F),
+    Q31(0.9218322558F),Q31(0.9220351896F),Q31(0.9222377821F),Q31(0.9224400335F),
+    Q31(0.9226419439F),Q31(0.9228435134F),Q31(0.9230447423F),Q31(0.9232456307F),
+    Q31(0.9234461787F),Q31(0.9236463865F),Q31(0.9238462543F),Q31(0.9240457822F),
+    Q31(0.9242449704F),Q31(0.9244438190F),Q31(0.9246423282F),Q31(0.9248404983F),
+    Q31(0.9250383293F),Q31(0.9252358214F),Q31(0.9254329747F),Q31(0.9256297896F),
+    Q31(0.9258262660F),Q31(0.9260224042F),Q31(0.9262182044F),Q31(0.9264136667F),
+    Q31(0.9266087913F),Q31(0.9268035783F),Q31(0.9269980280F),Q31(0.9271921405F),
+    Q31(0.9273859160F),Q31(0.9275793546F),Q31(0.9277724566F),Q31(0.9279652221F),
+    Q31(0.9281576513F),Q31(0.9283497443F),Q31(0.9285415014F),Q31(0.9287329227F),
+    Q31(0.9289240084F),Q31(0.9291147586F),Q31(0.9293051737F),Q31(0.9294952536F),
+    Q31(0.9296849987F),Q31(0.9298744091F),Q31(0.9300634850F),Q31(0.9302522266F),
+    Q31(0.9304406340F),Q31(0.9306287074F),Q31(0.9308164471F),Q31(0.9310038532F),
+    Q31(0.9311909259F),Q31(0.9313776654F),Q31(0.9315640719F),Q31(0.9317501455F),
+    Q31(0.9319358865F),Q31(0.9321212951F),Q31(0.9323063713F),Q31(0.9324911155F),
+    Q31(0.9326755279F),Q31(0.9328596085F),Q31(0.9330433577F),Q31(0.9332267756F),
+    Q31(0.9334098623F),Q31(0.9335926182F),Q31(0.9337750434F),Q31(0.9339571380F),
+    Q31(0.9341389023F),Q31(0.9343203366F),Q31(0.9345014409F),Q31(0.9346822155F),
+    Q31(0.9348626606F),Q31(0.9350427763F),Q31(0.9352225630F),Q31(0.9354020207F),
+    Q31(0.9355811498F),Q31(0.9357599503F),Q31(0.9359384226F),Q31(0.9361165667F),
+    Q31(0.9362943830F),Q31(0.9364718716F),Q31(0.9366490327F),Q31(0.9368258666F),
+    Q31(0.9370023733F),Q31(0.9371785533F),Q31(0.9373544066F),Q31(0.9375299335F),
+    Q31(0.9377051341F),Q31(0.9378800087F),Q31(0.9380545576F),Q31(0.9382287809F),
+    Q31(0.9384026787F),Q31(0.9385762515F),Q31(0.9387494993F),Q31(0.9389224223F),
+    Q31(0.9390950209F),Q31(0.9392672951F),Q31(0.9394392453F),Q31(0.9396108716F),
+    Q31(0.9397821743F),Q31(0.9399531536F),Q31(0.9401238096F),Q31(0.9402941427F),
+    Q31(0.9404641530F),Q31(0.9406338407F),Q31(0.9408032061F),Q31(0.9409722495F),
+    Q31(0.9411409709F),Q31(0.9413093707F),Q31(0.9414774491F),Q31(0.9416452062F),
+    Q31(0.9418126424F),Q31(0.9419797579F),Q31(0.9421465528F),Q31(0.9423130274F),
+    Q31(0.9424791819F),Q31(0.9426450166F),Q31(0.9428105317F),Q31(0.9429757274F),
+    Q31(0.9431406039F),Q31(0.9433051616F),Q31(0.9434694005F),Q31(0.9436333209F),
+    Q31(0.9437969232F),Q31(0.9439602074F),Q31(0.9441231739F),Q31(0.9442858229F),
+    Q31(0.9444481545F),Q31(0.9446101691F),Q31(0.9447718669F),Q31(0.9449332481F),
+    Q31(0.9450943129F),Q31(0.9452550617F),Q31(0.9454154945F),Q31(0.9455756118F),
+    Q31(0.9457354136F),Q31(0.9458949003F),Q31(0.9460540721F),Q31(0.9462129292F),
+    Q31(0.9463714719F),Q31(0.9465297003F),Q31(0.9466876149F),Q31(0.9468452157F),
+    Q31(0.9470025031F),Q31(0.9471594772F),Q31(0.9473161384F),Q31(0.9474724869F),
+    Q31(0.9476285229F),Q31(0.9477842466F),Q31(0.9479396584F),Q31(0.9480947585F),
+    Q31(0.9482495470F),Q31(0.9484040243F),Q31(0.9485581906F),Q31(0.9487120462F),
+    Q31(0.9488655913F),Q31(0.9490188262F),Q31(0.9491717511F),Q31(0.9493243662F),
+    Q31(0.9494766718F),Q31(0.9496286683F),Q31(0.9497803557F),Q31(0.9499317345F),
+    Q31(0.9500828047F),Q31(0.9502335668F),Q31(0.9503840209F),Q31(0.9505341673F),
+    Q31(0.9506840062F),Q31(0.9508335380F),Q31(0.9509827629F),Q31(0.9511316810F),
+    Q31(0.9512802928F),Q31(0.9514285984F),Q31(0.9515765982F),Q31(0.9517242923F),
+    Q31(0.9518716810F),Q31(0.9520187646F),Q31(0.9521655434F),Q31(0.9523120176F),
+    Q31(0.9524581875F),Q31(0.9526040534F),Q31(0.9527496154F),Q31(0.9528948739F),
+    Q31(0.9530398292F),Q31(0.9531844814F),Q31(0.9533288310F),Q31(0.9534728780F),
+    Q31(0.9536166229F),Q31(0.9537600659F),Q31(0.9539032071F),Q31(0.9540460470F),
+    Q31(0.9541885858F),Q31(0.9543308237F),Q31(0.9544727611F),Q31(0.9546143981F),
+    Q31(0.9547557351F),Q31(0.9548967723F),Q31(0.9550375100F),Q31(0.9551779485F),
+    Q31(0.9553180881F),Q31(0.9554579290F),Q31(0.9555974714F),Q31(0.9557367158F),
+    Q31(0.9558756623F),Q31(0.9560143112F),Q31(0.9561526628F),Q31(0.9562907174F),
+    Q31(0.9564284752F),Q31(0.9565659366F),Q31(0.9567031017F),Q31(0.9568399710F),
+    Q31(0.9569765446F),Q31(0.9571128229F),Q31(0.9572488061F),Q31(0.9573844944F),
+    Q31(0.9575198883F),Q31(0.9576549879F),Q31(0.9577897936F),Q31(0.9579243056F),
+    Q31(0.9580585242F),Q31(0.9581924497F),Q31(0.9583260824F),Q31(0.9584594226F),
+    Q31(0.9585924705F),Q31(0.9587252264F),Q31(0.9588576906F),Q31(0.9589898634F),
+    Q31(0.9591217452F),Q31(0.9592533360F),Q31(0.9593846364F),Q31(0.9595156465F),
+    Q31(0.9596463666F),Q31(0.9597767971F),Q31(0.9599069382F),Q31(0.9600367901F),
+    Q31(0.9601663533F),Q31(0.9602956279F),Q31(0.9604246143F),Q31(0.9605533128F),
+    Q31(0.9606817236F),Q31(0.9608098471F),Q31(0.9609376835F),Q31(0.9610652332F),
+    Q31(0.9611924963F),Q31(0.9613194733F),Q31(0.9614461644F),Q31(0.9615725699F),
+    Q31(0.9616986901F),Q31(0.9618245253F),Q31(0.9619500757F),Q31(0.9620753418F),
+    Q31(0.9622003238F),Q31(0.9623250219F),Q31(0.9624494365F),Q31(0.9625735679F),
+    Q31(0.9626974163F),Q31(0.9628209821F),Q31(0.9629442656F),Q31(0.9630672671F),
+    Q31(0.9631899868F),Q31(0.9633124251F),Q31(0.9634345822F),Q31(0.9635564585F),
+    Q31(0.9636780543F),Q31(0.9637993699F),Q31(0.9639204056F),Q31(0.9640411616F),
+    Q31(0.9641616383F),Q31(0.9642818359F),Q31(0.9644017549F),Q31(0.9645213955F),
+    Q31(0.9646407579F),Q31(0.9647598426F),Q31(0.9648786497F),Q31(0.9649971797F),
+    Q31(0.9651154328F),Q31(0.9652334092F),Q31(0.9653511095F),Q31(0.9654685337F),
+    Q31(0.9655856823F),Q31(0.9657025556F),Q31(0.9658191538F),Q31(0.9659354773F),
+    Q31(0.9660515263F),Q31(0.9661673013F),Q31(0.9662828024F),Q31(0.9663980300F),
+    Q31(0.9665129845F),Q31(0.9666276660F),Q31(0.9667420750F),Q31(0.9668562118F),
+    Q31(0.9669700766F),Q31(0.9670836698F),Q31(0.9671969917F),Q31(0.9673100425F),
+    Q31(0.9674228227F),Q31(0.9675353325F),Q31(0.9676475722F),Q31(0.9677595422F),
+    Q31(0.9678712428F),Q31(0.9679826742F),Q31(0.9680938368F),Q31(0.9682047309F),
+    Q31(0.9683153569F),Q31(0.9684257150F),Q31(0.9685358056F),Q31(0.9686456289F),
+    Q31(0.9687551853F),Q31(0.9688644752F),Q31(0.9689734987F),Q31(0.9690822564F),
+    Q31(0.9691907483F),Q31(0.9692989750F),Q31(0.9694069367F),Q31(0.9695146337F),
+    Q31(0.9696220663F),Q31(0.9697292349F),Q31(0.9698361398F),Q31(0.9699427813F),
+    Q31(0.9700491597F),Q31(0.9701552754F),Q31(0.9702611286F),Q31(0.9703667197F),
+    Q31(0.9704720490F),Q31(0.9705771169F),Q31(0.9706819236F),Q31(0.9707864695F),
+    Q31(0.9708907549F),Q31(0.9709947802F),Q31(0.9710985456F),Q31(0.9712020514F),
+    Q31(0.9713052981F),Q31(0.9714082859F),Q31(0.9715110151F),Q31(0.9716134862F),
+    Q31(0.9717156993F),Q31(0.9718176549F),Q31(0.9719193532F),Q31(0.9720207946F),
+    Q31(0.9721219794F),Q31(0.9722229080F),Q31(0.9723235806F),Q31(0.9724239976F),
+    Q31(0.9725241593F),Q31(0.9726240661F),Q31(0.9727237183F),Q31(0.9728231161F),
+    Q31(0.9729222601F),Q31(0.9730211503F),Q31(0.9731197873F),Q31(0.9732181713F),
+    Q31(0.9733163027F),Q31(0.9734141817F),Q31(0.9735118088F),Q31(0.9736091842F),
+    Q31(0.9737063083F),Q31(0.9738031814F),Q31(0.9738998039F),Q31(0.9739961760F),
+    Q31(0.9740922981F),Q31(0.9741881706F),Q31(0.9742837938F),Q31(0.9743791680F),
+    Q31(0.9744742935F),Q31(0.9745691707F),Q31(0.9746637999F),Q31(0.9747581814F),
+    Q31(0.9748523157F),Q31(0.9749462029F),Q31(0.9750398435F),Q31(0.9751332378F),
+    Q31(0.9752263861F),Q31(0.9753192887F),Q31(0.9754119461F),Q31(0.9755043585F),
+    Q31(0.9755965262F),Q31(0.9756884496F),Q31(0.9757801291F),Q31(0.9758715650F),
+    Q31(0.9759627575F),Q31(0.9760537071F),Q31(0.9761444141F),Q31(0.9762348789F),
+    Q31(0.9763251016F),Q31(0.9764150828F),Q31(0.9765048228F),Q31(0.9765943218F),
+    Q31(0.9766835802F),Q31(0.9767725984F),Q31(0.9768613767F),Q31(0.9769499154F),
+    Q31(0.9770382149F),Q31(0.9771262755F),Q31(0.9772140976F),Q31(0.9773016815F),
+    Q31(0.9773890275F),Q31(0.9774761360F),Q31(0.9775630073F),Q31(0.9776496418F),
+    Q31(0.9777360398F),Q31(0.9778222016F),Q31(0.9779081277F),Q31(0.9779938182F),
+    Q31(0.9780792736F),Q31(0.9781644943F),Q31(0.9782494805F),Q31(0.9783342326F),
+    Q31(0.9784187509F),Q31(0.9785030359F),Q31(0.9785870877F),Q31(0.9786709069F),
+    Q31(0.9787544936F),Q31(0.9788378484F),Q31(0.9789209714F),Q31(0.9790038631F),
+    Q31(0.9790865238F),Q31(0.9791689538F),Q31(0.9792511535F),Q31(0.9793331232F),
+    Q31(0.9794148633F),Q31(0.9794963742F),Q31(0.9795776561F),Q31(0.9796587094F),
+    Q31(0.9797395345F),Q31(0.9798201316F),Q31(0.9799005013F),Q31(0.9799806437F),
+    Q31(0.9800605593F),Q31(0.9801402483F),Q31(0.9802197112F),Q31(0.9802989483F),
+    Q31(0.9803779600F),Q31(0.9804567465F),Q31(0.9805353082F),Q31(0.9806136455F),
+    Q31(0.9806917587F),Q31(0.9807696482F),Q31(0.9808473143F),Q31(0.9809247574F),
+    Q31(0.9810019778F),Q31(0.9810789759F),Q31(0.9811557519F),Q31(0.9812323064F),
+    Q31(0.9813086395F),Q31(0.9813847517F),Q31(0.9814606433F),Q31(0.9815363147F),
+    Q31(0.9816117662F),Q31(0.9816869981F),Q31(0.9817620108F),Q31(0.9818368047F),
+    Q31(0.9819113801F),Q31(0.9819857374F),Q31(0.9820598769F),Q31(0.9821337989F),
+    Q31(0.9822075038F),Q31(0.9822809920F),Q31(0.9823542638F),Q31(0.9824273195F),
+    Q31(0.9825001596F),Q31(0.9825727843F),Q31(0.9826451940F),Q31(0.9827173891F),
+    Q31(0.9827893700F),Q31(0.9828611368F),Q31(0.9829326901F),Q31(0.9830040302F),
+    Q31(0.9830751574F),Q31(0.9831460720F),Q31(0.9832167745F),Q31(0.9832872652F),
+    Q31(0.9833575444F),Q31(0.9834276124F),Q31(0.9834974697F),Q31(0.9835671166F),
+    Q31(0.9836365535F),Q31(0.9837057806F),Q31(0.9837747983F),Q31(0.9838436071F),
+    Q31(0.9839122072F),Q31(0.9839805990F),Q31(0.9840487829F),Q31(0.9841167591F),
+    Q31(0.9841845282F),Q31(0.9842520903F),Q31(0.9843194459F),Q31(0.9843865953F),
+    Q31(0.9844535389F),Q31(0.9845202771F),Q31(0.9845868101F),Q31(0.9846531383F),
+    Q31(0.9847192622F),Q31(0.9847851820F),Q31(0.9848508980F),Q31(0.9849164108F),
+    Q31(0.9849817205F),Q31(0.9850468276F),Q31(0.9851117324F),Q31(0.9851764352F),
+    Q31(0.9852409365F),Q31(0.9853052366F),Q31(0.9853693358F),Q31(0.9854332344F),
+    Q31(0.9854969330F),Q31(0.9855604317F),Q31(0.9856237309F),Q31(0.9856868310F),
+    Q31(0.9857497325F),Q31(0.9858124355F),Q31(0.9858749404F),Q31(0.9859372477F),
+    Q31(0.9859993577F),Q31(0.9860612707F),Q31(0.9861229871F),Q31(0.9861845072F),
+    Q31(0.9862458315F),Q31(0.9863069601F),Q31(0.9863678936F),Q31(0.9864286322F),
+    Q31(0.9864891764F),Q31(0.9865495264F),Q31(0.9866096826F),Q31(0.9866696454F),
+    Q31(0.9867294152F),Q31(0.9867889922F),Q31(0.9868483769F),Q31(0.9869075695F),
+    Q31(0.9869665706F),Q31(0.9870253803F),Q31(0.9870839991F),Q31(0.9871424273F),
+    Q31(0.9872006653F),Q31(0.9872587135F),Q31(0.9873165721F),Q31(0.9873742415F),
+    Q31(0.9874317222F),Q31(0.9874890144F),Q31(0.9875461185F),Q31(0.9876030348F),
+    Q31(0.9876597638F),Q31(0.9877163057F),Q31(0.9877726610F),Q31(0.9878288300F),
+    Q31(0.9878848130F),Q31(0.9879406104F),Q31(0.9879962225F),Q31(0.9880516497F),
+    Q31(0.9881068924F),Q31(0.9881619509F),Q31(0.9882168256F),Q31(0.9882715168F),
+    Q31(0.9883260249F),Q31(0.9883803502F),Q31(0.9884344931F),Q31(0.9884884539F),
+    Q31(0.9885422331F),Q31(0.9885958309F),Q31(0.9886492477F),Q31(0.9887024838F),
+    Q31(0.9887555397F),Q31(0.9888084157F),Q31(0.9888611120F),Q31(0.9889136292F),
+    Q31(0.9889659675F),Q31(0.9890181273F),Q31(0.9890701089F),Q31(0.9891219128F),
+    Q31(0.9891735392F),Q31(0.9892249885F),Q31(0.9892762610F),Q31(0.9893273572F),
+    Q31(0.9893782774F),Q31(0.9894290219F),Q31(0.9894795911F),Q31(0.9895299853F),
+    Q31(0.9895802049F),Q31(0.9896302502F),Q31(0.9896801217F),Q31(0.9897298196F),
+    Q31(0.9897793443F),Q31(0.9898286961F),Q31(0.9898778755F),Q31(0.9899268828F),
+    Q31(0.9899757183F),Q31(0.9900243823F),Q31(0.9900728753F),Q31(0.9901211976F),
+    Q31(0.9901693495F),Q31(0.9902173314F),Q31(0.9902651436F),Q31(0.9903127865F),
+    Q31(0.9903602605F),Q31(0.9904075659F),Q31(0.9904547031F),Q31(0.9905016723F),
+    Q31(0.9905484740F),Q31(0.9905951086F),Q31(0.9906415763F),Q31(0.9906878775F),
+    Q31(0.9907340126F),Q31(0.9907799819F),Q31(0.9908257858F),Q31(0.9908714247F),
+    Q31(0.9909168988F),Q31(0.9909622086F),Q31(0.9910073543F),Q31(0.9910523364F),
+    Q31(0.9910971552F),Q31(0.9911418110F),Q31(0.9911863042F),Q31(0.9912306351F),
+    Q31(0.9912748042F),Q31(0.9913188117F),Q31(0.9913626580F),Q31(0.9914063435F),
+    Q31(0.9914498684F),Q31(0.9914932333F),Q31(0.9915364383F),Q31(0.9915794839F),
+    Q31(0.9916223703F),Q31(0.9916650981F),Q31(0.9917076674F),Q31(0.9917500787F),
+    Q31(0.9917923323F),Q31(0.9918344286F),Q31(0.9918763679F),Q31(0.9919181505F),
+    Q31(0.9919597769F),Q31(0.9920012473F),Q31(0.9920425621F),Q31(0.9920837217F),
+    Q31(0.9921247263F),Q31(0.9921655765F),Q31(0.9922062724F),Q31(0.9922468145F),
+    Q31(0.9922872030F),Q31(0.9923274385F),Q31(0.9923675211F),Q31(0.9924074513F),
+    Q31(0.9924472294F),Q31(0.9924868557F),Q31(0.9925263306F),Q31(0.9925656544F),
+    Q31(0.9926048275F),Q31(0.9926438503F),Q31(0.9926827230F),Q31(0.9927214461F),
+    Q31(0.9927600199F),Q31(0.9927984446F),Q31(0.9928367208F),Q31(0.9928748486F),
+    Q31(0.9929128285F),Q31(0.9929506608F),Q31(0.9929883459F),Q31(0.9930258841F),
+    Q31(0.9930632757F),Q31(0.9931005211F),Q31(0.9931376207F),Q31(0.9931745747F),
+    Q31(0.9932113836F),Q31(0.9932480476F),Q31(0.9932845671F),Q31(0.9933209425F),
+    Q31(0.9933571742F),Q31(0.9933932623F),Q31(0.9934292074F),Q31(0.9934650097F),
+    Q31(0.9935006696F),Q31(0.9935361874F),Q31(0.9935715635F),Q31(0.9936067982F),
+    Q31(0.9936418919F),Q31(0.9936768448F),Q31(0.9937116574F),Q31(0.9937463300F),
+    Q31(0.9937808629F),Q31(0.9938152565F),Q31(0.9938495111F),Q31(0.9938836271F),
+    Q31(0.9939176047F),Q31(0.9939514444F),Q31(0.9939851465F),Q31(0.9940187112F),
+    Q31(0.9940521391F),Q31(0.9940854303F),Q31(0.9941185853F),Q31(0.9941516044F),
+    Q31(0.9941844879F),Q31(0.9942172361F),Q31(0.9942498495F),Q31(0.9942823283F),
+    Q31(0.9943146729F),Q31(0.9943468836F),Q31(0.9943789608F),Q31(0.9944109047F),
+    Q31(0.9944427158F),Q31(0.9944743944F),Q31(0.9945059408F),Q31(0.9945373553F),
+    Q31(0.9945686384F),Q31(0.9945997902F),Q31(0.9946308112F),Q31(0.9946617017F),
+    Q31(0.9946924621F),Q31(0.9947230926F),Q31(0.9947535937F),Q31(0.9947839656F),
+    Q31(0.9948142086F),Q31(0.9948443232F),Q31(0.9948743097F),Q31(0.9949041683F),
+    Q31(0.9949338995F),Q31(0.9949635035F),Q31(0.9949929807F),Q31(0.9950223315F),
+    Q31(0.9950515561F),Q31(0.9950806549F),Q31(0.9951096282F),Q31(0.9951384764F),
+    Q31(0.9951671998F),Q31(0.9951957987F),Q31(0.9952242735F),Q31(0.9952526245F),
+    Q31(0.9952808520F),Q31(0.9953089564F),Q31(0.9953369380F),Q31(0.9953647971F),
+    Q31(0.9953925340F),Q31(0.9954201491F),Q31(0.9954476428F),Q31(0.9954750153F),
+    Q31(0.9955022670F),Q31(0.9955293981F),Q31(0.9955564092F),Q31(0.9955833003F),
+    Q31(0.9956100720F),Q31(0.9956367245F),Q31(0.9956632582F),Q31(0.9956896733F),
+    Q31(0.9957159703F),Q31(0.9957421494F),Q31(0.9957682110F),Q31(0.9957941553F),
+    Q31(0.9958199828F),Q31(0.9958456937F),Q31(0.9958712884F),Q31(0.9958967672F),
+    Q31(0.9959221305F),Q31(0.9959473784F),Q31(0.9959725115F),Q31(0.9959975300F),
+    Q31(0.9960224342F),Q31(0.9960472244F),Q31(0.9960719011F),Q31(0.9960964644F),
+    Q31(0.9961209148F),Q31(0.9961452525F),Q31(0.9961694779F),Q31(0.9961935913F),
+    Q31(0.9962175930F),Q31(0.9962414834F),Q31(0.9962652627F),Q31(0.9962889313F),
+    Q31(0.9963124895F),Q31(0.9963359377F),Q31(0.9963592761F),Q31(0.9963825051F),
+    Q31(0.9964056250F),Q31(0.9964286361F),Q31(0.9964515387F),Q31(0.9964743332F),
+    Q31(0.9964970198F),Q31(0.9965195990F),Q31(0.9965420709F),Q31(0.9965644360F),
+    Q31(0.9965866946F),Q31(0.9966088469F),Q31(0.9966308932F),Q31(0.9966528340F),
+    Q31(0.9966746695F),Q31(0.9966964001F),Q31(0.9967180260F),Q31(0.9967395475F),
+    Q31(0.9967609651F),Q31(0.9967822789F),Q31(0.9968034894F),Q31(0.9968245968F),
+    Q31(0.9968456014F),Q31(0.9968665036F),Q31(0.9968873037F),Q31(0.9969080019F),
+    Q31(0.9969285987F),Q31(0.9969490942F),Q31(0.9969694889F),Q31(0.9969897830F),
+    Q31(0.9970099769F),Q31(0.9970300708F),Q31(0.9970500651F),Q31(0.9970699601F),
+    Q31(0.9970897561F),Q31(0.9971094533F),Q31(0.9971290522F),Q31(0.9971485531F),
+    Q31(0.9971679561F),Q31(0.9971872617F),Q31(0.9972064702F),Q31(0.9972255818F),
+    Q31(0.9972445968F),Q31(0.9972635157F),Q31(0.9972823386F),Q31(0.9973010659F),
+    Q31(0.9973196980F),Q31(0.9973382350F),Q31(0.9973566773F),Q31(0.9973750253F),
+    Q31(0.9973932791F),Q31(0.9974114392F),Q31(0.9974295059F),Q31(0.9974474793F),
+    Q31(0.9974653599F),Q31(0.9974831480F),Q31(0.9975008438F),Q31(0.9975184476F),
+    Q31(0.9975359598F),Q31(0.9975533806F),Q31(0.9975707104F),Q31(0.9975879495F),
+    Q31(0.9976050981F),Q31(0.9976221566F),Q31(0.9976391252F),Q31(0.9976560043F),
+    Q31(0.9976727941F),Q31(0.9976894950F),Q31(0.9977061073F),Q31(0.9977226312F),
+    Q31(0.9977390671F),Q31(0.9977554152F),Q31(0.9977716759F),Q31(0.9977878495F),
+    Q31(0.9978039361F),Q31(0.9978199363F),Q31(0.9978358501F),Q31(0.9978516780F),
+    Q31(0.9978674202F),Q31(0.9978830771F),Q31(0.9978986488F),Q31(0.9979141358F),
+    Q31(0.9979295383F),Q31(0.9979448566F),Q31(0.9979600909F),Q31(0.9979752417F),
+    Q31(0.9979903091F),Q31(0.9980052936F),Q31(0.9980201952F),Q31(0.9980350145F),
+    Q31(0.9980497515F),Q31(0.9980644067F),Q31(0.9980789804F),Q31(0.9980934727F),
+    Q31(0.9981078841F),Q31(0.9981222147F),Q31(0.9981364649F),Q31(0.9981506350F),
+    Q31(0.9981647253F),Q31(0.9981787360F),Q31(0.9981926674F),Q31(0.9982065199F),
+    Q31(0.9982202936F),Q31(0.9982339890F),Q31(0.9982476062F),Q31(0.9982611456F),
+    Q31(0.9982746074F),Q31(0.9982879920F),Q31(0.9983012996F),Q31(0.9983145304F),
+    Q31(0.9983276849F),Q31(0.9983407632F),Q31(0.9983537657F),Q31(0.9983666926F),
+    Q31(0.9983795442F),Q31(0.9983923208F),Q31(0.9984050226F),Q31(0.9984176501F),
+    Q31(0.9984302033F),Q31(0.9984426827F),Q31(0.9984550884F),Q31(0.9984674208F),
+    Q31(0.9984796802F),Q31(0.9984918667F),Q31(0.9985039808F),Q31(0.9985160227F),
+    Q31(0.9985279926F),Q31(0.9985398909F),Q31(0.9985517177F),Q31(0.9985634734F),
+    Q31(0.9985751583F),Q31(0.9985867727F),Q31(0.9985983167F),Q31(0.9986097907F),
+    Q31(0.9986211949F),Q31(0.9986325297F),Q31(0.9986437953F),Q31(0.9986549919F),
+    Q31(0.9986661199F),Q31(0.9986771795F),Q31(0.9986881710F),Q31(0.9986990946F),
+    Q31(0.9987099507F),Q31(0.9987207394F),Q31(0.9987314611F),Q31(0.9987421161F),
+    Q31(0.9987527045F),Q31(0.9987632267F),Q31(0.9987736829F),Q31(0.9987840734F),
+    Q31(0.9987943985F),Q31(0.9988046584F),Q31(0.9988148534F),Q31(0.9988249838F),
+    Q31(0.9988350498F),Q31(0.9988450516F),Q31(0.9988549897F),Q31(0.9988648641F),
+    Q31(0.9988746753F),Q31(0.9988844233F),Q31(0.9988941086F),Q31(0.9989037313F),
+    Q31(0.9989132918F),Q31(0.9989227902F),Q31(0.9989322269F),Q31(0.9989416021F),
+    Q31(0.9989509160F),Q31(0.9989601690F),Q31(0.9989693613F),Q31(0.9989784931F),
+    Q31(0.9989875647F),Q31(0.9989965763F),Q31(0.9990055283F),Q31(0.9990144208F),
+    Q31(0.9990232541F),Q31(0.9990320286F),Q31(0.9990407443F),Q31(0.9990494016F),
+    Q31(0.9990580008F),Q31(0.9990665421F),Q31(0.9990750257F),Q31(0.9990834519F),
+    Q31(0.9990918209F),Q31(0.9991001331F),Q31(0.9991083886F),Q31(0.9991165877F),
+    Q31(0.9991247307F),Q31(0.9991328177F),Q31(0.9991408491F),Q31(0.9991488251F),
+    Q31(0.9991567460F),Q31(0.9991646119F),Q31(0.9991724232F),Q31(0.9991801801F),
+    Q31(0.9991878828F),Q31(0.9991955316F),Q31(0.9992031267F),Q31(0.9992106684F),
+    Q31(0.9992181569F),Q31(0.9992255925F),Q31(0.9992329753F),Q31(0.9992403057F),
+    Q31(0.9992475839F),Q31(0.9992548101F),Q31(0.9992619846F),Q31(0.9992691076F),
+    Q31(0.9992761793F),Q31(0.9992832001F),Q31(0.9992901701F),Q31(0.9992970895F),
+    Q31(0.9993039587F),Q31(0.9993107777F),Q31(0.9993175470F),Q31(0.9993242667F),
+    Q31(0.9993309371F),Q31(0.9993375583F),Q31(0.9993441307F),Q31(0.9993506545F),
+    Q31(0.9993571298F),Q31(0.9993635570F),Q31(0.9993699362F),Q31(0.9993762678F),
+    Q31(0.9993825519F),Q31(0.9993887887F),Q31(0.9993949785F),Q31(0.9994011216F),
+    Q31(0.9994072181F),Q31(0.9994132683F),Q31(0.9994192725F),Q31(0.9994252307F),
+    Q31(0.9994311434F),Q31(0.9994370107F),Q31(0.9994428327F),Q31(0.9994486099F),
+    Q31(0.9994543423F),Q31(0.9994600303F),Q31(0.9994656739F),Q31(0.9994712736F),
+    Q31(0.9994768294F),Q31(0.9994823417F),Q31(0.9994878105F),Q31(0.9994932363F),
+    Q31(0.9994986191F),Q31(0.9995039592F),Q31(0.9995092568F),Q31(0.9995145122F),
+    Q31(0.9995197256F),Q31(0.9995248971F),Q31(0.9995300270F),Q31(0.9995351156F),
+    Q31(0.9995401630F),Q31(0.9995451695F),Q31(0.9995501352F),Q31(0.9995550604F),
+    Q31(0.9995599454F),Q31(0.9995647903F),Q31(0.9995695953F),Q31(0.9995743607F),
+    Q31(0.9995790866F),Q31(0.9995837734F),Q31(0.9995884211F),Q31(0.9995930300F),
+    Q31(0.9995976004F),Q31(0.9996021324F),Q31(0.9996066263F),Q31(0.9996110822F),
+    Q31(0.9996155004F),Q31(0.9996198810F),Q31(0.9996242244F),Q31(0.9996285306F),
+    Q31(0.9996327999F),Q31(0.9996370326F),Q31(0.9996412287F),Q31(0.9996453886F),
+    Q31(0.9996495125F),Q31(0.9996536004F),Q31(0.9996576527F),Q31(0.9996616696F),
+    Q31(0.9996656512F),Q31(0.9996695977F),Q31(0.9996735094F),Q31(0.9996773865F),
+    Q31(0.9996812291F),Q31(0.9996850374F),Q31(0.9996888118F),Q31(0.9996925523F),
+    Q31(0.9996962591F),Q31(0.9996999325F),Q31(0.9997035727F),Q31(0.9997071798F),
+    Q31(0.9997107541F),Q31(0.9997142957F),Q31(0.9997178049F),Q31(0.9997212818F),
+    Q31(0.9997247266F),Q31(0.9997281396F),Q31(0.9997315209F),Q31(0.9997348708F),
+    Q31(0.9997381893F),Q31(0.9997414767F),Q31(0.9997447333F),Q31(0.9997479591F),
+    Q31(0.9997511544F),Q31(0.9997543194F),Q31(0.9997574542F),Q31(0.9997605591F),
+    Q31(0.9997636342F),Q31(0.9997666797F),Q31(0.9997696958F),Q31(0.9997726828F),
+    Q31(0.9997756407F),Q31(0.9997785698F),Q31(0.9997814703F),Q31(0.9997843423F),
+    Q31(0.9997871860F),Q31(0.9997900016F),Q31(0.9997927894F),Q31(0.9997955494F),
+    Q31(0.9997982818F),Q31(0.9998009869F),Q31(0.9998036648F),Q31(0.9998063157F),
+    Q31(0.9998089398F),Q31(0.9998115373F),Q31(0.9998141082F),Q31(0.9998166529F),
+    Q31(0.9998191715F),Q31(0.9998216642F),Q31(0.9998241311F),Q31(0.9998265724F),
+    Q31(0.9998289884F),Q31(0.9998313790F),Q31(0.9998337447F),Q31(0.9998360854F),
+    Q31(0.9998384015F),Q31(0.9998406930F),Q31(0.9998429602F),Q31(0.9998452031F),
+    Q31(0.9998474221F),Q31(0.9998496171F),Q31(0.9998517885F),Q31(0.9998539364F),
+    Q31(0.9998560610F),Q31(0.9998581624F),Q31(0.9998602407F),Q31(0.9998622962F),
+    Q31(0.9998643291F),Q31(0.9998663394F),Q31(0.9998683274F),Q31(0.9998702932F),
+    Q31(0.9998722370F),Q31(0.9998741589F),Q31(0.9998760591F),Q31(0.9998779378F),
+    Q31(0.9998797952F),Q31(0.9998816313F),Q31(0.9998834464F),Q31(0.9998852406F),
+    Q31(0.9998870141F),Q31(0.9998887670F),Q31(0.9998904995F),Q31(0.9998922117F),
+    Q31(0.9998939039F),Q31(0.9998955761F),Q31(0.9998972285F),Q31(0.9998988613F),
+    Q31(0.9999004746F),Q31(0.9999020686F),Q31(0.9999036434F),Q31(0.9999051992F),
+    Q31(0.9999067362F),Q31(0.9999082544F),Q31(0.9999097541F),Q31(0.9999112354F),
+    Q31(0.9999126984F),Q31(0.9999141433F),Q31(0.9999155703F),Q31(0.9999169794F),
+    Q31(0.9999183709F),Q31(0.9999197449F),Q31(0.9999211014F),Q31(0.9999224408F),
+    Q31(0.9999237631F),Q31(0.9999250684F),Q31(0.9999263570F),Q31(0.9999276289F),
+    Q31(0.9999288843F),Q31(0.9999301233F),Q31(0.9999313461F),Q31(0.9999325529F),
+    Q31(0.9999337437F),Q31(0.9999349187F),Q31(0.9999360780F),Q31(0.9999372218F),
+    Q31(0.9999383503F),Q31(0.9999394635F),Q31(0.9999405616F),Q31(0.9999416447F),
+    Q31(0.9999427129F),Q31(0.9999437665F),Q31(0.9999448055F),Q31(0.9999458301F),
+    Q31(0.9999468404F),Q31(0.9999478365F),Q31(0.9999488185F),Q31(0.9999497867F),
+    Q31(0.9999507411F),Q31(0.9999516819F),Q31(0.9999526091F),Q31(0.9999535230F),
+    Q31(0.9999544236F),Q31(0.9999553111F),Q31(0.9999561856F),Q31(0.9999570472F),
+    Q31(0.9999578960F),Q31(0.9999587323F),Q31(0.9999595560F),Q31(0.9999603674F),
+    Q31(0.9999611666F),Q31(0.9999619536F),Q31(0.9999627286F),Q31(0.9999634917F),
+    Q31(0.9999642431F),Q31(0.9999649828F),Q31(0.9999657110F),Q31(0.9999664278F),
+    Q31(0.9999671334F),Q31(0.9999678278F),Q31(0.9999685111F),Q31(0.9999691835F),
+    Q31(0.9999698451F),Q31(0.9999704960F),Q31(0.9999711364F),Q31(0.9999717662F),
+    Q31(0.9999723858F),Q31(0.9999729950F),Q31(0.9999735942F),Q31(0.9999741834F),
+    Q31(0.9999747626F),Q31(0.9999753321F),Q31(0.9999758919F),Q31(0.9999764421F),
+    Q31(0.9999769828F),Q31(0.9999775143F),Q31(0.9999780364F),Q31(0.9999785495F),
+    Q31(0.9999790535F),Q31(0.9999795485F),Q31(0.9999800348F),Q31(0.9999805124F),
+    Q31(0.9999809813F),Q31(0.9999814417F),Q31(0.9999818938F),Q31(0.9999823375F),
+    Q31(0.9999827731F),Q31(0.9999832005F),Q31(0.9999836200F),Q31(0.9999840316F),
+    Q31(0.9999844353F),Q31(0.9999848314F),Q31(0.9999852199F),Q31(0.9999856008F),
+    Q31(0.9999859744F),Q31(0.9999863407F),Q31(0.9999866997F),Q31(0.9999870516F),
+    Q31(0.9999873965F),Q31(0.9999877345F),Q31(0.9999880656F),Q31(0.9999883900F),
+    Q31(0.9999887078F),Q31(0.9999890190F),Q31(0.9999893237F),Q31(0.9999896220F),
+    Q31(0.9999899140F),Q31(0.9999901999F),Q31(0.9999904796F),Q31(0.9999907533F),
+    Q31(0.9999910211F),Q31(0.9999912830F),Q31(0.9999915391F),Q31(0.9999917896F),
+    Q31(0.9999920345F),Q31(0.9999922738F),Q31(0.9999925077F),Q31(0.9999927363F),
+    Q31(0.9999929596F),Q31(0.9999931777F),Q31(0.9999933907F),Q31(0.9999935987F),
+    Q31(0.9999938018F),Q31(0.9999940000F),Q31(0.9999941934F),Q31(0.9999943820F),
+    Q31(0.9999945661F),Q31(0.9999947456F),Q31(0.9999949206F),Q31(0.9999950912F),
+    Q31(0.9999952575F),Q31(0.9999954195F),Q31(0.9999955773F),Q31(0.9999957311F),
+    Q31(0.9999958807F),Q31(0.9999960265F),Q31(0.9999961683F),Q31(0.9999963063F),
+    Q31(0.9999964405F),Q31(0.9999965710F),Q31(0.9999966979F),Q31(0.9999968213F),
+    Q31(0.9999969412F),Q31(0.9999970576F),Q31(0.9999971707F),Q31(0.9999972805F),
+    Q31(0.9999973871F),Q31(0.9999974905F),Q31(0.9999975909F),Q31(0.9999976881F),
+    Q31(0.9999977824F),Q31(0.9999978738F),Q31(0.9999979624F),Q31(0.9999980481F),
+    Q31(0.9999981311F),Q31(0.9999982115F),Q31(0.9999982892F),Q31(0.9999983644F),
+    Q31(0.9999984370F),Q31(0.9999985072F),Q31(0.9999985750F),Q31(0.9999986405F),
+    Q31(0.9999987037F),Q31(0.9999987647F),Q31(0.9999988235F),Q31(0.9999988802F),
+    Q31(0.9999989348F),Q31(0.9999989873F),Q31(0.9999990379F),Q31(0.9999990866F),
+    Q31(0.9999991334F),Q31(0.9999991784F),Q31(0.9999992217F),Q31(0.9999992632F),
+    Q31(0.9999993030F),Q31(0.9999993411F),Q31(0.9999993777F),Q31(0.9999994128F),
+    Q31(0.9999994463F),Q31(0.9999994784F),Q31(0.9999995091F),Q31(0.9999995384F),
+    Q31(0.9999995663F),Q31(0.9999995930F),Q31(0.9999996184F),Q31(0.9999996426F),
+    Q31(0.9999996657F),Q31(0.9999996876F),Q31(0.9999997084F),Q31(0.9999997282F),
+    Q31(0.9999997469F),Q31(0.9999997647F),Q31(0.9999997815F),Q31(0.9999997973F),
+    Q31(0.9999998123F),Q31(0.9999998265F),Q31(0.9999998398F),Q31(0.9999998524F),
+    Q31(0.9999998642F),Q31(0.9999998753F),Q31(0.9999998857F),Q31(0.9999998954F),
+    Q31(0.9999999045F),Q31(0.9999999130F),Q31(0.9999999209F),Q31(0.9999999282F),
+    Q31(0.9999999351F),Q31(0.9999999414F),Q31(0.9999999472F),Q31(0.9999999526F),
+    Q31(0.9999999576F),Q31(0.9999999622F),Q31(0.9999999664F),Q31(0.9999999702F),
+    Q31(0.9999999737F),Q31(0.9999999769F),Q31(0.9999999798F),Q31(0.9999999824F),
+    Q31(0.9999999847F),Q31(0.9999999868F),Q31(0.9999999887F),Q31(0.9999999904F),
+    Q31(0.9999999919F),Q31(0.9999999932F),Q31(0.9999999943F),Q31(0.9999999953F),
+    Q31(0.9999999961F),Q31(0.9999999969F),Q31(0.9999999975F),Q31(0.9999999980F),
+    Q31(0.9999999985F),Q31(0.9999999988F),Q31(0.9999999991F),Q31(0.9999999993F),
+    Q31(0.9999999995F),Q31(0.9999999997F),Q31(0.9999999998F),Q31(0.9999999999F),
+    Q31(0.9999999999F),Q31(1.0000000000F),Q31(1.0000000000F),Q31(1.0000000000F),
+    Q31(1.0000000000F),Q31(1.0000000000F),Q31(1.0000000000F),Q31(1.0000000000F),
 };
 
-const float ff_vorbis_floor1_inverse_db_table[256]={
-    1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
-    1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
-    1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
-    2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
-    2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
-    3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
-    4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
-    6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
-    7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
-    1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
-    1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
-    1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
-    2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
-    2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
-    3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
-    4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
-    5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
-    7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
-    9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
-    1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
-    1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
-    2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
-    2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
-    3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
-    4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
-    5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
-    7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
-    9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
-    0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
-    0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
-    0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
-    0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
-    0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
-    0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
-    0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
-    0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
-    0.00092223983F, 0.00098217216F, 0.0010459992F,  0.0011139742F,
-    0.0011863665F,  0.0012634633F,  0.0013455702F,  0.0014330129F,
-    0.0015261382F,  0.0016253153F,  0.0017309374F,  0.0018434235F,
-    0.0019632195F,  0.0020908006F,  0.0022266726F,  0.0023713743F,
-    0.0025254795F,  0.0026895994F,  0.0028643847F,  0.0030505286F,
-    0.0032487691F,  0.0034598925F,  0.0036847358F,  0.0039241906F,
-    0.0041792066F,  0.0044507950F,  0.0047400328F,  0.0050480668F,
-    0.0053761186F,  0.0057254891F,  0.0060975636F,  0.0064938176F,
-    0.0069158225F,  0.0073652516F,  0.0078438871F,  0.0083536271F,
-    0.0088964928F,  0.009474637F,   0.010090352F,   0.010746080F,
-    0.011444421F,   0.012188144F,   0.012980198F,   0.013823725F,
-    0.014722068F,   0.015678791F,   0.016697687F,   0.017782797F,
-    0.018938423F,   0.020169149F,   0.021479854F,   0.022875735F,
-    0.024362330F,   0.025945531F,   0.027631618F,   0.029427276F,
-    0.031339626F,   0.033376252F,   0.035545228F,   0.037855157F,
-    0.040315199F,   0.042935108F,   0.045725273F,   0.048696758F,
-    0.051861348F,   0.055231591F,   0.058820850F,   0.062643361F,
-    0.066714279F,   0.071049749F,   0.075666962F,   0.080584227F,
-    0.085821044F,   0.091398179F,   0.097337747F,   0.10366330F,
-    0.11039993F,    0.11757434F,    0.12521498F,    0.13335215F,
-    0.14201813F,    0.15124727F,    0.16107617F,    0.17154380F,
-    0.18269168F,    0.19456402F,    0.20720788F,    0.22067342F,
-    0.23501402F,    0.25028656F,    0.26655159F,    0.28387361F,
-    0.30232132F,    0.32196786F,    0.34289114F,    0.36517414F,
-    0.38890521F,    0.41417847F,    0.44109412F,    0.46975890F,
-    0.50028648F,    0.53279791F,    0.56742212F,    0.60429640F,
-    0.64356699F,    0.68538959F,    0.72993007F,    0.77736504F,
-    0.82788260F,    0.88168307F,    0.9389798F,     1.F,
+const INTFLOAT ff_vorbis_floor1_inverse_db_table[256]={
+   Q31(1.0649863e-07F),Q31(1.1341951e-07F),Q31(1.2079015e-07F),Q31(1.2863978e-07F),
+   Q31(1.3699951e-07F),Q31(1.4590251e-07F),Q31(1.5538408e-07F),Q31(1.6548181e-07F),
+   Q31(1.7623575e-07F),Q31(1.8768855e-07F),Q31(1.9988561e-07F),Q31(2.128753e-07F ),
+   Q31(2.2670913e-07F),Q31(2.4144197e-07F),Q31(2.5713223e-07F),Q31(2.7384213e-07F),
+   Q31(2.9163793e-07F),Q31(3.1059021e-07F),Q31(3.3077411e-07F),Q31(3.5226968e-07F),
+   Q31(3.7516214e-07F),Q31(3.9954229e-07F),Q31(4.2550680e-07F),Q31(4.5315863e-07F),
+   Q31(4.8260743e-07F),Q31(5.1396998e-07F),Q31(5.4737065e-07F),Q31(5.8294187e-07F),
+   Q31(6.2082472e-07F),Q31(6.6116941e-07F),Q31(7.0413592e-07F),Q31(7.4989464e-07F),
+   Q31(7.9862701e-07F),Q31(8.5052630e-07F),Q31(9.0579828e-07F),Q31(9.6466216e-07F),
+   Q31(1.0273513e-06F),Q31(1.0941144e-06F),Q31(1.1652161e-06F),Q31(1.2409384e-06F),
+   Q31(1.3215816e-06F),Q31(1.4074654e-06F),Q31(1.4989305e-06F),Q31(1.5963394e-06F),
+   Q31(1.7000785e-06F),Q31(1.8105592e-06F),Q31(1.9282195e-06F),Q31(2.0535261e-06F),
+   Q31(2.1869758e-06F),Q31(2.3290978e-06F),Q31(2.4804557e-06F),Q31(2.6416497e-06F),
+   Q31(2.8133190e-06F),Q31(2.9961443e-06F),Q31(3.1908506e-06F),Q31(3.3982101e-06F),
+   Q31(3.6190449e-06F),Q31(3.8542308e-06F),Q31(4.1047004e-06F),Q31(4.3714470e-06F),
+   Q31(4.6555282e-06F),Q31(4.9580707e-06F),Q31(5.2802740e-06F),Q31(5.6234160e-06F),
+   Q31(5.9888572e-06F),Q31(6.3780469e-06F),Q31(6.7925283e-06F),Q31(7.2339451e-06F),
+   Q31(7.7040476e-06F),Q31(8.2047000e-06F),Q31(8.7378876e-06F),Q31(9.3057248e-06F),
+   Q31(9.9104632e-06F),Q31(1.0554501e-05F),Q31(1.1240392e-05F),Q31(1.1970856e-05F),
+   Q31(1.2748789e-05F),Q31(1.3577278e-05F),Q31(1.4459606e-05F),Q31(1.5399272e-05F),
+   Q31(1.6400004e-05F),Q31(1.7465768e-05F),Q31(1.8600792e-05F),Q31(1.9809576e-05F),
+   Q31(2.1096914e-05F),Q31(2.2467911e-05F),Q31(2.3928002e-05F),Q31(2.5482978e-05F),
+   Q31(2.7139006e-05F),Q31(2.8902651e-05F),Q31(3.0780908e-05F),Q31(3.2781225e-05F),
+   Q31(3.4911534e-05F),Q31(3.7180282e-05F),Q31(3.9596466e-05F),Q31(4.2169667e-05F),
+   Q31(4.4910090e-05F),Q31(4.7828601e-05F),Q31(5.0936773e-05F),Q31(5.4246931e-05F),
+   Q31(5.7772202e-05F),Q31(6.1526565e-05F),Q31(6.5524908e-05F),Q31(6.9783085e-05F),
+   Q31(7.4317983e-05F),Q31(7.9147585e-05F),Q31(8.4291040e-05F),Q31(8.9768747e-05F),
+   Q31(9.5602426e-05F),Q31(0.00010181521F),Q31(0.00010843174F),Q31(0.00011547824F),
+   Q31(0.00012298267F),Q31(0.00013097477F),Q31(0.00013948625F),Q31(0.00014855085F),
+   Q31(0.00015820453F),Q31(0.00016848555F),Q31(0.00017943469F),Q31(0.00019109536F),
+   Q31(0.00020351382F),Q31(0.00021673929F),Q31(0.00023082423F),Q31(0.00024582449F),
+   Q31(0.00026179955F),Q31(0.00027881276F),Q31(0.00029693158F),Q31(0.00031622787F),
+   Q31(0.00033677814F),Q31(0.00035866388F),Q31(0.00038197188F),Q31(0.00040679456F),
+   Q31(0.00043323036F),Q31(0.00046138411F),Q31(0.00049136745F),Q31(0.00052329927F),
+   Q31(0.00055730621F),Q31(0.00059352311F),Q31(0.00063209358F),Q31(0.00067317058F),
+   Q31(0.00071691700F),Q31(0.00076350630F),Q31(0.00081312324F),Q31(0.00086596457F),
+   Q31(0.00092223983F),Q31(0.00098217216F),Q31(0.0010459992F),Q31(0.0011139742F),
+   Q31(0.0011863665F),Q31(0.0012634633F),Q31(0.0013455702F),Q31(0.0014330129F),
+   Q31(0.0015261382F),Q31(0.0016253153F),Q31(0.0017309374F),Q31(0.0018434235F),
+   Q31(0.0019632195F),Q31(0.0020908006F),Q31(0.0022266726F),Q31(0.0023713743F),
+   Q31(0.0025254795F),Q31(0.0026895994F),Q31(0.0028643847F),Q31(0.0030505286F),
+   Q31(0.0032487691F),Q31(0.0034598925F),Q31(0.0036847358F),Q31(0.0039241906F),
+   Q31(0.0041792066F),Q31(0.0044507950F),Q31(0.0047400328F),Q31(0.0050480668F),
+   Q31(0.0053761186F),Q31(0.0057254891F),Q31(0.0060975636F),Q31(0.0064938176F),
+   Q31(0.0069158225F),Q31(0.0073652516F),Q31(0.0078438871F),Q31(0.0083536271F),
+   Q31(0.0088964928F),Q31(0.009474637F),Q31(0.010090352F),Q31(0.010746080F),
+   Q31(0.011444421F),Q31(0.012188144F),Q31(0.012980198F),Q31(0.013823725F),
+   Q31(0.014722068F),Q31(0.015678791F),Q31(0.016697687F),Q31(0.017782797F),
+   Q31(0.018938423F),Q31(0.020169149F),Q31(0.021479854F),Q31(0.022875735F),
+   Q31(0.024362330F),Q31(0.025945531F),Q31(0.027631618F),Q31(0.029427276F),
+   Q31(0.031339626F),Q31(0.033376252F),Q31(0.035545228F),Q31(0.037855157F),
+   Q31(0.040315199F),Q31(0.042935108F),Q31(0.045725273F),Q31(0.048696758F),
+   Q31(0.051861348F),Q31(0.055231591F),Q31(0.058820850F),Q31(0.062643361F),
+   Q31(0.066714279F),Q31(0.071049749F),Q31(0.075666962F),Q31(0.080584227F),
+   Q31(0.085821044F),Q31(0.091398179F),Q31(0.097337747F),Q31(0.10366330F),
+   Q31(0.11039993F),Q31(0.11757434F),Q31(0.12521498F),Q31(0.13335215F),
+   Q31(0.14201813F),Q31(0.15124727F),Q31(0.16107617F),Q31(0.17154380F),
+   Q31(0.18269168F),Q31(0.19456402F),Q31(0.20720788F),Q31(0.22067342F),
+   Q31(0.23501402F),Q31(0.25028656F),Q31(0.26655159F),Q31(0.28387361F),
+   Q31(0.30232132F),Q31(0.32196786F),Q31(0.34289114F),Q31(0.36517414F),
+   Q31(0.38890521F),Q31(0.41417847F),Q31(0.44109412F),Q31(0.46975890F),
+   Q31(0.50028648F),Q31(0.53279791F),Q31(0.56742212F),Q31(0.60429640F),
+   Q31(0.64356699F),Q31(0.68538959F),Q31(0.72993007F),Q31(0.77736504F),
+   Q31(0.82788260F),Q31(0.88168307F),Q31(0.9389798F),Q31(1.F),       
 };
 
-const float * const ff_vorbis_vwin[8] = {
+const INTFLOAT * const ff_vorbis_vwin[8] = {
       vwin64,  vwin128,  vwin256,  vwin512,
     vwin1024, vwin2048, vwin4096, vwin8192
 };
diff -uNr ffmpeg-0.7.12/libavcodec/vorbisdec.c ffmpeg-0.7.12-140902/libavcodec/vorbisdec.c
--- ffmpeg-0.7.12/libavcodec/vorbisdec.c	2012-04-10 01:05:33.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/vorbisdec.c	2013-10-31 11:10:02.000000000 +0800
@@ -20,12 +20,20 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#define CONFIG_FFT_FLOAT 0
+#define CONFIG_FFT_FIXED_32 1
+#define CONFIG_VORBIS_FIXED 1
+#define CONFIG_FIXED 1
+
 #include <inttypes.h>
 #include <math.h>
 
 #define ALT_BITSTREAM_READER_LE
 #include "avcodec.h"
-#include "get_bits.h"
+
+#include "fixed_bitstream.h"//jh
+#include "fixed_dsp.h"
+
 #include "dsputil.h"
 #include "fft.h"
 #include "fmtconvert.h"
@@ -41,6 +49,11 @@
 #undef NDEBUG
 #include <assert.h>
 
+////
+#define ENTER() //av_log(NULL,AV_LOG_INFO,"%s:ENTER\n", __FUNCTION__)
+#define LEAVE() //av_log(NULL,AV_LOG_INFO,"%s:LEAVE\n", __FUNCTION__)
+//#define SHOW(x) av_log(NULL,AV_LOG_INFO,"%s\n", x)
+
 typedef struct {
     uint8_t      dimensions;
     uint8_t      lookup_type;
@@ -50,13 +63,14 @@
     unsigned int nb_bits;
 } vorbis_codebook;
 
+
 typedef union  vorbis_floor_u  vorbis_floor_data;
 typedef struct vorbis_floor0_s vorbis_floor0;
 typedef struct vorbis_floor1_s vorbis_floor1;
 struct vorbis_context_s;
 typedef
 int (* vorbis_floor_decode_func)
-    (struct vorbis_context_s *, vorbis_floor_data *, float *);
+    (struct vorbis_context_s *, vorbis_floor_data *, INTFLOAT *);
 typedef struct {
     uint8_t floor_type;
     vorbis_floor_decode_func decode;
@@ -121,6 +135,7 @@
     AVCodecContext *avccontext;
     GetBitContext gb;
     DSPContext dsp;
+    AVFixedDSPContext fdsp;
     FmtConvertContext fmt_conv;
 
     FFTContext mdct[2];
@@ -132,7 +147,7 @@
     uint32_t      bitrate_nominal;
     uint32_t      bitrate_minimum;
     uint32_t      blocksize[2];
-    const float  *win[2];
+    const INTFLOAT  *win[2];
     uint16_t      codebook_count;
     vorbis_codebook *codebooks;
     uint8_t       floor_count;
@@ -145,9 +160,9 @@
     vorbis_mode  *modes;
     uint8_t       mode_number; // mode number for the current packet
     uint8_t       previous_window;
-    float        *channel_residues;
-    float        *channel_floors;
-    float        *saved;
+    INTFLOAT        *channel_residues;
+    INTFLOAT        *channel_floors;
+    INTFLOAT        *saved;
     float         scale_bias; // for float->int conversion
 } vorbis_context;
 
@@ -170,13 +185,13 @@
         VALIDATE_INDEX(idx, limit)\
     }
 
-static float vorbisfloat2float(unsigned val)
+static INTFLOAT vorbisfloat2float(unsigned val)//?????????????????
 {
     double mant = val & 0x1fffff;
-    long exp    = (val & 0x7fe00000L) >> 21;
+    long exp    = (val & 0x7fe00000L) >> 21;          ENTER();
     if (val & 0x80000000)
-        mant = -mant;
-    return ldexp(mant, exp - 20 - 768);
+        mant = -mant;                     LEAVE();  
+    return ldexp(mant, exp - 20 - 768); 
 }
 
 
@@ -184,7 +199,7 @@
 
 static void vorbis_free(vorbis_context *vc)
 {
-    int i;
+    int i;     ENTER();
 
     av_freep(&vc->channel_residues);
     av_freep(&vc->channel_floors);
@@ -221,7 +236,7 @@
         av_free(vc->mappings[i].angle);
         av_free(vc->mappings[i].mux);
     }
-    av_freep(&vc->mappings);
+    av_freep(&vc->mappings);       LEAVE();
 }
 
 // Parse setup header -------------------------------------------------
@@ -234,7 +249,7 @@
     uint8_t  *tmp_vlc_bits;
     uint32_t *tmp_vlc_codes;
     GetBitContext *gb = &vc->gb;
-    uint16_t *codebook_multiplicands;
+    uint16_t *codebook_multiplicands;         ENTER();
 
     vc->codebook_count = get_bits(gb, 8) + 1;
 
@@ -341,11 +356,11 @@
             unsigned i, j, k;
             unsigned codebook_lookup_values = ff_vorbis_nth_root(entries, codebook_setup->dimensions);
 
-            float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32));
+            float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32));//?????????????????
             float codebook_delta_value   = vorbisfloat2float(get_bits_long(gb, 32));
             unsigned codebook_value_bits = get_bits(gb, 4) + 1;
             unsigned codebook_sequence_p = get_bits1(gb);
-
+                                                     //av_log(NULL,AV_LOG_INFO,"%d,%d==", codebook_minimum_value,codebook_delta_value);
             av_dlog(NULL, " We expect %d numbers for building the codevectors. \n",
                     codebook_lookup_values);
             av_dlog(NULL, "  delta %f minmum %f \n",
@@ -355,7 +370,7 @@
                 codebook_multiplicands[i] = get_bits(gb, codebook_value_bits);
 
                 av_dlog(NULL, " multiplicands*delta+minmum : %e \n",
-                        (float)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value);
+                        (INTFLOAT)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value);
                 av_dlog(NULL, " multiplicand %u\n", codebook_multiplicands[i]);
             }
 
@@ -368,7 +383,7 @@
                 unsigned dim = codebook_setup->dimensions;
 
                 if (tmp_vlc_bits[i]) {
-                    float last = 0.0;
+                    INTFLOAT last = 0.0;
                     unsigned lookup_offset = i;
 
                     av_dlog(vc->avccontext, "Lookup offset %u ,", i);
@@ -426,14 +441,14 @@
 
     av_free(tmp_vlc_bits);
     av_free(tmp_vlc_codes);
-    av_free(codebook_multiplicands);
+    av_free(codebook_multiplicands);   LEAVE();
     return 0;
 
 // Error:
 error:
     av_free(tmp_vlc_bits);
     av_free(tmp_vlc_codes);
-    av_free(codebook_multiplicands);
+    av_free(codebook_multiplicands);  LEAVE();
     return -1;
 }
 
@@ -442,7 +457,7 @@
 static int vorbis_parse_setup_hdr_tdtransforms(vorbis_context *vc)
 {
     GetBitContext *gb = &vc->gb;
-    unsigned i, vorbis_time_count = get_bits(gb, 6) + 1;
+    unsigned i, vorbis_time_count = get_bits(gb, 6) + 1;  ENTER();
 
     for (i = 0; i < vorbis_time_count; ++i) {
         unsigned vorbis_tdtransform = get_bits(gb, 16);
@@ -454,21 +469,21 @@
             av_log(vc->avccontext, AV_LOG_ERROR, "Vorbis time domain transform data nonzero. \n");
             return -1;
         }
-    }
+    }                LEAVE();
     return 0;
 }
 
 // Process floors part
 
 static int vorbis_floor0_decode(vorbis_context *vc,
-                                vorbis_floor_data *vfu, float *vec);
+                                vorbis_floor_data *vfu, INTFLOAT *vec);
 static void create_map(vorbis_context *vc, unsigned floor_number);
 static int vorbis_floor1_decode(vorbis_context *vc,
-                                vorbis_floor_data *vfu, float *vec);
+                                vorbis_floor_data *vfu, INTFLOAT *vec);
 static int vorbis_parse_setup_hdr_floors(vorbis_context *vc)
 {
     GetBitContext *gb = &vc->gb;
-    int i,j,k;
+    int i,j,k;                        ENTER();
 
     vc->floor_count = get_bits(gb, 6) + 1;
 
@@ -630,7 +645,7 @@
             av_log(vc->avccontext, AV_LOG_ERROR, "Invalid floor type!\n");
             return -1;
         }
-    }
+    }                  LEAVE();
     return 0;
 }
 
@@ -640,9 +655,9 @@
 {
     GetBitContext *gb = &vc->gb;
     unsigned i, j, k;
-
+ 
     vc->residue_count = get_bits(gb, 6)+1;
-    vc->residues      = av_mallocz(vc->residue_count * sizeof(*vc->residues));
+    vc->residues      = av_mallocz(vc->residue_count * sizeof(*vc->residues));   ENTER();
 
     av_dlog(NULL, " There are %d residues. \n", vc->residue_count);
 
@@ -710,7 +725,7 @@
                 }
             }
         }
-    }
+    }         LEAVE();
     return 0;
 }
 
@@ -722,7 +737,7 @@
     unsigned i, j;
 
     vc->mapping_count = get_bits(gb, 6)+1;
-    vc->mappings      = av_mallocz(vc->mapping_count * sizeof(*vc->mappings));
+    vc->mappings      = av_mallocz(vc->mapping_count * sizeof(*vc->mappings));  ENTER();
 
     av_dlog(NULL, " There are %d mappings. \n", vc->mapping_count);
 
@@ -777,11 +792,11 @@
                     mapping_setup->submap_floor[j],
                     mapping_setup->submap_residue[j]);
         }
-    }
+    }        LEAVE();
     return 0;
 }
 
-// Process modes part
+// Process modes part//?????????????????
 
 static void create_map(vorbis_context *vc, unsigned floor_number)
 {
@@ -789,7 +804,7 @@
     vorbis_floor0 *vf;
     int idx;
     int blockflag, n;
-    int32_t *map;
+    int32_t *map;              ENTER();
 
     for (blockflag = 0; blockflag < 2; ++blockflag) {
         n = vc->blocksize[blockflag] / 2;
@@ -812,7 +827,7 @@
 
     for (idx = 0; idx <= n; ++idx) {
         av_dlog(NULL, "floor0 map: map at pos %d is %d\n", idx, map[idx]);
-    }
+    }               LEAVE();
 }
 
 static int vorbis_parse_setup_hdr_modes(vorbis_context *vc)
@@ -821,7 +836,7 @@
     unsigned i;
 
     vc->mode_count = get_bits(gb, 6) + 1;
-    vc->modes      = av_mallocz(vc->mode_count * sizeof(*vc->modes));
+    vc->modes      = av_mallocz(vc->mode_count * sizeof(*vc->modes));    ENTER();
 
     av_dlog(NULL, " There are %d modes.\n", vc->mode_count);
 
@@ -836,7 +851,7 @@
         av_dlog(NULL, " %u mode: blockflag %d, windowtype %d, transformtype %d, mapping %d\n",
                 i, mode_setup->blockflag, mode_setup->windowtype,
                 mode_setup->transformtype, mode_setup->mapping);
-    }
+    }  LEAVE();
     return 0;
 }
 
@@ -844,7 +859,7 @@
 
 static int vorbis_parse_setup_hdr(vorbis_context *vc)
 {
-    GetBitContext *gb = &vc->gb;
+    GetBitContext *gb = &vc->gb;  ENTER();
 
     if ((get_bits(gb, 8) != 'v') || (get_bits(gb, 8) != 'o') ||
         (get_bits(gb, 8) != 'r') || (get_bits(gb, 8) != 'b') ||
@@ -880,7 +895,7 @@
     if (!get_bits1(gb)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (framing flag). \n");
         return -8; // framing flag bit unset error
-    }
+    }LEAVE();
 
     return 0;
 }
@@ -891,7 +906,7 @@
 {
     GetBitContext *gb = &vc->gb;
     unsigned bl0, bl1;
-
+   ENTER();
     if ((get_bits(gb, 8) != 'v') || (get_bits(gb, 8) != 'o') ||
         (get_bits(gb, 8) != 'r') || (get_bits(gb, 8) != 'b') ||
         (get_bits(gb, 8) != 'i') || (get_bits(gb, 8) != 's')) {
@@ -949,10 +964,10 @@
 /*
     BLK = vc->blocksize[0];
     for (i = 0; i < BLK / 2; ++i) {
-        vc->win[0][i] = sin(0.5*3.14159265358*(sin(((float)i + 0.5) / (float)BLK*3.14159265358))*(sin(((float)i + 0.5) / (float)BLK*3.14159265358)));
+        vc->win[0][i] = sin(0.5*3.14159265358*(sin(((INTFLOAT)i + 0.5) / (INTFLOAT)BLK*3.14159265358))*(sin(((INTFLOAT)i + 0.5) / (INTFLOAT)BLK*3.14159265358)));
     }
 */
-
+          LEAVE();
     return 0;
 }
 
@@ -968,16 +983,19 @@
     GetBitContext *gb = &(vc->gb);
     int hdr_type;
 
-    vc->avccontext = avccontext;
+    vc->avccontext = avccontext;            ENTER();
+
+    avpriv_fixed_dsp_init(&vc->fdsp, avccontext->flags & CODEC_FLAG_BITEXACT);//jh 0827
+
     dsputil_init(&vc->dsp, avccontext);
-    ff_fmt_convert_init(&vc->fmt_conv, avccontext);
+    ff_fmt_convert_init(&vc->fmt_conv, avccontext);//?????????????????
 
     if (avccontext->request_sample_fmt == AV_SAMPLE_FMT_FLT) {
         avccontext->sample_fmt = AV_SAMPLE_FMT_FLT;
         vc->scale_bias = 1.0f;
     } else {
         avccontext->sample_fmt = AV_SAMPLE_FMT_S16;
-        vc->scale_bias = 32768.0f;
+        vc->scale_bias = 1.0f;
     }
 
     if (!headers_len) {
@@ -1022,7 +1040,7 @@
 
     avccontext->channels    = vc->audio_channels;
     avccontext->sample_rate = vc->audio_samplerate;
-    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2;
+    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2; LEAVE();
 
     return 0 ;
 }
@@ -1032,12 +1050,12 @@
 // Read and decode floor
 
 static int vorbis_floor0_decode(vorbis_context *vc,
-                                vorbis_floor_data *vfu, float *vec)
+                                vorbis_floor_data *vfu, INTFLOAT *vec)
 {
     vorbis_floor0 *vf = &vfu->t0;
     float *lsp = vf->lsp;
     unsigned amplitude, book_idx;
-    unsigned blockflag = vc->modes[vc->mode_number].blockflag;
+    unsigned blockflag = vc->modes[vc->mode_number].blockflag;        ENTER();
 
     amplitude = get_bits(&vc->gb, vf->amplitude_bits);
     if (amplitude > 0) {
@@ -1123,22 +1141,22 @@
 
                 /* fill vector */
                 do {
-                    vec[i] = q; ++i;
+                    vec[i] = Q23(q);  ++i;//av_log(NULL,AV_LOG_INFO,"%f,", vec[i]);
                 } while (vf->map[blockflag][i] == iter_cond);
             }
         }
     } else {
-        /* this channel is unused */
+        /* this channel is unused   av_log(NULL,AV_LOG_INFO,"\ntttttttttttttttttttt\n");*/ 
         return 1;
     }
 
-    av_dlog(NULL, " Floor0 decoded\n");
+    av_dlog(NULL, " Floor0 decoded\n");  LEAVE();
 
     return 0;
 }
 
 static int vorbis_floor1_decode(vorbis_context *vc,
-                                vorbis_floor_data *vfu, float *vec)
+                                vorbis_floor_data *vfu, INTFLOAT *vec)//?????????????????
 {
     vorbis_floor1 *vf = &vfu->t1;
     GetBitContext *gb = &vc->gb;
@@ -1150,7 +1168,7 @@
     unsigned partition_class, cdim, cbits, csub, cval, offset, i, j;
     int book, adx, ady, dy, off, predicted, err;
 
-
+ENTER();
     if (!get_bits1(gb)) // silence
         return 1;
 
@@ -1255,8 +1273,11 @@
 // Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?
 
     ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);
+/*int ii;
+for(ii = 0; ii < 100;ii++ )
+    av_log(NULL,AV_LOG_INFO,"%d,",vec[ii]);*/
 
-    av_dlog(NULL, " Floor decoded\n");
+    av_dlog(NULL, " Floor decoded\n");       LEAVE();
 
     return 0;
 }
@@ -1267,7 +1288,7 @@
                                                            vorbis_residue *vr,
                                                            unsigned ch,
                                                            uint8_t *do_not_decode,
-                                                           float *vec,
+                                                           INTFLOAT *vec,
                                                            unsigned vlen,
                                                            unsigned ch_left,
                                                            int vr_type)
@@ -1277,7 +1298,7 @@
     unsigned ptns_to_read = vr->ptns_to_read;
     uint8_t *classifs = vr->classifs;
     unsigned pass, ch_used, i, j, k, l;
-    unsigned max_output = (ch - 1) * vlen;
+    unsigned max_output = (ch - 1) * vlen; ENTER();
 
     if (vr_type == 2) {
         for (j = 1; j < ch; ++j)
@@ -1346,14 +1367,14 @@
                                 for (k = 0; k < step; ++k) {
                                     coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;
                                     for (l = 0; l < dim; ++l)
-                                        vec[voffs + k + l * step] += codebook.codevectors[coffs + l];  // FPMATH
+                                        {vec[voffs + k + l * step] += Q23(codebook.codevectors[coffs + l]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs + k + l * step,vec[voffs + k + l * step]);*/} // FPMATH
                                 }
                             } else if (vr_type == 1) {
                                 voffs = voffset + j * vlen;
                                 for (k = 0; k < step; ++k) {
                                     coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;
                                     for (l = 0; l < dim; ++l, ++voffs) {
-                                        vec[voffs]+=codebook.codevectors[coffs+l];  // FPMATH
+                                       { vec[voffs]+=Q23(codebook.codevectors[coffs+l]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs,vec[voffs]);*/} // FPMATH
 
                                         av_dlog(NULL, " pass %d offs: %d curr: %f change: %f cv offs.: %d  \n",
                                                 pass, voffs, vec[voffs], codebook.codevectors[coffs+l], coffs);
@@ -1365,23 +1386,23 @@
                                 if (dim == 2) {
                                     for (k = 0; k < step; ++k) {
                                         coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 2;
-                                        vec[voffs + k       ] += codebook.codevectors[coffs    ];  // FPMATH
-                                        vec[voffs + k + vlen] += codebook.codevectors[coffs + 1];  // FPMATH
+                                        vec[voffs + k       ] += Q23(codebook.codevectors[coffs    ]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs + k,vec[voffs + k       ]);*/ // FPMATH
+                                        vec[voffs + k + vlen] += Q23(codebook.codevectors[coffs + 1]); /* av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs + k + vlen,vec[voffs + k + vlen]);*/// FPMATH
                                     }
                                 } else if (dim == 4) {
                                     for (k = 0; k < step; ++k, voffs += 2) {
                                         coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 4;
-                                        vec[voffs           ] += codebook.codevectors[coffs    ];  // FPMATH
-                                        vec[voffs + 1       ] += codebook.codevectors[coffs + 2];  // FPMATH
-                                        vec[voffs + vlen    ] += codebook.codevectors[coffs + 1];  // FPMATH
-                                        vec[voffs + vlen + 1] += codebook.codevectors[coffs + 3];  // FPMATH
+                                        vec[voffs           ] += Q23(codebook.codevectors[coffs    ]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs,vec[voffs]); */// FPMATH
+                                        vec[voffs + 1       ] += Q23(codebook.codevectors[coffs + 2]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs + 1,vec[voffs + 1       ]); */// FPMATH
+                                        vec[voffs + vlen    ] += Q23(codebook.codevectors[coffs + 1]);/* av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs + vlen,vec[voffs + vlen       ]);*/ // FPMATH
+                                        vec[voffs + vlen + 1] += Q23(codebook.codevectors[coffs + 3]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs + vlen+1,vec[voffs + vlen+1       ]);*/ // FPMATH
                                     }
                                 } else
                                 for (k = 0; k < step; ++k) {
                                     coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;
                                     for (l = 0; l < dim; l += 2, voffs++) {
-                                        vec[voffs       ] += codebook.codevectors[coffs + l    ];  // FPMATH
-                                        vec[voffs + vlen] += codebook.codevectors[coffs + l + 1];  // FPMATH
+                                        vec[voffs       ] += Q23(codebook.codevectors[coffs + l    ]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs,vec[voffs]); */// FPMATH
+                                        vec[voffs + vlen] += Q23(codebook.codevectors[coffs + l + 1]);  /*av_log(NULL,AV_LOG_INFO,"%d:%d,",voffs + vlen,vec[voffs + vlen       ]);*/// FPMATH
 
                                         av_dlog(NULL, " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n",
                                                 pass, voffset / ch + (voffs % ch) * vlen,
@@ -1396,7 +1417,7 @@
                                 for (k = 0; k < step; ++k) {
                                     coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;
                                     for (l = 0; l < dim; ++l, ++voffs) {
-                                        vec[voffs / ch + (voffs % ch) * vlen] += codebook.codevectors[coffs + l];  // FPMATH FIXME use if and counter instead of / and %
+                                       { vec[voffs / ch + (voffs % ch) * vlen] += Q23(codebook.codevectors[coffs + l]); /*av_log(NULL,AV_LOG_INFO,"%d:%d,",(voffs / ch + (voffs % ch) * vlen),vec[voffs / ch + (voffs % ch) * vlen]);*/} // FPMATH FIXME use if and counter instead
 
                                         av_dlog(NULL, " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n",
                                                 pass, voffset / ch + (voffs % ch) * vlen,
@@ -1413,16 +1434,16 @@
                 voffset += vr->partition_size;
             }
         }
-    }
+    } LEAVE();
     return 0;
 }
 
 static inline int vorbis_residue_decode(vorbis_context *vc, vorbis_residue *vr,
                                         unsigned ch,
                                         uint8_t *do_not_decode,
-                                        float *vec, unsigned vlen,
+                                        INTFLOAT *vec, unsigned vlen,
                                         unsigned ch_left)
-{
+{ ENTER();
     if (vr->type == 2)
         return vorbis_residue_decode_internal(vc, vr, ch, do_not_decode, vec, vlen, ch_left, 2);
     else if (vr->type == 1)
@@ -1432,31 +1453,31 @@
     else {
         av_log(vc->avccontext, AV_LOG_ERROR, " Invalid residue type while residue decode?! \n");
         return -1;
-    }
+    }  LEAVE();
 }
 
-void vorbis_inverse_coupling(float *mag, float *ang, int blocksize)
+void vorbis_inverse_coupling(INTFLOAT *mag, INTFLOAT *ang, int blocksize)//?????????????????
 {
-    int i;
+    int i;ENTER();
     for (i = 0;  i < blocksize;  i++) {
-        if (mag[i] > 0.0) {
-            if (ang[i] > 0.0) {
+        if (mag[i] > 0) {
+            if (ang[i] > 0) {
                 ang[i] = mag[i] - ang[i];
             } else {
-                float temp = ang[i];
+                INTFLOAT temp = ang[i];
                 ang[i]     = mag[i];
                 mag[i]    += temp;
             }
         } else {
-            if (ang[i] > 0.0) {
+            if (ang[i] > 0) {
                 ang[i] += mag[i];
             } else {
-                float temp = ang[i];
+                INTFLOAT temp = ang[i];
                 ang[i]     = mag[i];
                 mag[i]    -= temp;
             }
         }
-    }
+    }LEAVE();
 }
 
 // Decode the audio packet using the functions above
@@ -1471,14 +1492,14 @@
     uint8_t no_residue[255];
     uint8_t do_not_decode[255];
     vorbis_mapping *mapping;
-    float *ch_res_ptr   = vc->channel_residues;
-    float *ch_floor_ptr = vc->channel_floors;
+    INTFLOAT *ch_res_ptr   = vc->channel_residues;
+    INTFLOAT *ch_floor_ptr = vc->channel_floors;
     uint8_t res_chan[255];
     unsigned res_num = 0;
     int retlen  = 0;
     unsigned ch_left = vc->audio_channels;
     unsigned vlen;
-
+                                            ENTER();
     if (get_bits1(gb)) {
         av_log(vc->avccontext, AV_LOG_ERROR, "Not a Vorbis I audio packet.\n");
         return -1; // packet type not audio
@@ -1501,8 +1522,8 @@
     if (blockflag)
         skip_bits(gb, 2); // previous_window, next_window
 
-    memset(ch_res_ptr,   0, sizeof(float) * vc->audio_channels * vlen); //FIXME can this be removed ?
-    memset(ch_floor_ptr, 0, sizeof(float) * vc->audio_channels * vlen); //FIXME can this be removed ?
+    memset(ch_res_ptr,   0, sizeof(INTFLOAT) * vc->audio_channels * vlen); //FIXME can this be removed ?
+    memset(ch_floor_ptr, 0, sizeof(INTFLOAT) * vc->audio_channels * vlen); //FIXME can this be removed ?
 
 // Decode floor
 
@@ -1570,23 +1591,44 @@
 
 // Inverse coupling
 
+/*av_log(NULL,AV_LOG_INFO,"\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+int ii;
+for(ii = 0; ii < blocksize;ii++ )
+    av_log(NULL,AV_LOG_INFO,"%d:%d,",ii,vc->channel_residues[ii]);*/
+
     for (i = mapping->coupling_steps - 1; i >= 0; --i) { //warning: i has to be signed
-        float *mag, *ang;
+        INTFLOAT *mag, *ang;
 
         mag = vc->channel_residues+res_chan[mapping->magnitude[i]] * blocksize / 2;
         ang = vc->channel_residues+res_chan[mapping->angle[i]]     * blocksize / 2;
-        vc->dsp.vorbis_inverse_coupling(mag, ang, blocksize / 2);
+        vorbis_inverse_coupling(mag, ang, blocksize / 2);
     }
 
 // Dotproduct, MDCT
 
     mdct = &vc->mdct[blockflag];
-
+/*int ii;
+for(ii = 0; ii < blocksize;ii++ )
+   if(vc->channel_residues[ii] < 0)
+    av_log(NULL,AV_LOG_INFO,"%d:%d,",ii,vc->channel_residues[ii]);*/
     for (j = vc->audio_channels-1;j >= 0; j--) {
         ch_floor_ptr = vc->channel_floors   + j           * blocksize / 2;
         ch_res_ptr   = vc->channel_residues + res_chan[j] * blocksize / 2;
-        vc->dsp.vector_fmul(ch_floor_ptr, ch_floor_ptr, ch_res_ptr, blocksize / 2);
+
+
+
+        vector_fmul_fixed_ogg(ch_floor_ptr, ch_floor_ptr, ch_res_ptr, blocksize / 2);
+
+/*int ii;
+for(ii = 0; ii < blocksize;ii++ )
+    if(ch_floor_ptr[ii] < 0)
+    av_log(NULL,AV_LOG_INFO,"%d:%d,",ii,ch_floor_ptr[ii]);*/
+
         mdct->imdct_half(mdct, ch_res_ptr, ch_floor_ptr);
+/*int ii;
+for(ii = 0; ii < blocksize;ii++ )
+    av_log(NULL,AV_LOG_INFO,"%d:%d,",ii,ch_res_ptr[ii]);*/
+
     }
 
 // Overlap/add, save data for next overlapping  FPMATH
@@ -1595,25 +1637,25 @@
     for (j = 0; j < vc->audio_channels; j++) {
         unsigned bs0 = vc->blocksize[0];
         unsigned bs1 = vc->blocksize[1];
-        float *residue    = vc->channel_residues + res_chan[j] * blocksize / 2;
-        float *saved      = vc->saved + j * bs1 / 4;
-        float *ret        = vc->channel_floors + j * retlen;
-        float *buf        = residue;
-        const float *win  = vc->win[blockflag & previous_window];
+        INTFLOAT *residue    = vc->channel_residues + res_chan[j] * blocksize / 2;
+        INTFLOAT *saved      = vc->saved + j * bs1 / 4;
+        INTFLOAT *ret        = vc->channel_floors + j * retlen;
+        INTFLOAT *buf        = residue;
+        const INTFLOAT *win  = vc->win[blockflag & previous_window];
 
         if (blockflag == previous_window) {
-            vc->dsp.vector_fmul_window(ret, saved, buf, win, blocksize / 4);
+            vector_fmul_window_fixed_ogg(ret, saved, buf, win, blocksize / 4); //av_log(NULL,AV_LOG_INFO,"\naaaaa\n");
         } else if (blockflag > previous_window) {
-            vc->dsp.vector_fmul_window(ret, saved, buf, win, bs0 / 4);
-            memcpy(ret+bs0/2, buf+bs0/4, ((bs1-bs0)/4) * sizeof(float));
+            vector_fmul_window_fixed_ogg(ret, saved, buf, win, bs0 / 4); //av_log(NULL,AV_LOG_INFO,"\nbbbb\n");
+            memcpy(ret+bs0/2, buf+bs0/4, ((bs1-bs0)/4) * sizeof(INTFLOAT));
         } else {
-            memcpy(ret, saved, ((bs1 - bs0) / 4) * sizeof(float));
-            vc->dsp.vector_fmul_window(ret + (bs1 - bs0) / 4, saved + (bs1 - bs0) / 4, buf, win, bs0 / 4);
+            memcpy(ret, saved, ((bs1 - bs0) / 4) * sizeof(INTFLOAT));
+            vector_fmul_window_fixed_ogg(ret + (bs1 - bs0) / 4, saved + (bs1 - bs0) / 4, buf, win, bs0 / 4);// av_log(NULL,AV_LOG_INFO,"\nccccc\n");
         }
-        memcpy(saved, buf + blocksize / 4, blocksize / 4 * sizeof(float));
+        memcpy(saved, buf + blocksize / 4, blocksize / 4 * sizeof(INTFLOAT));
     }
 
-    vc->previous_window = blockflag;
+    vc->previous_window = blockflag;         LEAVE();
     return retlen;
 }
 
@@ -1627,8 +1669,8 @@
     int buf_size       = avpkt->size;
     vorbis_context *vc = avccontext->priv_data ;
     GetBitContext *gb = &(vc->gb);
-    const float *channel_ptrs[255];
-    int i, len, out_size;
+    const INTFLOAT *channel_ptrs[255];
+    int i, len, out_size;              ENTER();
 
     if (!buf_size)
         return 0;
@@ -1670,12 +1712,12 @@
     }
 
     if (avccontext->sample_fmt == AV_SAMPLE_FMT_FLT)
-        vc->fmt_conv.float_interleave(data, channel_ptrs, len, vc->audio_channels);
+        vc->fmt_conv.fixed_interleave(data, channel_ptrs, len, vc->audio_channels);
     else
-        vc->fmt_conv.float_to_int16_interleave(data, channel_ptrs, len,
+        vc->fmt_conv.fixed_to_int16_interleave(data, channel_ptrs, len,//?????????????????
                                                vc->audio_channels);
 
-    *data_size = out_size;
+    *data_size = out_size;       LEAVE();
 
     return buf_size ;
 }
@@ -1684,10 +1726,10 @@
 
 static av_cold int vorbis_decode_close(AVCodecContext *avccontext)
 {
-    vorbis_context *vc = avccontext->priv_data;
+    vorbis_context *vc = avccontext->priv_data;  ENTER();
 
     vorbis_free(vc);
-
+                             LEAVE();
     return 0 ;
 }
 
diff -uNr ffmpeg-0.7.12/libavcodec/vorbis.h ffmpeg-0.7.12-140902/libavcodec/vorbis.h
--- ffmpeg-0.7.12/libavcodec/vorbis.h	2012-04-10 01:04:53.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavcodec/vorbis.h	2013-10-31 11:10:02.000000000 +0800
@@ -23,8 +23,58 @@
 
 #include "avcodec.h"
 
-extern const float ff_vorbis_floor1_inverse_db_table[256];
-extern const float * const ff_vorbis_vwin[8];
+#if CONFIG_VORBIS_FIXED
+
+#define CONFIG_FFT_FLOAT    0
+#define CONFIG_FFT_FIXED_32 1
+
+#define VORBIS_RENAME(x)       x ## _fixed
+#define VORBIS_RENAME2(x)      x ## _fixed
+#define VORBIS_RENAME_32(x)    x ## _fixed_32
+#define INTFLOAT int
+#define SHORTFLOAT int16_t
+#define VORBIS_SIGNE           int
+#define FIXR(a)             ((int)((a) * 1 + 0.5))
+#define FIXR10(a)           ((int)((a) * 1024.0 + 0.5))
+//#define Q19(a)              (int)((a) * 524288.0 + 0.5)
+//#define Q21(a)              (int)((a) * 2097152.0 + 0.5)
+#define Q23(a)              (int)((a) * 8388608.0 + 0.5)
+#define Q25(a)              (int)((a) * 33554432.0 + 0.5)
+#define Q27(a)              (int)((a) * 134217728.0 + 0.5)
+#define Q30(x)              (int)((x)*1073741824.0 + 0.5)
+#define Q31(x)              (int)((x)*2147483648.0 + 0.5)
+#define RANGE15(x)          x
+#define GET_GAIN(x, y)      (-(y) << (x)) + 1024
+#define VORBIS_MUL26(x, y)     (int)(((int64_t)(x) * (y) + 0x2000000) >> 26)
+#define VORBIS_MUL30(x, y)     (int)(((int64_t)(x) * (y) + 0x20000000) >> 30)
+#define VORBIS_MUL31(x, y)     (int)(((int64_t)(x) * (y) + 0x40000000) >> 31)
+#else
+
+#define CONFIG_FFT_FLOAT    1
+#define CONFIG_FFT_FIXED_32 0
+
+#define VORBIS_RENAME(x)       x
+#define VORBIS_RENAME2(x)      x ## _float
+#define VORBIS_RENAME_32(x)    x
+#define INTFLOAT float
+#define SHORTFLOAT float
+#define VORBIS_FLOAT float
+#define VORBIS_SIGNE           unsigned
+#define FIXR(x)             ((float)(x))
+#define FIXR10(x)           ((float)(x))
+#define Q23(x)              x
+#define Q30(x)              x
+#define Q31(x)              x
+#define RANGE15(x)          (32768.0 * (x))
+#define GET_GAIN(x, y)      powf((x), -(y))
+#define VORBIS_MUL26(x, y)     ((x) * (y))
+#define VORBIS_MUL30(x, y)     ((x) * (y))
+#define VORBIS_MUL31(x, y)     ((x) * (y))
+#endif
+
+
+extern const INTFLOAT ff_vorbis_floor1_inverse_db_table[256];
+extern const INTFLOAT * const ff_vorbis_vwin[8];
 extern const uint8_t ff_vorbis_channel_layout_offsets[8][8];
 extern const uint8_t ff_vorbis_encoding_channel_layout_offsets[8][8];
 extern const int64_t ff_vorbis_channel_layouts[9];
@@ -41,8 +91,8 @@
 int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, unsigned num);
 void ff_vorbis_floor1_render_list(vorbis_floor1_entry * list, int values,
                                   uint16_t *y_list, int *flag,
-                                  int multiplier, float * out, int samples);
-void vorbis_inverse_coupling(float *mag, float *ang, int blocksize);
+                                  int multiplier, INTFLOAT * out, int samples);
+void vorbis_inverse_coupling(INTFLOAT *mag, INTFLOAT *ang, int blocksize);
 
 #define ilog(i) av_log2(2*(i))
 diff -uNr ffmpeg-0.7.12/libavutil/samplefmt.h ffmpeg-0.7.12-140902/libavutil/samplefmt.h
--- ffmpeg-0.7.12/libavutil/samplefmt.h	2012-04-10 01:04:54.000000000 +0800
+++ ffmpeg-0.7.12-140902/libavutil/samplefmt.h	2014-09-02 16:29:33.000000000 +0800
@@ -31,6 +31,13 @@
     AV_SAMPLE_FMT_S32,         ///< signed 32 bits
     AV_SAMPLE_FMT_FLT,         ///< float
     AV_SAMPLE_FMT_DBL,         ///< double
+
+    AV_SAMPLE_FMT_U8P,         ///< unsigned 8 bits, planar
+    AV_SAMPLE_FMT_S16P,        ///< signed 16 bits, planar
+    AV_SAMPLE_FMT_S32P,        ///< signed 32 bits, planar
+    AV_SAMPLE_FMT_FLTP,        ///< float, planar
+    AV_SAMPLE_FMT_DBLP,        ///< double, planar
+
     AV_SAMPLE_FMT_NB           ///< Number of sample formats. DO NOT USE if linking dynamically
 };
 